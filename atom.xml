<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengzelev&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mengzelev.github.io/"/>
  <updated>2019-01-31T10:08:24.839Z</updated>
  <id>https://mengzelev.github.io/</id>
  
  <author>
    <name>Mengzelev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019美赛经历</title>
    <link href="https://mengzelev.github.io/2019/01/30/ICM-feelings/"/>
    <id>https://mengzelev.github.io/2019/01/30/ICM-feelings/</id>
    <published>2019-01-30T09:45:38.000Z</published>
    <updated>2019-01-31T10:08:24.839Z</updated>
    
    <content type="html"><![CDATA[<p>在经过了一夜的通宵之后终于把论文交上去惹，然后睡了一天，摸了一天，终于想起来要写这篇blog了。</p><h1 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h1><ul><li>学习MATLAB基本语法，笔记见<a href="https://mengzelev.github.io/2019/01/16/matlab-getstart/">MATLAB临时抱佛脚</a></li><li>学习数模基本算法，资料见<a href="https://github.com/NJUBroccoli/Material-of-MCM-ICM" target="_blank" rel="noopener">NJUBroccoli的github仓库</a></li><li>抄写常用算法模板，如：规划问题、AHP、灰色系统、灰色预测、主成分分析、方差分析等</li><li>阅读往年赛题和O奖论文，摸清套路</li><li><s>和朋友出去看电影</s></li><li>和队友做迫真模拟</li><li><s>补番</s></li></ul><h1 id="团队配置"><a href="#团队配置" class="headerlink" title="团队配置"></a>团队配置</h1><ul><li>po主：cs大二狗，会C/C++，LaTeX，以及Java和Verilog的皮毛，MATLAB是比赛前速成的。建模、计算、写论文、校对多面打杂，兼职美工和排版工人。</li><li>队友A：数学系大二小姐姐。建模扛把子。</li><li>队友B：大气科学大二小哥哥。负责给建模提供灵感，负责抱大气老师教授大腿，负责询问环科同学、商科同学…<s>这么写会不会被打死</s></li></ul><h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><ul><li>模型是一起讨论建的</li><li>数据是一起找的(虽然后来没怎么用上)</li><li>编程队友B不会所以我和队友A小姐姐一起负责</li><li>论文是每个人挑几个部分一起写的</li><li>翻译是交给有道姬完成的，由我和队友A校对<s>因为队友B校对的质量堪忧</s></li><li>排版由原po一人完成</li></ul><h1 id="比赛过程"><a href="#比赛过程" class="headerlink" title="比赛过程"></a>比赛过程</h1><h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><p>之前和队友商量好了选E或F题，因为MCM比较有难度，<s>D题需要排队论和马氏链不想看</s>。比赛当天题目公布的时候，看到F题需要不少硬核经济学知识果断放弃了，然后果断就上了E题这条贼船。MCM碰都没碰所以错过了养龙的机会，<s>我想养康娜酱啊呜呜呜</s></p><p>今年赛题内容大致为</p><ul><li>A题：养龙</li><li>B题：救救难民</li><li>C题：美国总统五大洲四日游</li><li>D题：逃离卢浮宫</li><li>E题：生态服务成本估价</li><li>F题：电子货币</li></ul><p>(只有E题是认真看过的，如有偏差欢迎指出)</p><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>E题按照惯例是环境问题，今年是要求对生态系统服务(ecological services)进行估价。生态系统服务是指生态系统提供的诸如净化空气、水体自净、保持水土等功能。要求大概有以下几点</p><ul><li>建立生态系统估价模型(ecological services valuation model)</li><li>对不同规模的土地开发利用项目进行成本效益分析(CBA)，评估这些项目的真实经济成本</li><li>决策者和管理者提出建议(implication)</li><li>随着时间推移模型如何修改</li></ul><p>本来是抱着AHP+GRA+PCA的觉悟来选的E题，结果一看这tm难道不是$\sum$单价$\times$数量的小学生模型吗，只要我找到每吨废水处理的价格，每吨垃圾回收的价格etc.<br>然后标准结局出现了：找不到！！！<br>比如污水处理费，中国大陆，HK和法国是按吨收的，美国英国是每年交固定的类似于下水道保护费一样的费用。<br>而且题干里都说了“现在的土地利用项目一般不考虑环境成本”，所以根本就找不到工程前后环境相关的数据。几篇类似的论文都是有自己的监测站的啊！！！！我们上哪找去啊！！！<br>环境经济学的书查了一堆啊！！！直接说环境估价是一个尚未解决的难题啊！！！！【废话要是解决了还会出成赛题吗<br>如此绝望了一天半之后，我们决定，死马当活马医：gtnd，上AHP！<br>然后就开始了玄学AHP玄学建模玄学论文解释<br>由于只是个心路历程记录，所以就不详细解释了</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>我们的玄学模型只有CBA那一块有一丢丢计算量，直接上MATLAB<br>甚至把图调得更好看花的时间还多一些【丢人</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p>是大家一起写的中文稿，然后扔给有道姬翻成英文，再手动修改</p><h2 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h2><p>DAY1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选题</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    讨论模;</span><br><span class="line">    找论文;</span><br><span class="line">    找数据;</span><br><span class="line">    推翻模型;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAY2：</p><ul><li>找数据</li><li>推翻模型</li><li>玄学建模开始</li><li>玄学AHP</li><li>玄学CBA</li><li>玄学编程</li><li>队友B开始玄学扯淡写论文</li></ul><p>DAY3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    论文扯淡;</span><br><span class="line">    发现模型有问题;</span><br><span class="line">    打补丁;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAY4(通宵)：</p><ul><li>写论文</li><li>继续给模型打补丁</li><li>翻译并校对</li><li>排版</li><li>提交</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><ul><li>美赛是<strong>真的很累</strong>！！！【不过也有些队伍早早就做完提交了根本没有通宵</li><li>前面不知道做些什么，所以每天都睡足了8小时，事情都积到最后一天做了，所以不得不通宵，所幸还是赶上了的</li><li>没有养龙好遗憾啊，反正哪题都不会做，不如养龙爽一把，非要吊死在E题上</li><li>美赛过于昂贵。3人平分100美元的报名费不说，因为作死没有留在学校里打，导致只能去市图书馆讨论，花费大量金钱在吃饭上，最后一天为了通宵还开了个房</li><li>这次的E题感觉还是挺坑的，涉及到不少环境经济学的知识，外行人慎选。<s>其实哪道题都是坑</s></li><li>我们的模型后来算出来西气东输是个失败的工程，感觉小命不保了</li><li>33.33美元，体验通宵的感觉，参赛一次，受益一生【棒读】</li></ul><blockquote><p>MCM/ICM真是一个骗钱又坑爹的比赛啊</p></blockquote><p><img src="/2019/01/30/ICM-feelings/trump.jpeg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在经过了一夜的通宵之后终于把论文交上去惹，然后睡了一天，摸了一天，终于想起来要写这篇blog了。&lt;/p&gt;
&lt;h1 id=&quot;赛前准备&quot;&gt;&lt;a href=&quot;#赛前准备&quot; class=&quot;headerlink&quot; title=&quot;赛前准备&quot;&gt;&lt;/a&gt;赛前准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Dairy" scheme="https://mengzelev.github.io/categories/Dairy/"/>
    
    
      <category term="Math Modeling" scheme="https://mengzelev.github.io/tags/Math-Modeling/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记</title>
    <link href="https://mengzelev.github.io/2019/01/23/python-getstart/"/>
    <id>https://mengzelev.github.io/2019/01/23/python-getstart/</id>
    <published>2019-01-23T07:37:50.000Z</published>
    <updated>2019-01-23T10:15:19.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Python是动态语言，即变量本身类型不固定，不需要提前声明变量类型的</p><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>整数可以是任意大小的</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数可以是任意精度的【但是运算也会出现误差】</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>字符串用单引号或双引号括起来</li><li>会涉及到转义符的问题</li><li>在字符串前加<code>r</code>表示让所有的转义符都不转义</li></ul><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><blockquote><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p></blockquote><ul><li>Python 3的字符串是以Unicode编码的</li><li><code>ord()</code>获取字符的整数表示，<code>chr()</code>把编码转换为对应的字符</li><li>字符串类型是<code>str</code>，加前缀<code>b&#39;</code>可以转换为<code>bytes</code>类型</li><li><p>Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为<code>bytes</code>类型，反过来<code>bytes</code>类型可以通过<code>decode()</code>方法解码为<code>str</code>类型</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">b'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'中文'</span></span><br></pre></td></tr></table></figure></li><li><p>len()函数返回字符串长度或<code>bytes</code>字节数</p></li><li>始终坚持使用UTF-8对<code>str</code>和<code>bytes</code>进行转换</li><li><p>开头通常需要加上</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure></li><li><p>格式化字符串<code>%</code>，用法同C的<code>printf</code></p></li></ul><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><ul><li>值为<code>True</code>或<code>False</code></li><li>运算<code>and</code>、<code>or</code>、<code>not</code></li></ul><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><ul><li><code>None</code>，是一个特殊变量</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul><li>习惯用全部大写的变量名表示常量</li><li>然而并不能保证该变量不会改变，不像C有<code>const</code></li></ul><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul><li>[]表示list</li><li><code>len(list name)</code>可以获得list元素的个数</li><li>[]为下标索引，从0开始，同C</li><li>[-1]表示最后一个元素,负号索引-n就表示倒数第n个<s>这也太nb了吧</s></li><li>list里的数据类型可以不同</li><li>list可以嵌套</li></ul><h3 id="list方法"><a href="#list方法" class="headerlink" title="list方法"></a>list方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylist.append(<span class="string">'a'</span>) <span class="comment"># 往list中追加元素到末尾</span></span><br><span class="line">mylist.insert(<span class="number">1</span>, <span class="string">'a'</span>) <span class="comment"># 把元素插入到指定位置</span></span><br><span class="line">mylist.pop() <span class="comment"># 删除list末尾的元素</span></span><br><span class="line">mylist.pop(<span class="number">1</span>) <span class="comment"># 删除指定位置的元素</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;p&gt;Python是动态语言，即变量本身类型不固定，不需要提前声明变量类型的&lt;/p&gt;
&lt;h2 id=&quot;整数&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数学建模几种常用算法</title>
    <link href="https://mengzelev.github.io/2019/01/19/matlab-usage/"/>
    <id>https://mengzelev.github.io/2019/01/19/matlab-usage/</id>
    <published>2019-01-19T08:41:45.000Z</published>
    <updated>2019-01-24T13:22:25.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据拟合"><a href="#数据拟合" class="headerlink" title="数据拟合"></a>数据拟合</h1><h2 id="多项式拟合"><a href="#多项式拟合" class="headerlink" title="多项式拟合"></a>多项式拟合</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [...];</span><br><span class="line">y = [...];</span><br><span class="line">P = polyfit(x,y,n); <span class="comment">% n是多项式的次数</span></span><br><span class="line">xi = <span class="number">0</span>: <span class="number">.2</span> :<span class="number">10</span>;</span><br><span class="line">yi = polyval(P, xi);</span><br><span class="line">plot(xi, yi, x, y, <span class="string">'r*'</span>);</span><br></pre></td></tr></table></figure><h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><p>标准型$$\min~c^Tx s.t. Ax\le b$$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = linprog(c, -a, -b, [], [], <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = fmincon(fun, x0, A, B, Aeq, Beq, LB, UB, [c,ceq], OPTIONS)</span><br><span class="line"><span class="comment">% fun:目标函数</span></span><br><span class="line"><span class="comment">% x0:x的初始条件</span></span><br><span class="line"><span class="comment">% A,B,Aeq,Beq:线性约束条件</span></span><br><span class="line"><span class="comment">% LB,UB:上下界</span></span><br><span class="line"><span class="comment">% [c,ceq]:.m文件定义的非线性约束条件,分别为不等式与等式约束</span></span><br></pre></td></tr></table></figure><h2 id="二次规划"><a href="#二次规划" class="headerlink" title="二次规划"></a>二次规划</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, fval] = quadprog(H, f, A, b, Aeq, Beq, LB, UB, X0, OPTIONS)</span><br></pre></td></tr></table></figure><h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><ul><li>隐枚举法</li><li>随机算法(蒙特卡洛)</li><li>分枝定界法</li></ul><h2 id="其他求解约束最优化问题的函数"><a href="#其他求解约束最优化问题的函数" class="headerlink" title="其他求解约束最优化问题的函数"></a>其他求解约束最优化问题的函数</h2><ul><li><code>fminbnd</code>:单变量非线性函数在区间上的极小值</li><li><code>fseminf</code></li><li><code>fminimax</code>:函数族的极大极小值</li></ul><h1 id="灰色预测"><a href="#灰色预测" class="headerlink" title="灰色预测"></a>灰色预测</h1><p>GM(1,1)模型适用于具有较强指数规律的序列，只能描述单调的变化过程，而Verhulst模型则适用于非单调的摆动发展序列或具有饱和状态的S形序列。<br>原始数列$x^{(0)}$，AGO累加生成数列$x^{(1)}$，加权均值数列$z^{(0)}$</p><h2 id="关联分析和优势分析"><a href="#关联分析和优势分析" class="headerlink" title="关联分析和优势分析"></a>关联分析和优势分析</h2><ul><li>根据bigger is better和smaller is better标准将数据分类进行初始化</li><li>根据公式算关联系数</li><li>根据关联系数计算关联度</li></ul><h2 id="灰色预测步骤"><a href="#灰色预测步骤" class="headerlink" title="灰色预测步骤"></a>灰色预测步骤</h2><ul><li>数据的检验与处理：计算级比，视情况进行必要的变换处理，使其落入可容覆盖内</li><li>建立模型 $x^{(1)}=…$可以得到预测值</li><li>残差检验</li><li>级比偏差检验</li><li>预测预报</li><li>另：灾变预测可以构造灾变数列</li></ul><h1 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h1><ul><li>求解多约束复杂非线性规划问题</li><li>直接调库吧，不可能看懂的</li></ul><h1 id="层次分析法-Analytic-Hierarchy-Process"><a href="#层次分析法-Analytic-Hierarchy-Process" class="headerlink" title="层次分析法(Analytic Hierarchy Process)"></a>层次分析法(Analytic Hierarchy Process)</h1><ul><li>用于解决较为复杂、模糊、难于定量分析的问题</li><li>当影响决策的因素较多且较主观时</li><li>分层、构造矩阵、检验一致性</li></ul><p>因为基本上做E或F题都会用到，所以详细展开一下</p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul><li>建立递阶层次结构模型；</li><li>构造出各层次中的所有判断矩阵；</li><li>层次单排序及一致性检验；</li><li>层次总排序及一致性检验。</li></ul><h2 id="层次结构的建立"><a href="#层次结构的建立" class="headerlink" title="层次结构的建立"></a>层次结构的建立</h2><p><img src="/2019/01/19/matlab-usage/1.png"></p><h2 id="构造判断矩阵"><a href="#构造判断矩阵" class="headerlink" title="构造判断矩阵"></a>构造判断矩阵</h2><p><img src="/2019/01/19/matlab-usage/2.png"></p><h2 id="层次单排序一致性检验"><a href="#层次单排序一致性检验" class="headerlink" title="层次单排序一致性检验"></a>层次单排序一致性检验</h2><ul><li>判断矩阵$A$对应于最大特征值$\lambda_{max}$的特征向量$W$ ，经归一化后即为同一层次相应因素对于上一层次某因素相对重要性的排序权值，这一过程称为层次单排序</li><li>如果比较结果是前后完全一致的，则矩阵$A$的元素还应当满足$a_{ij}a_{jk}=a_{ik}$，此时矩阵$A$成为一致矩阵</li><li>$n$阶正互反矩阵$A$为一致矩阵当且仅当其最大特征根$\lambda_{max}=n$，且当正互反矩阵$A$非一致时，必有$\lambda_{max}&gt;n$</li><li>一致性检验步骤<ul><li>计算一致性指标$CI=\frac{\lambda_{max}-n}{n-1}$</li><li>查找相应的平均随机一致性指标$RI$</li><li>计算一致性比例$CR=\frac{CR}{CI}$</li><li>$CR&lt;0.10$时，认为判断矩阵的一致性是可以接受的，否则应对判断矩阵作适当修正</li></ul></li></ul><h2 id="层次总排序一致性检验"><a href="#层次总排序一致性检验" class="headerlink" title="层次总排序一致性检验"></a>层次总排序一致性检验</h2><p>设A层(上一层次)包含$A_1,…A_m$共$m$个因素，层次总排序权重分别为$a_1,…a_m$，又设其后的下一层次B层包含$n$个因素$B_1,…B_n$，它们关于$A_j$的层次单排序权重分别为$b_{1j},…b_{nj}$(当$B_i$与$A_j$无关时，$b_{ij}=0$)。现求$B$层中各因素关于总目标的权重，即求$B$层个因素的层次总排序权重$b_1,…,b_n$。<br>$B$层各因素的层次总排序权重$b_i=\sum\limits_{j=1}^{m}b_{ij}a_{j}$<br>B层总排序随机一致性比例$$CR=\frac{\sum\limits_{j=1}^{m}CI(j)a_j}{\sum\limits_{j=1}^{m}RI(j)a_j}$$<br>$CR&lt;0.10$时认为层次总排序具有较满意的一致性并接受该分析结果</p><h1 id="方差分析-ANOVA"><a href="#方差分析-ANOVA" class="headerlink" title="方差分析(ANOVA)"></a>方差分析(ANOVA)</h1><ul><li>又称F检验</li><li>用数理统计分析试验结果、鉴别各因素对结果影响程度的方法</li></ul><h2 id="单因素方差分析"><a href="#单因素方差分析" class="headerlink" title="单因素方差分析"></a>单因素方差分析</h2><ul><li>任务：从试验结果推断某因素对指标有无显著影响</li><li>单因素方差分析表</li><li>方差分析命令<code>anoval</code>，<code>p = anoval(x,group)</code>将算得的概率<code>p</code>与<code>\alpha</code>进行比较</li></ul><h2 id="双因素方差分析"><a href="#双因素方差分析" class="headerlink" title="双因素方差分析"></a>双因素方差分析</h2><ul><li><code>p = anova2(x,reps)</code></li></ul><h2 id="多因素方差分析"><a href="#多因素方差分析" class="headerlink" title="多因素方差分析"></a>多因素方差分析</h2><ul><li><code>anovan</code></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y = [<span class="number">31</span> <span class="number">54</span> <span class="number">38</span> <span class="number">53</span> <span class="number">49</span> <span class="number">42</span> <span class="number">57</span> <span class="number">62</span> <span class="number">64</span>]; <span class="comment">%试验结果</span></span><br><span class="line">g1 = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]; <span class="comment">%正交表第一列</span></span><br><span class="line">g2 = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span>];</span><br><span class="line">g3 = [<span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>];</span><br><span class="line">[p,t,st] = anovan(y,&#123;g1,g2,g3&#125;)</span><br></pre></td></tr></table></figure><h1 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h1><ul><li><p>用来检验拟合函数的准确度</p></li><li><p>残差：实际观察值，估计值(拟合值)之间的差</p></li><li>$R^2$判定系数：可解释的变异占总变异的百分比</li></ul><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[b,bint,r,rint,stats] = regress(y,x,alpha);</span><br><span class="line"><span class="comment">% b为回归系数估计值</span></span><br><span class="line"><span class="comment">% bint为置信区间 </span></span><br><span class="line"><span class="comment">% r为残差，rint为残差的置信区间</span></span><br><span class="line"><span class="comment">% stats是用于检验回归模型的统计量[R^2,F,p,s^2]</span></span><br><span class="line"><span class="comment">% alpha显著性水平，缺省时为0.05</span></span><br></pre></td></tr></table></figure><h2 id="一元多项式回归"><a href="#一元多项式回归" class="headerlink" title="一元多项式回归"></a>一元多项式回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[p,s] =  polyfit(x0, y0, <span class="number">2</span>);</span><br><span class="line"><span class="comment">% s为用于计算函数值的数据结构，如</span></span><br><span class="line">[y,delta] = polyconf(p,x0,s);y</span><br><span class="line"><span class="comment">%可以得到y的拟合值、置信区间半径delta</span></span><br></pre></td></tr></table></figure><h2 id="多元二项式回归"><a href="#多元二项式回归" class="headerlink" title="多元二项式回归"></a>多元二项式回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rstool(x,y,model,alpha)</span><br><span class="line"><span class="comment">% x:n×m维矩阵</span></span><br><span class="line"><span class="comment">% y:n维向量</span></span><br><span class="line"><span class="comment">%model:线性、纯二次、交叉、完全二次四选一</span></span><br></pre></td></tr></table></figure><h1 id="主成成分分析"><a href="#主成成分分析" class="headerlink" title="主成成分分析"></a>主成成分分析</h1><ul><li>用较少的变量去解释原来资料中的大部分变异</li><li>选出比原始变量个数少、能解释大部分资料中的变异的几个新变量</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>对原始数据进行标准化处理</li><li>计算相关系数矩阵$R$</li><li>计算特征值和特征向量</li><li>选择$p$个主成分，计算综合评价值</li><li>计算综合得分</li></ul><h1 id="排队论"><a href="#排队论" class="headerlink" title="排队论"></a>排队论</h1><ul><li>有很多公式，用的时候再查吧</li><li>优化：最优服务率，最优服务台数</li></ul><h1 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h1><ul><li>当模型的数据中有一个或几个发生变化时，最优解会有什么变化</li><li>这些数据在什么范围内变化时，已求解的最优解不变</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据拟合&quot;&gt;&lt;a href=&quot;#数据拟合&quot; class=&quot;headerlink&quot; title=&quot;数据拟合&quot;&gt;&lt;/a&gt;数据拟合&lt;/h1&gt;&lt;h2 id=&quot;多项式拟合&quot;&gt;&lt;a href=&quot;#多项式拟合&quot; class=&quot;headerlink&quot; title=&quot;多项式拟合&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019年寒假计划(flags)</title>
    <link href="https://mengzelev.github.io/2019/01/17/2019-winter-flags/"/>
    <id>https://mengzelev.github.io/2019/01/17/2019-winter-flags/</id>
    <published>2019-01-17T06:02:11.000Z</published>
    <updated>2019-01-17T12:18:24.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美赛准备"><a href="#美赛准备" class="headerlink" title="美赛准备"></a>美赛准备</h1><ul><li>MATLAB入门《MATLAB数学工具软件实例简明教程》</li><li>《MATLAB在数学建模中的应用》</li><li>研读优秀论文，总结模板</li></ul><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul><li>学习Python</li><li>分析minilab的git log中的CE数据</li></ul><h1 id="HK学术竞赛"><a href="#HK学术竞赛" class="headerlink" title="HK学术竞赛"></a>HK学术竞赛</h1><ul><li>等打完美赛再来研究</li></ul><h1 id="番剧"><a href="#番剧" class="headerlink" title="番剧"></a>番剧</h1><h2 id="追番"><a href="#追番" class="headerlink" title="追番"></a>追番</h2><ul><li>多罗罗</li><li>灵能百分百第二季</li><li>关于我转生成为史莱姆的这档事</li><li>强风吹拂</li><li>不吉波普不笑</li><li>约定的梦幻岛 </li></ul><h2 id="补番"><a href="#补番" class="headerlink" title="补番"></a>补番</h2><ul><li>战栗杀机</li><li>小林家的龙女仆</li></ul><h1 id="吉他"><a href="#吉他" class="headerlink" title="吉他"></a>吉他</h1><ul><li>看B站教学视频</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;美赛准备&quot;&gt;&lt;a href=&quot;#美赛准备&quot; class=&quot;headerlink&quot; title=&quot;美赛准备&quot;&gt;&lt;/a&gt;美赛准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MATLAB入门《MATLAB数学工具软件实例简明教程》&lt;/li&gt;
&lt;li&gt;《MATLAB在数学建模中的应用》&lt;
      
    
    </summary>
    
      <category term="Flags" scheme="https://mengzelev.github.io/categories/Flags/"/>
    
    
      <category term="Flags" scheme="https://mengzelev.github.io/tags/Flags/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB临时抱佛脚</title>
    <link href="https://mengzelev.github.io/2019/01/16/matlab-getstart/"/>
    <id>https://mengzelev.github.io/2019/01/16/matlab-getstart/</id>
    <published>2019-01-16T09:04:59.000Z</published>
    <updated>2019-01-20T03:49:08.093Z</updated>
    
    <content type="html"><![CDATA[<p>来源：王正盛 《MATLAB数学工具软件实例简明教程》</p><h1 id="入门技能"><a href="#入门技能" class="headerlink" title="入门技能"></a>入门技能</h1><h2 id="命令行命令"><a href="#命令行命令" class="headerlink" title="命令行命令"></a>命令行命令</h2><p>matlab基本可以看成一个有自己语法的命令行终端使用<br>下面列举一些我觉得自己将来可能会用到的</p><ul><li><code>clc</code>:擦除当前工作窗中所有显示内容</li><li><code>dir</code>:相当于<code>ls</code></li><li><code>cd</code>:你懂的</li><li><code>who</code>:检查内存变量</li><li><code>whos</code>:检查驻留变量的详细情况</li><li><code>help</code>:召唤FM</li><li><code>lookfor</code>:对<code>man</code>进行<code>grep</code></li></ul><p>MATLAB也是有当前工作路径的，同Linux的bash</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量基本以矩阵形式存在<br>还有一些预定义的变量</p><ul><li><code>eps</code>:计算机表示的最小正数</li><li><code>pi</code>:圆周率</li><li><code>inf</code>或<code>Inf</code></li><li><code>NaN</code></li><li><code>i,j</code></li><li><code>flops</code>:浮点运算次数，用于统计计算量</li></ul><h2 id="显示格式"><a href="#显示格式" class="headerlink" title="显示格式"></a>显示格式</h2><ul><li><code>short</code></li><li><code>long</code></li><li><code>short/long e</code> 科学计数法显示</li><li><code>bank</code> 银行格式</li><li><code>hex</code> 十六进制格式</li><li><code>+</code>用于大矩阵的紧凑格式 </li></ul><h1 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h1><h2 id="矩阵创建"><a href="#矩阵创建" class="headerlink" title="矩阵创建"></a>矩阵创建</h2><ul><li>直接输入法</li><li><code>reshape</code>把长行向量拆成$n\times m$的矩阵</li><li><code>diag</code>可以实现向量和对角阵之间的互相转化</li><li><code>.m</code>和<code>.mat</code>文件</li></ul><h2 id="矩阵运算与数组运算"><a href="#矩阵运算与数组运算" class="headerlink" title="矩阵运算与数组运算"></a>矩阵运算与数组运算</h2><ul><li>矩阵运算：按矩阵法则进行的运算</li><li>数组运算：对元素逐个进行</li><li>可以将数组直接作为参数传入函数中，而不用写循环，不同于C<br><img src="/2019/01/16/matlab-getstart/sign.png"></li><li>MATLAB推荐：尽量使用除运算，少用逆运算</li></ul><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><ul><li>系数行向量表示：$p=[a_0,a_1,…a_n]$</li><li>指令<code>p=poly(AR)</code>产生多项式<ul><li>若<code>AR</code>是方阵，则产生特征多项式</li><li>若<code>AR</code>是向量，则<code>AR</code>中每个数是该多项式=0的解</li></ul></li></ul><h3 id="多项式运算"><a href="#多项式运算" class="headerlink" title="多项式运算"></a>多项式运算</h3><ul><li><code>R = roots(p)</code>：求根</li><li><code>PA = polyval(p,S)</code>:按数组运算规则计算多项式的值</li><li><code>PA = polyvalm(p,S)</code>:按矩阵运算规则计算多项式的值</li><li><code>P = polyfit(x,y,n)</code>:用$n$阶多项式拟合$x,y$给定的数据</li></ul><h2 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h2><ul><li><code>S = quad(&#39;fname&#39;, a, b, tol, trace)</code> 自适用Simpson数值积分法</li><li><code>S = quad8(&#39;fname&#39;, a, b, tol, trace)</code>自适用Newton-Cotes数值积分法</li><li><code>quad8</code>比<code>quad</code>性能和精度更好</li></ul><h2 id="非线性方程"><a href="#非线性方程" class="headerlink" title="非线性方程"></a>非线性方程</h2><ul><li><code>r = roots(p)</code> 多项式非线性函数求根</li><li><code>z = fzero(&#39;fname&#39;, x0, tol, trace)</code> 单变量函数求零点，只给出离<code>x0</code>最近的根</li></ul><h2 id="微分方程的数值解"><a href="#微分方程的数值解" class="headerlink" title="微分方程的数值解"></a>微分方程的数值解</h2><ul><li><code>[t,x] = ode23/45(&#39;xprime&#39;, [t0,tf], x0, tol, trace)</code></li></ul><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul><li><code>cd, type, delete, dir</code>，和bash用起来差不多</li><li><code>!</code>可用于执行外部程序</li></ul><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><ul><li><p><code>fopen</code>打开二进制文件</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fid = fopen(<span class="string">'a.dat'</span>, <span class="string">'r'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>fread</code>将数据装入变量</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = fread(fid);</span><br><span class="line">a = fread(fid, <span class="number">100</span>);</span><br><span class="line">a = fread(fid, [<span class="number">10</span>,<span class="number">10</span>]);</span><br></pre></td></tr></table></figure></li><li><p><code>fwrite</code>按照指定的书精度将矩阵中的元素写入文件</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt = fwrite(fid, <span class="built_in">magic</span>(<span class="number">5</span>), <span class="string">'integer * 4'</span>);</span><br><span class="line"><span class="comment">%返回写入数据的个数</span></span><br><span class="line">status = fclose(fid);</span><br></pre></td></tr></table></figure></li><li><p><code>save</code>命令及<code>-ascii</code>选项</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">rand</span>(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">save a.dat a -ascii</span><br></pre></td></tr></table></figure></li></ul><h1 id="符号计算"><a href="#符号计算" class="headerlink" title="符号计算"></a>符号计算</h1><h2 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h2><ul><li><p><code>sym</code>定义符号或表达式</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sym(<span class="string">'x'</span>)</span><br><span class="line">sym(`<span class="number">1</span> + x / <span class="number">2</span>`)</span><br><span class="line">syms a b c d </span><br><span class="line"><span class="comment">%syms可以定义多个符号</span></span><br></pre></td></tr></table></figure></li><li><p><code>findsym</code>确认符号表达式中的符号</p></li></ul><h2 id="微积分运算"><a href="#微积分运算" class="headerlink" title="微积分运算"></a>微积分运算</h2><h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><ul><li><code>diff(f,t,n)</code>函数<code>f</code>对变量<code>t</code>求<code>n</code>阶导，<code>t</code>缺省时对<code>x</code>求导，<code>n</code>缺省为1</li><li>参数为矩阵时，作用于每个元素</li></ul><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><ul><li><code>int(f,t)</code> 函数<code>f</code>对变量<code>t</code>求不定积分</li><li><code>int(f,t,a,b)</code> 函数<code>f</code>对符号变量求从<code>a</code>到<code>b</code>的定积分</li></ul><h3 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h3><ul><li><code>limita(f,t,a)</code>当符号变量<code>t-&gt;a</code>时，函数<code>f</code>的极限，<code>t</code>缺省<code>x</code>，<code>a</code>缺省为0</li></ul><h3 id="级数和"><a href="#级数和" class="headerlink" title="级数和"></a>级数和</h3><ul><li><code>symsum(s,t,a,b)`</code>s<code>中的符号变量</code>t<code>从</code>a<code>到</code>b`的级数和</li></ul><h3 id="Taylor展开"><a href="#Taylor展开" class="headerlink" title="Taylor展开"></a>Taylor展开</h3><ul><li><code>taylor(f,n,a)</code>函数<code>f</code>对符号变量<code>x</code>或最接近字母<code>x</code>的符号变量在<code>a</code>点的<code>n-1</code>阶泰勒多项式,<code>n</code>缺省时值为6,<code>a</code>缺省值为0</li></ul><h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><ul><li><code>solve(f,t)</code>对<code>f</code>中的符号标量<code>t</code>解方程<code>f=0</code></li><li><code>solve(&#39;fname&#39;,t)</code> 求解形如<code>f(x)=g(x)</code>的方程</li><li><code>dsolve(&#39;S&#39;,&#39;s1&#39;,...&#39;x&#39;)</code> </li></ul><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><ul><li>用，都可以用</li></ul><h2 id="化简和代换"><a href="#化简和代换" class="headerlink" title="化简和代换"></a>化简和代换</h2><ul><li><code>collect</code>合并同类项</li><li><code>expand</code>将乘积展开为和式</li><li><code>factor</code>将和式展开为乘积</li><li><code>horner</code>嵌套多项式</li><li><code>simplify</code>利用各种</li></ul><h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><ul><li><code>plot(x,y)</code>其中<code>x</code>和<code>y</code>为坐标向量</li><li><p>在<code>plot</code>指令中增加一些参数，可以绘制出不同颜色与不同线性的图形，e.g.</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(x, y1, <span class="string">'k:'</span>, x, y2, <span class="string">'b-'</span>)</span><br></pre></td></tr></table></figure></li><li><p>每条曲线的线型和颜色由字符串<code>&#39;cs&#39;</code>指定，其中<code>&#39;c&#39;</code>表示颜色，<code>&#39;s&#39;</code>表示线型<br>  <img src="/2019/01/16/matlab-getstart/cs.png"></p></li><li>图形标记指令<code>title</code>,<code>xlabel</code>,<code>ylabel</code>,<code>text</code>,<code>legend</code></li><li><code>axis([xmin, xmax, ymin, ymax])</code>设定坐标轴</li><li><code>hold on</code>保持已有图形绘制新的图形</li><li><code>fplot(fname, lims, tol)</code>为函数提供自适应采样</li><li><code>loglog(x,y)</code>双对数坐标</li><li><code>semilogx,semilogy</code> 单对数坐标</li><li><code>polar(theat, rho)</code> 极坐标</li></ul><p><img src="/2019/01/16/matlab-getstart/plot.png"></p><h2 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h2><ul><li><code>plot3</code>用法同<code>plot</code></li><li><code>mesh(x,y,z,c)</code>绘制三维网格图</li><li><code>surf(x,y,z,c)</code>三维曲面图</li><li><code>view</code>指定视点</li><li><code>contour3</code>等高线图</li></ul><h1 id="MATLAB程序设计"><a href="#MATLAB程序设计" class="headerlink" title="MATLAB程序设计"></a>MATLAB程序设计</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul><li><p><code>input</code>函数</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = input(<span class="string">'Enter matrix A=&gt;'</span>)</span><br><span class="line"><span class="comment">%这样可以在执行该语句时首先给出提示，再接收键盘输入</span></span><br></pre></td></tr></table></figure></li><li><p><code>pause(延迟秒数)</code></p></li><li><code>Disp()</code>输出函数， 输出项可以为矩阵或字符串</li></ul><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><ul><li>结尾需要加<code>end</code></li><li><code>else</code>和<code>if</code>可以连起来写成<code>elseif</code></li></ul><h3 id="swith语句"><a href="#swith语句" class="headerlink" title="swith语句"></a>swith语句</h3><p>与C相比：</p><ul><li><code>default</code>改为<code>otherwise</code></li><li>结尾加<code>end</code></li></ul><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><ul><li>for 初始条件:步长(缺省为1):终值</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">2</span> : <span class="number">2</span>*n<span class="number">-1</span></span><br><span class="line">    <span class="comment">%循环体</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>for 循环变量=矩阵表达式，使循环变量取遍矩阵里每个数的值(以行为周期)</li></ul><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><ul><li>结尾加<code>end</code>，用法同C</li></ul><h2 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h2><ul><li>一般格式为</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 输出形参表 = 函数名<span class="params">(输入形参表)</span></span></span><br><span class="line">    <span class="comment">%注释说明部分</span></span><br><span class="line">    <span class="comment">%函数体</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>当输出形参多于1个时，用方括号括起来</li><li>函数调用<code>[输出参数表]=函数名(输入参数表)</code>，支持嵌套调用和递归</li><li>参数个数可变：通过变量<code>nargin</code>和<code>nargout</code>实现</li><li>函数内部申明的变量都是局部变量</li><li>全局变量前缀<code>global</code>，所有函数都可以对其进行存取和修改</li></ul><h1 id="关于括号"><a href="#关于括号" class="headerlink" title="关于括号"></a>关于括号</h1><h2 id="圆括号"><a href="#圆括号" class="headerlink" title="() 圆括号"></a>() 圆括号</h2><p>引用数组中的元素</p><h2 id="方括号"><a href="#方括号" class="headerlink" title="[] 方括号"></a>[] 方括号</h2><p>表示向量或矩阵</p><h2 id="花括号"><a href="#花括号" class="headerlink" title="{} 花括号"></a>{} 花括号</h2><p>用于元胞(cell)数组的分配和引用<br>元胞与矩阵的区别是能放任何类似的元素，而矩阵只能放数值型数据</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D=&#123;[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>],<span class="string">'abc'</span>,&#123;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>&#125;，[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>;<span class="number">11</span> <span class="number">22</span> <span class="number">33</span>]&#125;</span><br><span class="line"></span><br><span class="line">D&#123;<span class="number">1</span>&#125; <span class="comment">%表示D中第一个元素        显示为 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">D&#123;<span class="number">1</span>&#125;(<span class="number">2</span>) <span class="comment">%表示D中第一个元素中第二个元素        显示为 2</span></span><br><span class="line">D&#123;<span class="number">3</span>&#125;&#123;<span class="number">1</span>&#125; <span class="comment">%表示第三个元素中第一个元素        显示为 7</span></span><br><span class="line"></span><br><span class="line">D&#123;<span class="number">3</span>&#125;(<span class="number">1</span>) <span class="comment">%表示第三个元素中第一个元素        显示为&#123;[7]&#125;</span></span><br><span class="line"></span><br><span class="line">D&#123;[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]&#125; <span class="comment">%表示前三个元素        显示为1 2 3 4 ;    ‘abc’  ;&#123;[7]&#125;  &#123;[8]&#125;  &#123;[9]&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：王正盛 《MATLAB数学工具软件实例简明教程》&lt;/p&gt;
&lt;h1 id=&quot;入门技能&quot;&gt;&lt;a href=&quot;#入门技能&quot; class=&quot;headerlink&quot; title=&quot;入门技能&quot;&gt;&lt;/a&gt;入门技能&lt;/h1&gt;&lt;h2 id=&quot;命令行命令&quot;&gt;&lt;a href=&quot;#命令行命令
      
    
    </summary>
    
      <category term="Self-learning" scheme="https://mengzelev.github.io/categories/Self-learning/"/>
    
    
      <category term="MATLAB" scheme="https://mengzelev.github.io/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>问题求解3-总复习</title>
    <link href="https://mengzelev.github.io/2019/01/07/Problem-Solving-3/"/>
    <id>https://mengzelev.github.io/2019/01/07/Problem-Solving-3/</id>
    <published>2019-01-07T11:21:20.000Z</published>
    <updated>2019-01-08T15:40:21.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><ul><li>问题的最优解由相关子问题的最优解组合而成，这些子问题可以独立求解</li><li>使用“剪切-粘贴”技术证明：假设原问题取得最优解时，子问题没有取最优解，那么可以将子结构从整体删除替换为最优解，这与原问题取得最优解的前提矛盾</li><li>子问题间互相独立</li><li>运行时间：子问题总数*每个问题要考察的选择数</li></ul><p>求解时先找出最优子结构，列出递推式</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>自顶向下的备忘算法（带备忘的递归）</li><li>自底向上的动态规划算法（难写，但是快）</li><li>并没有板子</li></ul><h2 id="能解决的问题"><a href="#能解决的问题" class="headerlink" title="能解决的问题"></a>能解决的问题</h2><ul><li>矩阵乘法问题</li><li>最长公共子序列</li><li>最长上升子序列</li></ul><p><s>&gt;主要就是一个列递推式的问题但是就是列不出来</s></p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h2><ul><li>进行选择时，直接做出当前问题中看来最优的选择，而不必考虑子问题的解</li><li>贪心不太方便时可以进行预处理</li><li>证明：替换法<ul><li>贪心算法得到一个解S，假设存在一个抽象的最优解S’，证明S’可以通过若干步满足要求的替换变成S</li><li>也可以证明S优于S(e.g.S的代价$\le$S’的代价)，加上S’优于S的天然条件，可知S与S’都是最优解</li></ul></li></ul><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ul><li>教室安排问题</li><li>Huffman编码树【可以等价为叶结点的带权路径长度之和最小问题</li><li>区间选点问题<ul><li>数轴上有n个闭区间$[a_i,b_i]$。取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以是同一个）</li><li>将区间按右端点升序排序，优先处理小区间</li></ul></li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul><li>这个完全就是因题而异的了啊【哭了</li></ul><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="三个基本操作"><a href="#三个基本操作" class="headerlink" title="三个基本操作"></a>三个基本操作</h2><ul><li>MAKE-SET($x$)</li><li>UNION($x,y$)</li><li>FIND-SET($x$)：返回$x$所在集合的代表元</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>时间复杂度make和find是$O(1)$，UNION$O(n\lg n)$</li><li>简单加权合并式启发策略（小的并到大的上</li></ul><h2 id="不相交集合森林"><a href="#不相交集合森林" class="headerlink" title="不相交集合森林"></a>不相交集合森林</h2><ul><li>按秩合并，路径压缩</li><li>make和find$O(1)$，UNION$O(m_{\alpha}(n))$</li></ul><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = i;            </span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*递归版*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[i] == i ? i : f[i] = find(f[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*非递归版*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = f[x];</span><br><span class="line">    <span class="keyword">while</span>(root != f[root]) root = f[root];</span><br><span class="line">    <span class="keyword">int</span> y = f[x];</span><br><span class="line">    <span class="keyword">while</span>(x != root) &#123;</span><br><span class="line">        y = f[x];</span><br><span class="line">        f[x] = root;</span><br><span class="line">        x = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(a);</span><br><span class="line">    <span class="keyword">int</span> fb = find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa != fb) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rank[a] &lt; rank[b]) f[a] = fb;</span><br><span class="line">        <span class="keyword">else</span> f[b] = fa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h2><ul><li>带权并查集</li><li>分类并查集</li></ul><p><s>&gt;考到自求多福</s></p><h2 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h2><ul><li>无向图连通分量个数</li></ul><h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><p>参考了ytr的整理</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>诱导子图</li><li>链walk，迹trail，路path</li><li>回路circuit，圈cycle</li><li>连通性，连通分支</li><li>距离，测地线(长度为$u-v$距离的$u-v$路)，直径</li><li>环(loop)，你 连 你 自 己</li><li>平行边：重边</li><li>度数deg，最小度数$\delta(G)$，最大度数$\Delta(G)$</li><li>度序列，可图的</li></ul><h2 id="几种图"><a href="#几种图" class="headerlink" title="几种图"></a>几种图</h2><ul><li>完全图$K_n$</li><li>补图</li><li>二部图，完全二部图($K_{s,t}$)，星图star($K_{1,s}$)</li><li>多部图，完全多部图(K_{s,s,s})</li><li>$G+H$：$G$和$H$放一起，顶点两两连起来</li><li>$G\times H$：$G$的每个点都替换成一个$H$</li><li>n方体cube($Q_n=Q_{n-1}\times K_2$)</li><li>$r-$正则图：每个点度数都为$r$</li></ul><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><ul><li>设$G$是一个阶至少为3的图，则$G$是连通的当且仅当$G$包含两个不同的顶点$u$和$v$,使得$G-u$和$G-v$都是连<br>通的</li><li>非平凡图$G$是二部的当且仅当$G$不含奇圈</li><li><strong>图论第一定理</strong>：度数和=边数*2</li><li>每一个图都有偶数个奇点</li><li>设$G$为$n$阶图,若对于$G$中任意两个不邻接的顶点$u$和$v$, 都满足$$deg~u+deg~v\geq n-1$$，则$G$是连通的且$diam(G)\leq$2</li><li>设$r$和$n$为满足$0\leq r\leq n-1$的整数． 则存在n阶的r正则图当且仅当$r$和$n$中至少有一个为偶数</li><li>度序列可图的充要条件(删掉一个点依然可图)</li></ul><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>割边</li><li>树，森林</li></ul><h2 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h2><ul><li>某条边是割边当且仅当该边不在任何一个cycle上</li><li>每一棵非平凡树都至少有两个端点(最长路径的两个端点)<ul><li><strong>【可以成为数学归纳法的依据】</strong></li><li>使用数学归纳法证明图论问题的关键在于找到一个端点</li></ul></li><li>有$k$个连通分量的森林有$n-k$条边，树就有$n-1$条边</li><li>每一个有$n$个顶点的连通图至少有$n-1$条边【证明：最小数原理】</li><li>任意两条可得树：连通、无环、$m=n-1$</li><li>每个连通图都包含一棵生成树</li><li>Matrix Tree Theorem：连通图$G$的生成树个数可以用行列式求得</li><li>$T$是唯一最小生成树当且仅当$\forall e\in G\setminus T: w(e)&gt;w(\text{every other edge on the cycle in $T+e$})$<ul><li>推论：distinct weights $\Leftarrow$ unique MST</li><li>推论：Maximum-weight edge in any cycle is unique $\Leftarrow$ unique MST </li></ul></li><li>若每个点度数大于等于2，则该图有cycle</li><li>$e$是割边当且仅当$e$存在于$G$的某一棵生成树上</li></ul><h2 id="最小生成树性质"><a href="#最小生成树性质" class="headerlink" title="最小生成树性质"></a>最小生成树性质</h2><ul><li>Cut Property <ul><li>VER I:$X$是某棵最小生成树的一部分，$(S,V\setminus S)$是一个$X$没有横跨的切割，$e$为横跨$(S,V\setminus)$的一条最轻的边，则$X\cup {e}$是某棵最小生成树$T_2$的一部分。</li><li>VER II:$e$为横跨$(S,V\setminus)$的一条最轻的边，则$e$属于某棵最小生成树</li><li>贪心选择性质，可由替换法证明</li></ul></li><li>Cycle Property<ul><li>若$e$为任意一个cycle上权重最大的一条边，则存在一棵最小生成树$T$，使$e\notin T$</li></ul></li></ul><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><ul><li>$O(E\lg~V)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(edge, edge + m, cmp);<span class="comment">//将边按权重从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;<span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edge[i].u;</span><br><span class="line">        <span class="keyword">int</span> b = edge[i].v;</span><br><span class="line">        <span class="keyword">int</span> fa = find(a), fb = find(b);</span><br><span class="line">        <span class="keyword">if</span>(fa != fb) &#123;</span><br><span class="line">            f[fa] = fb;</span><br><span class="line">            ans += edge[i].w;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><ul><li>$O(E\lg V)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        mincost[i] = INF;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; (v == <span class="number">-1</span> || mincost[i] &lt; mincost[v])) v = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">        ans += mincost[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            mincost[i] = min(mincost[i], <span class="built_in">map</span>[v][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图的计算机表示及其遍历"><a href="#图的计算机表示及其遍历" class="headerlink" title="图的计算机表示及其遍历"></a>图的计算机表示及其遍历</h1><h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><ul><li>邻接链表</li><li>邻接矩阵</li></ul><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ul><li>维护一个队列</li><li>时间复杂度$O(V+E)$</li><li>搜完了会得到广度优先树</li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ul><li>前驱子图：深度优先森林</li><li>边的类型<ul><li>树边</li><li>前向边F：祖宗指向儿子</li><li>后向边B：儿子指向祖宗</li><li>横向边C：没有亲缘关系</li></ul></li><li>复杂度$O(V+E)$</li><li>每个结点有两个时间戳<ul><li>$v.d$：记录该结点第一次被发现的时间</li><li>$v.f$：记录搜索完成对$v$的邻接链表的扫描的时间</li><li>$v.d&lt;v.f$</li></ul></li></ul><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul><li>根据DFS后的$v.f$时间戳降序排序，即拓扑序最前的最晚结束访问</li><li>若$(u,v)\in G$，则$v.f&lt;u.f$</li><li>只有DAG才有拓扑排序</li></ul><h2 id="SCC"><a href="#SCC" class="headerlink" title="SCC"></a>SCC</h2><p>算法描述</p><ul><li>DFS($G$)</li><li>DFS($G^{T})$，在主循环根据$v.f$的大小降序访问其邻接点，得到的每棵树都是一个强连通分量</li></ul><h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><ul><li><strong>松弛操作</strong>是<strong>唯一</strong>导致最短路径估计和前驱结点发生变化的操作</li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>三角不等式性质：$s,u,v$</li><li>上界性质：$v.d$撑死就是$\delta(s,v)$</li><li>非路径性质：$s-v$之间没路则$\delta(s,v)=+\infty$</li><li>收敛性质：松弛前是最短路径，松弛后也是最短路径</li><li>路径松弛性质：一条最短路径上的点按先后顺序松弛，则终点的估计值等于最短路径长度</li><li>前驱子图性质：$v.d=\delta(s,v)$，则前驱子图是一棵根结点为$s$的最短路径树</li></ul><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><ul><li>对每条边进行$|V|-1$次relax</li><li>可以识别负权重环</li><li>$O(VE)$</li><li>本质上是DP</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[e[j].u &lt; INF &amp;&amp; dist[e[j].v] &gt; dist[e[j].u] + e[j].w) &#123;</span><br><span class="line">                dist[e[j].v] = dist[e[j].u] + e[j].w;</span><br><span class="line">                pre[e[j].v] = e[j].u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        <span class="keyword">if</span>(dist[e[j].v] &gt; dist[e[j].u] + e[j].w) flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h2><ul><li>按拓扑序松弛结点（路径松弛性质保证）</li><li>$\Theta(V+E)$</li></ul><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><ul><li>所有权重都非负</li><li>二叉堆实现$O(E\lg V)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prority_queue &lt;node&gt; q;</span><br><span class="line">    ver[<span class="number">0</span>].d = <span class="number">0</span>;</span><br><span class="line">    q.push(ver[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> vid = son[u.id][i];</span><br><span class="line">            <span class="keyword">if</span>(ver[vid].d &lt; u.d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(ver[vid].d &gt; u.d + <span class="built_in">map</span>[u.id][vid]) &#123;</span><br><span class="line">                ver[vid].d = u.d + <span class="built_in">map</span>[u.id][vid];</span><br><span class="line">                q.push(ver[vid]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><ul><li>差分图：若$x_j-x_i\le b_k$，则$w(v_i,v_j)=b_k$</li><li>Bellman-Ford可以求解</li></ul><h1 id="所有结点对最短路"><a href="#所有结点对最短路" class="headerlink" title="所有结点对最短路"></a>所有结点对最短路</h1><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><ul><li>我不想管了！！</li><li>是$n$维的Bellman-Ford</li></ul><h2 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h2><ul><li>本质DP，枚举最短路径上的中间结点</li><li>不允许负权重环，但是能报错（看对角元是否有负数）</li><li>$\Theta(n^3)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(); <span class="comment">//记得将所有map[i][i]置零</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) </span><br><span class="line">                <span class="built_in">map</span>[i][j] = min(<span class="built_in">map</span>[i][j], <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Johnson算法"><a href="#Johnson算法" class="headerlink" title="Johnson算法"></a>Johnson算法</h2><ul><li>用于稀疏图</li><li>重新赋值<ul><li>新增源点$s$，该点与各点有权重为0的边</li><li>先跑一次Bellman-Ford，没有负权重环就重新赋值为$\hat{w}(u,v)=w(u,v)+\delta(s,u)-\delta(s,v)$</li><li>对每个点Dijkstra</li><li>恢复权重并返回</li></ul></li><li>$O(VE\lg E)$</li></ul><h1 id="连通度"><a href="#连通度" class="headerlink" title="连通度"></a>连通度</h1><h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><ul><li>$v$与割边相连，则$v$是割点当且仅当$deg~v\ge 2$</li><li>对于至少有3个顶点的连通图，只要有割边，就一定有割点</li><li>$v$是连通图$G$的割点，当且仅当存在两个不同的顶点$u$和$w$，使得$v$位于$u-w$的任意一条路径上</li><li>非平凡连通图中，距离某个点最远的点不是割点</li><li>任意非平凡连通图至少包含两个非割点的顶点</li><li>不可分图：没有割点的非平凡连通图</li></ul><h2 id="块"><a href="#块" class="headerlink" title="块"></a>块</h2><ul><li>图的一个最大不可分子图【类比连通分量</li><li>任意两个不同块的性质<ul><li>不相交</li><li>至多一个公共点</li><li>如果有公共点，则该公共点为割点</li></ul></li></ul><h2 id="连通度-1"><a href="#连通度-1" class="headerlink" title="连通度"></a>连通度</h2><ul><li>$\kappa(G)$点连通度=最小顶点割基数</li><li>$\lambda(G)$边连通度=最小边割基数</li><li>点连通度$\le$边连通度$\le$最小度数    <ul><li>$\kappa(G)\le \lfloor\frac{2m}{n}\rfloor$</li></ul></li></ul><h2 id="Menger定理"><a href="#Menger定理" class="headerlink" title="Menger定理"></a>Menger定理</h2><ul><li>设$u$和$v$是$G$中两个不邻接的顶点，则$u-v$的最小分离集的顶点个数等于内部不相交$u-v$路的最大个数</li><li><p>类似的有边定理：分离$u-v$的边的最小个数等于边不相交$u-v$路的最大个数</p></li><li><p>$k$连通当且仅当任意两个顶点至少有$k$条内部不相交路</p></li><li>$k$连通图中任意$k$个顶点均位于某一个圈上</li></ul><h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*无向图tarjan*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">    dfs_clock ++;</span><br><span class="line">    dfn[u] = low[u] = dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;<span class="comment">//(u,v)是树边</span></span><br><span class="line">            tarjan(v,u);</span><br><span class="line">            child ++;</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>((u == <span class="number">1</span> &amp;&amp; child &gt; <span class="number">1</span>) || (u != <span class="number">1</span> &amp;&amp; dfn[u] &lt;= low[v])) &#123;</span><br><span class="line">                cut_node.push_back(u);</span><br><span class="line">            &#125;<span class="comment">//割点判定：根结点有多个子树，或非根结点的访问序数小于等于能回溯的最大祖先</span></span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u]) bridge.push_back(&#123;min(u,v), max(u,v)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v !=  pre) low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="旅行问题"><a href="#旅行问题" class="headerlink" title="旅行问题"></a>旅行问题</h1><h2 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h2><ul><li>欧拉回路【闭合】/欧拉迹</li><li>有欧拉回路才算欧拉图</li><li>一个非平凡连通图是Euler的 当且仅当它的每个顶点的度都为偶数</li><li>有欧拉迹当且仅当只有两个奇度点</li></ul><h2 id="哈密尔顿图"><a href="#哈密尔顿图" class="headerlink" title="哈密尔顿图"></a>哈密尔顿图</h2><ul><li>哈密尔顿圈/哈密尔顿路</li><li>性质<ul><li>$G$的任一非空子集$S$，都有$k(G-S)\ge |S|$（$G$是哈密尔顿图，$k(G)$指图$G$的连通分支数）</li></ul></li><li>充分条件<ul><li>(Ore定理)对于不少于3个顶点的图，任意两个不邻接的顶点度数之和大于等于$n$，则$G$是哈密尔顿的。</li><li>推论：每个点的度数大于等于$n/2$</li><li>$u$和$v$是不邻接的两个顶点，且度数之和大于等于$n$，则$G+uv$是哈密尔顿的当且仅当$G$是哈密尔顿的</li><li>一个图是哈密尔顿的当且仅当它的闭包是哈密尔顿的</li><li>对于每个整数$j(1\le j\le n/2)$，$G$中度数至多为$j$的顶点数小于$j$，则$G$是哈密尔顿的</li></ul></li></ul><h1 id="匹配与覆盖"><a href="#匹配与覆盖" class="headerlink" title="匹配与覆盖"></a>匹配与覆盖</h1><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><ul><li>Hall条件：$\forall X\subseteq U, |N(X)\ge |X|$</li><li>婚姻定理：$r$个女人，$s$个男人，可能出现$r$对婚姻当且仅当对任意$k$，任意$k$个女人共认识至少$k$个男人。</li><li>最大匹配</li><li>完美匹配：阶为$2k$的图存在一个基数为$k$的匹配</li><li>任意$r$正则二部图均有一个完美匹配</li></ul><h2 id="独立性参数"><a href="#独立性参数" class="headerlink" title="独立性参数"></a>独立性参数</h2><ul><li>最大边独立数$\alpha’(G)$</li><li>最下边覆盖数$\beta’(G)$</li><li>最大点独立数$\alpha’(G)$</li><li>最小点覆盖数$\beta(G)$</li><li>Gallai恒等式<ul><li>点独立数+点覆盖数=$n$</li><li>边独立数+边覆盖数=$n$</li></ul></li><li>一般独立集比覆盖集好求</li></ul><h2 id="因子分解"><a href="#因子分解" class="headerlink" title="因子分解"></a>因子分解</h2><ul><li>$r-$因子：图$G$的$r-$正则生成图</li><li>完美匹配产生1-因子</li><li>图$G$包含1-因子当且仅当对于$V(G)$的任意真子集$S$,$k_O(G-S)\le |S|$。($k_O(G)$表示$G$的奇连通分支个数)</li><li>Petersen定理：所有无割边的3-正则图包含1-因子</li><li>任一至多有两条割边的3-正则图包含1-因子</li><li>可因子分解：能划分成多个因子</li><li>Petersen图不可1-因子分解</li></ul><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">0</span> || find(match[i])) &#123;</span><br><span class="line">                match[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span> ,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(find(i)) ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li>$f:V\times V\to\mathbb{R}$</li><li><strong>容量限制</strong>：$0\le f(u,v)\le c(u,v)$</li><li><strong>流量守恒</strong>：$\forall u\in V-s,t, \sum\limits_{v\in V}f(u,v)=\sum_\limits_{v\in V}f(v,u)$【流入=流出】</li><li>流的值$|f|=\sum\limits_{v\in V}f(s,v)-\sum\limits_{v\in V}f(v,s)$(从源结点流出的总流量-流入源结点的总流量)</li></ul><h2 id="几种特殊处理"><a href="#几种特殊处理" class="headerlink" title="几种特殊处理"></a>几种特殊处理</h2><ul><li>反平行边：拆其中一条边为两条边</li><li>多源多汇</li></ul><h2 id="残存网络"><a href="#残存网络" class="headerlink" title="残存网络"></a>残存网络</h2><p>残存容量<br>$$c_f=(u,v)=\begin{cases}<br>c(u,v)-f(u,v) &amp; (u,v)\in E \<br>f(v,u) &amp; (v,u)\in E\<br>0 &amp; o.w.$$</p><h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><ul><li>把$V$划分为$S$和$T$两个集合，其中$s\in S, t\in T$</li><li>横跨该切割的净流量：$f(S,T)=\sum\limits_{u\in S}\sum\limits_{v\in T}f(u,v)-\sum\limits_{u\in S}\sum\limits_{v\in T}f(v,u)$【所有结点对的流量之和</li><li>切割的容量：$c(S,T)=\sum\limits_{v\in S}\sum\limits_{v\in T}c(u,v)$【只考虑$S$出发进入$T$的容量</li><li>最小切割：容量最小的切割</li><li>最大流最小割定理</li></ul><h2 id="网络流解决最大匹配"><a href="#网络流解决最大匹配" class="headerlink" title="网络流解决最大匹配"></a>网络流解决最大匹配</h2><ul><li>一个集合连$s$，一个集合连$t$，两个集合间两两连，每条边都是单位容量</li><li>$O(VE)$</li></ul><h1 id="图论证明方法"><a href="#图论证明方法" class="headerlink" title="图论证明方法"></a>图论证明方法</h1><p>解题时可能会用到一个或多个</p><ul><li>反证法</li><li>构造法</li><li>临界法(最小/最大的满足条件的一个图)</li><li>归纳法</li><li>算两次</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;最优子结构&quot;&gt;&lt;a href=&quot;#最优子结构&quot; class=&quot;headerlink&quot; title=&quot;最优子结构&quot;&gt;
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
  </entry>
  
  <entry>
    <title>Lab4 实验报告</title>
    <link href="https://mengzelev.github.io/2018/12/29/lab4-report/"/>
    <id>https://mengzelev.github.io/2018/12/29/lab4-report/</id>
    <published>2018-12-29T09:22:55.000Z</published>
    <updated>2019-01-07T11:15:17.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验进度描述"><a href="#实验进度描述" class="headerlink" title="实验进度描述"></a>实验进度描述</h1><p>我已完成所有内容。</p><p>以下是可以忽略的碎碎念：</p><ul><li>实验开始一小时：写代码；实验开始两小时推翻前一个小时写的代码；实验开始四小时：推翻前两小时写的代码……</li><li>会发生上面的情况其实是因为写<code>cache_read</code>的时候觉得调入调出可以封装为函数，写到<code>cache_write</code>的时候觉得<code>cache_read</code>里的寻找比对、缺失处理都可以封装成函数。在写PA的时候深受Copy-paste其害，所以想把能共享的代码都尽量封装成函数，减轻debug的痛苦</li><li>测试的时候曾经出现过写过的地址从cache调出之后回写到内存不成功。加了回写检查函数<code>check_write_back()</code>依然没有定位错误。出去吹了冷风突然意识到可能是回写的内存地址算错了。回去一看发现是cache装入的时候tag没有更新。结论：吹冷风调试法真有用</li><li>一开始在虚拟机里用vim写的时候，为了区分变量，都取了超长的名字，打起来很累，后来无奈先在windows里用CLion打开写了基本框架再放到Linux里进行调试(因为虚拟机里开CLion会卡爆)。CLion写代码真的是体验极佳，下学期OSLab双系统走起了</li><li>我个**！！！第一遍做完数据没用给定的trace！第二遍做的数据被我一个手抖永久删除了！！！excel还没办法脚本导入！！！一个数据做了3遍！！！</li></ul><h1 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h1><p>为了提高代码的复用率、降低debug负担，我封装了很多API。</p><ul><li>为了模拟cache结构定义了如下结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CacheLine</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid; <span class="comment">//有效位</span></span><br><span class="line">    <span class="keyword">bool</span> dirty; <span class="comment">//脏位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag; <span class="comment">//标记位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> data[<span class="number">16</span>]; <span class="comment">//一行64B数据</span></span><br><span class="line">&#125;line[<span class="number">1024</span>];</span><br></pre></td></tr></table></figure><ul><li>定义了如下全局变量来记录cache的相关信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* cache info */</span></span><br><span class="line"><span class="keyword">int</span> ass_width; <span class="comment">//关联宽度</span></span><br><span class="line"><span class="keyword">int</span> total_width; <span class="comment">//总宽度</span></span><br><span class="line"><span class="keyword">int</span> group_width; <span class="comment">//组宽度(指cache组号在主存地址中的位数)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_ASS exp2(ass_width) <span class="comment">//宏定义，组内行数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET  0x3f <span class="comment">//与操作后可以取出块内偏移量</span></span></span><br></pre></td></tr></table></figure><p>将以下功能封装为了API。因为宏定义会涉及到加括号等问题，怕出现奇奇怪怪的bug，所以并没有使用宏定义，而是直接用函数代替</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> get_tag(<span class="keyword">uintptr_t</span> addr) &#123;</span><br><span class="line"><span class="comment">//获得一个内存地址的tag字段</span></span><br><span class="line">    <span class="keyword">return</span> (addr &gt;&gt; (group_width + BLOCK_WIDTH));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> get_group(<span class="keyword">uintptr_t</span> addr) &#123;</span><br><span class="line">    <span class="comment">//获得一个内存地址的cache组号字段</span></span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; BLOCK_WIDTH) &amp; mask_with_len(group_width));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_in</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">int</span> line_num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将主存中某一块调入cache中</span></span><br><span class="line">assert(line[line_num].valid == <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">uint32_t</span> block_num = addr &gt;&gt; BLOCK_WIDTH;</span><br><span class="line">mem_read(block_num, (<span class="keyword">uint8_t</span>*)(line[line_num].data));</span><br><span class="line">line[line_num].valid = <span class="literal">true</span>;</span><br><span class="line">line[line_num].dirty = <span class="literal">false</span>;</span><br><span class="line">line[line_num].tag = get_tag(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_out</span><span class="params">(<span class="keyword">int</span> group_num, <span class="keyword">int</span> line_num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将cache的某一行调回到主存中，同时判断dirty bit并写回</span></span><br><span class="line">assert(line[line_num].valid == <span class="literal">true</span>);</span><br><span class="line">assert(line_num &lt; <span class="number">1024</span>);</span><br><span class="line">line[line_num].valid = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(line[line_num].dirty) &#123;</span><br><span class="line"><span class="keyword">uintptr_t</span> block_num = (line[line_num].tag &lt;&lt; group_width) + group_num;</span><br><span class="line"></span><br><span class="line">mem_write(block_num, (<span class="keyword">uint8_t</span>*)line[line_num].data);</span><br><span class="line">line[line_num].dirty = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//write back</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_in_group</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">int</span> group_num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//在某一组寻找找某主存地址对应的行，返回其所在行号，缺失则返回-1</span></span><br><span class="line"><span class="keyword">int</span> group_start = group_num * NR_ASS;</span><br><span class="line"><span class="keyword">int</span> group_end = group_start + NR_ASS;</span><br><span class="line"><span class="keyword">uint32_t</span> tag = get_tag(addr);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = group_start; i &lt; group_end; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(line[i].valid &amp;&amp; line[i].tag == tag) &#123;</span><br><span class="line">cycle_increase(<span class="number">1</span>);</span><br><span class="line">hit_visit ++;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">replace_in_group</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">int</span> group_num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将主存地址对应的主存块调入cache中</span></span><br><span class="line">miss_visit ++;</span><br><span class="line"><span class="keyword">int</span> group_start = group_num * NR_ASS;</span><br><span class="line"><span class="keyword">int</span> group_end = group_start + NR_ASS;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = group_start; i &lt; group_end; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(!line[i].valid) &#123;</span><br><span class="line">move_in(addr, i);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果组内有空行，则直接放入空行中</span></span><br><span class="line"><span class="keyword">int</span> line_out = group_start + choose(NR_ASS);</span><br><span class="line">assert(line_out &lt; group_end);</span><br><span class="line"></span><br><span class="line">move_out(group_num, line_out);</span><br><span class="line">move_in(addr, line_out);</span><br><span class="line"><span class="comment">//否则随机替换一行</span></span><br><span class="line"><span class="keyword">return</span> line_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_in_line</span><span class="params">(<span class="keyword">int</span> line_num, <span class="keyword">int</span> index, <span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> wmask)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将数据写入cache某一行的某个index中</span></span><br><span class="line">line[line_num].dirty = <span class="literal">true</span>;</span><br><span class="line">line[line_num].data[index] &amp;= (~wmask);</span><br><span class="line">line[line_num].data[index] |= (data &amp; wmask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样一来需要实现的3个函数只需要调用以上API即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">(<span class="keyword">int</span> total_size_width, <span class="keyword">int</span> associativity_width)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*设置cache的一系列参数*/</span></span><br><span class="line">total_width = total_size_width;</span><br><span class="line">assert(total_width &lt;= <span class="number">14</span>);</span><br><span class="line">ass_width = associativity_width;</span><br><span class="line">group_width = total_width - ass_width - BLOCK_WIDTH;</span><br><span class="line"><span class="comment">/*初始化用于统计的变量*/</span></span><br><span class="line">cycle_cnt = <span class="number">0</span>;</span><br><span class="line">total_visit = hit_visit = miss_visit = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* set all the valid bits and dirty bits to invalid */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NR_LINE; ++i) line[i].valid = line[i].dirty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> cache_read(<span class="keyword">uintptr_t</span> addr) &#123;</span><br><span class="line">total_visit ++;</span><br><span class="line"><span class="keyword">uint32_t</span> group_num = get_group(addr);</span><br><span class="line"><span class="keyword">uint32_t</span> index = (addr &amp; OFFSET) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">//index in group</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line_num = find_in_group(addr, group_num);</span><br><span class="line"><span class="keyword">if</span>(line_num &gt;= <span class="number">0</span>) <span class="keyword">return</span> line[line_num].data[index];</span><br><span class="line"><span class="comment">//hit则直接读出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line_out = replace_in_group(addr, group_num);</span><br><span class="line"><span class="keyword">return</span> line[line_out].data[index];</span><br><span class="line"><span class="comment">//否则从主存调入cache</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_write</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> wmask)</span> </span>&#123;</span><br><span class="line">total_visit++;</span><br><span class="line"><span class="keyword">uint32_t</span> group_num = get_group(addr);</span><br><span class="line"><span class="keyword">uint32_t</span> index = (addr &amp; OFFSET) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">//index in group</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line_num = find_in_group(addr, group_num);</span><br><span class="line"><span class="keyword">if</span>(line_num &gt;= <span class="number">0</span>) </span><br><span class="line">write_in_line(line_num, index, data, wmask);</span><br><span class="line"><span class="comment">//hit则直接写入</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> line_out = replace_in_group(addr, group_num);</span><br><span class="line">write_in_line(line_out, index, data, wmask);</span><br><span class="line">&#125;<span class="comment">//否则写分配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="cache性能测试"><a href="#cache性能测试" class="headerlink" title="cache性能测试"></a>cache性能测试</h1><h1 id="运行时间测算"><a href="#运行时间测算" class="headerlink" title="运行时间测算"></a>运行时间测算</h1><ul><li>框架代码已经给内存的读写赋好了相应的时钟周期数，所以我很自然地想到通过统计<strong>时钟周期数</strong>来统计运行的时间</li><li>关于怎么对cache读写操作的时钟周期测算，讲义说可以建立关于关联度的带参数的模型，但是我回想起来课本上讲过，组相联组内是用了很多比较器进行<strong>并行</strong>比较的。所以我认为读写的时钟周期数应该和关联度以及cache容量关系不大，所以将读写的时钟周期都设置为1。<s>&gt;可能也有想省事的惰性成分在里面</s></li><li>除时钟周期数外，还衡量一个缺失率。由于主存读写比cache读写慢得多，读写命中率也能表征cache的性能</li></ul><p>声明了一些用于统计的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* statistics */</span></span><br><span class="line"><span class="keyword">uint64_t</span> total_visit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> hit_visit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> miss_visit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>测算方法：控制变量法，控制组相联度或cache总宽度其中一个量不变，改变另外一个量。每种配置测量3次后取平均。根据结果使用excel作图，得到如下结果。【数据已经放在打包上传的.xlsx文件中】</li></ul><center><br><img src="/2018/12/29/lab4-report/miss-width.png"><br><img src="/2018/12/29/lab4-report/clk-width.png"><br><img src="/2018/12/29/lab4-report/miss-ass.png"><br><img src="/2018/12/29/lab4-report/clk-ass.png"><br></center><p>从以上数据和图表中可以看出：</p><ul><li>cache容量越大，缺失率越低，花费的总时钟周期数也越少。这是因为cache容量大了以后，能装入更多的主存块，缺失率就会相应地降低，需要进行替换的次数也会变少。但是cache大就意味着高昂的造价，而且SDRAM的材质(?)决定了cache不可能做到很大。而且由图中可以看出，当cache容量增大到一定大小时，其性能增长就很不明显了，因此一般会选择比较中等的大小。</li><li><p>缺失率与组相联度似乎并不是呈单调关系。原理上分析，组相联度越大，同一组内发生冲突的概率就越低，需要调出的次数也会越低。但有可能microbench-test中的访存顺序会导致某些经常访问的块，在相联度较小时被放到了不同的组中，而相联度较大时被放到了同一组中，导致发生冲突的次数增加。而且越高的组相联度，意味着越多的比较器，意味着更大的体积和更高的造价。</p></li><li><p>综上，对于microbench-test下的workload，我认为最佳的组相联宽度是2(4路组相联)。如果有钱任性，cache容量越大越好；如果要省钱经济，12或13的容量宽度(4KB或8KB的容量)是比较理想的。</p></li></ul><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h1 id="数据对齐和存储层次结构"><a href="#数据对齐和存储层次结构" class="headerlink" title="数据对齐和存储层次结构"></a>数据对齐和存储层次结构</h1><ul><li>如果没有对齐，同一个数据可能会被分配再两个主存块的交界处，读取这个数据的时候发生cache miss的概率更大，cache miss后可能需要调入两个主存块，代价更大，运行速度会大大降低。</li></ul><h1 id="不知道cache的复杂性对频率的影响"><a href="#不知道cache的复杂性对频率的影响" class="headerlink" title="不知道cache的复杂性对频率的影响?"></a>不知道cache的复杂性对频率的影响?</h1><ul><li>我不是很看得懂这里的建模的意思。我认为$ak^2+b$中%a,b$只是两个参数，考察它们对cache性能的影响是没有意义的，而是应该固定$a,b$，考察组相联度和cache容量对cache性能的影响。但是我已经在上文提到了我并没有把这两者与cache的读写速度关联起来。所以我没有建立带参数的模型。</li></ul><h1 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h1><ul><li>感谢不水的正经学习群的朋友们当我的小黄鸭，帮我调试</li><li>感谢*<em>的自己，因为一系列\</em>*行为，成功锻炼了心理承受能力</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验进度描述&quot;&gt;&lt;a href=&quot;#实验进度描述&quot; class=&quot;headerlink&quot; title=&quot;实验进度描述&quot;&gt;&lt;/a&gt;实验进度描述&lt;/h1&gt;&lt;p&gt;我已完成所有内容。&lt;/p&gt;
&lt;p&gt;以下是可以忽略的碎碎念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实验开始一小时：写代码
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
  <entry>
    <title>PA4实验报告</title>
    <link href="https://mengzelev.github.io/2018/12/28/PA4-report/"/>
    <id>https://mengzelev.github.io/2018/12/28/PA4-report/</id>
    <published>2018-12-28T08:00:32.000Z</published>
    <updated>2019-01-07T11:13:04.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h2><p>我已完成全部实验内容。</p><p>2018/12/15:<br>完成PA4.1。不少自认为关键的地方竟然怎么改都是对的，有点慌</p><p>2018/12/16:<br>PA4.2第一个任务完成，再不开始做数电大实验就要死了，只能封印PA</p><p>2018/12/23：<br>被数电大实验折磨完，PA4.2完成。仙剑跑得慢到感人。</p><p>2018/12/24：<br>平安夜，发现4.2最后一个task忘了跑了，定位了半天bug发现是<code>context_kload</code>忘了改成<code>context_uload</code>，心情简单。开始做4.3，但是由于前几天睡眠不足连着写了好几个沙雕bug，于是决定先放弃。</p><p>2018/12/25：<br>圣诞节，继续写PA4.3，花了一个小时解决了平安夜昏睡状态下写出的沙雕bug，花了4个小时解决了当天写出的沙雕bug，也就是PA最后一个bug。PA通关!</p><h2 id="蓝框思考题"><a href="#蓝框思考题" class="headerlink" title="蓝框思考题"></a>蓝框思考题</h2><p>迫于作业和复习考试压力，这次也一道都没做……</p><h2 id="我遇到的bug"><a href="#我遇到的bug" class="headerlink" title="我遇到的bug"></a>我遇到的bug</h2><ul><li>没看到讲义上要求把<code>loader</code>把文件映射到物理页的要求，映射到虚拟页上，结果一直出发<code>pte.present==0</code>的assert。仔细一想<code>loader</code>的确有义务把程序搬到合适的实际位置</li><li>即使是一个简单的dummy程序，其内容也有两页多。而且不能直接用文件大小/PGSIZE，否则余数部分会被丢弃</li><li><code>make run</code>的时候可能会碰到一大堆链接报错，原因不明，目前解决方案是在所有目录下都来一遍<code>clean(-update)-run</code>全家桶。<s>这时候调试公理1是不是被打破了呢？</s></li><li><code>_switch</code>是用来切换到下一个进程的，因此传入参数肯定为<code>next</code>而非<code>tf</code>【这不是我遇到的bug，是我不少同学都遇到的bug，所以也记下来了</li><li>增加时钟中断时需要填写idt表，太久没碰系统调用这个都忘了</li><li>4.3最后测试进程切换的时候千万不要因为嫌仙剑跑得太慢换成<code>bmptest</code>，这玩意儿是根本block了<code>events_read()</code>的，导致我debug了4个小时才发现</li></ul><h2 id="实验中的发现"><a href="#实验中的发现" class="headerlink" title="实验中的发现"></a>实验中的发现</h2><ul><li>与<code>cr3</code>和<code>cr0</code>有关的指令的译码函数其实可以使用框架代码提供的现成的译码函数,只不过需要研究一下怎么使用</li><li>在写<code>_map</code>函数时，我思考了很久，为什么当页目录的present位无效时，要用回调函数申请一个新的物理页。觉得应该是把这一页作为了存放页表的物理页</li><li>一些头文件里有不少讲义没提到的、可以方便coding的宏定义，例如<code>x86.h</code>和<code>mmu.h</code>,论RTFSC的重要性</li></ul><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ul><li>一定要好好读讲义</li><li>和同学交流了一下，发现不一定要全部理解了再开始写代码。可以把框架代码中提供的东西输出一下，根据输出的值来猜测这个变量的含义，或者这个函数的功能。做实验和理解理论是相辅相成的</li><li>每次开机，看着一行行初始化Log，就会想到这只是一个比我刚刚造完的<s>(其实大部分都是yzh写的)</s>的东西复杂一点<s>(这个一点有点多)</s>的家伙，就觉得五味杂陈</li><li>迫于时间压力不少挑战极限的选做题都没做</li><li>这学期做PA还是依赖了不少人的帮助，寒假想要二周目并完成PA5，希望也能把不少选做题都做一下</li></ul><h1 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h1><ul><li>感谢某人提供的探路和盯着写bug服务</li><li>感谢不水的正经学习群的群友们互帮互助的debug氛围</li></ul><p>本实验报告同样会将去掉必答题的版本同步上传至<a href="https://mengzelev.github.io/">个人blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验进度&quot;&gt;&lt;a href=&quot;#实验进度&quot; class=&quot;headerlink&quot; title=&quot;实验进度&quot;&gt;&lt;/a&gt;实验进度&lt;/h2&gt;&lt;p&gt;我已完成全部实验内容。&lt;/p&gt;
&lt;p&gt;2018/12/15:&lt;br&gt;完成PA4.1。不少自认为关键的地方竟然怎么改都是对的，
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
      <category term="ICS" scheme="https://mengzelev.github.io/tags/ICS/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-矩阵运算</title>
    <link href="https://mengzelev.github.io/2018/12/18/clrs28Matrix-Operation/"/>
    <id>https://mengzelev.github.io/2018/12/18/clrs28Matrix-Operation/</id>
    <published>2018-12-18T01:50:18.000Z</published>
    <updated>2019-01-07T11:16:02.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h1><p>$$Ax=b$$<br><strong>欠定的(underdetermined)</strong>：方程的数目少于未知变量数目$n$，则该线性方程组为欠定的<br><strong>超定的(overdetermined)</strong>:方程数目超过未知变量数目$n$<br><strong>非奇异矩阵</strong>：$A$的秩等于未知变量的个数$n$</p><h2 id="LUP分解"><a href="#LUP分解" class="headerlink" title="LUP分解"></a>LUP分解</h2><p>思想：找出3个$n\times n$矩阵$L,U,P$，满足$PA=LU$,其中<br>$L$是一个单位下三角矩阵<br>$U$是一个上三角矩阵<br>$P$是一个置换矩阵<br>每一个非奇异矩阵$A$都会有这样一种分解<br>$$Ax=b$$<br>$$PAx=Pb$$<br>$$LUx=Pbx$$<br>求解两个三角线性系统<br>下三角系统$Ly=Pb$<br>上三角系统$Ux=y$</p><h2 id="正向替换与方向替换"><a href="#正向替换与方向替换" class="headerlink" title="正向替换与方向替换"></a>正向替换与方向替换</h2><p>可在$\Theta(n^2)$时间内求解下三角系统</p><p>置换阵$P$可以用数组$\pi[1..n]$表示<br>$$P_{i,j}=<br>\begin{cases}<br>1 &amp; (j == \pi[i])\<br>0 &amp; (j\neq\pi[i])<br>\end{cases}<br>$$<br>从第一个式子开始正向替换，可以得到<br>$$y_i=b_{\pi[i]}-\sum\limits_{j=1}^{i-1}l_{ij}y_i$$</p><p>反向替换同理，最终可以得到<br>$$x_i=(y_i-\sum\limits_{j=i+1}^{n}u_{ij}x_j)/u_{ii}$$</p><p><img src="/2018/12/18/clrs28Matrix-Operation/LUP-SOLVE.png"></p><h2 id="LU分解计算"><a href="#LU分解计算" class="headerlink" title="LU分解计算"></a>LU分解计算</h2><p>Gauss消元法：</p><ul><li>行消元得到的行梯阵即$U$</li><li>$L$由消去变量所用的行的乘数组成</li></ul><p><img src="/2018/12/18/clrs28Matrix-Operation/1.png"><br><img src="/2018/12/18/clrs28Matrix-Operation/2.png"></p><p><img src="/2018/12/18/clrs28Matrix-Operation/LU-DE.png"></p><p>可以看成$$a_{ij}=a_{ij}-\frac{a_{ik}a_{kj}}{a_{kk}}$$</p><p>运行时间$\Theta(n^3)$</p><h2 id="LUP分解计算"><a href="#LUP分解计算" class="headerlink" title="LUP分解计算"></a>LUP分解计算</h2><p>在LU分解的基础上，为了保证除数不为0和减少数值不稳定，每次选择该列中具有最大绝对值的元素，交换到对角元的位置</p><p><img src="/2018/12/18/clrs28Matrix-Operation/LUP-DE.png"></p><p>运行时间$\Theta(n^3)$</p><h1 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h1><p>LUP分解可以用于计算逆矩阵(废话，高斯消元可以，LUP当然可以)$$AX_{i}=e_i$$</p><p>矩阵乘法和矩阵求逆具有相同的时间复杂度</p><p>证明时间复杂度相同：两个问题都能在O(另一个问题算法的时间复杂度)时间内解决</p><ul><li>证明的时候可能会用到分块阵的思想来转化问题</li></ul><h1 id="对称正定阵"><a href="#对称正定阵" class="headerlink" title="对称正定阵"></a>对称正定阵</h1><p><strong>引理28.3</strong>：任何对称正定矩阵都是非奇异矩阵<br>任何对称正定矩阵都有逆矩阵。</p><p><strong>引理28.4</strong>：如果$A$是一个对称正定矩阵，那么$A$的每一个主子矩阵都是对称正定的。</p><p><strong>舒尔补</strong>：矩阵$A$关于主子矩阵$A_k$的舒尔补为$S=C-B{A_k}^{-1}B^T$。其中，$A$为对称正定阵且<br>$$A=\left[<br>    \begin{matrix}<br>    A_k &amp; B^T \<br>    B &amp; C<br>    \end{matrix}<br>    \right]$$</p><p><strong>舒尔补定理</strong>：如果$A$是一个对称正定矩阵，$A_k$是$A$的$k\times k$主子矩阵，那么$A$关于$A_k$的舒尔补是对称正定的。</p><p><strong>推论28.6</strong>：一个对称正定矩阵的LU分解永远不会出现除数为0的情形</p><h1 id="最小二乘逼近"><a href="#最小二乘逼近" class="headerlink" title="最小二乘逼近"></a>最小二乘逼近</h1><p>就是看上去很厉害实际上真的很厉害的曲线拟合</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求解线性方程组&quot;&gt;&lt;a href=&quot;#求解线性方程组&quot; class=&quot;headerlink&quot; title=&quot;求解线性方程组&quot;&gt;&lt;/a&gt;求解线性方程组&lt;/h1&gt;&lt;p&gt;$$Ax=b$$&lt;br&gt;&lt;strong&gt;欠定的(underdetermined)&lt;/strong&gt;：
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-平面图与着色</title>
    <link href="https://mengzelev.github.io/2018/12/13/planar-graph-and-coloring/"/>
    <id>https://mengzelev.github.io/2018/12/13/planar-graph-and-coloring/</id>
    <published>2018-12-13T06:30:30.000Z</published>
    <updated>2018-12-15T03:40:57.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h1><p><strong>平面图(planar graph)：</strong>如果$G$能够被画在一个平面上而使得任何两条边都不会交叉</p><p><strong>平图(plane graph)</strong>：如果$G$是平面图且$G$的任何两条边都不交叉</p><p>平面图的例子：cycle, path, star, tree</p><p><strong>区域(regions)</strong>：一个平图把平面分成一些连通片<br><strong>外区域(exterior region)</strong>：每个平图中总有的一个无界的区域<br><strong>边界(boundary)</strong>：在一个平图中，顶点和边斗鱼某个给定区域$R$关联的子图称为是$R$的边界</p><p>割边总是恰好在一个区域的边界上<br>非割边一定位于两个区域的边界上</p><p>如果$G$是一个至少含有三条边的连通平图，则$G$的而每个区域的边界至少含有三条边</p><p><strong>定理9.1(Euler恒等式)</strong>：如果$G$是一个阶为$n$，边数为$m$且含有$r$个区域的连通平图，则$n-m+r=2$</p><p><strong>定理9.2</strong>：如果$G$是一个阶为$n\ge 3$且边数为$m$的平面图，则$m\le 3n-6$。(平面图的必要条件，非平面图的充分条件)<br>逆否命题：设$G$阶为$n$，若$m&gt;3n-6$，则$G$是非平面图。<br>注：满足$m\le 3n-6$的不一定是平面图</p><p><strong>推论9.3</strong>：每个平面图含有一个度小于或等于5的顶点。</p><p><strong>推论9.4</strong>：完全图$K_5$是非平面的。</p><p><strong>极大平面的(maximal planar)</strong>：若$G$是平面的，且在$G$的任意两个不邻接的顶点之间添加一条边即可产生一个非平面图。<br>另一种表述：$G$是平面的，但$G$不是任何一个平面图的生成子图<br>极大平面图满足$m=3n-6$</p><p><strong>定理9.5</strong>：图$K_{3,3}$是非平面的</p><p><strong>细分(subdivision)</strong>： 如果有一个或多个度为2的顶点被插入到$G$的一条或多条边中，则称图$G’$是图$G$的一个细分</p><p><strong>定理9.7(Kuratowski定理)</strong>：一个图$G$是平面图当且仅当$G$不含$K_5$，$K_{3,3}$，或者$K_5$或$K_{3,3}$的一个细分作为子图。</p><p>如果一个图$G$含有(1)至多4个度大于或等于4的顶点(2)至多5个度大于或等于3的顶点，则$G$必定是平面的。</p><h1 id="顶点染色"><a href="#顶点染色" class="headerlink" title="顶点染色"></a>顶点染色</h1><p><strong>对偶(dual)</strong>：每张地图都有一个与之关联的图$G$，称为该地图的对偶，其中$G$的顶点即为地图的区域，$G$的两个顶点是邻接的当且仅当它们所对应的区域是相邻的<br>每张地图的对偶图都是平面图，每个连通的平面图都是某个地图的对偶。</p><p><strong>真染色(proper coloring)</strong>：给$G$的顶点分配一些颜色(来自于某个颜色集合)，是的每个顶点都能分配到一种颜色，且邻接的顶点被染成不同的颜色，简称为<strong>染色(coloring)</strong></p><p><strong>色数(chromatic number)$\chi(G)$</strong>：在$G$的所有染色中，所用的最少颜色数</p><p><strong>$k$可染色的(k-colorable)</strong>：如果能用一个含有$k$种颜色的集合给$G$的顶点染色，则称$G$是$k$<strong>可染色的(k-colorable)</strong>，应用$k$种颜色的染色称为是<strong>$k$染色(k-coloring)</strong>。</p><p>若$\chi(G)=k$，则$G$也称为是<strong>$k$色的(k-chromatic)</strong>，并且$G$的每个$k$染色都是$G$的<strong>最小染色(minimum coloring)</strong></p><p><strong>定理10.1(四色定理)</strong>：每个平面图的色数至多是4</p><p><strong>色类(color classes)</strong>：若$G$是一个$k$色图，则可以把$V(G)$划分成$k$个独立集$V_1,V_2,…,V_k$，此时这些顶点集称为色类。</p><p><strong>定理10.2</strong>：图$G$的色数是2当且仅当$G$是一个非空的二部图。</p><p>(复习：<strong>定理1.12</strong>：图$G$是二部的当且仅当其不含奇圈)<br>若$G$含有奇圈，则$\chi(G)\ge 3$</p><p>$n$阶图$G$的色数为$n$当且仅当$G=K_n$</p><p>证明$\chi(G)=k$，必须证明：</p><ul><li>至少需要$k$种颜色来为$G$染色(不能用$k-1$种颜色为$G$染色)</li><li>存在$G$的一个$k$染色</li></ul><p>若$H$为$G$的一个子图，则$\chi(H)\le\chi(G)$</p><p><strong>团(clique)</strong>：$G$的一个完全子图<br><strong>团数(clique number)\omega(G)</strong>：图$G$中最大团的阶数<br>$\alpha(G)=k$当且仅当$\omega(G)=k$</p><p><strong>定理10.5</strong>：对每个$n$阶图$G$：$$\chi(G)\ge\omega(G), \chi(G)\ge\frac{n}{\alpha(G)}$$<br>(给出了图$G$的色数的下限)</p><p>图$G$的染色可以看成是$V(G)\to\mathbb{N}$的一个函数$c:V(G)\to\mathbb{N}$，使得当$uv\in E(G)$时，$c(u)\neq c(v)$</p><p><strong>定理10.7</strong>：对于每个图$G$，$\chi(G)\le 1+\Delta(G)$。($\Delta(G)$为$G$的最大度)</p><p><strong>定理10.8(Brooks定理)</strong>：对每个非奇圈也非完全的连通图$G$，$\chi(G)\le\Delta(G)$</p><p><strong>定理10.9</strong>：对于每个图$G$,$\chi(G)\le 1+\max{\delta(H)}$，其中$\max$取遍$G$的所有诱导子图$H$。</p><p><strong>影子图(shadow graph)$S(G)$</strong>:通过在$G$中，对其每个顶点$v$，增加一个新的顶点$v’$，称之为$v$的<strong>影子顶点(shadow vertex)</strong></p><p><img src="/2018/12/13/planar-graph-and-coloring/shadow.png"></p><p><strong>定理10.10</strong>：对于每个整数$k\ge 3$，都存在一个色数为$k$的无三角的图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平面图&quot;&gt;&lt;a href=&quot;#平面图&quot; class=&quot;headerlink&quot; title=&quot;平面图&quot;&gt;&lt;/a&gt;平面图&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;平面图(planar graph)：&lt;/strong&gt;如果$G$能够被画在一个平面上而使得任何两条边都不会交叉&lt;/p
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>卫宫家今天的饭</title>
    <link href="https://mengzelev.github.io/2018/12/10/Dinner/"/>
    <id>https://mengzelev.github.io/2018/12/10/Dinner/</id>
    <published>2018-12-10T08:22:19.000Z</published>
    <updated>2018-12-10T09:43:06.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题源"><a href="#题源" class="headerlink" title="题源"></a>题源</h1><p>POJ 3281 Dining<br><a href="http://bailian.openjudge.cn/practice/3479/" target="_blank" rel="noopener">openjudge传送门</a><br><s>饱受OJ折磨的我决定以德报怨给大家出道水题</s></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>基本只是把原题搬到了月球上</p><ul><li>N位客人，F种食物，D种饮料</li><li>每位客人有多种喜欢的事物和饮料</li><li>每位客人只吃一种食物、只喝一种饮料</li><li>每种食物，每种饮料只能被一位客人吃/喝</li></ul><p>可以看成两个二分图最大匹配问题</p><h1 id="构建流网络"><a href="#构建流网络" class="headerlink" title="构建流网络"></a>构建流网络</h1><ul><li>先尝试：食物-客人-饮料 <ul><li>会出现一位客人对应多份食物或饮料的情况</li><li>客人结点需要加上结点容量</li><li>将每个客人结点拆分为两个</li></ul></li><li>源点s-食物-客人1-客人2-饮料-汇点</li></ul><h1 id="最大流算法"><a href="#最大流算法" class="headerlink" title="最大流算法"></a>最大流算法</h1><ul><li>数据规模[1,100]</li><li>EK完全OK</li><li>没有刻意生成卡任何算法的数据，也许可以尝试暴力</li><li>板子写起来有丶难度</li><li>代码虽然我贴了，但是务必自己写一遍！</li></ul><h1 id="EK板子"><a href="#EK板子" class="headerlink" title="EK板子"></a>EK板子</h1><p><img src="/2018/12/10/Dinner/ff.png"></p><ul><li><s>容量c[N][N]，流量f[N][N]</s></li><li>只需要一个记录当前残存容量的数组map[N][N]</li><li>随便搜一下就能找到</li></ul><h2 id="板子代码"><a href="#板子代码" class="headerlink" title="板子代码"></a>板子代码</h2><pre><code>int edmonds_karp() {    int ans = 0;    int minc;    while((minc = bfs()) != -1) { //bfs找到一条增广路径        ans += minc;    //加上这条增广路径的流量        int tt = t,pt;          while(tt != s) {            pt = pre[tt];            map[pt][tt] -= minc;            map[tt][pt] += minc;            tt = pt;        }   //修改这条增广路径上的边的残存容量    }    return ans;}</code></pre><h2 id="bfs寻找增广路径"><a href="#bfs寻找增广路径" class="headerlink" title="bfs寻找增广路径"></a>bfs寻找增广路径</h2><pre><code>int bfs(){    memset(pre, -1, sizeof(pre));    int minc = 1e9;    queue &lt;int&gt; q;    q.push(s);    while(!q.empty()){        int u = q.front();        q.pop();        if(u == t) break;        for(int i = 1; i &lt;= t; ++i) {            if(pre[i] == -1 &amp;&amp; map[u][i]) {                minc = min(minc, map[u][i]);                //更新当前路径的最小残存容量                q.push(i);                pre[i] = u;                 //pre数组用于记录bfs找到的增广路径            }        }    }    if(pre[t] == -1) return -1;    else return minc;}</code></pre><h2 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h2><p>代码不贴惹，自己写吧:)</p><p>Tips:<br>为了将各种不同类型的所有点都囊括在一个数组里的同时，增强代码的可读性，可以使用宏定义</p><pre><code>#define FOOD(x) **我**#define GUEST1(x) **是**#define GUEST2(x) **马**#define DRINK(x) **赛**#define s **克**#define t **!**</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题源&quot;&gt;&lt;a href=&quot;#题源&quot; class=&quot;headerlink&quot; title=&quot;题源&quot;&gt;&lt;/a&gt;题源&lt;/h1&gt;&lt;p&gt;POJ 3281 Dining&lt;br&gt;&lt;a href=&quot;http://bailian.openjudge.cn/practice/3479/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PA3实验报告</title>
    <link href="https://mengzelev.github.io/2018/12/08/PA3-report/"/>
    <id>https://mengzelev.github.io/2018/12/08/PA3-report/</id>
    <published>2018-12-08T08:00:32.000Z</published>
    <updated>2019-01-07T11:11:41.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h1><p>我已完成所有内容。<br>好，下面是惯例碎碎念。</p><p>2018/11/18<br>心态爆炸的一天！先是因为脑子短路完全没有想到<code>idt</code>的地址就在<code>lidt</code>译码过后的<code>id_dest</code>里。然后还因为惯性思维从<code>id_dest-&gt;val</code>里读地址，疯狂出错才发现应该在<code>id_dest-&gt;addr</code>里（因为是地址）。组织Context的时候思考了半天，最后问了大腿才知道怎么判断上下文的组织结构。感觉还是课本知识学得不够扎实的恶果。今日不宜PA，关机睡觉。</p><p>2018/11/19<br>PA3.1完成。感觉测试手段都不太给力，不知道有没有埋下隐藏bug</p><p>2018/11/24<br>PA3.2完成。感觉莫名顺利，可能是3.3要自闭的征兆</p><p>2018/12/1<br>开始自闭PA3.3，实现了文件读写操作，死活看不到PASS!!!，文件读写时对长度超过文件大小的情况的处理有一些麻烦，调了半天，最后发现是PA3.2时就好了的SYS_write没有加上刚刚写的<code>fs_write</code>，喷了。开始编写设备文件操作，看不懂vga那块到底是要干啥，机房关门了，回去睡觉。</p><p>2018/12/2<br>继续自闭PA3.3。为了看懂VGA那块的架构直接翻出了bmptest的源码，然后一路摸到NDL库的源码，花了大概一个下去终于显示出了ProjectN的Logo。实现<code>events_read()</code>时还把事件的格式搞错了debug了半天，终于可以开始跑仙剑了。小心翼翼地开始游戏，没有注释掉<code>Log</code>因此看到了瀑布般的<code>Log</code>信息，然后50min才播放完片头对话，所幸无事。然后注释掉了所有<code>Log</code>，又胆战心惊地开始尝试所有存档点，尝试了穿墙和穿人，全部失败，确认了没有肉眼可见的bug。长舒一口气，然后加急写完了批处理系统，机房关门，走人。难以置信我居然跑出了仙剑，亢奋。</p><h1 id="必答题"><a href="#必答题" class="headerlink" title="必答题"></a>必答题</h1><p><s>其实我写PA的时候都在系统调用过程梳理里做好笔记了</s></p><h2 id="游戏的存档"><a href="#游戏的存档" class="headerlink" title="游戏的存档"></a>游戏的存档</h2><ul><li>仙剑奇侠传中调用C标准I/O库函数<code>fread()</code></li><li>库函数<code>fread()</code>会调用libos中的系统调用的封装函数<code>_read()</code></li><li>libos中的<code>_read()</code>函数通过调用<code>_syscall_()</code>，直接使用内联汇编语句编译出<code>int 0x81</code>的系统调用内陷指令，并将相应的参数放入约定的寄存器中(<code>%eax</code>,<code>%ebx</code>，<code>%ecx</code>，<code>%edx</code>)</li><li>nemu执行指令时遇到了<code>int 0x81</code>指令，译码后执行<code>raise_intr()</code>，将EFLAGS，CS，EIP的值压入栈中，并到am中的中断门描述符表<code>idt</code>中查询0x81对应的跳转目标的偏移量offset，为<code>vectrap()</code></li><li><code>vectrap()</code>直接通过汇编指令将错误码<code>irq</code>压栈，然后跳转到<code>asm_jmp</code>函数执行（nexus-am/am/arch/x86-nemu/src/trap.S中定义）</li><li>在<code>asm_trap</code>中通过<code>pusha</code>指令让nemu将所有寄存器压栈，然后执行<code>irq_handle()</code>函数（在nexus-am/am/arch/x86-nemu/src/cte.c中）</li><li><code>irq_handle()</code>把执行流切换的原因打包成事件，然后调用在<code>_cte_init()</code> 中注册的事件处理回调函数, 将事件交给Nanos-lite来处理</li><li>Nanos-lite中的<code>do_event()</code>函数根据nemu打包传过来的时间决定系统调用类型，此处是<code>_EVENT_SYSCALL</code>类型的，就调用<code>do_syscall()</code>函数来处理这个系统调用</li><li><code>do_syscall()</code>根据上下文中寄存器<code>%eax</code>保存的参数确定系统调用的类型，此时为<code>SYS_read</code>类型，就调用文件系统中的<code>fs_read()</code>并将相应的参数传入</li><li><code>fs_read()</code>根据传入的文件名（存档信息文件的名称）读取需要的长度到指定的位置，恢复成存档前的状态，就可以从存档点继续游戏</li><li><code>fs_read()</code>执行完成后，一路返回到<code>asm_trap</code>中，恢复之前压入栈中保存的寄存器，然后执行<code>iret</code>指令</li><li>nemu执行<code>iret</code>指令，恢复EFLAGS，CS，EIP，跳转到EIP所指向的地方继续执行之后的指令</li></ul><p>至此，一次读取存档的系统调用全部完成</p><h2 id="更新屏幕"><a href="#更新屏幕" class="headerlink" title="更新屏幕"></a>更新屏幕</h2><ul><li>仙剑奇侠传中调用libndl中的库函数<code>NDL_DrawRect()</code></li><li><code>NDL_DrawRect()</code>会调用C标准I/O库函数<code>fwrite()</code>，将当前的像素信息写入<code>stdout</code>中，这里的<code>stdout</code>不是终端里的标准输出，而是应用程序的标准输出<code>_REENT-&gt;stdout</code></li><li>系统调用过程同上，此处不再赘述。进入Nanos-lite的文件系统后，由于是对显示设备抽象成的文件<code>/dev/fb</code>进行读取，<code>fs_write()</code>调用的是<code>fb_write()</code></li><li><code>fb_write()</code>调用了am的klib中提供的<code>screen_width()</code>和<code>draw_rect()</code></li><li>am中的<code>draw_rect()</code>调用了vga设备的写函数<code>video_write()</code>，把相应的像素信息写入到映射到<code>vga_memory</code>的物理内存中</li><li>当nemu访问到从0x4000开始的一段被映射到I/O空间的物理地址时，就会通过<code>mmio_write</code>来修改I/O空间的数据</li><li>I/O空间的数据被修改后调用了<code>update_screen()</code>，由nemu把更新后的屏幕显示信息显示了出来</li><li>进行系统调用的返回操作，同样不再赘述</li></ul><p>至此，一次更新屏幕的系统调用完成</p><h1 id="蓝框思考题"><a href="#蓝框思考题" class="headerlink" title="蓝框思考题"></a>蓝框思考题</h1><p>最近太忙了一题都没写…<br>想写的时候讲义又挂了…<br>二周目的时候再思考吧orz</p><h1 id="实验中的发现"><a href="#实验中的发现" class="headerlink" title="实验中的发现"></a>实验中的发现</h1><h2 id="关于nanos-lite和nemu是怎么通讯的"><a href="#关于nanos-lite和nemu是怎么通讯的" class="headerlink" title="关于nanos-lite和nemu是怎么通讯的"></a>关于nanos-lite和nemu是怎么通讯的</h2><p>在写PA3.1中的<code>lidt</code>指令的时候，我有个很大的疑惑，<code>idt</code>是在nanos-lite里被定义的，nemu要怎么获取它的地址呢？<code>_cte_init</code>中有一步调用了<code>set_idt</code>函数，将idt的地址和大小用内联汇编语句写入了指令集。因此当nanos编译成nemu可执行的指令后，idt的地址就可以通过相应的译码函数写入<code>id_dest</code>中。<br>问了一位nb的学长后，学长给出了如下理解</p><blockquote><p>不在system.c里的指令，一般靠编译c文件成机器码就可以给nemu做事，所以pa2很顺利；而system.c的东西依赖于系统（比如中断），只靠编译c文件做不到int、lidt这些东西，所以要内联汇编</p></blockquote><h2 id="关于如何判断-Context结构的组织顺序"><a href="#关于如何判断-Context结构的组织顺序" class="headerlink" title="关于如何判断_Context结构的组织顺序"></a>关于如何判断<code>_Context</code>结构的组织顺序</h2><p><code>_Context</code>是在函数<code>irq_handle</code>里作为参数的类型被传入的，然而<code>irq_handle</code>是通过汇编代码直接调用的，因此没有显式的参数传递语句，实际的参数是存放在栈中<code>%ebp-8</code>的位置开始的位置，观察<code>call irq_handle</code>之前所有的<code>push</code>相关语句就可以得知寄存器的顺序。而<code>eip</code>,<code>eflags</code>和<code>eip</code>是硬件保存的，因此需要观察<code>int</code>指令中的入栈顺序才能知道这三者的顺序。</p><h2 id="系统调用过程梳理"><a href="#系统调用过程梳理" class="headerlink" title="系统调用过程梳理"></a>系统调用过程梳理</h2><ol><li>用户层navy-apps在相应的系统调用函数（如<code>_exit()</code>）中调用系统调用接口函数<code>_syscall_()</code></li><li><code>_syscall_</code>用内联汇编语句将<code>int 0x80</code>和相应的系统调用参数传给nemu</li><li>nemu执行<code>int</code>指令，叫出nanos-lite</li><li><code>irq_handler</code>通过<code>int</code>指令传入的参数识别出这是一次系统调用的event，打包传给<code>do_event</code></li><li><code>irq.c</code>中的<code>do_event()</code>函数调用<code>do_syscall()</code>执行系统调用事件</li><li><code>syscall.c</code>中的<code>do_syscall()</code>函数根据传入的参数（在上下文的相应寄存器中）执行相应的系统调用操作，设置返回值并返回</li></ol><h1 id="我遇到的bug"><a href="#我遇到的bug" class="headerlink" title="我遇到的bug"></a>我遇到的bug</h1><ul><li>堆区管理的时候声明的用于记录program break的变量<code>pbrk</code>没有初始化【所以说初始化真的是个好文明</li><li>写了<code>fs_write</code>却忘了修改相应的系统调用<code>SYS_write</code>找了一个下午</li><li>所有关于文件读写的系统操作都需要控制<code>open_offset</code>，不能超过当前文件的size，但是<code>serial_write</code>和<code>dispinfo_read</code>等不同文件的读写又不能一概而论，写bug和debug的时候要特别注意</li><li><code>fs_lseek</code>最后要控制当前的<code>open_offset</code>，不然可能会导致<code>fs_read</code>和<code>fs_write</code>的功能无法正常使用</li><li><code>fs_read</code>和<code>fs_write</code>需要对<code>open_offset</code>做出修改</li><li>函数指针的调用就跟函数一样用就行了</li><li><code>fb_write</code>里的<code>offset</code>怎么用，怎么给<code>draw_rect</code>传参，可能要一直摸到<code>libnbl</code>才能搞清楚</li><li>字符串不能x**初始化，会由于某些我搞不懂的原因编译出<code>STOS</code>指令，导致看到亲切的i386 Logo</li><li><code>if((keytemp &amp; 0x8000) == 1)</code>和<code>if(keytemp &amp; 0x8000)</code>是不一样的！！！！！！[你是沙雕吗.jpg]</li></ul><h1 id="对讲义的一些建议（你们选择性反馈给yzh）"><a href="#对讲义的一些建议（你们选择性反馈给yzh）" class="headerlink" title="对讲义的一些建议（你们选择性反馈给yzh）"></a>对讲义的一些建议（你们选择性反馈给yzh）</h1><ul><li>建议把能看到<code>PASS!!!</code>信息的放在<code>serial_write()</code>之后，不少同学都在实现完<code>SYS_write</code>之后没看到PASS！！！感到困惑（当然仔细想一下还是能想通）</li><li>堆区管理那一块太考验阅读理解水平了，而且大部分人会忘掉PA2还接触过AM里一个叫<code>heap</code>的结构体，就稍微提醒一下下呗（</li><li>让dummy实现<code>_syscall_</code>时，最好能提醒一下如果按照之前加系统调用一下加入<code>do_event</code>中会触发死循环，或者干脆把下面的必做部分并到一起写，减少困惑</li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>RTFSC是很难的，不要一下子看不出来就自闭，<s>不然会出事情的</s></li><li>要成为一名优秀的程序猿，首先你要学好语文</li><li>出bug不可怕，如果能通过debug的过程对框架代码和计算机系统的原理有更深刻的理解，其实是一件很赚的事情。听了助教讲课之后我深刻感受到，一出bug就问大腿“怎么写才是对的”，实在太亏了，应该搞清楚哪里写错了，为什么写的fault这个出现这样的failure。</li></ul><h1 id="Appreciation"><a href="#Appreciation" class="headerlink" title="Appreciation"></a>Appreciation</h1><ul><li>感谢某人提供的探路和debug服务，我觉得有点保护过度了再这样下去我要不会自己写代码了【捂脸</li><li>感谢名字一直在换的学习群的群友们互帮互助的debug氛围</li></ul><p>本实验报告同样会将去掉必答题的版本同步上传至<a href="https://mengzelev.github.io/">个人blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验进度&quot;&gt;&lt;a href=&quot;#实验进度&quot; class=&quot;headerlink&quot; title=&quot;实验进度&quot;&gt;&lt;/a&gt;实验进度&lt;/h1&gt;&lt;p&gt;我已完成所有内容。&lt;br&gt;好，下面是惯例碎碎念。&lt;/p&gt;
&lt;p&gt;2018/11/18&lt;br&gt;心态爆炸的一天！先是因为脑子短路
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-最大流</title>
    <link href="https://mengzelev.github.io/2018/12/05/clrs-26Maximum-Flow/"/>
    <id>https://mengzelev.github.io/2018/12/05/clrs-26Maximum-Flow/</id>
    <published>2018-12-05T07:03:20.000Z</published>
    <updated>2019-01-17T12:08:51.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流网络"><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h1><h2 id="流网络-1"><a href="#流网络-1" class="headerlink" title="流网络"></a>流网络</h2><ul><li>有向图$G=(V,E)$</li><li>图中中每条边$(u,v)\in E$有一个非负的<strong>容量值</strong>$c(u,v)\ge 0$</li><li>如果$(u,v)\notin E$，定义$c(u,v)=0$</li><li>如果边集合$E$包含一条边$(u,v)$，则图中不存在反方向的边$(v,u)$</li><li>有<strong>源结点$s$</strong>和<strong>汇点$t$</strong></li><li>流网络图是连通的</li><li>除源结点外的每个结点都至少有一条进入的边，$|E|\ge |V|-1$</li></ul><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>设$G=(V,E)$为一个流网络，其容量函数为$c$。设$s$为网络的源结点，$t$为汇点。$G$中的流是一个实值函数$f: V\times V \to \mathbb{R}$，满足下面两条性质：</p><ul><li><strong>容量限制</strong>：对于所有的结点$u,v\in V$，要求$0\le f(u,v)\le c(u,v)$</li><li><strong>流量守恒</strong>：对于所有的结点$u\in V-{s,t}$，要求$$\sum\limits f(v,u)=\sum\limits f(u,v)$$当$(u,v)\notin E$时，从结点$u$到结点$v$之间没有流，因此$f(u,v)=0$</li></ul><p>称非负数值$f(u,v)$为从结点$u$到结点$v$的流。（流入=流出）</p><p>一个流$f$的<strong>值</strong>$|f|=\sum\limits_{v\in V}f(s,v)-\sum\limits_{v\in V}f(v,s)$ （从源结点流出的总流量减去流入源结点的总流量）</p><p><strong>最大流问题</strong>：给定一个流网络$G$、一个源结点$s$、一个汇点$t$，找到值最大的一个流</p><h2 id="反平行边"><a href="#反平行边" class="headerlink" title="反平行边 "></a><strong>反平行边</strong> </h2><p>如果要使用反平行边来模拟一个流问题，就选择两条反平行边中的一条，加入一个新结点来将其分解为两段，并以新的结点到原来边的结点的两条路替换所选边，同时将两条新设立的边的容量设置为与原来的边的容量相同。</p><p><img src="/2018/12/05/clrs-26Maximum-Flow/antiparallel.png"></p><h2 id="具有多个源结点和多个汇点的网络"><a href="#具有多个源结点和多个汇点的网络" class="headerlink" title="具有多个源结点和多个汇点的网络"></a>具有多个源结点和多个汇点的网络</h2><p>加入一个<strong>超级源结点$s$</strong>和一个<strong>超级汇点$t$</strong></p><p><img src="/2018/12/05/clrs-26Maximum-Flow/multi.png"></p><h1 id="Ford-Fulkerson方法"><a href="#Ford-Fulkerson方法" class="headerlink" title="Ford-Fulkerson方法"></a>Ford-Fulkerson方法</h1><p><img src="/2018/12/05/clrs-26Maximum-Flow/ffm.png"></p><h2 id="残存网络"><a href="#残存网络" class="headerlink" title="残存网络"></a>残存网络</h2><p>给定流网络$G$和流量$f$，残存网络$G_f$由那些仍有空间对流量进行调整的边构成。</p><p>残存容量为$c_f(u,c)=c(u,v)-f(u,v)$</p><p>对正流量的<strong>缩减</strong>：将边$(v,u)$加入到图$G_f$中，并将其残存容量设置为$c_f(v,u)=f(u,v)$</p><p><strong>残存容量</strong>的形式化定义如下：<br><img src="/2018/12/05/clrs-26Maximum-Flow/residual_capacity.png"></p><p>给定一个流网络$G=(V,E)$和一个流$f$，则有$f$所诱导的图$G$的残存网络为$G_f=(V,E_f)$，其中$E_f={(u,v)\in V\times V: c_f(u,v)&gt;0}$，有$|E_f|\le 2|E|$</p><p><strong>递增</strong>：如果$f$是$G$的一个流，$f’$是对应的残存网络$G_f$的中的一个流，定义$$f’\uparrow f’:V\times V\to\mathbb{R}$$为流$f’$对流$f$的<strong>递增</strong></p><p><img src="/2018/12/05/clrs-26Maximum-Flow/augmentation.png"></p><p><strong>抵消操作</strong>：在残存网络中将流量推送回去</p><p><strong>引理26.1</strong>：$$|f\uparrow f’|=|f|+|f’|$$</p><h2 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h2><p><strong>增广路径</strong>$p$：残存网络$G_f$中一条从源结点$s$到汇点$t$的简单路径</p><p><strong>残存容量</strong>：在一条增广路径$p$上能够为每条边增加的流量的最大值$$c_f(p)=\min{c_f(u,v): (u,v)\in p}$$</p><p><img src="/2018/12/05/clrs-26Maximum-Flow/Lemma26-2.png"><br><img src="/2018/12/05/clrs-26Maximum-Flow/Lemma26-3.png"></p><h2 id="流网络的切割"><a href="#流网络的切割" class="headerlink" title="流网络的切割"></a>流网络的切割</h2><p><strong>流网络的切割</strong>：将结点集合$V$划分为$S$和$T=V-S$两个集合，使得$s\in S, t\in T$</p><p>横跨切割的$(S,T)$的<strong>净流量</strong>$f(S,T)$：$$f(S,T)=\sum\limits_{u\in S}\sum\limits_{v\in T}f(u,v)-\sum\limits_{u\in S}\sum\limits_{v\in T}f(v,u)$$</p><p>切割$(S,T)$的<strong>容量</strong>：$$c(S,T)=\sum\limits_{v\in S}\sum\limits_{v\in T}c(u,v)$$<br><strong>最小切割</strong>：整个网络中容量最小的切割</p><ul><li>对于容量，只计算从集合$S$发出进入集合$T$的边的容量，而忽略反方向边上的容量</li><li>对于流，考虑从$S$到$T$的流量减去从$T$到$S$的反方向的流量</li></ul><p><strong>引理26.4</strong>：整个流网络的流量与横跨某一个切割的流量相等$$f(S,T)=|f|$$</p><p><strong>推论26.5</strong>：$|f|\ge c(S,T)$</p><p><strong>定理26.6(最大流最小割定理)</strong><br><img src="/2018/12/05/clrs-26Maximum-Flow/Theorem26-6.png"></p><h2 id="基本的Ford-Fulkerson算法"><a href="#基本的Ford-Fulkerson算法" class="headerlink" title="基本的Ford-Fulkerson算法"></a>基本的Ford-Fulkerson算法</h2><p><img src="/2018/12/05/clrs-26Maximum-Flow/ff.png"></p><p>粗糙的时间复杂度上界：$O(E|f<em>|)$（$f</em>$为将有理数流网络转换成整数流网络后，网络中的一个最大流）</p><h2 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h2><p>在Ford-Fulkerson算法的第三行使用<strong>广度优先搜索</strong>来寻找增广路径。<br>每次在残存网络中选择的增广路径是一条从源结点$s$到汇点$t$的最短路径，其中每条边的权重为单位距离。</p><p>时间复杂度：$O(VE^2)$</p><p><strong>引理26.7</strong>：使用Edmonds-Karp算法，对于除源结点和汇点外的所有结点$v$，残存网络$G_f$中的最短路径距离$\delta_f(s,v)$随着每次流量的递增而单调递增。</p><p><strong>定理26.8</strong>：Edmonds-Karp算法所执行的流量递增操作的总次数为$O(VE)$</p><p><strong>关键边</strong>：在残存网络中，一条路径$p$的残存容量是该条路径上边$(u,v)$的残存容量，即$c_f(p)=c_f(u,v)$<br>对于$E$的每条边来说，其成为关键边的次数最多为$|V|/2$次。</p><h1 id="最大二分匹配"><a href="#最大二分匹配" class="headerlink" title="最大二分匹配"></a>最大二分匹配</h1><p>在一个二分图中，结点集合可以划分为$V=L\cup R$，其中$L$和$R$是不相交的，并且边集合$E$中所有的边都横跨$L$和$R$。</p><p>构造一个流网络$G=(V’,E’)$，其中$$V’=V\cup{s,t}$$$$E={(s,u):u\in L, u\in L}\cup {(u,v):(u,v)\in E}\cup {(v,t):v\in\mathbb{R}}$$<br>给$E’$中的每条边赋单位容量</p><p><img src="/2018/12/05/clrs-26Maximum-Flow/26-9.png"></p><p>流$f$是<strong>整数值</strong>的：对于所有的边$(u,v)\in V\times V$，$f(u,v)$都是整数值。</p><p><strong>定理26.10（完整性定理Integrality theorem）</strong>：如果容量函数$c$只能取整数值，则$Ford-Fulkerson$方法所生成的最大流$f$满足$|f|$是整数值的性质。而且，对于所有的结点$u$和$v$，$f(u,v)$都是整数。</p><p><strong>推论26.11</strong>：二分图$G$中的一个最大匹配$M$的基数等于其对应的流网络$G’$中某一最大流$f$的值。</p><p>时间复杂度：$O(VE)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;流网络&quot;&gt;&lt;a href=&quot;#流网络&quot; class=&quot;headerlink&quot; title=&quot;流网络&quot;&gt;&lt;/a&gt;流网络&lt;/h1&gt;&lt;h2 id=&quot;流网络-1&quot;&gt;&lt;a href=&quot;#流网络-1&quot; class=&quot;headerlink&quot; title=&quot;流网络&quot;&gt;&lt;/a&gt;流网
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-图中的匹配与覆盖</title>
    <link href="https://mengzelev.github.io/2018/11/28/matchings/"/>
    <id>https://mengzelev.github.io/2018/11/28/matchings/</id>
    <published>2018-11-28T06:59:39.000Z</published>
    <updated>2018-12-01T02:14:22.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><h2 id="匹配的定义"><a href="#匹配的定义" class="headerlink" title="匹配的定义"></a>匹配的定义</h2><p><strong>独立</strong>：若图的边集中任意两条边不邻接，则称该集合是独立的</p><p><strong>匹配</strong>：图$G$中的边的一个独立集<br>$G$的<strong>匹配</strong>是一个边的集合$M={e_1,e_2,…,e_k}$，其中$e_i=u_iw_i(1\le i\le k)$，使得$u_1,u_2,…,u_k$是$U$中$k$个不同的顶点，$w_1,w_2,…,w_k$是$W$中$k$个不同的顶点。</p><h2 id="匹配存在的条件"><a href="#匹配存在的条件" class="headerlink" title="匹配存在的条件"></a>匹配存在的条件</h2><p><strong>邻域(neighbourhood)</strong>$N(X)$：设$G$为二部图，其部集为$U$和$W$，且$|U|\le |W|$，对于$U$的非空子集$X$，$X$中所有顶点的邻域的并。</p><p><strong>Hall’s condition/友好的(neighborly)</strong>：对于$U$的任意非空子集$X$，均有$|N(X)|\ge |X|$。</p><p><strong>定理8.3</strong>：设$G$为二部图，其部集为$U$和$W$，且$r=|U|\le |W|$。则$G$包含一个基数为$r$的匹配当且仅当$U$是<strong>友好的</strong>。 </p><p><strong>定理8.4</strong>：非空有限集族${S_1,S_2,…,S_n}$有一个互异代表元系(system of distinct representative) 当且仅当 对于任一整数$k(1\le k\le n)$，集族中任意$k$个集合的并至少包含$k$个元素。</p><p><strong>定理8.5(婚姻定理)</strong>:在一个由$r$个女人和$s$个男人构成的人群中，$1\le r\le s$，在熟识的男女之间可能出现$r$对婚姻当且仅当对每个整数$k(1\le k\le r)$，任意$k$个女人共认识至少$k$个男人。</p><p><strong>最大匹配(maximum matching)</strong>：具有最大基数的匹配</p><p><strong>完美匹配(perfect matching)</strong>：阶为$2k$的图$G$存在一个基数为$k$的匹配$M$，则称该匹配$M$为完美匹配</p><p><strong>定理8.6</strong>：任意$r$正则二部图$(r\ge 1)$均有一个完美匹配。</p><h2 id="边的独立性参数"><a href="#边的独立性参数" class="headerlink" title="边的独立性参数"></a>边的独立性参数</h2><p><strong>边独立数(edge independence number)</strong>$\alpha ‘(G)$：最大边独立集的基数</p><p><strong>覆盖</strong>：一个顶点和与其相连的一条边</p><p><strong>边覆盖数(edge covering number)</strong>$\beta ‘(G)$：$G$中所有边覆盖的最小基数</p><p><strong>最小边覆盖集(minimum edge cover)</strong>：具有最小基数的边覆盖集</p><p><strong>定理8.7</strong>：对于任意不包含孤立点的$n$阶图$G$，$$\alpha’(G)+\beta’(G)=n$$</p><h2 id="顶点的独立性参数"><a href="#顶点的独立性参数" class="headerlink" title="顶点的独立性参数"></a>顶点的独立性参数</h2><p>如果图中的一个顶点集合中任意两顶点都不邻接，则称该顶点的集合是<strong>独立</strong>的</p><p><strong>点独立数(vertex independence number)</strong>$\alpha(G)$:$G$中点独立集的最大基数，又称<strong>独立数</strong></p><p><strong>最大独立集(maximum independence set)</strong>：图$G$中基数为$\alpha(G)$的独立集</p><p><strong>点覆盖(vertex cover)</strong>：图$G$的某个顶点子集可以覆盖$G$的所有边</p><p><strong>点覆盖数(vertex covering number)</strong>$\beta(G)$：$G$的所有点覆盖的最小基数</p><p><strong>最小点覆盖(minimum vertex cover)</strong>：基数为$\beta(G)$的点覆盖</p><p><strong>定理8.8</strong>:对于任意不包含孤立点的$n$阶图，$$\alpha(G)+\beta(G)=n$$</p><p><strong>定理8.7</strong>与<strong>定理8.8</strong>合称为<strong>Gallai恒等式</strong></p><p>一般独立集比覆盖集好求</p><h1 id="因子分解"><a href="#因子分解" class="headerlink" title="因子分解"></a>因子分解</h1><h2 id="1因子"><a href="#1因子" class="headerlink" title="1因子"></a>1因子</h2><p><strong>1因子(1-factor)</strong>：图$G$的1正则生成子图。<br>$n$阶图$G$的完美匹配$M$的诱导的子图$F[M]$是$G$的1因子。<br>图$G$有1因子当且仅当$G$有完美匹配。</p><p>连通分支的<strong>奇偶性</strong>就是该连通分支的阶的<strong>奇偶性</strong>。<br>$k_O(G)$表示图$G$的<strong>奇连通分支</strong>的个数。</p><p><strong>定理8.10</strong>：图$G$包含1因子当且仅当对于$V(G)$的任意真子集$S$，$k_O(G-S)\le |S|$。</p><p><strong>定理8.11(Petersen定理)</strong>：所有无割边的3正则图包含1因子。</p><p><strong>定理8.12</strong>：任一至多含有两条割边的3正则图包含1因子。</p><h2 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h2><p><strong>可因子分解的(1-factorable)</strong>：若$G$有1因子$F_1,F_2,…,F_r$，使得${E(F_1),E(F_2),…,E(F_r)}$是$E(G)$的一个划分，此时我们称$G$被<strong>因子分解(factored)</strong>成1因子$F_1,F_2,…,F_r$；这些1因子构成了$G$的<strong>1因子分解(1-factorization)</strong></p><p>任一可1因子分解的图是正则的，反之不真，反例：Peterson图</p><p><strong>定理8.13</strong>：Petersen图是不可1因子分解的。</p><p><strong>定理8.14</strong>：对于任意正整数$k$，完全图$K_{2k}$是可1因子分解的。</p><p><strong>循环因子分解(cyclic factorization)</strong>：如图所示，所有因子分解可以由某一个因子分解旋转一定角度得到</p><p><img src="/2018/11/28/matchings/cyclic.png"></p><p><strong>定理8.15</strong>：任意$r$正则的二部图$(r\ge 1)$是可1因子分解的。</p><h2 id="2因子"><a href="#2因子" class="headerlink" title="2因子"></a>2因子</h2><p><strong>2因子(2-factor)</strong>：图$G$的二正则生成子图</p><p>2因子的任一连通分支是一个圈。</p><p><strong>可2因子分解的(2-factorable)</strong>：定义类似1因子</p><p><strong>定理8.16</strong>：图$G$是可2因子分解的当且仅当存在某个正偶数$r$，是的$G$是$r$正则的。</p><p><strong>*Hamilton因子分解(Hamilton factorization)</strong>：$G$的一个2因子分解，满足该分解中所有2因子均是Hamilton圈</p><p><strong>定理8.17</strong>：对于任一整数$k\ge 1$，完全图$K_{2k+1}$是可Hamilton分解的。<br>证明：构造法（如图）</p><p><img src="/2018/11/28/matchings/K9.png"></p><h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p><strong>因子(factor)</strong>：图$G$不含有孤立点的生成子图</p><p><strong>可因子分解(factorable)</strong>：因子$F_1,F_2,…,F_r$，满足${E(F_1),E(F_2),…,E(F_r)}$是$E(G)$的一个划分。</p><p><strong>可F-因子分解的(F-factorable)</strong>：若存在某个图$F$，是的每个因子$F_i\cong F$</p><h2 id="Kirkman三元系"><a href="#Kirkman三元系" class="headerlink" title="Kirkman三元系"></a>Kirkman三元系</h2><p><strong>n阶的Kirkman三元系(Kirkman triple system)</strong>：有一个基数为$n$的集合$S$，和$S$的三元子集（称为<strong>三元组(triple)</strong>）族$T$，以及$T$的一个划分$\mathcal{P}$构成，且满足如下性质：</p><ol><li>$S$中任意两个不同的元素属于$T$中唯一的三元组</li><li>$S$中任一元素属于划分$\mathcal{P}$的每一元素的唯一的三元组</li></ol><p>存在一个$6k+3$阶Kirkman三元系当且仅当存在一个$K_{6k+3}$的$(2k+1)K_3$因子分解</p><p><strong>定理8.19</strong>：$n(n\ge 3)$阶的Kirkman三元系存在当且仅当$n\equiv 3(mod 6)$，即$n=6k+3$</p><p><strong>定理8.20</strong>：对于每个整数$k\ge 1$，完全图$K_{2k}$可因子分解为$k-1$个Hamilton圈和一个1因子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;匹配&quot;&gt;&lt;a href=&quot;#匹配&quot; class=&quot;headerlink&quot; title=&quot;匹配&quot;&gt;&lt;/a&gt;匹配&lt;/h1&gt;&lt;h2 id=&quot;匹配的定义&quot;&gt;&lt;a href=&quot;#匹配的定义&quot; class=&quot;headerlink&quot; title=&quot;匹配的定义&quot;&gt;&lt;/a&gt;匹配的定
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
      <category term="Matchings" scheme="https://mengzelev.github.io/tags/Matchings/"/>
    
      <category term="Factorization" scheme="https://mengzelev.github.io/tags/Factorization/"/>
    
  </entry>
  
  <entry>
    <title>Lab3：链接与加载（2）实验报告</title>
    <link href="https://mengzelev.github.io/2018/11/24/lab3-report/"/>
    <id>https://mengzelev.github.io/2018/11/24/lab3-report/</id>
    <published>2018-11-24T09:17:47.000Z</published>
    <updated>2018-11-30T14:18:07.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现描述"><a href="#实现描述" class="headerlink" title="实现描述"></a>实现描述</h1><h2 id="寻找正确的入口地址"><a href="#寻找正确的入口地址" class="headerlink" title="寻找正确的入口地址"></a>寻找正确的入口地址</h2><p>在框架代码抽取出的<code>symtab</code>中主项寻找，如果该项的<code>Type</code>属性为<code>STT_FUNC</code>，就根据其<code>st_name</code>属性去字符串表<code>strtab</code>里寻找该函数的<code>Name</code>属性，并与<code>main</code>进行对比，就能找到<code>main</code>函数对应的表项，此时该表项的<code>st_value</code>属性即 我们需要的入口地址。</p><h2 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h2><p><code>loader()</code>函数的实现需要程序头表，模仿<code>load_elf_table()</code>函数的写法可将程序头表抽取到结构体<code>Elf32_phdr</code>中，找到<code>p_type</code>为<code>PT_LOAD</code>的表项，读取其<code>p_offset</code>，<code>p_vaddr</code>，<code>p_filesz</code>，<code>p_memsz</code>属性，按照讲义的描述，使用<code>fread</code>函数将可执行文件中相对文件偏移<code>p_offset</code>的内容读取<code>p_filedz</code>到内存地址为<code>[p_addr, p_addr + p_filesz</code>的地方，并用<code>memset</code>函数将<code>[p_vaddr + p_filesz, p_vaddr + p_memsiz)</code>对应的物理区间清零。</p><h2 id="打印栈帧链"><a href="#打印栈帧链" class="headerlink" title="打印栈帧链"></a>打印栈帧链</h2><p>第一次打印<code>eip</code>的值作为当前地址，之后每次都取内存中<code>ebp-4</code>的地址存放的返回地址作为函数调用的地址。函数的名字通过去<code>symtab</code>中寻找对应表项并从<code>strtab</code>中提取而得。仿照gdb的<code>bt</code>命令输出打印出来。对<code>ebp</code>的值解引用能得到上一个函数的<code>ebp</code>的值。如此循环直到<code>ebp</code>的信息为0为止。</p><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p>留着以后当笑话看的碎碎念</p><h2 id="寻找正确的入口地址-1"><a href="#寻找正确的入口地址-1" class="headerlink" title="寻找正确的入口地址"></a>寻找正确的入口地址</h2><p>我本来以为这个只要做好RTFSC就不会花太多时间的，<code>man 5 elf</code>之后理所当然地写了如下代码：</p><pre><code>if(symtab[i].st_info == STT_FUNC)</code></pre><p>发现怎么都找不到<code>main</code>，各种调试了一个多小时之后，问了同学才意识到，<code>st_info</code>不是直接的<code>type</code>值，<code>type</code>只占了低四位，高四位为绑定属性<code>bind</code>，把FM继续往下翻可以看到</p><pre><code>ELF32_ST_BIND(info), ELF64_ST_BIND(info)                                                                    Extract a binding from an st_info value. </code></pre><p><s>泪，可以流下来吗</s><br>论耐心RTFM的重要性</p><h2 id="加载程序-1"><a href="#加载程序-1" class="headerlink" title="加载程序"></a>加载程序</h2><p>这部分基本是照抄框架代码抽取<code>El32_Shdr</code>的方法抽取了<code>Elf32_Phdr</code>，让我自己写大概还是写不出来的吧[自卑.jpg]</p><h2 id="打印栈帧连"><a href="#打印栈帧连" class="headerlink" title="打印栈帧连"></a>打印栈帧连</h2><p>先用gdb调试了给的<code>segmentfault.c</code>，摸索了一下<code>bt</code>命令的打印格式，确认了打印的栈帧链中的地址为函数调用时压入栈中的返回地址。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="堆和栈在哪里？"><a href="#堆和栈在哪里？" class="headerlink" title="堆和栈在哪里？"></a>堆和栈在哪里？</h2><p>经过PA3.2的调教，可以知道堆是程序运行时调用<code>malloc</code>动态向高地址申请空间维护的。堆区的开始位置就是数据段的结束位置。当调用<code>malloc</code>函数时，会触发系统调用<code>sbrk</code>查询并调整堆区的结束位置，即program break，以调整堆区的大小。<br>栈区是从内核虚存区开始向低地址方向生长的，栈顶的地址保存在寄存器<code>esp</code>中。通过<code>push</code>和<code>pop</code>等指令来调整栈区大小。<br>堆和栈的内容不放入可执行文件，我猜想一方面因为这些部分是动态生成的，程序执行过程中它们的大小时刻变化着，因此不能放入静态的可执行文件中。另一方面，栈区会有一个随机化操作来防止恶意攻击，不便于放入可读的可执行文件中。</p><h2 id="如何识别不同格式的可执行文件？"><a href="#如何识别不同格式的可执行文件？" class="headerlink" title="如何识别不同格式的可执行文件？"></a>如何识别不同格式的可执行文件？</h2><p>ELF可执行目标文件有ELF头，根据ELF可执行文件的各种规范书写。Windows生成的可执行文件应该也有自己的文件头的格式，在GNU/Linux下执行时，系统按照ELF头的格式解析该文件的文件头出现了错误，例如没有读到“魔数”，就会报告“格式错误”。</p><h2 id="消失的符号"><a href="#消失的符号" class="headerlink" title="消失的符号"></a>消失的符号</h2><p>因为这些符号只在本模块内被使用，其被动态分配在栈中，链接器并不需要这些符号的信息，因此不会出现在符号表中。符号是指参与链接的变量名和函数名。</p><h2 id="寻找”Hello-World-”"><a href="#寻找”Hello-World-”" class="headerlink" title="寻找”Hello World!”"></a>寻找”Hello World!”</h2><p>用上述方法找到<code>hello</code>程序的字符串表，会发现“Hello World!”字符串…它…根本不在字符串表中，而是在<code>.rodata</code>节中。</p><p><img src="/2018/11/24/lab3-report/HelloWorld.png"></p><p>因为<code>printf</code>中的格式化字符串是一个只读的字符串，所以编译时会被放入只读数据节<code>.rodata</code>节中。</p><h2 id="冗余的符号表"><a href="#冗余的符号表" class="headerlink" title="冗余的符号表"></a>冗余的符号表</h2><p>编译单独的hello程序没有问题，但是尝试对hello.o进行链接时就会链接报错（忘了截图了）。因为符号表用于链接中的符号解析，单独运行程序时没有符号表，单有指令就也没有问题。</p><h2 id="冗余的属性？"><a href="#冗余的属性？" class="headerlink" title="冗余的属性？"></a>冗余的属性？</h2><p>起初我猜测是.bss节的数据没有在<code>Filesz</code>中被计算，而是计算在了<code>Memsz</code>中。但是我把.bss节的大小加上<code>Filesz</code>后还是比<code>Memsz</code>小一些，STFW发现stackoverflow上有人问了类似的问题，欣喜地点进去发现并没有人回答….我再思考一下说不定就有stackoverflow首答了…</p><h2 id="为什么要清零？"><a href="#为什么要清零？" class="headerlink" title="为什么要清零？"></a>为什么要清零？</h2><p>数电和问求还没写完，溜了…….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实现描述&quot;&gt;&lt;a href=&quot;#实现描述&quot; class=&quot;headerlink&quot; title=&quot;实现描述&quot;&gt;&lt;/a&gt;实现描述&lt;/h1&gt;&lt;h2 id=&quot;寻找正确的入口地址&quot;&gt;&lt;a href=&quot;#寻找正确的入口地址&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-旅行问题</title>
    <link href="https://mengzelev.github.io/2018/11/21/traversability/"/>
    <id>https://mengzelev.github.io/2018/11/21/traversability/</id>
    <published>2018-11-21T13:05:50.000Z</published>
    <updated>2018-11-30T14:19:40.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Euler图"><a href="#Euler图" class="headerlink" title="Euler图"></a>Euler图</h1><p><strong>Euler回路(Euler cycle)</strong>：图$G$的一条包含$G$的每一条边的回路$C$</p><p><strong>Euler图(Euler graph)</strong>:含有Euler回路的连通图</p><p><strong>Euler迹(Euler trial)</strong>含有连通图$G$的每条边的开迹</p><p>当讨论图的Euler性质时，</p><p><strong>定理6.1</strong>：一个非平凡连通图$G$是Euler的 当且仅当 $G$的每个顶点的度都为偶数</p><p><strong>推论6.2</strong>：一个连通图$G$含有一条Euler迹当且仅当$G$恰有两个度为奇数的顶点，而且$G$的每一条Euler迹始于一个度为奇数的顶点而终止于另一个度为奇数的顶点。</p><p><strong>例6.3结论</strong>：设$G$和$H$是两个非平凡的连通图，则$G\times H$是Euler的当且仅当$G$和$H$都是Euler的或者$G$和$H$的每个顶点度均为奇数。</p><h1 id="Hamilton图"><a href="#Hamilton图" class="headerlink" title="Hamilton图"></a>Hamilton图</h1><p><strong>Hamilton圈(Hamiltonian cycle)</strong>：一个含图$G$的每个顶点的圈</p><p><strong>Hamilton图(Hamiltonian graph)</strong>：一个含有Hamilton圈的图</p><p><strong>Hamilton路(Hamiltonian path)</strong>：一条含图$G$的每个顶点的路</p><p>有Hamilton圈, 一定有Hamilton路；<br>有Hamilton路，不一定有Hamilton圈</p><h2 id="Hamilton图的特征"><a href="#Hamilton图的特征" class="headerlink" title="Hamilton图的特征"></a>Hamilton图的特征</h2><ul><li>$n\ge 3$阶图的一个Hamilton圈$C$是$n$阶的连通2正则子图</li><li>$C$不含有阶小于$n$的圈作为子图</li><li>$G$也不含有有度大于等于3的子图</li><li>如果$G$含有度为2的顶点，则与$v$关联的两条边一定位于$C$上</li></ul><p><strong>定理6.4</strong>：Peterson图不是Hamilton的</p><h2 id="Hamilton图的性质"><a href="#Hamilton图的性质" class="headerlink" title="Hamilton图的性质"></a>Hamilton图的性质</h2><p>$k(G)$：图的连通分支数</p><p><strong>定理6.5</strong>：如果$G$是一个Hamilton图，则对$G$顶点的任一非空真子集$S$，都有$k(G-S)\ge |S|$（一个图是Hamilton图的<strong>必要条件</strong>）<br>逆否命题：设$G$为一个图。如果对$V(G)$的某个非空真子集$S$,有$k(G-S)&gt;|S|$，则$G$不是Hamilton的（一个图为非Hamilton的充分条件）<br>如果图$G$含有一个割点$v$，则$G$不是Hamilton的</p><h2 id="Hamilton图的充分条件"><a href="#Hamilton图的充分条件" class="headerlink" title="Hamilton图的充分条件"></a>Hamilton图的充分条件</h2><p><strong>定理6.6(Ore 定理)</strong>：设$G$为一个$n(n\ge 3)$阶的图，如果对于$G$的每对不邻接的顶点$u,v$，有$deg u +deg v\ge n$,则$G$是Hamilton的。<br>该定理给出的界是紧的</p><p><strong>推论6.7</strong>：设$G$为一个$n\ge 3$的图，如果对于$G$的每个顶点$v$，均有$deg v\ge n/2$，则$G$是Hamilton的。</p><p><strong>定理6.8</strong>：设$u$和$v$是一个$n$阶图$G$的两个不邻接的顶点，并且$deg u + deg v\ge n$，则$G+uv$是Hamilton的当且仅当$G$是Hamilton的。</p><p><strong>闭包(closure)</strong>：由$G$出发递归地连接度数之和至少为$n$的不邻接顶点对，记为$C(G)$</p><p><strong>定理6.9</strong>：一个图是Hamilton的当且仅当它的闭包是Hamilton的。</p><p><strong>推论6.10</strong>：如果$G$是一个阶至少为3的图，且它的闭包$C(G)$是一个完全图，则$G$是一个Hamilton图</p><p><strong>定理 6.11</strong>：设$G$是一个$n(n\ge 3)$阶的图。如果对于每个整数$j(1\le j&lt;\frac{n}{2})$，$G$中度至多为$j$的顶点数小于$j$，则$G$是Hamilton的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Euler图&quot;&gt;&lt;a href=&quot;#Euler图&quot; class=&quot;headerlink&quot; title=&quot;Euler图&quot;&gt;&lt;/a&gt;Euler图&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Euler回路(Euler cycle)&lt;/strong&gt;：图$G$的一条包含$G$的每一条
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
      <category term="Traversibility" scheme="https://mengzelev.github.io/tags/Traversibility/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-图中的连通性与距离</title>
    <link href="https://mengzelev.github.io/2018/11/14/connectivity/"/>
    <id>https://mengzelev.github.io/2018/11/14/connectivity/</id>
    <published>2018-11-14T08:19:10.000Z</published>
    <updated>2018-11-30T14:19:28.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h1><p>割点的定义：去掉这个点后，原图不再连通</p><p><strong>定理5.1</strong>：设$v$是连通图$G$中与bridge相连的一个结点，则$v$是割点当且仅当$deg v\ge 2$<br>非简单树 = 端点 + 割点</p><p><strong>推论5.2</strong>：设$G$是一个至少有3个顶点的连通图，若$G$有bridge，则$G$一定有割点</p><p><strong>定理5.3</strong>：设$v$是连通图$G$的一个割点，$u$和$w$是$G-v$不同components中的两个顶点，则$v$位于$G$的任意一条$u-w$路径上。</p><p>回顾<strong>定理4.1</strong>：边$e$是bridge当且仅当$e$不存在于任何一个cycle上</p><p><strong>推论5.4</strong>：$v$是连通图$G$的一个割点 当且仅当 存在与$v$不同的两个顶点$u$和$w$，使得$v$位于$G$的任意一条$u-w$路上</p><p><strong>定理5.5</strong>：设$G$是非平凡连通图，$u\in V(G)$。若$v$是$G$中距离$u$最远的顶点，则$v$不是$G$的割点。</p><p><strong>推论5.6</strong>：任意非平凡的连通图至少包含两个非割点的顶点。</p><h1 id="块-Blocks"><a href="#块-Blocks" class="headerlink" title="块(Blocks)"></a>块(Blocks)</h1><p><strong>不可分图(nonseparable graph)：</strong>没有割点的非平凡连通图</p><p><strong>定理5.7</strong>：结点数不少于3的图是不可分的 当且仅当 任意两个顶点都位于某个圈上</p><p><strong>块(block)</strong>:图$G$的一个最大的不可分子图</p><p><strong>定理5.8</strong>：$R$是定义在非平凡连通图$G$的边集上的关系：对于$e,f\in E(G)$，若$e=f$或$e,f$位于$G$的同一个圈上，则$e,f$有关系$R$，即为$eRf$且$R$是等价关系。<br>该定理将图$G$的边画划分为了若干等价类。</p><p><strong>推论5.9</strong>：非平凡连通图$G$的任意两个不同的块$B_1$和$B_2$具有下面性质：</p><ul><li>$B_1$和$B_2$是不相交的</li><li>$B_1$和$B_2$至多有一个公共结点</li><li>若$B_1$和$B_2$有一个公共结点$v$，则$v$是$G$的割点</li></ul><h1 id="连通度"><a href="#连通度" class="headerlink" title="连通度"></a>连通度</h1><h2 id="顶点割"><a href="#顶点割" class="headerlink" title="顶点割"></a>顶点割</h2><p><strong>顶点割(vertex-cut)</strong>：顶点集$U$，$G-U$是不连通的</p><p><strong>最小顶点割</strong>：自行感受一下</p><p>只有非完全图才有顶点割，且所有非完全图都有顶点割</p><p><strong>(点)连通度(vertex-connectivity)</strong>:$\kappa(G)$=最小顶点割的基数<br>$$ 0\le \kappa(G)\le n-1 $$</p><p>图$G$是k-连通的(k-connected)，即$\kappa(G)\ge k$，随便去掉$k$个点之后依然是连通的</p><h2 id="边割-edge-cut"><a href="#边割-edge-cut" class="headerlink" title="边割(edge-cut)"></a>边割(edge-cut)</h2><p><strong>边割(edge-cut)</strong>：边集$X$，$G-X$是不连通的</p><p><strong>最小边割</strong>和<strong>极小边割</strong>是不同的概念</p><p><strong>边连通度(edge-connectivity)</strong>:$\lambda(G)$=最小边割的基数<br>$$ 0\le \lambda(G)\le n-1 $$</p><p>完全图的边连通度$\lambda(K_n)=n-1$</p><h2 id="点、边连通度间的关系"><a href="#点、边连通度间的关系" class="headerlink" title="点、边连通度间的关系"></a>点、边连通度间的关系</h2><p><strong>定理5.11</strong>：对于任意图$G$，$$\kappa(G)\le \lambda(G)\le \delta(G)$$<br>点连通度$\le$边连通度$\le$最小度数</p><p><strong>定理5.12</strong>：立方图$\kappa(G)=\lambda(G)$</p><p><strong>定理5.13</strong>：$G$顶点数为$n$，边数为$m$，则$\kappa(G)\le \lfloor\frac{2m}{n}\rfloor$</p><h2 id="Harary图"><a href="#Harary图" class="headerlink" title="Harary图"></a>Harary图</h2><p><strong>定理5.14</strong>：如果$G$是至少有3个结点的连通图，则$G^2$时候2-连通的。</p><p><strong>定理5.15</strong>：对于任意整数$r,n$满足$2\le r&lt;n$，有$$\kappa(H_{r,n})=r$</p><h1 id="Menger定理"><a href="#Menger定理" class="headerlink" title="Menger定理"></a>Menger定理</h1><p><strong>分离集(separating set)</strong>：$S$是图$G$的顶点集的一个子集，$u$和$v$是$G$的两个顶点。若$G-S$是不连通的且$u$和$v$属于$G-S$不同的连通分支，则称$S$<strong>分离</strong>$u$和$v$，$S$是一个<strong>$u-v$分离集</strong></p><p><strong>内点(internal vertex)</strong>:一条$u-v$路径上除去$u,v$的点<br><strong>内部不相交(internally disjoint)</strong>：两条路径除端点外没有公共点</p><p><strong>定理5.16(Menger定理)：</strong>设$u$和$v$是图$G$的不邻接的两个顶点，则$u-v$分离集中顶点的最小个数等于$G$中内部不相交$u-v$路的最大个数。<br>证明使用了数学归纳法，归纳步时分了3种情况讨论</p><p><strong>定理5.17</strong>：一个非平凡图$G$是$k$连通的($k\ge 2$) 当且仅当 对于$G$的任意两个顶点$u,v$，$G$至少有$k$条内部内部不相交的$u-v$路。</p><p><strong>推论5.18</strong>：设$G$为$k$连通图，$S$是由$G$中任意$k$个顶点构成的集合。若图$H$是由$G$通过添加一个新的顶点$w$以及连接$w$到$S$中所有的顶点所得，则$H$也是$k$连通的。</p><p><strong>推论5.19</strong>：若$G$为$k$连通图，$u,v_1,v_2,…,v_k$为$G$中$k+1$个不同的顶点，则$G$有内部不相交的$u-v_i$路($1\le i\le k$)</p><p><strong>定理5.20</strong>：若$G$为$k$连通图($k\ge 2$)，则$G$中任意$k$个顶点均位于某一个圈上。</p><p><strong>定理5.21</strong>：对于图$G$两个不同的顶点$u$和$v$，$G$中分离$u,v$的边的最小个额数等于$G$中边不相交$u-v$路的最大个数</p><p><strong>定理5.22</strong>：一个非平凡图$G$是$k$边连通的当且仅当对于$G$中任意两个不同的顶点$u,v$，$G$包含$k$条边不相交的$u-v$路</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;割点&quot;&gt;&lt;a href=&quot;#割点&quot; class=&quot;headerlink&quot; title=&quot;割点&quot;&gt;&lt;/a&gt;割点&lt;/h1&gt;&lt;p&gt;割点的定义：去掉这个点后，原图不再连通&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理5.1&lt;/strong&gt;：设$v$是连通图$G$中与bridge相
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
      <category term="Connectivity" scheme="https://mengzelev.github.io/tags/Connectivity/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-所有结点对的最短路径问题</title>
    <link href="https://mengzelev.github.io/2018/11/07/clrs-25All-Pairs-Shortest-Paths/"/>
    <id>https://mengzelev.github.io/2018/11/07/clrs-25All-Pairs-Shortest-Paths/</id>
    <published>2018-11-07T08:17:34.000Z</published>
    <updated>2019-01-07T11:15:54.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><p>$l_{ij}^(m)}$:从结点$i$到结点$j$的至多包含$m$条边的任意路径中的最小权重。<br>$$<br>l_{ij}^{(m)} = \min\limits_{1\lek\le n}{l_{ik}^{(m1)}+w_{kj}}<br>$$</p><h2 id="自底向上计算最短路径权重"><a href="#自底向上计算最短路径权重" class="headerlink" title="自底向上计算最短路径权重"></a>自底向上计算最短路径权重</h2><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/extend.png"></p><p>三重循环，时间复杂度为$\Theta(n^3)$</p><p>形式上与矩阵乘法的计算非常类似</p><p>计算$L^{(n-1)}=W^{n-1}$</p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/slowall.png"><br>这个算法本质上就是对$n$个点每个跑了一遍Bellman-Ford</p><h2 id="改进运行时间"><a href="#改进运行时间" class="headerlink" title="改进运行时间"></a>改进运行时间</h2><p>重复平方技术<br>二分计算矩阵的幂</p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/chongfu.png"></p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/faster.png"></p><p>优化后时间复杂度为$\Theta(n^3\lgn n)$</p><h1 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h1><p>枚举最短路径上的中间结点来进行递归的计算</p><ul><li>不允许有负权重环</li><li>但是可以做到在有负权重环的情况下报告（看对角元是否有负数）</li></ul><p>$d_{ij}^{(k)}$：从$i$到$j$经过的中间结点为${1,…k}$的子集的最短路径长度<br><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/d.png"></p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/floyd-alg.png"></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$\Theta(n^3)$</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>看似需要$\Theta(n^3)$，但是作业题中证明了只需要一个矩阵来存储，为$\Theta(n^2)$</p><h2 id="构建最短路径"><a href="#构建最短路径" class="headerlink" title="构建最短路径"></a>构建最短路径</h2><p>采用动态规划的思想，递推式如下</p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/pi0.png"></p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/pik.png"></p><h1 id="用于稀疏图的Johnson算法"><a href="#用于稀疏图的Johnson算法" class="headerlink" title="用于稀疏图的Johnson算法"></a>用于稀疏图的Johnson算法</h1><p>用一种神奇的方式对图中每条边的权重进行重新赋值，使新的图满足</p><ul><li>所有权重都为非负值</li><li>新图中的最短路径就是旧图中的最短路径</li></ul><h2 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/Johnson.png"></p><p>先增加一个新结点$s$，该点到原先各结点都有边相连，权重为0<br>对新图进行一次Bellman-Ford算法，寻找是否有负权重环路<br>没有负权重环，就用神奇的长得像顶点的势能函数一样的函数给每条边重新赋值<br>$$ \hat{w}(u,v)=w(u,v)+h(u)-h(v)$$<br>$$ h(u)=\delta(s,u)$$<br>然后对每个点进行Dijkstra<br>最后记得将最短路径的权重恢复，并存入矩阵$D$中返回</p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>二叉最小优先队列实现Dijkstra：$O(VE\lg V)$<br>斐波那契堆实现：$O(V^2\lgV+VE)$<br>在稀疏图的情况下，表现比Floyd-Warshall好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;矩阵乘法&quot;&gt;&lt;a href=&quot;#矩阵乘法&quot; class=&quot;headerlink&quot; title=&quot;矩阵乘法&quot;&gt;&lt;/a&gt;矩阵乘法&lt;/h1&gt;&lt;h2 id=&quot;最优子结构&quot;&gt;&lt;a href=&quot;#最优子结构&quot; class=&quot;headerlink&quot; title=&quot;最优子结构&quot;&gt;
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Lab2:链接与加载 实验报告</title>
    <link href="https://mengzelev.github.io/2018/11/06/lab2-report/"/>
    <id>https://mengzelev.github.io/2018/11/06/lab2-report/</id>
    <published>2018-11-06T09:17:47.000Z</published>
    <updated>2018-11-30T14:17:54.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>按照实验讲义的提示，首先找到了libc库所在的位置，输出基本与讲义中给出的一致，不作赘述。</p><p>编写的测试文件a.c的代码为</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main (){    int a = rand();    printf(&quot;%d\n&quot;,a);    return 0;}</code></pre><p>只需要有对<code>rand</code>的调用且保证不会被编译器优化掉就可以了。</p><p>找到动态库文件之后，对该二进制文件进行反汇编</p><pre><code>$ objdump -d /lib/x86_64-linux-gnu/libc.so.6 &gt; libc64</code></pre><p>然后对反汇编后的文件进行查看，可以看到一堆库函数的反汇编代码。此时我看到了讲义中的这句话：</p><blockquote><p>然后你会发现这个文件对你并没有什么卵用，好吧，其实一会儿是会用到的。</p></blockquote><p>导致我真的以为现在用不到这个文件，于是，我<s>傻fufu地</s>按照讲义的指示去找<code>rand</code>函数的地址了。<br><code>gdb</code>，启动！看到了一堆跳转语句，感受到了自己对课本内容掌握不足；<br>课本，打开！复习了一下动态链接相关的知识点；<br><code>gdb</code>，开始！单步执行到<code>&lt;rand@plt&gt;</code>处时，发现了<code>rand</code>对应的GOT表项的地址，为<code>0x55555575020</code></p><p><img src="/2018/11/06/lab2-report/rand_id.png"></p><p>然后疯狂<code>si</code>，会看一堆<code>dl_</code>开头的，八成是和动态链接有关的函数。一不小心回车过头，最后在<code>main</code>里停下来，总之动态链接过程已经完成了，这时候可以查看内存地址为<code>0x55555575020</code>处的内容为<code>0x7ffff7a70820</code>（忘了截图了）</p><p>打印<code>0x7ffff7a70820</code>的内容，确认了确实为<code>rand</code>函数的地址</p><p><img src="/2018/11/06/lab2-report/rand.png"></p><p>做到这里，感觉像是完成了什么，开始思考下一步要做什么。等一下，我们的最终目标不是只要得到<code>system</code>到<code>rand</code>的偏移量吗，那我费尽千辛万苦搞到<code>rand</code>的地址干什么……算了，就当复习了一下动态链接的相关知识点和回忆了一下<code>gdb</code>的使用方法吧</p><p>不管了，总之先打开之前反汇编的动态库看一下，分别找到<code>rand</code>和<code>system</code>的地址</p><p><img src="/2018/11/06/lab2-report/rand64.png"></p><p><img src="/2018/11/06/lab2-report/system64.png"></p><p>偏移量为<code>0x3f480-0x36820=0x8c60</code></p><p>为了验证一下正确性，使用<code>gdb</code>打印了和<code>rand</code>具有相应偏移量（其实就是后3位不同）出的内存内容</p><p><img src="/2018/11/06/lab2-report/system.png"></p><p>这下准没错了，于是开始编写<code>oj_killer</code>函数</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>最初仅考虑64位情况的<code>oj_killer</code>函数代码如下</p><pre><code>#include &lt;stdlib.h&gt;void* oj_killer(){        void* randptr = (void *)rand;        //获得rand函数的地址        return (void*)(randptr + 0x8c60);        //加上libc中rand到system的偏移量，返回system函数的地址}</code></pre><p>编译运行后能够成功输出<code>Hello World</code></p><p><img src="/2018/11/06/lab2-report/hello64.png"></p><h2 id="兼容32位"><a href="#兼容32位" class="headerlink" title="兼容32位"></a>兼容32位</h2><p>接下来考虑32位的情况</p><p>如果将上述程序直接编译为32位，会得到<code>Illegal instruction</code>的错误</p><p><img src="/2018/11/06/lab2-report/illegal.png"></p><p>对<code>a.c</code>加上<code>-m32</code>选项进行编译后查看其调用的动态链接库，可以发现调用的是32位的库，和64位的库是不一样的（当然了</p><pre><code>$gcc a.c -m32 -o a32.out$file a32.outa32.out: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically link│ed, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=b3e591a0858f18│2549e63239c338f5fd30496ce2, not stripped $ldd a32.out                                              linux-gate.so.1 (0xf77ac000)                                                      libc.so.6 =&gt; /lib32/libc.so.6 (0xf75d1000)                                        /lib/ld-linux.so.2 (0xf77ae000)$file -L /lib32/libc.so.6                             /lib32/libc.so.6: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=84bb53910470c7ceb2a0963044117fdf8a2bb975, for GNU/Linux 2.6.32, stripped  </code></pre><p>使用同样的方法进行反汇编后</p><pre><code>$objdump -d /lib32/libc.so.6 &gt; libc32</code></pre><p>分别得到<code>rand</code>和<code>system</code>在<code>libc</code>内的地址</p><p><img src="/2018/11/06/lab2-report/rand32.png"></p><p><img src="/2018/11/06/lab2-report/system32.png"></p><p>于是可以按照同样的思路编写代码</p><h2 id="真·代码解释"><a href="#真·代码解释" class="headerlink" title="真·代码解释"></a>真·代码解释</h2><pre><code>void* oj_killer(){    int type = sizeof(void*);    void* randptr = (void *)rand;    //获得rand函数的地址    if(type == 8)     //判断当前环境是否为64-bit        return (void*)(randptr + 0x8c60);    //加上64位时libc中的偏移量    else return (void*)(randptr - 0x2f6f0 + 0x3a850);         //加上32位时libc的偏移量}</code></pre><p>为了保证代码的可移植性，特意将变量<code>randptr</code>声明为<code>void*</code>类型，而非<code>int</code>或<code>long long</code>。<br>判断当前环境为32/64位则依靠对<code>void*</code>长度的判断。 <s>暴露了不太会用<code>#if</code>预编译指令的事实</s></p><p>分别按32位和64位编译后，可以得到<code>Hello World</code>的输出：</p><p><img src="/2018/11/06/lab2-report/success.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验过程&quot;&gt;&lt;a href=&quot;#实验过程&quot; class=&quot;headerlink&quot; title=&quot;实验过程&quot;&gt;&lt;/a&gt;实验过程&lt;/h2&gt;&lt;p&gt;按照实验讲义的提示，首先找到了libc库所在的位置，输出基本与讲义中给出的一致，不作赘述。&lt;/p&gt;
&lt;p&gt;编写的测试文件a.
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
  <entry>
    <title>PA2实验报告</title>
    <link href="https://mengzelev.github.io/2018/11/06/PA2-report/"/>
    <id>https://mengzelev.github.io/2018/11/06/PA2-report/</id>
    <published>2018-11-06T01:33:26.000Z</published>
    <updated>2018-11-06T01:34:50.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验进度描述"><a href="#实验进度描述" class="headerlink" title="实验进度描述"></a>实验进度描述</h1><p><strong>2018/10/04</strong><br>RTF实验讲义，RTFSC，我是谁，我在哪儿，我要干什么</p><p><strong>2018/10/05</strong><br>经历了两天的RTFSC后终于看懂了框架代码是干嘛的，RTFM实现了<code>sub</code>,<code>push</code>,<code>ret</code>,<code>call</code>等指令，在nemu中运行了第一个程序<code>dummy</code></p><p><strong>2018/10/21</strong><br>听了同学们的建议，先实现了<code>diff-test</code>，结果发现PA2.1的指令实现有bug。修复了这些bug并温故框架代码的构成</p><p><strong>2018/10/22</strong><br>花了一整天对照着FM实现了exec目录下大部分指令，填写<code>opcode_table</code>巨表，然而有海量bug等待发现</p><p><strong>2018/10/27</strong><br>开<code>diff-test</code>跑完了cputest中所有的测试，修复了能发现的PA2.2中的bug。<code>bash runall</code>后看到了绿油油的full-combo，心情舒畅。<s>然而并不知道2.3的时候还有海量bug等着自己</s></p><p><strong>2018/10/28</strong><br>实现了<code>string.c</code>中所有的库函数和<code>sprintf</code>，先在nemu外单独手动测试，然后放入klib中，成功运行<code>string.c</code>和<code>hell-str.c</code>，PA2.2基本完成，<code>make submit</code></p><p><strong>2018/11/2</strong><br>实现了<code>in/out</code>指令，成功运行<code>hello</code>。与同学出去吃火锅，讨论发现自己的<code>diff-test</code>歪打正着可以正常运行。</p><p><strong>2018/11/3</strong><br>实现了<code>printf</code>，测试时钟时陷入莫名其妙的Segmentation Fault，在指令中加入大量Log测试，无果；找到大腿进行文件替换，无果；把指令实现和库函数又给了大腿二号进行替换，发现一切运行正常。心态爆炸，怀疑人生，git滚回到2.2完成的状态，从2开始的PA2.3。修仙实现了时钟、键盘和vga，并通过了相关测试，成功运行打字游戏（虽然慢的一笔）。跑分测试时还是出现了bug，遂开启<code>diff-test</code>后滚去睡觉</p><p><strong>2018/11/4</strong><br>起来看到结果发现是<code>neg</code>指令写错了，修复bug后成功运行了三个跑分测试。看到超级无敌慢动作马里奥，差点笑死，<s>录成视频发到qq空间被jyy点赞了</s>。复习链接相关知识，自学Makefile语法，编写硬核实验报告。</p><h1 id="必答题"><a href="#必答题" class="headerlink" title="必答题"></a>必答题</h1><blockquote><p>只有聪明的人才看得见</p></blockquote><h1 id="我遇到的那些bug"><a href="#我遇到的那些bug" class="headerlink" title="我遇到的那些bug"></a>我遇到的那些bug</h1><p>以后实验报告新增这一环节，希望可以帮到其他人</p><ul><li>有些指令不是RTL完了就完事的，还需要<code>operand_write</code>写入到相应位置</li><li>test指令手册表意不清，虽然写了<code>DEST := LeftSRC AND RightSRC</code>，但是两个操作数并不需要改变，不需要进行<code>operand_write</code></li><li>框架里已经为你准备了丰富多彩的译码函数，有些指令有自己特殊的译码函数，赶紧到<code>decode.h</code>里去康康吧！</li><li><code>ret</code>指令需要跳转到返回地址的，没有好好RTFM的后果</li><li><code>sar</code>是需要符号扩展的</li><li>译码函数的立即数读入也是需要符号扩展的</li><li>编译<code>timetest</code>的时候链接出错：<code>undefined reference to</code>，其实是因为<code>stdio.c</code>没有加上重要的头文件</li><li>运行跑分测试<code>coremark</code>时出现内存地址越界，发现是<code>opcode_table</code>中的<code>imul</code>指令的译码函数写错了</li><li><code>neg</code>指令只需要直接取反加一</li><li>不知道时钟怎么写，可以参考一下<code>_putc</code>的代码，里面有提示</li><li><code>native</code>的输入输出实现里有不少提示可供参考</li><li><strong>框架代码中没有rol指令，不知道是可爱PA作者的疏忽还是故意让我们练手的</strong></li></ul><h1 id="蓝框思考题"><a href="#蓝框思考题" class="headerlink" title="蓝框思考题"></a>蓝框思考题</h1><p>临近期中考试，时间不是很充裕，写得很少，但愿今后有机会二周目思考吧</p><ul><li><p>Q:AT&amp;T格式反汇编结果中的少量指令, 与i386手册中列出的指令名称不符, 如cltd. 除了STFW之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?<br>A:先STFW试图搞清楚这个指令是干什么的，然后翻手册的目录寻找描述差不多的指令。比如<code>cltd</code>是Convert longword to doubleword的意思，翻手册的目录能找到意思差不多的Convert word to double word。运气好的话可能在STFW的时候就能找到对应的i386的指令名称了。</p></li><li><p>Q：你或许会感到疑惑, 代码优化不是一件好事情吗? 为什么会有volatile这种奇葩的存在? 思考一下, 如果代码中p指向的地址最终被映射到一个设备寄存器, 去掉volatile可能会带来什么问题?<br>  A：因为编译器基本是根据输入输出状态进行的代码优化，而我们有些时候是care中间过程的，例如lab01中的性能测试。如果代码中<code>p</code>指向的地址最终被映射到一个设备寄存器，可能会发生设备状态的跳变，比如显示器某块地方应该是由蓝变绿再变红，会直接从蓝色变成红色。</p></li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>未测试的代码永远是错的，测试过的代码也不会是对的！隐藏bug无处不在。【PA2.2full-combo的大家几乎都在2.3里发现了cputests没能暴露的bug，以此类推PA3的时候可能还会发现PA2的bug</li><li>要及时坚定滚回去从头再来的决心，试过了力所能及的所有方法都找不出来的bug就不要找了，肯定是在一些玄学的地方犯了玄学的错误，干脆从头重新写一遍</li><li>am相关的概念还不是非常清楚，目前还不影响做实验，但还是想进一步了解</li><li>Copy-paste是坏文明</li><li>github private远程库保命是真的很重要，安心多了</li><li>跑分结果堪忧，但是本着先写对，再完美的宗旨，<s>不管了</s>还是值得开心一下的</li><li>bug死活找不出的时候容易心态血崩，但是这时候只要实现一个小的功能就能瞬间高兴回来</li><li>敲代码真**开心</li></ul><h1 id="Appreciation"><a href="#Appreciation" class="headerlink" title="Appreciation"></a>Appreciation</h1><ul><li>感谢“™写™PA真™开心”群的群友们，一起修仙，一起写bug，一起交流bug，帮忙debug，<s>还在心态快崩的时候一起出去约了顿火锅</s></li><li>感谢xy同学，提供了可供替换的大腿，做得太快了，还给我剧透了不少，让我少踩了不少坑</li><li>感谢ldw同学，用我的代码替换到了他的代码上证明我的指令集和库函数并没有大问题，给了我滚回去重做的决心（</li><li>感谢某位还是不愿意透露姓名的nb学长，通过千里眼，帮忙发现了不少bug</li></ul><p>本实验报告同样会将去掉必答题的版本同步上传至<a href="https://mengzelev.github.io/">个人blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验进度描述&quot;&gt;&lt;a href=&quot;#实验进度描述&quot; class=&quot;headerlink&quot; title=&quot;实验进度描述&quot;&gt;&lt;/a&gt;实验进度描述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;2018/10/04&lt;/strong&gt;&lt;br&gt;RTF实验讲义，RTFSC，我是谁，我在哪儿，
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
  </entry>
  
</feed>
