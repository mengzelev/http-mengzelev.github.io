<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengzelev&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mengzelev.github.io/"/>
  <updated>2018-10-04T09:21:25.581Z</updated>
  <id>https://mengzelev.github.io/</id>
  
  <author>
    <name>Mengzelev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>做pa的时候可能会用到的操作</title>
    <link href="https://mengzelev.github.io/2018/10/04/pa-inspirations/"/>
    <id>https://mengzelev.github.io/2018/10/04/pa-inspirations/</id>
    <published>2018-10-04T09:18:29.000Z</published>
    <updated>2018-10-04T09:21:25.581Z</updated>
    
    <content type="html"><![CDATA[<p>当做笔记随便写写的，希望能帮到一些人吧。毕竟作为一名优秀的bug maker，别人遇到的问题我基本都能遇到的。</p><p>vim和tmux另外写了教程：</p><p><a href="https://mengzelev.github.io/2018/09/06/vim/">vim初探</a></p><p><a href="https://mengzelev.github.io/2018/09/12/tmux/">使用tmux变身炫酷程序猿(x</a></p><p><u>持续更新中</u><br>最后更新:</p><blockquote><p>2018/10/04 17:18:29 新增PA2时运行dummy出错的解决方式</p></blockquote><h1 id="语言规范"><a href="#语言规范" class="headerlink" title="语言规范"></a>语言规范</h1><hr><p>这名字很中二…但其实就是个人写文章的时候一点习惯用的表示，和别人的可能不一样，很可能非常不标准，注意区分就好</p><ul><li>[]方括号表示需要自定义的内容，括起来的只是你应该输入的东西的名字</li><li>$开头的表示在命令行中键入的代码，否则为文件中的代码</li></ul><h1 id="在整个目录下查找代码"><a href="#在整个目录下查找代码" class="headerlink" title="在整个目录下查找代码"></a>在整个目录下查找代码</h1><hr><p>在某个文件里看到某个函数或者宏或者变量的定义的时候经常会好奇在哪里、怎么使用过，除了用<code>/+(搜索内容)</code>靠vim的功能在文件内搜索外，还可以</p><pre><code>$ grep &quot;搜索内容&quot; -r &lt;目录&gt;</code></pre><p>e.g.</p><pre><code>$ grep &quot;CPU_state&quot; -r .</code></pre><p>其中-r表示递归搜索，可以搜索整个目录下所有的文件</p><h1 id="一键跳转定义处"><a href="#一键跳转定义处" class="headerlink" title="一键跳转定义处"></a>一键跳转定义处</h1><hr><p>创建接口的时候经常需要查看某些函数、宏、结构体的定义，于是被某位nb的学长安利了ctags神器，可以一键跳转至定义处并一键调回，先贴上自己查到的教程</p><p>首先需要<strong>安装</strong>ctags，一般来说直接apt就好了，但是莫名不行，可能是镜像源的问题</p><pre><code>$ sudo apt install ctags</code></pre><p>于是我选择了从<a href="http://ctags.sourceforge.net/" target="_blank" rel="noopener">ctags官网</a>手动下载<code>ctags-5.8.tar.gz</code></p><p>如果是在host里下载的，下载后通过自己的共享方式扔到虚拟机里面，进行<strong>解压缩</strong></p><pre><code>$ cd [压缩包所在目录]$ tar jxvf [文件名].tar.bz</code></pre><p>解压后<strong>手动安装</strong></p><pre><code>$ cd ctags-5.8$ ./configure$ make$ make install</code></pre><p>安装完成后<strong>测试</strong>一下是否安装成功</p><pre><code>$ whereis ctags</code></pre><p>你应该能看到让你觉得成功的提示信息。</p><p>安装成功后，为源码<strong>生成tags文件</strong>，在需要使用ctags的目录下(所有子目录都可以享受到)运行</p><pre><code>$ ctags -R</code></pre><p>为了使得字段补全有效，在生成tags时需要一些额外的参数，推荐的c语言（c处可以替换成其他语言）参数主要是：</p><pre><code>$ ctags -R --c-kinds=+px --fields=+iaS --extra=+q</code></pre><p>其中，fileds 用于指定每条标记的扩展字段域，extra 选项用于增加额外的条目，f表示每个文件增加一个条目，q为每个类增加一个条目</p><p>之后<strong>配置vim</strong>，就不用每次都手动设置</p><pre><code>$ vim ~/.vimrc</code></pre><p>在.vimrc 中加入如下内容</p><pre><code>set tags=[path]/tagsset tags=./tags,tags;$HOME</code></pre><p>第二行我暂时也不知道是干什么的，但是不加上去好像用不起来（小声</p><p>然后用vim编辑你需要的代码文件，当光标落到你想查询定义的函数上时使用<code>Ctrl + ]</code>跳转到定义处<s>（其实明明是两键跳转对不对）</s>，然后<code>Ctrl + o</code>或者<code>Ctrl + t</code>返回跳转前的位置。</p><p><a href="https://www.cnblogs.com/zl-graduate/p/5777711.html" target="_blank" rel="noopener">参考教程原地址</a></p><h1 id="编译dummy时出错"><a href="#编译dummy时出错" class="headerlink" title="编译dummy时出错"></a>编译dummy时出错</h1><p>进行到<strong>PA2</strong>开始时，试图编译dummy会产生如下的报错：</p><center><br><img src="/2018/10/04/pa-inspirations/cdefs.png"><br></center><p>这时候如果STFW得到的答案应该是安装<code>libc6-dev-i386</code></p><pre><code>$ sudo apt-get install libc6-dev-i386</code></pre><p>然而我装了之后还是报错，到stackoverflow上稍微刨了一下发现可能还需要安装<code>gcc-multilib</code></p><pre><code>$ sudo apt-get install gcc-multilib</code></pre><p>然后可以开始愉快的PA2了</p><center><br><img src="/2018/10/04/pa-inspirations/dummy.png"><br></center><p><a href="https://askubuntu.com/questions/470796/fatal-error-sys-cdefs-h-no-such-file-or-directory" target="_blank" rel="noopener">stackoverflow原回答地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当做笔记随便写写的，希望能帮到一些人吧。毕竟作为一名优秀的bug maker，别人遇到的问题我基本都能遇到的。&lt;/p&gt;
&lt;p&gt;vim和tmux另外写了教程：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mengzelev.github.io/2018/09/06/vim
      
    
    </summary>
    
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
      <category term="Linux" scheme="https://mengzelev.github.io/tags/Linux/"/>
    
      <category term="vim" scheme="https://mengzelev.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>PA1实验报告</title>
    <link href="https://mengzelev.github.io/2018/10/04/PA1-report/"/>
    <id>https://mengzelev.github.io/2018/10/04/PA1-report/</id>
    <published>2018-10-04T09:17:47.000Z</published>
    <updated>2018-10-04T09:18:35.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h1><p><strong>2018/9/15：</strong><br>完成阶段一，实现了单步执行、打印寄存器和扫描内存（简易版）<br>开始做之前忘了<code>git checkout pa1</code>导致工作都在pa0分支里完成了，后来在pa1分支下返工了一遍，<strong>两边的git log里都可以查到记录所以求求老师不要扣我的分qwq</strong>我下次确定一定肯定确认分支后再开始工作</p><p><strong>2018/9/23:</strong><br>完成阶段二，实现了包含<code>(</code>、<code>)</code>、<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>和十进制数字的表达式计算。为了处理负数将类型都实现为了<code>long long</code>而不是<code>uint32_t</code>，需要按<code>uint32_t</code>类型使用时进行强制类型转换。实现了表达式生成器并测试。</p><p><strong>2018/9/29:</strong><br>完成阶段三，扩展了表达式计算中的<code>==</code>、<code>!=</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&lt;</code>、解除引用和寄存器计算。实现了监视点添加、删除和打印信息功能。用自带的用户镜像初步测试无问题。</p><p><strong>2018/9/30:</strong><br>早上起来和同学聊天发现了自己监视点实现的隐藏bug，一开始看了半天没理解到底怎么回事，然后动手加了一堆<code>printf</code>语句缩小范围终于找到了出错的区间，虽然具体的原理还没理解透彻，但是靠着一知半解成功修复了隐藏bug。</p><p><img src="/2018/10/04/PA1-report/bug.png" height="200"></p><h1 id="必答题"><a href="#必答题" class="headerlink" title="必答题"></a>必答题</h1><p>不敢po上来的！</p><h1 id="部分蓝框思考题"><a href="#部分蓝框思考题" class="headerlink" title="部分蓝框思考题"></a>部分蓝框思考题</h1><p><strong>Q：</strong>假设你在Windows中使用Docker安装了一个GNU/Linux container, 然后在container中完成PA, 通过NEMU运行Hello World程序. 在这样的情况下, 尝试画出相应的层次图.<br><strong>A：</strong>参考了docker官网上的架构图</p><table><thead><tr><th style="text-align:center">架构</th></tr></thead><tbody><tr><td style="text-align:center">“Hello World” program</td></tr><tr><td style="text-align:center">simulated x86 hardware</td></tr><tr><td style="text-align:center">NEMU</td></tr><tr><td style="text-align:center">bins/libs</td></tr><tr><td style="text-align:center">Docker</td></tr><tr><td style="text-align:center">host os  (windows)</td></tr><tr><td style="text-align:center">Hardware</td></tr></tbody></table><p><strong>Q：</strong>如果没有寄存器, 计算机还可以工作吗? 如果可以, 这会对硬件提供的编程模型有什么影响呢?<br><strong>A：</strong>我认为没有寄存器计算机是可以工作的，但是效率会非常低，因为数据的读写只能从内存中进行，而内存的读写速度是慢于寄存器的。而且现在我们学的IA-32架构是不允许在两个内存单元之间进行数据操作的，必须用寄存器作为中间媒介。编程模型一周目的我查了一下没有看懂，但愿二周目的我能看懂吧。</p><p><strong>Q：</strong>我们知道, 时序逻辑电路里面有”状态”的概念. 那么, 对于TRM来说, 是不是也有这样的概念呢? 具体地, 什么东西表征了TRM的状态? 在状态模型中, 执行指令和执行程序, 其本质分别是什么?<br><strong>A：</strong>TRM中存在一个叫做状态寄存器的组成部分，会存储图灵机当前的状态。（状态模型又是什么）执行指令和执行程序的本质区别是程序是一大堆指令的集合。（个人理解）</p><p><strong>Q：</strong>嗯… 如果你觉得提示还不够, 那就来一个劲爆的: 回忆程序设计课的内容, 一个程序从哪里开始执行呢?如果你不屑于回答这个问题, 不妨先冷静下来. 其实这是一个值得探究的问题, 你会在将来重新审视它.<br><strong>A：</strong>我正在尝试冷静下来….</p><p><strong>Q：</strong>阅读reg_test()的代码, 思考代码中的assert()条件是根据什么写出来的<br><strong>A：</strong>我不太理解“根据什么写出来”是什么意思……反正没有对错我就说一下个人理解吧。reg_test里的assert们应该是check了一下所有寄存器的存储状态，包括整个32位、低16位和两个低8位，从而来检查CPU_state的结构是否正确。根据…根据CPU_state应有的结构写出来的？</p><p><strong>Q：</strong>在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1, 你知道这是什么意思吗?<br><strong>A：</strong>这样就不会做<code>cpu_exec()</code>中的for循环而直接执行<code>if(nemu_state == NEMU_RUNNING) nemu_state = NEMU_STOP</code>语句实现单步执行。</p><p><strong>Q：</strong>opcode_table到底是个什么类型的数组?<br><strong>A：</strong>是一个opcode_entry结构体类型的数组，通过RTFSC推测应该是模拟指令码的结构体。</p><p><strong>Q：</strong>你可能会抑制不住编码的冲动: 与其RTFM, 还不如自己写. 如果真是这样, 你可以考虑一下, 你会如何测试自己编写的字符串处理函数?<br><strong>A：</strong><s>其实我更愿意RTFM，有现成的为什么要造轮子</s><br>写个随机生成字符串的程序产生输入，然后将输入和输出全部都输出肉眼比对一下，大概测试个20组没问题就当过了吧。（做oj的后遗症）</p><p><strong>Q：</strong>框架代码中定义<code>wp_pool</code>等变量的时候使用了关键字<code>static</code>, <code>static</code>在此处的含义是什么? 为什么要在此处使用它?<br><strong>A：</strong>static是Internal Linkage的意思，是指编译过程中进行链接时由<code>static</code>修饰的变量不参与与外部文件的链接。这样就使外部的函数一旦使用了这几个变量，编译器就会报错，保证了与WP相关的操作都只能定义在这个文件中。（如果真是这样就有点OOP的感觉？对外只提供接口，实现都在内部，保证了数据和操作的安全性）</p><p>剩下一些思考题要么是能力不够STFW找不到满意的答案，要么是找到了看上去满意的答案然而看不懂….</p><h1 id="遇到的问题以及对问题的思考"><a href="#遇到的问题以及对问题的思考" class="headerlink" title="遇到的问题以及对问题的思考"></a>遇到的问题以及对问题的思考</h1><ul><li>git merge的时候发生了conflict<br>STFW之后发现需要先git reset –merge然后cat冲突文件查看是哪里冲突，修改相应地方之后再git merge</li><li>全部写完之后才发现写错分支了<br>本来以为git merge之后再给分支重命名就可以了，但是各种冲突实在太多了，所以重新写了一遍，血的教训告诉我们以后一定要在写之前反复检查git branch。因为难以找到一段完整的时间一次性写完，所以每次开始工作之前都需要git branch。</li><li>vim忽然“死机”<br>写完一段之后下意识Ctrl+S，之后发现其实是把vim锁定了，Ctrl+Q解锁</li><li>vim非正常退出后再次打开与.swp文件发生冲突<br>按R检查是否是自己需要的状态，然后rm .[filename].c.swp将交换文件删除（删之前一定要谨慎不然就是作死）</li><li><strong>量子态更新<a href="https://mengzelev.github.io/">个人blog</a>中，<s>欢迎老师视奸后加分</s></strong></li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>PA虽然是个时间黑洞但是真的很好玩！</li><li>开始动手之前一定要认真RTFSC</li><li>看不懂代码的时候手动加点测试可以帮助理解</li><li>人真是越学越挑剔，曾经我可以看着全默认的ui手动缩进代码，现在编辑器要是没有（配置）喜欢的字体、自动缩进、括号匹配、甚至一键函数跳转，我可能都会当场疯掉<s>某种意义上越挑剔也就越有学习的欲望</s>很多大佬的故事都告诉我们，工具的改进源于对现有工具的极大不爽</li><li>PA1完全是写给自己用的程序而不是OJ那样的了，一定要扪心自问：你写的代码对得起你自己吗？</li></ul><h1 id="Acknowledegments"><a href="#Acknowledegments" class="headerlink" title="Acknowledegments"></a>Acknowledegments</h1><ul><li>感谢 Massimo同学 在我vim出现异常的时候告诉我是<code>Ctrl+s</code>把屏幕给锁死了并成功教我“急救”方法</li><li>感谢 某不愿透露姓名的nb学长 帮忙看了一下表达式生成器的bug，还解决了我的一堆疑问，并且提供深夜debug陪聊服务，并给我负罪感使我以后牢记优先STFW</li><li>感谢 xy同学 提供轻度剧透，使我避免了一些bug，还告诉了我一个隐藏bug的存在</li><li>感谢 不学习的正经水群 交流pa心得一起快乐编程</li></ul><p><u>实验报告虽然写了很多还是意犹未尽啊，为了赶ddl并尽快愉快地开始PA2先交了，等ddl过了之后会上传删掉了必做题的版本到个人blog，不定时更新</u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验进度&quot;&gt;&lt;a href=&quot;#实验进度&quot; class=&quot;headerlink&quot; title=&quot;实验进度&quot;&gt;&lt;/a&gt;实验进度&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;2018/9/15：&lt;/strong&gt;&lt;br&gt;完成阶段一，实现了单步执行、打印寄存器和扫描内存（简易版）&lt;b
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
  </entry>
  
  <entry>
    <title>关于“过程调用”的讨论</title>
    <link href="https://mengzelev.github.io/2018/09/27/ics-process-calling/"/>
    <id>https://mengzelev.github.io/2018/09/27/ics-process-calling/</id>
    <published>2018-09-27T01:59:13.000Z</published>
    <updated>2018-10-04T09:15:16.428Z</updated>
    
    <content type="html"><![CDATA[<p>这是计算机系统基础课上的开放课题，在不同环境下测试一些UB的结果，照理说此处应该有分析但是萌捷列夫懒了，等ddl处理掉了再来写。</p><h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#include &lt;stdio.h&gt; int main(int argc, char* argv[]){    int a = 10;    double *p = (double*)&amp;a;    printf(&quot;%f\n&quot;, *p);    printf(&quot;%f\n&quot;, ((double)(a)));return 0;}</code></pre><h2 id="windows10"><a href="#windows10" class="headerlink" title="windows10"></a>windows10</h2><p>环境：dev-cpp/TDM-GCC 4.9.2 64bit Release</p><p><img src="/2018/09/27/ics-process-calling/ics1-win.png"></p><p><img src="/2018/09/27/ics-process-calling/ics1-win-asm.png"></p><h2 id="Debian-64bit"><a href="#Debian-64bit" class="headerlink" title="Debian-64bit"></a>Debian-64bit</h2><p><img src="/2018/09/27/ics-process-calling/ics1-debian.png"></p><p><img src="/2018/09/27/ics-process-calling/ics1-debian-asm.png"></p><h2 id="Ubuntu-32bit"><a href="#Ubuntu-32bit" class="headerlink" title="Ubuntu-32bit"></a>Ubuntu-32bit</h2><p><img src="/2018/09/27/ics-process-calling/ics1-ubuntu.png"></p><p><img src="/2018/09/27/ics-process-calling/ics1-ubuntu-asm.png"></p><h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code>#include&lt;stdio.h&gt;int main(){    double a = 10;    printf(&quot;a = %d\n&quot;, a);    return 0;}</code></pre><h2 id="windows10-1"><a href="#windows10-1" class="headerlink" title="windows10"></a>windows10</h2><p><img src="/2018/09/27/ics-process-calling/ics2-win.png"></p><p><img src="/2018/09/27/ics-process-calling/ics2-win-asm.png"></p><h2 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h2><p><img src="/2018/09/27/ics-process-calling/ics2-debian.png"></p><p><img src="/2018/09/27/ics-process-calling/ics2-debian-asm.png"></p><h2 id="Ubuntu-32bit-1"><a href="#Ubuntu-32bit-1" class="headerlink" title="Ubuntu-32bit"></a>Ubuntu-32bit</h2><p><img src="/2018/09/27/ics-process-calling/ics2-ubuntu.png"></p><p><img src="/2018/09/27/ics-process-calling/ics2-ubuntu-asm.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是计算机系统基础课上的开放课题，在不同环境下测试一些UB的结果，照理说此处应该有分析但是萌捷列夫懒了，等ddl处理掉了再来写。&lt;/p&gt;
&lt;h1 id=&quot;实验一&quot;&gt;&lt;a href=&quot;#实验一&quot; class=&quot;headerlink&quot; title=&quot;实验一&quot;&gt;&lt;/a&gt;实验一&lt;/
      
    
    </summary>
    
    
      <category term="ics" scheme="https://mengzelev.github.io/tags/ics/"/>
    
      <category term="process calling" scheme="https://mengzelev.github.io/tags/process-calling/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习笔记</title>
    <link href="https://mengzelev.github.io/2018/09/21/regex/"/>
    <id>https://mengzelev.github.io/2018/09/21/regex/</id>
    <published>2018-09-21T14:04:40.000Z</published>
    <updated>2018-09-21T14:38:21.936Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，贴4张截图就跑路（。</p><p>有空还是会回来写的，容我先把ddl肝完（瘫）。</p><p><a href="http://docs.huihoo.com/c/linux-c-programming/ch32.html" target="_blank" rel="noopener">PA讲义中的Linux-C教程</a></p><p><img src="/2018/09/21/regex/table1.png"><br><img src="/2018/09/21/regex/table2.png"><br><img src="/2018/09/21/regex/table3.png"><br><img src="/2018/09/21/regex/table4.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话不多说，贴4张截图就跑路（。&lt;/p&gt;
&lt;p&gt;有空还是会回来写的，容我先把ddl肝完（瘫）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.huihoo.com/c/linux-c-programming/ch32.html&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
      <category term="regular expressions" scheme="https://mengzelev.github.io/tags/regular-expressions/"/>
    
      <category term="linux" scheme="https://mengzelev.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-摊还分析</title>
    <link href="https://mengzelev.github.io/2018/09/17/clrs-17amortized/"/>
    <id>https://mengzelev.github.io/2018/09/17/clrs-17amortized/</id>
    <published>2018-09-17T15:47:29.000Z</published>
    <updated>2018-09-20T15:58:45.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h1><p>聚合分析指，证明对所有n，一个n个操作的序列的最坏情况下花费的总时间为T(n)。因此在最坏情况下，每个操作的平均代价，或<strong>摊还代价</strong>为T(n)/n。</p><p>摊还操作可以看作是不带概率计算的平均情况分析。因为概率不好计算。<s>概率什么时候好计算过了</s></p><p>此摊还代价适用于<strong>每个</strong>操作，即使序列中有多种类型的操作也是如此。</p><p>算法导论上给出的示例为<strong>增加了MULTIPOP的栈操作</strong>和<strong>二进制计数器递增</strong>问题，简单概括一下二者的共同点：</p><ul><li>需要分析复杂度的操作由连续的n个操作构成</li><li>每个单步操作的时间复杂度难以确定为与n有关的表达式，与当前状态密切相关</li><li>对每个单步操作取最坏情况得出的上界过于宽松，浪费时间</li><li>n个连续操作的总时间复杂度比较容易求得</li></ul><p>大致感觉就是，使用摊还分析可以给这些操作一个<strong>清白</strong>，它们事实上没有那么慢。</p><h1 id="核算法"><a href="#核算法" class="headerlink" title="核算法"></a>核算法</h1><p>核算法就是对不同的操作赋予不同的信用，这个信用值可能会多于或少于实际消耗的代价。实际操作时采用多退少补的原则，保证总信用（支付的代价-实际的代价）始终非负即可。</p><p>一般用于解决不同操作间具有依赖关系的问题，例如聚合分析中提到的<strong>栈操作问题</strong>（出栈操作次数上界即为进栈操作次数）和<strong>二进制计数器递增问题</strong>（复位操作次数依赖于置位操作次数）。</p><h1 id="势能分析"><a href="#势能分析" class="headerlink" title="势能分析"></a>势能分析</h1><p>势能分析看上去更加数(wu)学(li)一点，与核算法有点类似，不同之处势能分析为每一个状态都设置了一个对应的势能，即势能函数。虽然在操作过程中势能可能有升有降，但只要最终势能是增加的，就可以证明代价的上界。</p><p>选择势能函数应该是比较困难的。产生的摊还代价依赖于选择的势能函数。具体根据需要证明的上界来选择适度的势能函数，毕竟最优势能函数不是那么好找的。</p><h1 id="动态表"><a href="#动态表" class="headerlink" title="动态表"></a>动态表</h1><p>这个有丶玄学，是势能分析的综合应用，建议看书。</p><p><u>睡觉了，先更到这里，明天继续更</u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;聚合分析&quot;&gt;&lt;a href=&quot;#聚合分析&quot; class=&quot;headerlink&quot; title=&quot;聚合分析&quot;&gt;&lt;/a&gt;聚合分析&lt;/h1&gt;&lt;p&gt;聚合分析指，证明对所有n，一个n个操作的序列的最坏情况下花费的总时间为T(n)。因此在最坏情况下，每个操作的平均代价，或&lt;s
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="amortized analysis" scheme="https://mengzelev.github.io/tags/amortized-analysis/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-贪心算法</title>
    <link href="https://mengzelev.github.io/2018/09/17/clrs-16greedy/"/>
    <id>https://mengzelev.github.io/2018/09/17/clrs-16greedy/</id>
    <published>2018-09-17T02:53:05.000Z</published>
    <updated>2018-09-18T03:10:20.626Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇dp写得又乱又烂简直不想看。但愿自己能坚持下去吧。<s>可是这依然改变不了搬运和截图多于实际内容的事实</s></p><h1 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h1><p>贪心算法可以看做是动态规划的弱化版，处理某一类特殊的具有最优子结构的问题。</p><blockquote><p>在每个贪心算法之下，几乎总有一个更繁琐的动态规划算法。</p></blockquote><h2 id="算法设计步骤"><a href="#算法设计步骤" class="headerlink" title="算法设计步骤"></a>算法设计步骤</h2><ol><li>将最优化问题转化为这样的形式：对其作出一次选择后，只剩下<strong>一个</strong>子问题需要求解【子问题削减】</li><li>证明作出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的【安全性证明：<strong>替换法</strong>】</li><li>证明作出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构【确认最优子结构】</li></ol><h2 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h2><p>贪心选择性质是指，当进行选择时，我们直接作出在当前问题中看来最优的选择，而不必考虑子问题的解【鼠目寸光】</p><p>贪心起来不太方便的时候，可以改进贪心选择，例如做一些预处理（活动选择问题中按照结束时间对活动进行排序）</p><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><p>证明：子问题最优解 + 贪心选择 = 原问题最优解<br>隐含地使用了数学归纳法</p><h2 id="两种背包问题"><a href="#两种背包问题" class="headerlink" title="两种背包问题"></a>两种背包问题</h2><ul><li><strong>0-1背包问题</strong></li><li><strong>分数背包问题</strong></li></ul><p>共同的条件是有一堆不同价值、重量的东西，用一个有一定承重量的背包去装，求装得的最大价值。<br>不同在于，<strong>0-1背包问题</strong>中每个东西要么拿要么不拿，而<strong>分数背包问题</strong>中可以拿分数个东西。</p><p>前者无法用贪心算法求解，但后者可以，主要区别在于考虑<strong>0-1背包问题</strong>中是否将一个商品装入背包时，必须比较包含此商品的子问题的解和不包含此商品的子问题的解。简单来说就是，空闲空间的存在非常讨厌。只能使用动态规划来求解</p><h1 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><center><br><img src="/2018/09/17/clrs-16greedy/activity1.png" height="200"><br></center><h2 id="最优子结构-1"><a href="#最优子结构-1" class="headerlink" title="最优子结构"></a>最优子结构</h2><p>通俗地说，对于某一个活动$a_k$，在它开始之前结束的所有活动，和在它结束之后开始的所有活动，这两个集合都应该取到最优解，可以使用剪切-粘贴发得到证明。因为如果子问题存在更优解，只需替换即可得到原问题的最优解，与原问题已经是最优解矛盾。</p><p>严谨化表述可以描述为：</p><center><br><img src="/2018/09/17/clrs-16greedy/activity2.png" height="100"><br></center><br>其中，$S{ij}$表示在$ai$结束后开始、在$aj$开始前结束的活动的集合；<br>c[i,j]表示集合$S{ij}$的最优解。<br><br>贪心选择<br>———————————<br>抛开各种分析直接来看这个问题，或者说和一个不知道动态规划的人谈起这个问题，很容易（大概）有这样一种想法：<br>对于每一次选择，都取不冲突的、最早结束的活动，感觉应该能够得到最优解。<br><br>事实上这个想法是对的，可以使用<a href="#replace">替换法</a>进行证明。<br><center><br><img src="/2018/09/17/clrs-16greedy/activity3.png" height="200"><br></center><p>这样每次做选择的时候就只剩下了一个子问题。</p><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p>贪心算法可以自顶向下实现。</p><center><br><img src="/2018/09/17/clrs-16greedy/activity4.png" height="200"><br></center><h2 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h2><center><br><img src="/2018/09/17/clrs-16greedy/activity5.png" height="250"><br></center><p>其中Q是一个单调队列。如果用最小堆实现，则该算法的时间复杂度为O(nlgn)。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>如果直接使用dp，状态转移是O(n)的，子问题总数为O(n^2)，因此总时间复杂度为O(n^3)。</p><p>而如果使用贪心策略，压缩了解空间，限制了解的范围，从伪代码可以看出每个$a_{i}$都被检查且只被检查了一次，因此时间复杂度是O(n)的。</p><p>如果输入数据是无序的那么还需要一个O(nlgn)的排序时间，总体的时间复杂度为O(nlgn)。</p><h1 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>解释起来有点麻烦，提供STFW快捷入口</p><p><a href="https://baike.baidu.com/item/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/1719730?fr=aladdin" target="_blank" rel="noopener">百度百科-哈夫曼编码</a></p><p><a href="https://en.wikipedia.org/wiki/Huffman_coding" target="_blank" rel="noopener">wikipedia-Huffman coding</a></p><p>简单概括一下：</p><ul><li>用变长编码压缩编码长度</li><li>Huffman树的叶结点与码字的编码一一对应</li><li>字符的二进制码字用从根结点到该字符对应的叶结点的简单路径表示</li><li>代价的定义：<center><br><img src="/2018/09/17/clrs-16greedy/huffman2.png" height="150"><br></center></li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><center><br><img src="/2018/09/17/clrs-16greedy/huffman1.png" height="200"><br></center><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>这一块设计很多数学推导，难度比较大，此处指概括大致思路，<u>配合算法导论原书食用风味更佳</u></p><p>主要是需要证明两个引理。</p><p><center><br><img src="/2018/09/17/clrs-16greedy/huffman3.png" height="100"><br></center><br>引理2旨在说明在单步选择下，贪心能得到是最优解。用的是<strong>替换法</strong>。从假想出一个<strong>抽象的最优解T</strong>，经过某些变换得到<strong>根据贪心选择构造出的解T’’</strong>，运用数学手段证明这两个解具有相等的代价。<br>此处采用的是相减得到大于等于关系，与最优解天然具有的小于等于构造解相结合，证明等价。</p><p><center><br><img src="/2018/09/17/clrs-16greedy/huffman4.png" height="120"><br></center><br>引理3旨在证明该问题的最优子结构。采用了<s>喜闻乐见的</s>的剪切-粘贴法，也使用了一定的数学手段导出了矛盾。</p><p>引理2+引理3能证明上文的贪心算法可以生成一个最优前缀码。</p><p><s>课程要求暂时只需要看前三章</s></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一篇dp写得又乱又烂简直不想看。但愿自己能坚持下去吧。&lt;s&gt;可是这依然改变不了搬运和截图多于实际内容的事实&lt;/s&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础理论&quot;&gt;&lt;a href=&quot;#基础理论&quot; class=&quot;headerlink&quot; title=&quot;基础理论&quot;&gt;&lt;/a&gt;基础理论&lt;/h1
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="greedy algorithm" scheme="https://mengzelev.github.io/tags/greedy-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>面向OJ的Java学习</title>
    <link href="https://mengzelev.github.io/2018/09/16/startjava/"/>
    <id>https://mengzelev.github.io/2018/09/16/startjava/</id>
    <published>2018-09-16T05:34:22.000Z</published>
    <updated>2018-09-17T15:49:24.661Z</updated>
    
    <content type="html"><![CDATA[<p><u>各路ddl原因本文目前还处于混乱状态，十分丢人，谨慎阅读</u><br><u>源代码为了防止查重，在OJ截止后会附上，也十分丢人</u></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="下载安装IDE"><a href="#下载安装IDE" class="headerlink" title="下载安装IDE"></a>下载安装IDE</h2><p>本UI警察使用的是JetBrains的IntelliJ IDEA，可以直接从<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">官网</a>下载，用学生邮箱注册可以免费获得Utilmate版，下载后安装即可。安装时会安利一些插件，根据个人需要选择安装。</p><p>下载后打开IJ，选择新建一个工程，这时候会提醒你选择JDK，只需要点击<u>Download JDK</u>直接在官网上下载即可。（这一步忘记截图了）</p><p>下载并安装完JDK之后，可以先对编辑器进行设置(File -&gt; Settings 或 Ctrl + Alt +S)，选择自己喜欢的字体和配色风格。我使用的是默认的Darcula配色和Monaco字体。</p><center><br>&lt;img src = “startjava/font.png”, height=300&gt;<br></center><p>大致效果如下（我jio得非常好看（请无视xjb乱写的第一个java程序</p><center><br>&lt;img src = “startjava/a+b.png”, height=300&gt;<br></center><h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><p>由于<strong>暂时用于应付oj</strong>，以下步骤非常不严谨，<strong>不适合开发相关</strong>，只确保能正常完成oj作业，欢迎随时指出不严谨之处</p><p>点击<code>File -&gt; New -&gt; Project</code>，新建一个项目，其他东西可以暂时不用管，在新的项目中找到src文件夹，右键选择<code>New -&gt; Java class</code>，注意<a href="#name">命名规范</a></p><p>之后会得到一个有模板的<code>.java</code>代码文件（球球无视一切xjb命名）</p><center><br>&lt;img src = “startjava/newclass.png”, height=300&gt;<br></center><p>移动光标就可以开始敲代码啦！装了IdeaVim插件的童鞋别忘了用vim的相关快捷键啊~<s>某捷列傻直接Ctrl-C+Ctrl-V半天没有反应</s></p><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>拷贝了一下poj上a + b问题的源代码，之后就要来尝试编译运行了。IJ并没有像dev一样的一键运行，但是如果做oj题的话还是比较方便的，直接右击左边项目列表的该.java文件选择<code>Run &#39;Main.main()&#39;</code>(快捷键<code>Ctrl + Shift +F10</code>)就可以在屏幕下方的运行窗口里得到运行结果并输入数据进行验证。</p><center><br>&lt;img src = “startjava/runa+b.png”, height=130&gt;<br></center><p><s>某捷列傻可是等了半天的黑框框的</s></p><h1 id="开始编程"><a href="#开始编程" class="headerlink" title="开始编程"></a>开始编程</h1><p>基本工作都做好了以后可以开始学习一点基础的语法应付oj了，大佬们推荐了Thinking in Java这本书（可以下载到pdf），比较适合系统学习Java，但是萌捷列夫的ddl迫在眉睫，所以只能采用简易一点的<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p><p>Java的语法总体与C语言是比较相似的，而且默认本教程读者已有一定的C/C++编程基础，萌捷列夫在学的时候大致按照<a href="#similar">和C一样放心使用</a>和<a href="#diff">和C不一样了</a>两大类进行了整理，以供参考</p><p>时间原因暂时不能贴出比较简洁易懂的示例代码，可以参考上文的<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>中的代码，本文最后也会贴出本次OJ所有题的题解代码以供参考。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>写C程序的时候，第一件事肯定是<code>#inlcude&lt;xxxx&gt;</code>，在Java里也需要头文件，但稍有区别。</p><p>Java中的头文件分为<code>package</code>和<code>import</code>两类。<code>package</code>语句用于表示一个类定义在某个包中，包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。这个我们写oj暂时用不到我就先晾这儿了。</p><p><code>import</code>语句的作用类似于C的<code>inlcude</code>，用来提供一个合理的路径，使编译器可以找到某个类。poj的a+b程序源码中有</p><pre><code>import java.io.*;</code></pre><p>就是用于让命令编译器载入java_installation/java/io路径下的所有类，从名称可以看出这些类与输入输出有关。<br>特别地，IJ提供自动补全import语句的功能，萌捷列夫在手动赋值a+b源码的时候IJ自动将POJ上的import替换为了</p><pre><code>import java.util.Scanner;</code></pre><p>一样可以正常运行。</p><p>头文件命名要遵循的规范：</p><ul><li>如果一个类定义在某个包中，那么package语句应该在源文件的首行</li><li>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面</li><li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明</li></ul><h2 id="各种声明"><a href="#各种声明" class="headerlink" title="各种声明"></a>各种声明</h2><p>写C的时候敲完所有头文件，差不多就该<code>int main()</code>了，（当然还有全局变量和函数声明），Java也有类似的<strong>主方法入口</strong>：</p><pre><code>public static void main(String []args)</code></pre><p>所有Java程序都是从这个入口开始执行的。</p><p>Java里也有变量的概念，但声明不是从变量开始的，而是<strong>从类开始</strong>的，充分贯彻了OOP的思想。类声明类似于用C++进行OOP编程，有<code>public</code>和<code>private</code>之别，还有其他一些特殊的类，写oj暂时用不到。类中可以定义变量和方法。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>类的声明遵循以下规范：</p><ul><li>一个源文件中只能有<strong>一个</strong>public类</li><li>一个源文件可以有多个非public类</li><li>源文件的名称应该和public类的类名保持<strong>一致</strong>。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java</li></ul><p>同C++一样，类也可以添加不同的访问修饰词</p><ul><li><code>public</code>:表示公开的类和变量，既所有的类都可以引入使用的</li><li><code>protected</code>：表示受保护的类，只有子孙类和本类可以引入使用</li><li><code>private</code>：表示私人的，只有在本类中可以引入使用</li><li><code>啥都不加</code>（默认）：表示同包中和本类中可以引入使用。</li></ul><p>定义了类之后可以使用<code>new</code>关键字创建属于这个类的<strong>对象</strong>。对象是类的实例化，大致需要以下三步：</p><ul><li>声明：声明一个对象，包括对象名称和对象类型。</li><li>实例化：使用关键字<code>new</code>来创建一个对象。</li><li>初始化：使用<code>new</code>创建对象时，会调用构造方法初始化对象。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java中的变量有三种：</p><ul><li>局部变量： 定义在方法、构造方法或者语句块之中，变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。例如循环变量<code>i</code></li><li>成员变量： 定义在类中、方法体之外，表示类的某种属性，在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问，例如人的身高、体重数据</li><li>类变量：声明在类中、方法体之外，但必须声明为static类型，为属于该类的所有对象所共有，不会因为对象的个体差异而改变。例如<code>Student</code>类中可以定义一个类变量<code>n</code>来统计学生的总人数，不会因为是不同的学生而不同。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java的内置数据类型基本同C，<code>char</code>,<code>short</code>,<code>int</code>,<code>long</code>,<code>float</code>,<code>double</code>,<code>boolean</code>都可以放心使用，默认值都是相应类型下的<code>0</code>。相比于C多出来一个<code>byte</code>，表示8位、有符号的，以二进制补码表示的整数。</p><p>Java还有一类<strong>引用数据类型变量</strong>，类似于C的指针，引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型，所有引用类型的默认值都是null。一个引用变量可以用来引用任何与之兼容的类型。e.g.<code>Site site = new Site(&quot;Runoob&quot;)</code></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>构造方法</strong>：每个类都需要一个构造方法。如果没有显示定义，编译器会提供一个默认构造方法（这点同C）。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>声明完乱七八糟一堆东西之后，一般会从输入入手。Java输入需要调用<code>Scanner</code>这个类，包含在“头文件”<code>import java.util.Scanner</code>中。</p><p>先要创建<code>Scanner</code>对象</p><pre><code>Scanner cin = new Scanner(System.in)</code></pre><p>读入整数，其中<code>nextInt()</code>是指输入中的下一个整数，类似的也可以有空白的<code>next()</code></p><pre><code>int a = cin.nextInt();</code></pre><h2 id="Java命名规范"><a href="#Java命名规范" class="headerlink" title="Java命名规范"></a><span id="name">Java命名规范</span></h2><p>首先，切记：<strong>Java是大小写敏感的</strong></p><ul><li><p><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass </p></li><li><p><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写，例如myFirstJavaMethod</p></li><li><p><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java（如果文件名和类名不相同则会导致编译错误）</p></li></ul><p>Java所有的组成部分都需要名字，类名、变量名以及方法名都被称为<strong>标识符</strong>。标识符的命名规范与C/C++基本相同（不同之处已标出）：</p><ul><li>所有的标识符都应该以字母（A-Z或者a-z）,<strong>美元符（$）</strong>、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z或者a-z）,<strong>美元符（$）</strong>、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li><li>合法标识符举例：age、$salary、_value、__1_value</li><li>非法标识符举例：123abc、-salary</li></ul><h1 id="相关整理"><a href="#相关整理" class="headerlink" title="相关整理"></a>相关整理</h1><h2 id="和C一样放心使用"><a href="#和C一样放心使用" class="headerlink" title="和C一样放心使用"></a><span id="similar">和C一样放心使用</span></h2><ul><li>注释语法</li><li>枚举语法<code>enum</code></li><li>变量类型，如<code>int</code>,<code>string</code>,<code>void</code>等</li></ul><h2 id="和C不一样了"><a href="#和C不一样了" class="headerlink" title="和C不一样了"></a><span id="diff">和C不一样了</span></h2><ul><li>没有指针<s>大快人心哈哈哈哈</s></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;各路ddl原因本文目前还处于混乱状态，十分丢人，谨慎阅读&lt;/u&gt;&lt;br&gt;&lt;u&gt;源代码为了防止查重，在OJ截止后会附上，也十分丢人&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Java" scheme="https://mengzelev.github.io/tags/Java/"/>
    
      <category term="programming" scheme="https://mengzelev.github.io/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>使用tmux变身炫酷程序猿(x</title>
    <link href="https://mengzelev.github.io/2018/09/12/tmux/"/>
    <id>https://mengzelev.github.io/2018/09/12/tmux/</id>
    <published>2018-09-12T01:59:29.000Z</published>
    <updated>2018-09-15T09:46:34.113Z</updated>
    
    <content type="html"><![CDATA[<p>以前看电影里面的程序猿都是屏幕上花花绿绿键盘噼里啪啦根本不用鼠标的觉得太炫酷了，学了cs以后以为希望破灭了，直到被pa讲义安利了tmux……</p><p>本文只是一个备忘笔记，方便日后查阅</p><p><u>更新中未完待续</u></p><h2 id="按键前缀"><a href="#按键前缀" class="headerlink" title="按键前缀"></a>按键前缀</h2><p>默认是<code>Ctrl-b</code>，大部分话教程会修改成离得比较近的<code>Ctrl-a</code></p><p>修改方法：打开tmux配置文件</p><pre><code>$ vim ~/.tmux.conf</code></pre><p>添加如下代码：</p><pre><code>unbind C-bset -g prefix C-a</code></pre><h2 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h2><p>因为是针对pa才学的tmux，所以要用的操作都非常基本</p><p>从terminal进入tmux，直接在命令行里输入tmux即可</p><pre><code>$ tmux</code></pre><p>然后进行分屏</p><p>水平分屏: <code>prefix + %</code></p><p>垂直分屏：<code>prefix + &quot;</code></p><p>我一般都使用左1+右2的形式【暂时忘了截图下次贴】</p><p>关闭该窗口：<code>prefix + &amp;</code> 会询问是否确定关闭，按y即可</p><p>切换窗口：<code>prefix +方向键</code></p><p><strong>使用tmux操作时，先按住Ctrl再按前缀键，然后可以稍微停一下再按下一个功能键</strong></p><p>以上操作目前做pa已经够用了，以后遇到新的问题再另寻解决方法并更新该文</p><h2 id="他山之玉"><a href="#他山之玉" class="headerlink" title="他山之玉"></a>他山之玉</h2><p>忙着赶作业来不及写完所以先贴篇别人整理的</p><p><a href="https://blog.csdn.net/a1181986340/article/details/51727297" target="_blank" rel="noopener">tmux多窗口操作</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前看电影里面的程序猿都是屏幕上花花绿绿键盘噼里啪啦根本不用鼠标的觉得太炫酷了，学了cs以后以为希望破灭了，直到被pa讲义安利了tmux……&lt;/p&gt;
&lt;p&gt;本文只是一个备忘笔记，方便日后查阅&lt;/p&gt;
&lt;p&gt;&lt;u&gt;更新中未完待续&lt;/u&gt;&lt;/p&gt;
&lt;h2 id=&quot;按键前缀&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="linux" scheme="https://mengzelev.github.io/tags/linux/"/>
    
      <category term="tmux" scheme="https://mengzelev.github.io/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>vim初探</title>
    <link href="https://mengzelev.github.io/2018/09/06/vim/"/>
    <id>https://mengzelev.github.io/2018/09/06/vim/</id>
    <published>2018-09-06T15:06:23.000Z</published>
    <updated>2018-10-01T14:59:18.004Z</updated>
    
    <content type="html"><![CDATA[<p>网上类似的教程已经有很多了，只是在玩耍<code>vimtutor</code>过程中的一点笔记。</p><p>同时开markdownPad和vim输入的后果就是在精神分裂的边缘试探.jpg</p><p>然而关键还是多用，这些破整理并没有卵用。（不知道我能坚持用vim到什么时候</p><p>在学的过程中不断出现的提示：</p><center><br><img src="/2018/09/06/vim/learnbyusing.png"><br><img src="/2018/09/06/vim/lbu2.png"><br></center><h1 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h1><p>方向键：<code>j↓ k↓ h← l→</code> （两边左右，中间下上）</p><p><s>所以h这篇文l章里j突然出现一些hjkl也不奇怪了呢</s></p><p>光标向前移动n个单词:<code>1w,2w,3w...</code></p><p>光标向前移动至第n个单词的末尾：<code>1e,2e,3e...</code></p><p>移动至行首：<code>0</code></p><p>移动至文末：<code>G</code></p><p>移动至文章开始：<code>gg</code></p><p><code>Ctrl-G</code>配合<code>G</code>使用风味更佳（跳转到某一行）</p><p>选中：<code>v+光标移动</code></p><h1 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h1><p>Normal mode: <code>ESC</code></p><p>进入输入模式:<code>i</code>（要操作时记得按esc退出）</p><h1 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h1><p>不保存并退出：<code>:q!</code></p><p>保存并退出：<code>:wq</code></p><p>另存为：<code>:w [filename]</code></p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>删除字符：<code>x</code></p><p>删除单词：<code>dw</code>(光标需移动到单词的开头</p><p>删除至行末：<code>d$</code></p><p>删除至词末:<code>dw</code></p><p>用count进行删除：<code>d2w,d1e...</code></p><p>删除整行：<code>dd，2dd,...</code> </p><p><s>从此dd具有了全新的意思</s></p><p>用<code>dd</code>删除的行被放入了寄存器中，<code>p</code>可在上方恢复</p><h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><p>撤销最后一步操作:<code>u</code></p><p>撤销整行所有的操作：<code>U</code></p><p>恢复撤销：<code>Ctrl+R</code></p><h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>改写单个字符（rewrite）：<code>r+(the right character)</code></p><p>改写多个字符：<code>R+(right characters)</code></p><p>改写至词尾：<code>ce</code>（记得esc退出输入模式）</p><p>改写至行尾：<code>c$</code></p><p>整词替换：</p><pre><code>:s/old/new         //替换第一个:s/old/new/g     //在光标所在单行内将&quot;old&quot;全部替换为&quot;new&quot;\#,#old/new/g     //在\#标记出的行数范围内进行替换:%s/old/new/g    //在全文范围内进行替换:%s/old/new/gc    //在全文范围内查找并询问是否需要替换</code></pre><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>插入某个文件的内容：<code>:r+[filename]</code></p><p>插入某个命令行函数的返回值:e.g.<code>:r !dir</code></p><p>在光标上方新建一行：<code>O</code></p><p>在光标下方新建一行：<code>o</code></p><p>从词末开始输入：<code>a</code></p><p>从行末开始输入：<code>A</code>（Append）</p><p>复制：<code>y(yank)</code> <code>yw</code>可以复制一整个单词</p><p>粘贴：<code>p(paste)</code></p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找内容：<code>/+（查找内容）</code></p><p>正向查找：<code>n</code></p><p>反向查找：<code>N</code></p><p>从文末开始查找：<code>?+(查找内容)</code></p><p>返回查找前的地方：<code>ctrl-o</code> <strong>是字母O不是数字0</strong></p><p>括号匹配：<code>%</code></p><p>忽略大小写：<code>:set ic</code>(ignore case)</p><p>关闭忽略大小写:<code>:set noic</code></p><p>查找内容高亮：<code>:set hls/hlsearch</code></p><p>关闭高亮：<code>:nohlsearch</code></p><p>部分查找：<code>:set is/incsearch</code> (incsearch)</p><h1 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h1><p>看到一篇不错的教程，就不复述了</p><p><a href="https://www.cnblogs.com/manziluo/p/5789700.html" target="_blank" rel="noopener">vim分屏功能总结</a></p><h1 id="暂时无法分组指令"><a href="#暂时无法分组指令" class="headerlink" title="暂时无法分组指令"></a>暂时无法分组指令</h1><p>输入命令行指令:<code>:!+(命令行指令)</code></p><p>帮助：<code>F1</code> or <code>help</code></p><p>指令补全：<code>Ctrl-D</code>配合<code>Tab</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网上类似的教程已经有很多了，只是在玩耍&lt;code&gt;vimtutor&lt;/code&gt;过程中的一点笔记。&lt;/p&gt;
&lt;p&gt;同时开markdownPad和vim输入的后果就是在精神分裂的边缘试探.jpg&lt;/p&gt;
&lt;p&gt;然而关键还是多用，这些破整理并没有卵用。（不知道我能坚持用vim到
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="vim" scheme="https://mengzelev.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-动态规划</title>
    <link href="https://mengzelev.github.io/2018/08/31/clrs-15dp/"/>
    <id>https://mengzelev.github.io/2018/08/31/clrs-15dp/</id>
    <published>2018-08-31T08:37:42.000Z</published>
    <updated>2018-09-05T02:12:40.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>以下是大段算法导论原句搬运。</p><p>只有带<u>下划线</u>的句子才是自己总结的。</p><h2 id="最优化问题"><a href="#最优化问题" class="headerlink" title="最优化问题"></a>最优化问题</h2><blockquote><p>动态规划方法通常用来求解<strong>最优化问题</strong>。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们成这样的解为问题的<u>一个</u>最优解，而不是最优解。</p></blockquote><h2 id="算法设计步骤"><a href="#算法设计步骤" class="headerlink" title="算法设计步骤"></a>算法设计步骤</h2><ul><li>刻画一个最优解的结构特征</li><li>递归地定义最优解的值</li><li>计算最优解的值，通常采用自底向上的方法</li><li>利用计算出的信息构造一个最优解（有时不需要）</li></ul><p>动态规划求解最优化问题应该具备的两个要素：<strong>最优子结构</strong>和<strong>子问题重叠</strong>。</p><p><u>简单来说就是，能根据原问题得到一个递推式（最优子结构），但是在这个递推式的计算过程中会出现大量重复计算的时候（子问题重叠），可以使用动态规划。</u></p><h2 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h2><blockquote><p>问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。</p></blockquote><p>在发觉最优子结构性质的过程中，实际上遵循了如下的通用模式：<br>1.证明问题最优解的第一个组成部分是做出一个选择；<br>2.对于一个给定问题，在其可能的第一步选择中，你假定已经知道哪种选择才会得到最优解。<br>3.给定可获得的最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；<br>4.利用“剪切-粘贴”技术证明：作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解（反证法）：<u>假设子问题存在更优解，将子结构从整体中删除替换为更优解，与最优假设矛盾。</u></p><p>保持子问题空间尽可能简单，只在必要时才扩展它。（e.g.矩阵链乘法问题必须允许子问题在“两端”都可变）</p><p>可以用<strong>子问题的总数</strong>和<strong>每个问题需要考察多少种选择</strong>这两个因素的乘积来粗略肥西动态规划算法的运行时间。</p><p>具有最优子结构的问题子问题之间是<strong>无关</strong>，同一个原问题的一个子问题的解不影响另一个子问题的解。e.g.无权最短路径vs无权最长路径</p><h2 id="子问题重叠"><a href="#子问题重叠" class="headerlink" title="子问题重叠"></a>子问题重叠</h2><p>如果递归方法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。与之相对的，利用分治方法求解的问题通常在递归的每一步都生成全新的子问题。</p><p>重构最优解：用另一个数组来记录最优解</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>自顶向下的备忘算法</li><li>自底向上的动态规划算法<br>一般自底向上的动态规划算法会比较快（没有递归调用开销，表的维护开销也更小）</li></ul><p>如果子问题空间中的某些子问题完全不必求解，备忘方法就会体现出优势</p><h1 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>某公司出售一段长度为i英寸的钢条的价格为$p_i(i=1,2,…,$单位为美元）。给定一段长度为n英寸的钢条和一个价格表$p_i(i=1,2,…,n)$，求切割钢条方案，使得销售收益$r_n$最大。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>长度为n英寸的钢条共有$2^{n-1}$中不同的切割方案。</p><p>如果一个最优解将钢条切割为k段$(1\le k\le n$)，那么最优切割方案<br>$$ n=i_1+i_2+…+i_k$$</p><p>将钢条切割为长度分别为$i_1,i_2,…,i_k$的小段，得到最大收益<br>$$ r_n=p_{i_1}+p_{i_2}+…+p_{i_k}$$</p><p>对于$r_n\ge 1$，我们可以用更短的钢条的最优切割收益来描述：<br>$$r_n=max(p_n,r_1+r_{n-1},r_2+r_{n-2},…,r_{n-1}+r_1)$$</p><p>更简单的，我们将钢条从左边切割下长度为$i$的一段，只对右边剩下的长度为$n-i$的一段继续进行切割（递归求解），对左边的一段则不再进行切割。可以得到$$r_n=max\limits_{1\le i\le n}(p_i+r_{n-i})$$<br>这样原问题只包含一个相关子问题的解而不是两个。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：$\Theta(n^2)$</p><h2 id="子问题图"><a href="#子问题图" class="headerlink" title="子问题图"></a>子问题图</h2><center><br><img src="/2018/08/31/clrs-15dp/subpro.png" height="500"><br></center><h1 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h1><p>懒得写了。</p><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><center><br><img src="/2018/08/31/clrs-15dp/matrix1.png" height="80"><br></center><p>对子问题的分析发现必须是子问题必须是两头可动的（i.e.一维数组是不够的）</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><del>为什么原书是分页的我还得手敲一遍不能忍</del></p><pre><code>MATRIX-CHAIN-ORDER(p)    //自底向上的动态规划实现    n=p.length-1    let m[1..n,1..n] and s[1..n-1,2..n] be new tables    for i=1 to n        m[i,i]=0    for l=2 to n        for i=1 to n-l+1            j=i+l-1            m[i,j]=\infty            for k=i to j-1                q=m[i,k]+m[k+1,j]+p[i-1]*p[k]*p[j]                if q&lt;m[i,j]                    m[i,j]=q                    s[i,j]=k    return m and s</code></pre><h1 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h1><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>先略</p><h2 id="最优子结构-1"><a href="#最优子结构-1" class="headerlink" title="最优子结构"></a>最优子结构</h2><center><br><img src="/2018/08/31/clrs-15dp/lcs1.png" height="120"><br><img src="/2018/08/31/clrs-15dp/lcs2.png" height="100"><br></center><h2 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h2><center><br><img src="/2018/08/31/clrs-15dp/lcs-length.png" height="500"><br><img src="/2018/08/31/clrs-15dp/lcs-table.png" height="300"><br></center><h1 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h1><p>和矩阵链乘法类似</p><p>也懒得抄了</p><p><s>一份毫无营养的学习笔记就完成了</s></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h1&gt;&lt;p&gt;以下是大段算法导论原句搬运。&lt;/p&gt;
&lt;p&gt;只有带&lt;u&gt;下划线&lt;/u&gt;的句子才是自己总结的。&lt;/p&gt;
&lt;h2 id=&quot;最优化
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="dynamic programming" scheme="https://mengzelev.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言复习笔记（二）</title>
    <link href="https://mengzelev.github.io/2018/08/30/asm2/"/>
    <id>https://mengzelev.github.io/2018/08/30/asm2/</id>
    <published>2018-08-30T08:37:42.000Z</published>
    <updated>2018-08-30T08:42:36.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h1><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><p><u>格式： mov S(源操作数), D(目标操作数)</u></p><p>mov  &nbsp;&nbsp; 一般传送指令</p><p>movs &nbsp;&nbsp; 符号扩展传送</p><p>movz &nbsp;&nbsp; 零扩展传送</p><p>push &nbsp;&nbsp; 压栈，等价于sub+mov</p><p>pop  &nbsp;&nbsp; 退栈，等价于mov+add</p><p>按源操作数的长度加上b,w,l后缀，分别表示1、2、4字节。(movz,movs需要双后缀)</p><center><br><img src="/2018/08/30/asm2/mov.png" height="400"><br></center><p>见<a href="#lealmov">leal与movl的区别</a></p><p><strong>指令后缀、操作数长度、目标寄存器宽度必须要一致！！</strong></p><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><ul><li>立即数 Imm &nbsp;&nbsp; 整型常量，加<code>$</code>前缀，e.g.<code>$233, $0x66FFCC</code></li><li>寄存器 Reg &nbsp;&nbsp; 加%前缀，e.g.<code>%eax,%ebx,%esp</code></li><li>存储器 Mem &nbsp;&nbsp; 寻址操作</li></ul><center><br><img src="/2018/08/30/asm2/memaddr.png" height="400"><br></center><p><strong>不能在一条指令里实现存储器到存储器的传送！！</strong>要实现存储器间的传送必须经过寄存器。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><center><br><img src="/2018/08/30/asm2/regs.png" height="400"><br></center><p>所有寄存器都可以单独读取低16位</p><p>只有%eax,%ecx,%edx,%ebx可以读取低8位（x字辈）</p><h2 id="地址运算指令"><a href="#地址运算指令" class="headerlink" title="地址运算指令"></a>地址运算指令</h2><p><u>格式: leal S,D </u></p><p>S是<strong>复杂寻址地址形式的表达式</strong>，将表达式表示的值写入D，其中D一定是<strong>寄存器</strong></p><p>用途：</p><ul><li>直接计算地址的值 e.g.<code>p=&amp;x</code></li><li>执行简单的算数运算</li></ul><p><span id="lealmov"> leal与mov操作的区别： </span><br><strong>leal不会对寻址表达式解引用</strong></p><p>e.g.</p><pre><code>//R[%edx]=xmovl 7(%edx,%edx,4),%eax    //R[%eax]=M[5x+7]leal 7(%edx,%edx,4),%eax    //R[%eax]=5x+7</code></pre><h1 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h1><h2 id="看表"><a href="#看表" class="headerlink" title="看表"></a>看表</h2><center><br><img src="/2018/08/30/asm2/arith.png" height="500"><br></center><p><strong>※使用时也需要根据操作数长度添加后缀</strong></p><h2 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h2><p>imull &nbsp;&nbsp; 带符号乘法指令，只有一个操作数时，另一个乘数隐含在%eax中，乘积的高32位放入%edx,低32位存入%eax</p><p>idivl &nbsp;&nbsp; 带符号除法指令，只有一个操作数时，%edx-%eax为被除数，操作数为除数，商存入%eax,余数存入%edx</p><p>还有无符号版本mull和divl</p><p>cltd 符号扩展指令，将%eax中的数符号扩展至%edx成为64位,经常用于idivl的准备工作</p><center><br><img src="/2018/08/30/asm2/sparith.png" height="350"><br></center><h2 id="关于imul"><a href="#关于imul" class="headerlink" title="关于imul"></a>关于imul</h2><table><thead><tr><th style="text-align:center">操作数个数</th><th style="text-align:center">格式</th><th style="text-align:left">操作</th><th style="text-align:center">结果存放</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><code>imul src</code></td><td style="text-align:left">src*R[%eax]，完全乘法（自己取的名字）</td><td style="text-align:center">%edx-%eax</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"><code>imul src dst</code></td><td style="text-align:left">src*dst,高位截断，只保留低位</td><td style="text-align:center">dst</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"><code>imul reg src imm</code></td><td style="text-align:left">R[reg]=src*imm，只保留低位</td><td style="text-align:center">reg</td></tr></tbody></table><p>具体还是看老师ppt截图吧（侵权删）</p><center><br><img src="/2018/08/30/asm2/imull.png" height="400"><br></center><h1 id="条件控制指令"><a href="#条件控制指令" class="headerlink" title="条件控制指令"></a>条件控制指令</h1><h2 id="比较与测试"><a href="#比较与测试" class="headerlink" title="比较与测试"></a>比较与测试</h2><center><br><img src="/2018/08/30/asm2/cmp.png" height="350"><br></center><p>cmp和test指令实际上是用减法和按位与操作实现的。</p><p>注意两个操作数的先后顺序与实际是<strong>相反</strong>的</p><h2 id="条件置位指令setX"><a href="#条件置位指令setX" class="headerlink" title="条件置位指令setX"></a>条件置位指令setX</h2><p>setX指令根据相应的条件标志位将某一位置0或置1。</p><p>有符号数的大小关系用greater/less表示，无符号数的用above/below表示。</p><center><br><img src="/2018/08/30/asm2/set.png" height="400"><br></center><h2 id="条件跳转指令jmpX"><a href="#条件跳转指令jmpX" class="headerlink" title="条件跳转指令jmpX"></a>条件跳转指令jmpX</h2><p>基本同setX</p><center><br><img src="/2018/08/30/asm2/jmp.png" height="400"><br></center><p>间接跳转：跳转的目标是从寄存器或存储器中读取的，e.g.<code>jmp *%eax</code>表示跳转至R[%eax]存储的地址位置</p><p>跳转地址分为<strong>绝对地址</strong>和<a href="#pc-r"><strong>相对地址(PC-relative addressing)</strong></a>。</p><p>绝对地址即4个字节直接指定的目标地址。</p><h2 id="PC-relative-addressing"><a href="#PC-relative-addressing" class="headerlink" title="PC-relative addressing"></a><span id="pc-r">PC-relative addressing</span></h2><p>程序计数器的值是<strong>跳转指令后</strong>的那条指令的地址，而非跳转指令本身的地址</p><p>实际跳转到的地址=下一条指令的地址+右边的操作数<strong>（小端补码表示）</strong></p><p>e.g.</p><pre><code>804828f:    74 05                je         XXXXXXX8048291:    e8 1e 00 00 00         call    80482b4XXXXXXX=0x8048291+0x05=0x8048296</code></pre><h2 id="条件传送指令cmovX"><a href="#条件传送指令cmovX" class="headerlink" title="条件传送指令cmovX"></a>条件传送指令cmovX</h2><p>满足某个条件时执行mov操作</p><p><strong>※必须与cmp操作连用，比较的不是cmov指令的两个操作数而是cmp的两个操作数</strong></p><center><br><img src="/2018/08/30/asm2/cmov.png" height="400"><br></center><h2 id="条件分支语句的编译"><a href="#条件分支语句的编译" class="headerlink" title="条件分支语句的编译"></a>条件分支语句的编译</h2><p>if-else语句通常按goto方式执行</p><p>一般翻译思路为:</p><pre><code>if (test-expr)     then-statementelse    else-statement</code></pre><p>会被翻译为</p><pre><code>if(!test-expr)    goto falsethen-statementgoto donefalse:else-statementdone:</code></pre><p>可以参考下图中示例：</p><center><br><img src="/2018/08/30/asm2/ifelse.png" height="600"><br></center><h1 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h1><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><p>一般循环语句都最终翻译成do-while的形式</p><pre><code>do    body-statementwhile(test-expr)</code></pre><p>会被翻译为</p><pre><code>loop:    body-statement    if(test-expr) goto loop;</code></pre><center><br><img src="/2018/08/30/asm2/dowhile.png" height="500"><br></center><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre><code>while(test-expr)    body-statement</code></pre><p>会被翻译为</p><pre><code>if(!test-expr) goto done;loop:    body-statement    if(test-expr) goto loop;done:</code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code>for(init-expr; test-expr; update-expr)    body-statement</code></pre><p>会被翻译为</p><pre><code>init-expr;if(!test-expr) goto done;loop:    body-statement    update-expr    if(test-expr) goto loop;done:</code></pre><h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表是一个数组，其中每个下标i对应一个代码段的地址<br><img src="/2018/08/30/asm2/jumplist.png" height="300"></p><p>好处：执行一个switch语句的时间和case的数量无关<br>跳跃表一般被存放在内存的某个位置，可以调用gdb查看</p><p>一大波截图预警</p><center><br><img src="/2018/08/30/asm2/switch1.png" height="1000"><br><img src="/2018/08/30/asm2/switch2.png" height="800"><br></center><h1 id="作业二的教训"><a href="#作业二的教训" class="headerlink" title="作业二的教训"></a>作业二的教训</h1><hr><p>1.几个指令的名称对应功能要背熟</p><p>2.确定数据类型：确定长度+<strong>有无符号</strong></p><p>3.别忘了<strong>指针</strong>也是一种数据类型</p><p>4.jmp指令的第二个操作数是<strong>小端补码表示</strong></p><p>5.模拟汇编控制流就是要把代码拆分成简单语句（注意运算优先级）</p><p>6.分清<strong>andl</strong>和<strong>addl</strong></p><p>7.补充C代码的时候就不要再写<strong>8x</strong>这样意义不明的东西了，是<strong><code>8*x</code></strong>啊老兄</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据传送&quot;&gt;&lt;a href=&quot;#数据传送&quot; class=&quot;headerlink&quot; title=&quot;数据传送&quot;&gt;&lt;/a&gt;数据传送&lt;/h1&gt;&lt;h2 id=&quot;数据传送指令&quot;&gt;&lt;a href=&quot;#数据传送指令&quot; class=&quot;headerlink&quot; title=&quot;数据传送指
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Assembly Language" scheme="https://mengzelev.github.io/tags/Assembly-Language/"/>
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言复习笔记（一）</title>
    <link href="https://mengzelev.github.io/2018/08/29/asm-notes/"/>
    <id>https://mengzelev.github.io/2018/08/29/asm-notes/</id>
    <published>2018-08-29T05:11:42.000Z</published>
    <updated>2018-08-30T03:32:00.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文为学校课程面向考试复习笔记，参考内容为老师的课堂讲义&amp;<em>深入理解计算机系统</em>，依据这两者做了一些个人的整理便于复习。<del>然而浪了一个假期在退课的边缘试探</del></p><h1 id="信息的表示"><a href="#信息的表示" class="headerlink" title="信息的表示"></a>信息的表示</h1><h2 id="数值的表示"><a href="#数值的表示" class="headerlink" title="数值的表示"></a>数值的表示</h2><ul><li>原码：这个很直观的</li><li>反码：这个几乎不用的</li><li>补码：$D’=R^n-D$ / 按位取反加1；</li><li>移码：见<a href="#float">浮点数</a></li></ul><p><strong>补码</strong></p><ul><li>相当于取模操作</li><li>着重区分<strong>基数的值(R)</strong>和<strong>补码位表示的实际的值(D)</strong></li><li>R与D的相对大小一致</li><li>$R=D+D_{w-1}\cdot 2^w$</li></ul><h2 id="C语言中的整数"><a href="#C语言中的整数" class="headerlink" title="C语言中的整数"></a>C语言中的整数</h2><ul><li>无符号数：在数后加U或u</li><li>同时有无符号数和带符号数，编译器将带符号数强制转换为<strong>无符号数</strong></li><li>int的最大正值为2147483647，最大负值为-2147483648</li><li><strong>比较时要特别注意是按什么规则进行的</strong></li></ul><h2 id="数据的存放"><a href="#数据的存放" class="headerlink" title="数据的存放"></a>数据的存放</h2><ul><li>小端：最低有效字节存放在<strong>最小</strong>地址</li><li>大端：最低有效字节存放在<strong>最大</strong>地址</li></ul><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a><span id="float">浮点数</span></h2><p>编码表示分3个字段</p><ul><li>符号s &nbsp; 0正1负 </li><li>阶码E &nbsp; k位阶码字段exp </li><li>尾数M &nbsp; n位小数字段frac &nbsp; 表示的是a/2^n</li></ul><p>float &nbsp; k=8,n=23</p><p>double &nbsp; k=11,n=52</p><p><strong>三种表示情况</strong></p><p><strong>1.规格化</strong> &nbsp;&nbsp;<br><strong>阶码部分既不全0也不全1</strong></p><p>采用偏置形式：<code>E=e-Bias</code></p><p>其中，E为阶码实际的值，e为位模式下的无符号数，偏置Bias= $2^{k-1}-1$ <code>float:127, double:1023</code></p><p>指数范围： <code>float: -126~+127; double -1022~1023</code></p><p>尾数 <code>M=f+1</code> &nbsp; 其中 <code>0&lt;=f&lt;1; 1&lt;=M&lt;2</code></p><p><strong>非规格化</strong> &nbsp;&nbsp;<br><strong>阶码全0</strong></p><p>阶码<code>E=1-Bias</code></p><p>尾数<code>M=f</code></p><p>存在意义：提供了0的表示方法，逐渐溢出 &nbsp; （否则[0,$2^{-n})范围内的数都无法表示）</p><p><strong>特殊值</strong> &nbsp;&nbsp;<br><strong>阶码全1</strong></p><ul><li>尾数全0：正负无穷大</li><li>尾数非全0： NaN</li></ul><p><strong>浮点数加减运算</strong><br>步骤：对阶→加减→规格化（→舍入）</p><p>对阶：小阶向大阶看齐，小阶尾数右移（带上隐含的1）</p><h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>没什么好说的。</p><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><ul><li>左移<code>x&lt;&lt;k</code>  丢弃最高k位，在右端补k个0</li><li>右移<code>x&gt;&gt;k</code>  丢弃最低k为，在右端补k个0/符号位</li></ul><p><strong>移位运算是向下取整</strong></p><h2 id="整数加减法"><a href="#整数加减法" class="headerlink" title="整数加减法"></a>整数加减法</h2><p>发生在n位带标志加法器中</p><p>###条件标志位<br>计算<code>t=a+b</code></p><table><thead><tr><th style="text-align:center">eflag</th><th style="text-align:center">中文名称</th><th style="text-align:center">有效条件</th></tr></thead><tbody><tr><td style="text-align:center">OF</td><td style="text-align:center">溢出标志</td><td style="text-align:center">a,b同号但t与a,b异号</td></tr><tr><td style="text-align:center">SF</td><td style="text-align:center">符号标志</td><td style="text-align:center">t&lt;0</td></tr><tr><td style="text-align:center">ZF</td><td style="text-align:center">零标志</td><td style="text-align:center">t==0</td></tr><tr><td style="text-align:center">CF</td><td style="text-align:center">进位标志</td><td style="text-align:center">(unsigned)t&lt;(unsigned)a</td></tr></tbody></table><p>比较大小相当于做减法</p><ul><li>无符号数： CF==0 $\Leftrightarrow$ a&gt;b</li><li>有符号数： OF==SF $\Leftrightarrow$ a&gt;b</li></ul><h2 id="整数乘法"><a href="#整数乘法" class="headerlink" title="整数乘法"></a>整数乘法</h2><p>乘数中有常数时：采用移位(左移)+加减法相结合的形式</p><h2 id="整数除法"><a href="#整数除法" class="headerlink" title="整数除法"></a>整数除法</h2><p>默认朝0方向舍入：，即正数商取比自身<strong>小</strong>的最接近整数，负数商取比自身<strong>大</strong>的最接近整数</p><p><strong>用移位代替除法时需要负数需要加上一个偏移量</strong></p><p>除数为2的幂次时，采用右移运算，得到朝0方向舍入的结果</p><ul><li>无符号数、有符号正整数： 移出的地位直接丢弃</li><li>有符号负整数： ：加偏移量 (2^k-1) ，然后再右移k位，低位截断</li></ul><h1 id="作业一的教训"><a href="#作业一的教训" class="headerlink" title="作业一的教训"></a>作业一的教训</h1><p>1.~按位取反 和 ！全部取反要区分清楚</p><p>2.非按位运算操作符非0的都视为true</p><p>3.浮点数的转化要好好看一下，把转化公式写好</p><p>4.移位是向下取整</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文为学校课程面向考试复习笔记，参考内容为老师的课堂讲义&amp;amp;&lt;em&gt;深入理解计算机系统&lt;/em&gt;，依据这两者做了一些个人的整理便于复习
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Assembly Language" scheme="https://mengzelev.github.io/tags/Assembly-Language/"/>
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>胡言乱语的大一总结</title>
    <link href="https://mengzelev.github.io/2018/08/18/freshman/"/>
    <id>https://mengzelev.github.io/2018/08/18/freshman/</id>
    <published>2018-08-18T13:27:02.000Z</published>
    <updated>2018-08-18T15:46:17.255Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;生日兼七夕窝在家里无聊于是开了这样一篇文章写了整整两天，都是些碎碎念。本来并没有写这种东西的习惯的<em>(:з」∠)</em>但是既然开了个人blog总要写点什么的于是就写吧！<del>试图掩盖写不出教程的事实</del>将来过好几年来看可能会很有回忆的感觉。</p><h2 id="学习篇"><a href="#学习篇" class="headerlink" title="学习篇"></a>学习篇</h2><p>刚进大学的时候，军训期间闲得蛋疼去考了计拔居然还被录取了，<del>txp他老人家眼光真的没问题吗，</del>于是就开始了贼船之旅。大一上第一个国庆长假就只能窝在家里写作业写了好久堪称心理阴影，大一上被问求这门神奇的课给吓尿了，动不动就为了赶作业修仙到两点。<del>其实还是有在疯狂补小排球的</del> 到了大一下觉得大一上还是很空闲的，起码不用搭面包板，也不用抄大物作业。大二上可能会觉得大一下很轻松吧，笑着活下去.jpg</p><center><br><img src="/2018/08/18/freshman/up.png" height="500"><br><br>大一上课表<br><br><img src="/2018/08/18/freshman/down.png" height="400"><br><br>大一下课表<br></center><p>随便说说几门课给我的感受。</p><p><strong>微积分</strong>早有耳闻，学起来没有觉得很难，可能也是托了qlz的福，这样有主见有原则的老师我超级赞赏的，上课还会讲故事，<del>最重要的是他给分高啊！</del> 本来和害怕数学的我渐渐也能感受到数学的美了吧，大概。</p><p><strong>微电子</strong>，浪费生命的水课，课听了，作业做了，考试考了但是感觉毫无收获。 </p><p><strong>大物实验</strong>，水课，求求来个人告诉我实验报告怎样才能拿到优。</p><p> <strong>大物</strong>，不明觉厉，学学物理其实挺好玩的，但是ldx这本书为什么这么…【无fuck说.jpg】<del>果然xmw这种老师还是早点辞退比较好</del> xw是真的很卖力啊但是为什么我还是听不懂，对不起他。虽然物理课每节都有在听但是经常忍不住水群导致错过了好多，下学期请务必全神贯注，不然电磁学要GG了。 </p><p><strong>思修</strong>， <strong>军理</strong>， <strong>马原</strong>， 水课三连，马原老师讲的哲学还有那么点意思，可惜全在写oj了没认真听。<del>军理部分老师太sb了请立刻辞退</del></p><p><strong>数电</strong> 嘛，还挺有意思的，搭面包板有点抓狂但是比比大班就有心里安慰了。<del>还有wgs真的好帅啊！！！</del> </p><p><strong>英语</strong>， 我喜欢，大一上的视听说拍视频很开心，<del>虽然我只是个压榨组员的主催</del>。大一下的配音和演讲超有意思的，演讲做了啊你妹相关的虽然很花时间但还是超开心的。Ruth的读写课天下第一好，我吹爆她！第一学期的时候就猜对了一个谜语而已她居然觉得我很厉害还送了我一个史迪仔期末还给了我满分，真的只是非洲人突然偷渡入欧而已…总之超级感谢的…第二学期结课的时候Ruth还哭了…能跟学生交心的老师是真的难得啊qwq</p><p><strong>问求</strong>， 终于到了这门让我百感交集无fuck说的课。大一上:卧槽我在学什么；大一下：卧槽这题该怎么做。大一上作业不算难但是量炒鸡大，期末考试也莫名其妙。大一下，作业不多但是好多不会做的，其他课作业又比较多只能出卖灵魂与网络上的算法导论参考答案签订契约成为期末挂科烧酒（雾）。OJ…别提了…我只是题解的搬运工…期末mj查什么重啊…您出题出这么难不找题解还怎么做啊…把OJ当acm校队选拔吗…</p><p><strong>汇编</strong>，一定要告诫学弟学妹，千万别听whj讲课，看csapp自学效率最高。whj讲课听不懂催眠效果还极好。实验部分装装Linux调调gdb还是挺好玩的，作业也还行，做下来对CPU的工作方式算是有了个全新的认识。【然而汇编笔记的文章还是没有产出来】拆炸弹是真的很有意思，每拆完一个phase都超有成就感，我应该是走火入魔了，连着3个晚上没睡好觉，闭眼就是寄存器，然后被自己炸醒。拆了三天也是够慢的，自卑.jpg.马上开学要考试了完全不想复习，在退课的边缘试探，，，</p><p><strong>通识</strong>, 感觉这一年里还是太忙于专业课的学习了，通识课上下来并没有太大的收获，基本都是上课不听埋头写作业<del>或者沉迷水群</del>，期末论文之类的也是东拼西凑的学术垃圾。和进大学之前想的完全不一样唉…悦读经典emmmmm论理想与现实的差距，目前为止选的三本书没有哪一本是认真看过的，我什么时候能中《呐喊》、《彷徨》呢？即使中了，在专业课重压之下真的会好好看吗？</p><p>课外学习的话，平时在校根本挤不出时间，总是带着不到ddl不写作业的惰性思维，这一点希望能改啊，<del>可是既然有时间难道不应该优先看番吗</del>。暑假龟速自学了git和markdown，其实都不是很有技术含量的东西，接下来的时间看看能不能学…你数学建模相关还一点没看呢吧…吧…美赛还没报名呢吧…咕掉了校内培训和选拔的严重后果…总之，加油吧。</p><p>也一度因为周围的人都去打acm迷茫过要不要去打，但是高中三年noip下来其实也不是太愉快，貌似不太喜欢这种过于理论、过于数学的题目，可能也是一种逃避现实的借口吧。嘛，既然决定了不打acm就一定要认真科研啊。不过现在学得太少真的不敢妄下定论自己喜欢什么。<del>西瓜书，请。</del></p><p>还有既然决定要出国了，请认真背单词。</p><blockquote><p>这个人真的不是精神分裂吗</p></blockquote><h2 id="社团活动篇"><a href="#社团活动篇" class="headerlink" title="社团活动篇"></a>社团活动篇</h2><p>说到大学必须得有社团活动哒！上大学之前幻想了很多的，进了大学为生活所迫也就活跃了几个地方。</p><p><strong>吉协</strong>是早就想去的，结果实际上也就大一上去上了弹唱提高班。老师还挺好的吧，至少比家这里的好，还稍微入门了一下指弹。之后的活动完全没有参加了orz什么时候才能把曲子练到能上台表演的水平呢…</p><p><strong>辩队</strong>还是有好好待的！<del>虽然是被学姐忽悠进去的还只打了两场正式比赛全是输给冠军的一轮游。</del>在辩队一年还从来没赢过一场，太惨了。每次比赛前讨论真的好花时间。一开始写一辩稿还好，后来开始被钦定打三辩稿子都是开场前30min写的了简直丢人。受了信管那边的学长学姐好多照顾（包括wrc)，除了辩论技巧还被拖着玩了狼人杀，所以，传火吧，骚年！</p><p><strong>CAC音乐部</strong>每天水水群约约饭很开心der!还认识了一帮宅友！好多会玩乐器的、唱歌超好听的小哥哥小姐姐！<del>还有豹跳如雷的海豹们两个月四对的传说</del>！还有每次交作业被33处刑…去过大活楼梯间约歌（一次），线上歌会（两次），107（等末子姐姐拍照一次），完美错过所有线下约k。也算是遗憾比较大的一个地方，当初大一上觉得自己作业太多了没去Monge，乐队的锅也没接。现在Monge都凉了，大二上更不可能有空了。仔细想想大一上其实能好好安排时间的话完全是有空的，但是刚进大学谁能想到呢？还是太求稳了缺少逼自己一把的勇气吧。为才能不足而自卑.jpg。接了vocal团的锅希望表达一点愧疚之意吧。<del>你们的(副)团长是全团最不会唱歌的人。</del></p><p><strong>流跡</strong>是在你群水群聊骨头社意外被33拉进去的。之前完全没想过还有这么硬核的探讨宅话题的地方。一开始什么都看不懂（现在依然是），但是以此为契机了解了不少<del>其实也不多</del>啊你妹制作相关的知识。后来进来的玄枝爷爷讲了好多叙事学的东西，很厉害的样子但是完全没听懂自卑.jpg。自从能在流跡吹水新番之后感觉自己的追番越来越勤快了，经各位的安利看番面也越来越广了。和各位的约饭也非常愉快。英语pre做了动画制作流程相关的内容以及现在补《白箱》都和流跡脱不了干系，想快点变得pro能和各位聊起来啊qwq</p><p><strong>排队</strong>是恶补了小排球之后才加的，虽然没有小排球里那么刺激<del>也没有那么多可爱的男孩子</del>但是打排球真的好开心！在场边加油很晒应该没晒黑多少吧(bushi)学姐们都好厉害！一路打进了院系杯四强！技术不足还不足以成为战力下个学期要好好加油了！</p><p>除此之外开学乱加的几个早就为作业所迫咕掉了。比如校会学创啊，信管乒队什么的。（你真的会打乒乓吗）大二上也不敢对社团活动有所奢望了，好好在辩队带带小孩、vocal团的工作做做好，流跡快点把制作流程产出，我就满足了。<code>你看又开始求稳没有拼劲了</code></p><h2 id="生活篇"><a href="#生活篇" class="headerlink" title="生活篇"></a>生活篇</h2><p>大学生活的第一年吗…总体还算平稳的吧。</p><p>宿舍不是太愉快。烦心事也就不多提了，忘掉最好。</p><p>一年来基本都靠食堂过日子，叫外卖的次数屈指可数。大一上基本没出过几次校门，大一下逐渐开始放浪形骸。</p><p>寒假鼓起勇气买了人生第一套jk制服，月野家的奶油黄基础款冬服，到快入夏的时候才到的，也就穿了一次。之后入了优马家的绀金和红酒雪梨，燕子家的白五本，从此走上攒钱买衣服的不归路。优马大小姐的定金已经下了，最近出了那么多问题…等浅色的出货爱咋滴咋地吧。代码定金也下了，坐等出货，我也想穿着代码敲代码！</p><p>es军训的时候还在肝rock，开学后尝到了生活的艰辛，尤其是在做人情肝了一发节分守门两小时作业一笔未动修仙勉强做完后，从此es脱坑。现在极其想把手头的谷子都卖掉，忘记我这个出坑的人渣吧。fgo军训无聊稍微玩了一下，总之是不想过靠肝和欧生活的日子了，这月就不登了。</p><p>大一下开始学车，暑假的时候留校一个多礼拜把科三给考了，过得超惊险。大二上要在上课和作业的夹缝中学科二了。</p><h2 id="补番篇"><a href="#补番篇" class="headerlink" title="补番篇"></a>补番篇</h2><p>就不一一列举了这一年里补/追过的番了，类似于推荐的形式挑几部印象深刻的写吧。</p><p><strong>小排球</strong>  强推！吹爆！运动番天花板！剧情作画配乐都堪称一流！看到停不下来！一般深夜补番的我多次因为小排球亢奋到睡不着。好久没看这么从头正到尾的番了，既有很现实的设定（及川大王和影山）也有理想的处理（日向和乌野的大家）。不会气活牛顿的科学运动番，<del>唯一不现实的地方是现实中的小男孩哪有这么可爱。</del>看完甚至开始打排球的我不是一个人。心情不好的时候看看小排球就能马上开心起来。有生之年能遇到这样的番真是太好了。</p><p><strong>三月的狮子</strong> 对上电波的慢节奏番，吹爆羽海野老师和新房！！零酱超可爱！！（摸摸）很喜欢这种有关人生与成长的题材，零酱和三姐妹经历的困难特殊而普遍，仿佛能看到自己的过去。身世悲惨的他们也时常享有寻常的幸福，这种强烈对比大概就是三狮的动人之处。岛田大师兄、小胖、老师等配角刻画得也很好。虽然将棋部分的内容完全看不懂但也不妨碍其成为一部佳作。</p><p><strong>超自然九人组</strong> 志仓千代丸的作品，剧情，尤其是开头和中间展开很精彩，节奏飞快，收尾略显仓促，不少坑挖了没填，听说游戏表现得反而没有动画好有点可惜。<del>佐仓这回治好了我的巨乳控！</del></p><p><strong>宅男腐女恋爱难</strong> 太甜了！一部刷新我恋爱观的番！我萌捷列夫就是饿死，死外边，也不会看狗粮番的——真香！</p><p>其他看过的番bangumi上都有记录了就不作赘述了。顺便贴上<a href="http://bangumi.tv/user/426807/&quot;萌捷列夫的bangumi&quot;" target="_blank" rel="noopener">我的bangumi</a>。</p><h2 id="恋爱篇"><a href="#恋爱篇" class="headerlink" title="恋爱篇"></a>恋爱篇</h2><p>您是不是一上来就通过目录索引跳这儿来了？哈哈！对不起！毛都没有！</p><p>……</p><p>没有对象但还是想说说恋爱观的，毕竟之前也没有认真思考过这个问题，就大一上拒了俩然后被吓到了发表了一堆独身主义宣言<del>现在想想全tm是黑历史啊好想删说说。</del>其实也没有那么抗拒了啦<code>首先你得...</code>只是自己不是那种想随便玩玩的人，所以想尽可能抱着认真谨慎的心态来对待这么重要的事情<code>首先你得...</code>不过话说回来还是作业太多了，客观上不想再多加一件需要操心的事情了<code>首先你得...</code>没有空间里那些对象怪那么迫切，还是很享受单身的自由生活的，只要管好自己就行了，<del>想喜欢谁就喜欢谁做个dd不好吗？</del>也就是出去玩找不到小伙伴的时候会稍微有点寂寞（）。各有各的生活方式吧。总之，这么看缘分的事情还是随缘吧…</p><p>嗯？您问有没有喜欢的人了？这篇文章没加密我当然不会说啦！(doge)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;生日兼七夕窝在家里无聊于是开了这样一篇文章写了整整两天，都是些碎碎念。本来并没有写这种东西的习惯的&lt;em&gt;(:з」∠)&lt;/em&gt;但是既然开了个人blog总要写点什么的于是就写吧！&lt;del&gt;试图掩盖写不出教程的事实&lt;/del&gt;将来过好几年来看可能会很有
      
    
    </summary>
    
      <category term="Diary" scheme="https://mengzelev.github.io/categories/Diary/"/>
    
    
      <category term="freshman" scheme="https://mengzelev.github.io/tags/freshman/"/>
    
      <category term="college life" scheme="https://mengzelev.github.io/tags/college-life/"/>
    
  </entry>
  
  <entry>
    <title>Markdown test</title>
    <link href="https://mengzelev.github.io/2018/08/12/test-md/"/>
    <id>https://mengzelev.github.io/2018/08/12/test-md/</id>
    <published>2018-08-12T13:27:02.000Z</published>
    <updated>2018-08-12T13:35:34.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是标题君"><a href="#这是标题君" class="headerlink" title="这是标题君"></a>这是标题君</h1><h2 id="这是副标题君"><a href="#这是副标题君" class="headerlink" title="这是副标题君"></a>这是副标题君</h2><p>我知道这篇文章看起来很沙雕，因为作者就是一个沙雕</p><p>列表非常有趣</p><ul><li>这是第一项</li><li>这是第二项</li><li>这是第三项</li></ul><hr><p>有时候会有需要<strong>强调</strong>的内容。</p><p>插入代码是一件非常爽的事情：</p><pre><code>printf(&quot;%s&quot;,&quot;Hello world!\n&quot;);</code></pre><p>突然发现自己不会用printf真是太丢人了。</p><hr><p>有时候需要插入链接，这里贴一个<a href="http://www.baidu.com/" target="_blank" rel="noopener">百度</a>。</p><p>有时候又需要插入图片</p><center><br>    <img src="https://pic2.zhimg.com/80/v2-bf04338ea0065cea5dc853e7d1675c25_hd.jpg" height="330"><br></center><p>看张血小板冷静一下吧（图源网络）</p><p>图片的尺寸可以用命令进行修改</p><hr><p>暂时先写这么多吧，敬请关注后面几期，计划中将会有</p><ul><li>汇编课程相关学习笔记</li><li>日本动画制作流程及《白箱》观后感整理</li><li>大一回顾与总结</li></ul><blockquote><p>但愿到时候不要鸽（小声）<br>评论功能等我明天再来开<br>不要问我这里为什么是引用格式，看不出来我只是在试试吗</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;这是标题君&quot;&gt;&lt;a href=&quot;#这是标题君&quot; class=&quot;headerlink&quot; title=&quot;这是标题君&quot;&gt;&lt;/a&gt;这是标题君&lt;/h1&gt;&lt;h2 id=&quot;这是副标题君&quot;&gt;&lt;a href=&quot;#这是副标题君&quot; class=&quot;headerlink&quot; title=&quot;这
      
    
    </summary>
    
      <category term="Diary" scheme="https://mengzelev.github.io/categories/Diary/"/>
    
    
      <category term="markdown" scheme="https://mengzelev.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://mengzelev.github.io/2018/07/28/hello-world/"/>
    <id>https://mengzelev.github.io/2018/07/28/hello-world/</id>
    <published>2018-07-28T06:23:10.175Z</published>
    <updated>2017-10-28T00:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
