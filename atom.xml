<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengzelev&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mengzelev.github.io/"/>
  <updated>2020-06-17T05:03:41.599Z</updated>
  <id>https://mengzelev.github.io/</id>
  
  <author>
    <name>Mengzelev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode刷题笔记</title>
    <link href="https://mengzelev.github.io/2020/05/15/leetcode-notes/"/>
    <id>https://mengzelev.github.io/2020/05/15/leetcode-notes/</id>
    <published>2020-05-15T12:33:29.000Z</published>
    <updated>2020-06-17T05:03:41.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode刷题笔记"><a href="#LeetCode刷题笔记" class="headerlink" title="LeetCode刷题笔记"></a>LeetCode刷题笔记</h1><h2 id="解法与注意点整理"><a href="#解法与注意点整理" class="headerlink" title="解法与注意点整理"></a>解法与注意点整理</h2><table><thead><tr><th style="text-align:center">题目序号</th><th style="text-align:left">题目描述</th><th>大致解法</th><th>注意点</th></tr></thead><tbody><tr><td style="text-align:center">2. 两数相加</td><td style="text-align:left">两个链表存储的整数，求加起来的数的链表表示</td><td>遍历链表，处理相加与进位</td><td>不要递归；进位善后；一数到底的处理；</td></tr><tr><td style="text-align:center">3.无重复字符的最长字符串</td><td style="text-align:left">给定一个字符串，找出其中不含有重复字符的<strong>最长子串</strong>的长度。（不是子序列）</td><td>滑动窗口。双指针实现。当字串中无重复元素时向右移动右指针，否则向右移动左指针，直到无重复为止。</td><td>注意开始条件（长度为1和2的字符串）</td></tr><tr><td style="text-align:center">4. 寻找两个正序数组的中位数</td><td style="text-align:left">给定两个排好序的数组，找出这两个数组中的数的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</td><td>二分。法一：转换为寻找第k小的数。每次检查A[k/2-1]和B[k/2-1]，若A[k/2-1]&lt;=B[k/2-1]，说明比A[k/2-1]小的数最多只有k-2个，因此可以删去A[0:k/2-1]的数；反之同理。当范围缩小到只剩一个数组或为k为1时返回。法二：转换为寻找最大的i，满足A[i-1]&lt;=B[(m+n+1)/2 -i]即可（此处有复杂数学证明）</td><td>难。中位数的本质：第n/2小的数（奇数个数）或 一个划分标准，使得一半的数比它小，另一半的数比它大；</td></tr><tr><td style="text-align:center">9. 回文数</td><td style="text-align:left">判断输入数是否为回文数</td><td>法一：转成字符串，直接比较/双指针比较；法二：使用运算反转数字的一半（<code>while x &gt; reverse_x</code>），比较<code>x==reverse_x</code>（偶数位数）或<code>reverse_x//10 == x</code>（奇数位数）</td><td>Python的整除是<strong>双斜杠</strong>；Python反转字符串<code>s[::-1]</code></td></tr><tr><td style="text-align:center">14. 最长公共前缀</td><td style="text-align:left">找出输入的一组字符串的最长公共前缀</td><td>法一：无脑模拟。可以在前缀为空时提前退出。法二：二分分治。对strs数组进行分治查找。</td><td></td></tr><tr><td style="text-align:center">70.爬楼梯</td><td style="text-align:left">每次可以爬 1 或 2 个台阶。有多少种不同的方法可以爬到n阶楼梯楼顶</td><td>DP。<code>dp[i]=dp[i-1]+dp[i-2] (i &gt;= 2)</code>，即斐波那契数。</td><td>可以用矩阵快速幂或通项公式优化为$O(\log n)$</td></tr><tr><td style="text-align:center">990. 等式方程的可满足性</td><td style="text-align:left">给定一系列变量不等或相等关系，判断是否存在一种赋值使这些关系被全部满足</td><td>并查集。第一次遍历将相等的变量合并到用一个并查集中；第二次遍历查找是否有不等但处于同一个并查集中的变量。</td><td>并查集的非递归写法；由于题意要求变量全是小写字母故最多26个变量（使用<code>ord(var)-ord(&#39;a&#39;)</code>索引变量）；时间复杂度$O(n+ClogC)`</td></tr><tr><td style="text-align:center">1014.最佳观光组合</td><td style="text-align:left">给定一个数组A，寻找一对i,j(i&lt;j)使得A[i]+A[j]+i-j最大</td><td>枚举。维护目前最大的a[i]+i，对每个j计算a[j]-j+max(a[i]+i)</td><td>可以将一个属性递推维护来减少枚举的维度</td></tr><tr><td style="text-align:center">1300. 转变数组后最接近目标值的数组和</td><td style="text-align:left">给定一个整数数组 arr 和一个目标值 target ，返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。优先返回最小的解。</td><td>双重二分。1. 在[0, max(arr)]二分搜索出一个<code>value</code>，使得<code>sum(arr, val)&lt;=target&lt;=sum(arr, val+1)</code>；2. 计算<code>sum(arr, val)</code>时，先将<code>arr</code>排序，然后找到第一个比<code>val</code>的大的数的下标<code>id</code>，则<code>sum(arr, val)=prefix_sum[id] + (n-id)*val</code></td><td>Python可以使用<code>bisect.bisect_left(arr, x)</code>二分查找并返回第一个比<code>x</code>大的数的下标；二分搜索模板。（见涨姿势部分）</td></tr><tr><td style="text-align:center">1465. 一次编辑</td><td style="text-align:left">给定两个字符串a和b，判断是否能通过一次编辑（增删改）由a得到b</td><td>双指针逐个遍历字符，不相同时比较该字符之后的字符串</td><td></td></tr><tr><td style="text-align:center">1476.旋转矩阵</td><td style="text-align:left">在不用额外的空间将矩阵（正方形）旋转90°</td><td>每一层四周交换或水平翻转+对角翻转</td><td>下标数量关系需要现场推导</td></tr><tr><td style="text-align:center">1477.零矩阵</td><td style="text-align:left">若M × N矩阵中某个元素为0，则将其所在的行与列清零</td><td>第一次扫描标记需要清零的位置，第二次扫描清零</td><td>必须分两次扫描</td></tr><tr><td style="text-align:center">1482.分割链表</td><td style="text-align:left">给定链表和数<code>x</code>，返回新链表，前半部分都是比<code>x</code>小的数，后半部分都是不小于<code>x</code>的数</td><td>双头链表，小的插前面，大的插后面</td><td></td></tr><tr><td style="text-align:center">1583.重建二叉树</td><td style="text-align:left">给出二叉树的前序遍历和中序遍历，重建二叉树</td><td>递归：在preorder中找到根，然后拆分遍历结果，递归重建左右子树；迭代：栈结构存储preorder中的根及左子树节点，遇到第一个右子树节点时退栈</td><td>注意空二叉树；递归和迭代都可以</td></tr><tr><td style="text-align:center">1489.堆盘子</td><td style="text-align:left">多个栈，一个栈放满了就放进下一个栈；要求<code>push</code>和<code>pop</code>和一个栈时表现相同，且可以指定<code>pop</code>哪个栈的内容</td><td>闭着眼睛写</td><td>pop指定栈时一个栈pop空了要将它删去</td></tr><tr><td style="text-align:center">1498.节点间通路</td><td style="text-align:left">给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</td><td>输入的邻接矩阵转化为临界链表，dfs/bfs</td><td>先将输入的邻接矩阵转换成临界链表</td></tr><tr><td style="text-align:center">1502.合法二叉搜索树</td><td style="text-align:left">检查一棵二叉树是否为二叉搜索树</td><td>1.中序遍历，对每个节点维护上下界并判断节点值是否处于上下界之间；2.中序遍历成数组，判断数组是否升序排列</td><td></td></tr><tr><td style="text-align:center">1505.二叉搜索树序列</td><td style="text-align:left">给定一个由不同节点组成的二叉树，输出所有可能生成此树的数组。</td><td>根必须出现在其所有子节点之前；用一个队列维护某个时刻能够成为下个节点的所有数值（即当根进队后将其子节点压入队列），循环输出所有可能的数组。</td><td>用<strong>队列</strong>维护可行的下个节点</td></tr><tr><td style="text-align:center">1601.正则表达式匹配</td><td style="text-align:left">判断字符串<code>s</code>是否与包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式<code>p</code>相匹配</td><td>dp，用<code>f[i][j]</code>表示<code>s</code>的前<code>i</code>位与<code>p</code>的前<code>j</code>位是否匹配。若<code>s[i-1]==p[j-1] or p[j-1]==&#39;.&#39;</code>，则<code>f[i][j]=f[i-1][j-1]</code>；若<code>p[j-1]==&#39;*&#39;</code>，如果之前的字符只出现0次，只需去掉最后了两个字符（<code>f[i][j]=f[i][j-2]</code>），否则回溯<code>s</code>串考察该字符是否出现了多次，即`if(s[i-1]==p[j-2] or p[j-2]==’.’) f[i][j] \</td><td>\</td><td>= f[i-1][j]`</td><td>动态规划；边界条件</td></tr><tr><td style="text-align:center">1593.矩阵中的路径</td><td style="text-align:left">判断在一个矩阵中是否存在一条包含某字符串所有字符的路径，同一个格子不可重复走</td><td>dfs（因为只要找到一条路径所以不是bfs）+剪枝；二重循环遍历寻找开始点，当开始点邻域内存在下个相应的字符时继续往下遍历；不存在下个字符时或<strong>路径长度超过字符串长度</strong>时返回。</td><td>回退时将走过的格子访问状态还原；标记访问状态可以不开数组直接在原矩阵内操作</td></tr><tr><td style="text-align:center">1594.机器人的运动范围</td><td style="text-align:left">m行n列的方格，从左上角到右下角，只能走坐标数位和不超过<code>k</code>的格子，求可达格子数</td><td>dfs和bfs均可。由于数位和的增减特性，可以<strong>只向右、下</strong>两个方向搜索。</td><td></td></tr><tr><td style="text-align:center">1608.树的子结构</td><td style="text-align:left">输入两棵二叉树A和B，判断B是不是A的子结构</td><td>双重dfs。第一重：寻找A中可以作为B的根节点的点；第二重：判断从该点开始是否存在与B相同的结构。</td><td>A可以有多余的子节点，只需要包含B即可；对节点为空的处理</td></tr><tr><td style="text-align:center">1613.栈的压入、弹出序列</td><td style="text-align:left">输入两个整数序列，第一个序列表示栈的压入顺序，判断第二个序列是否为该栈的弹出顺序</td><td><strong>模拟</strong>。根据出入栈序列模拟栈的行为，若能模拟成功即为合法出栈序列。模拟方法：入栈直到栈顶元素为当前出栈序列中被指向的元素，无元素可入栈但出栈序列未过完时模拟失败。</td><td>模拟只要$O(N)$，数学判断要$O(N^3)$；写py多用<code>for elem in list</code> 而非 <code>for i in range(0, len): list[i]</code></td></tr><tr><td style="text-align:center">1614.从上到下打印二叉树</td><td style="text-align:left">从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印</td><td><strong>BFS。</strong></td><td>对树bfs得到的就是“从上到下、从左到右”的输出顺序；注意处理空树；<code>deque</code>的双端插入删除操作更快</td></tr><tr><td style="text-align:center">1616.从上到下打印二叉树 III</td><td style="text-align:left">之字形顺序打印二叉树</td><td>BFS+奇偶分别判断。bfs的队列用<code>deque</code>。以层为单位进行出队和入队（二重循环，每次里层循环开始时bfs队列中只有同一层的节点，将这一层的节点按照层数奇偶性正序或倒序放入输出队列，然后把这些节点的子节点加入bfs队列。保证里层循环进行的次数为循环开始前bfs队列的大小。）</td><td>空树。</td></tr><tr><td style="text-align:center">面试题29.顺时针打印矩阵</td><td style="text-align:left">按照从外向里以顺时针的顺序依次打印出矩阵中的每一个数字。（螺旋打印）</td><td>模拟。注意前进方向的维护即可。</td><td></td></tr><tr><td style="text-align:center">面试题33. 二叉搜索树的后序遍历序列</td><td style="text-align:left">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。</td><td>1.递归：递归判断某一段序列是否满足“比跟小”（左子树）+“比根大（右子树）”+根。2. 辅助栈还原BST：遇到递减节点（左子树节点）前将所有节点作为候选根节点压栈，遇到递减节点就退栈直到栈顶为当前子树的根。若能还原成功就满足要求。</td><td>一步能做完的事尽量不要靠递归；BST与栈；</td></tr><tr><td style="text-align:center">面试题34. 二叉树中和为某一值的路径</td><td style="text-align:left">打印出二叉树中节点值的和等于输入整数的所有路径。（根→叶子算路径）</td><td>dfs所有路径，满足要求的加入输出</td><td>路径节点值可能为负数，不能剪枝</td></tr><tr><td style="text-align:center">面试题35. 复杂链表的复制</td><td style="text-align:left">深拷贝。复杂链表：每个节点除了<code>next</code>还有<code>random</code>（随机指向一个节点或<code>null</code>）</td><td>哈希表存放深拷贝前后节点的映射关系。（优化：拷贝的节点放在原节点的next，这样可以直接通过next访问对应的拷贝节点）</td><td>链表遍历一定要写<code>node = node.next</code>！！！！</td></tr><tr><td style="text-align:center">面试题36.BST与双向链表</td><td style="text-align:left">把BST改成双向循环链表。左孩子指针指向前驱，右孩子指针指向后继。</td><td>中序遍历。因为中序遍历的顺序就是排序的顺序，使用全局变量记录一个前驱<code>pre</code>。对于每个节点先遍历左子树，然后将前驱的右指针改为当前节点，当前节点的左指针改为前驱。全部遍历完后将首尾相接形成循环。</td><td>Python中可以使用<code>self.xx</code>当成<strong>全局变量</strong>；<strong>强化记忆</strong>：BST的中序遍历就是排序序列</td></tr><tr><td style="text-align:center">面试题37. 序列化二叉树</td><td style="text-align:left">实现两个函数，分别用来序列化和反序列化二叉树。（序列化：把数据结构变成字符串）</td><td>BFS。序列化和反序列化都通过队列保存候选根节点，BFS遍历整棵树。不必须序列化成leetcode的规范。</td><td>Python字符串格式化合并<code>join</code>与分割<code>split</code>；使用<code>if x</code>判断<code>x</code>非空时注意<code>x</code>可能会有非空但值为0的情况；（leetcode规范）反序列化时注意右子树可能无；</td></tr><tr><td style="text-align:center">面试题38.字符串的排列</td><td style="text-align:left">输出给定字符串的全排列。（同样的字符视为同一个如”aab”前两个”a”视为相同）</td><td>回溯。递归确定每一位上的字符，已经在该位上出现过的字符不再考虑（使用<code>set</code>）。当确定了前<code>len(s)-1</code>位时记录答案并返回。</td><td>注意相同字符去重；python有<code>itertools.permutations()</code></td></tr><tr><td style="text-align:center">面试题41. 数据流中的中位数</td><td style="text-align:left">设计一个支持“插入元素”与“返回所有元素”操作的数据结构。</td><td>堆。维护两个堆，小堆A维护较大的一半元素，大堆B维护较小的一半元素（奇数个元素时A多一个）。插入元素：若AB大小相等，则向A插入元素（先向B插入元素，然后将B的堆顶弹出插入A中）；否则向B插入元素（方法同前）。返回中位数：根据AB大小，返回A的堆顶或AB堆顶的平均数。</td><td>Python的list的insert操作不是O(1)的；插入元素时要先插入另一个堆中然后迁移堆顶；</td></tr><tr><td style="text-align:center">面试题43.1出现的次数</td><td style="text-align:left">输入<code>n</code>，求出1~n十进制整数中1在数位上出现的次数。</td><td>模拟（？）。迭代计算1在每个数位上出现的次数。维护基数<code>base</code>和低位数<code>low</code>。每次循环判断<code>n</code>的最低位，至少<code>ans+=(n/10)*base</code>；若最低位为1则<code>ans+=(low+1)</code>；若最低位大于1则<code>ans+=base</code>。然后更新使<code>low=low+base*(n%10), base*=10, n/=10</code>。</td><td>注意<code>low</code>的更新；注意最低位为1的情况；</td></tr><tr><td style="text-align:center">面试题44. 数字序列中某一位的数字</td><td style="text-align:left">数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，如第5位（从下标0开始计数）是5，第13位是1，第19位是4</td><td>模拟（找规律）。先求出目标数位属于几位数的范畴，然后计算出目标数位是这个区间的第几个数的第几位。</td><td>注意下标从0开始。</td></tr><tr><td style="text-align:center">面试题45. 把数组排成最小的数</td><td style="text-align:left">输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</td><td>排序。比较规则：对于数$a,b$，$a$应带排在$b$前面当且仅当$\overline{ab}&lt;\overline{ba}$。</td><td>Python3里使用<code>sorted(str_list, key=functools.cmp_to_key(cmp))</code>实现自定义排序。</td></tr><tr><td style="text-align:center">面试题46.把数字翻译成字符串</td><td style="text-align:left">数字0~25编码为字符a~z，给定一串数字，求编码成字符串的方案数</td><td>DP。<code>dp[i]</code>表示<code>[0..i]</code>位的数的编码方案数。转移方程：$dp[i]=dp[i-1]+dp[i-2]$ if  $10n_{i-1}+n_[i]\in [10,25]$;  $dp[i-1]$ o.w.。由于只用到前两位的信息因此计算过程中可以只维护两个变量、</td><td>0的处理，00不表示字母a；</td></tr><tr><td style="text-align:center">面试题47. 礼物的最大价值</td><td style="text-align:left">给定一个矩阵，求从左上角走到右下角（只能向下和向右）经过路线上数字之和的最大值</td><td>DP。<code>dp[i][j]</code>表示走到坐标为<code>(i,j)</code>的点经过路线上数字之和的最大值。非边界情况递推式：<code>dp[i][j]=max(dp[i-1][j] +dp[i][j-1])</code>。边界情况为<code>i=0</code>或<code>j=0</code>的情况。</td><td>记忆化搜索会超时，因为只需要考虑向右和向下的路径所以可以dp；可以直接在输入list上做dp</td></tr><tr><td style="text-align:center">面试题49.丑数</td><td style="text-align:left">丑数是质因子只有2,3,5的数。1是第一个丑数，求第$n$个丑数。</td><td>DP。<code>dp[i]</code>表示第<code>i+1</code>个丑数。递推式形式为<code>dp[i]=min(dp[a]*2, dp[b]*3, dp[c]*5)</code>。<code>a,b,c</code>在之前的递推中维护，当<code>dp[j]&gt;=dp[a]*2</code>时，<code>a=j</code>。（3和5同理）初始条件<code>dp[0]=1, a=b=c=0</code></td><td>此题递推时同时需要维护；</td></tr><tr><td style="text-align:center">面试题51. 数组中的逆序对</td><td style="text-align:left">求给定数组中逆序对的个数。</td><td>法一：归并排序。当右侧指针移动时走过的就是逆序对。法二：树状数组。将输入数组离散化，用一个桶统计每个数出现的次数。反向扫描原数组，某数被扫描到时在桶中的前缀和就是以该数为首的逆序对的个数。（这个数之后比它小的数的个数）</td><td>离散化：排序后使用二分法为每个数分配一个Index，之后使用index代表这个数。Python树状数组实现见涨姿势部分。</td></tr><tr><td style="text-align:center">面试题56 - I. 数组中数字出现的次数</td><td style="text-align:left">一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</td><td>位运算（异或）。如果只有一个数字只出现一次，整个数组的异或和就是答案。此时有两个只出现一次的数字，因此需要将数组分组。分组依据为取整个数组的异或中为1的某位，然后根据该位是否为1将整个数组分成两组分别求异或和，就能得到答案。</td><td>异或和可以用来寻找只出现了一次的数；Python求异或和可以使用<code>functools.reduce</code></td></tr><tr><td style="text-align:center">面试题64.求1+2+…+n</td><td style="text-align:left">求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</td><td>法一：求和公式。无法使用循环和分支所以用位运算代替乘法：<code>(b&amp;1) &amp;&amp; ans += a; b &lt;&lt;= 1; a &gt;&gt;= 1;</code>。$n$最大为10000(14位)，故手动展开14次即可。法二：迭代。禁止循环，改为递归。用bool运算的短路实现条件分支，<code>(n &gt; 1) &amp;&amp; sum(n-1); ans += n;</code></td><td>bool运算的短路可以实现条件分支（编译实验白写了）</td></tr></tbody></table><h2 id="涨姿势"><a href="#涨姿势" class="headerlink" title="涨姿势"></a>涨姿势</h2><ul><li><p><code>abs(str1.size()-str2.size())</code>会报错，因为C++string类的<code>size()</code>函数为了不同平台上的兼容性返回的是<code>string::size_type</code>的类型。而<code>abs()</code>函数可以接受多种参数，但编译时无法确定应该使用哪个<code>abs()</code>所以会报ambiguous。——使用string类的<code>size()</code>函数先确定类型</p></li><li><p>C++的<code>new [struct name]</code>返回的是<strong>指针</strong>（就相当于C的<code>malloc</code>），我怎么连这个都不知道……</p></li><li><p>C++定义动态大小的二维数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li><li><p>Python定义动态大小的二维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br></pre></td></tr></table></figure></li><li><p>C++的bool表达式勤加括号</p></li><li><p>在访问任何对象的成员前检查对象是否<strong>非空</strong></p></li><li><p>python实现队列和栈时优先使用<code>deque</code>，因为两端的插入和删除操作都是$O(1)$，而普通的List是$O(N)$</p></li><li><p>Python设置最大值：<code>float(&quot;+inf&quot;)</code></p></li><li><p>借助<strong>栈</strong>可以将遍历序列还原为BST</p></li><li><p>Python反转字符串<code>s[::-1]</code></p></li><li><p>Python同时迭代元素和下标：<code>for i, x in enumerate(a)</code></p></li><li><p>Python自定义排序：</p><ul><li>定义一个函数<code>cmp(a, b)</code>，满足<code>a</code>排在<code>b</code>前面时返回-1（任意负数）,否则返回1（任意正数）</li><li>对待排序列表使用<code>sorted(list_to_sort, key=functools.cmp_to_key(cmp))</code></li><li>原理<code>cmp_to_key(cmp)</code>里面定义了一个类，该类的<code>__lt__()</code>方法返回<code>True</code>当且仅当<code>cmp(self.obj, other.obj)&lt;0</code></li></ul></li><li><p>二分搜索模板（+1-1傻傻分不清）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find the largest 'x' that f(x) &lt;= target</span></span><br><span class="line"><span class="keyword">while</span> l &lt; r:</span><br><span class="line">    m = (l + r + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> f(m) &lt;= target:</span><br><span class="line">        l = m</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = m - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> l <span class="comment"># return r is the same</span></span><br></pre></td></tr></table></figure></li><li><p>Python树状数组模板</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.tree = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowbit</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            ret += self.tree[x]</span><br><span class="line">            x -= BIT.lowbit(x)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, x, delta)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x &lt;= self.n:</span><br><span class="line">            self.tree[x] += delta</span><br><span class="line">            x += BIT.lowbit(x)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Python语言相关"><a href="#Python语言相关" class="headerlink" title="Python语言相关"></a>Python语言相关</h2><p><strong>全局解释器锁GIL</strong></p><ul><li>Python的多线程程序并不能利用多核CPU的优势，如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行</li><li>GIL只会影响到那些严重依赖CPU的程序（比如计算型的）。 如果你的程序大部分只会涉及到I/O，比如网络交互，那么使用多线程就很合适，因为它们大部分时间都在等待</li><li>线程不是专门用来优化性能的。优化性能应该：优化底层算法，性能瓶颈代码移到C语言扩展模块（操作数组使用Numpy），Pypy使用JIT编译器优化执行效率</li><li>解决：<ul><li>进程池（<code>multiprocessing.Pool()</code>）。进程池在另一个进程中启动一个单独的Python解释器工作</li><li>C扩展：计算密集型任务转移给C，在C代码中释放GIL。Cpython的ctypes库会在调用C时自动释放GIL</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode刷题笔记&quot;&gt;&lt;a href=&quot;#LeetCode刷题笔记&quot; class=&quot;headerlink&quot; title=&quot;LeetCode刷题笔记&quot;&gt;&lt;/a&gt;LeetCode刷题笔记&lt;/h1&gt;&lt;h2 id=&quot;解法与注意点整理&quot;&gt;&lt;a href=&quot;#解法与注意
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络-期末复习</title>
    <link href="https://mengzelev.github.io/2019/12/29/network-review/"/>
    <id>https://mengzelev.github.io/2019/12/29/network-review/</id>
    <published>2019-12-29T02:37:19.000Z</published>
    <updated>2020-01-01T12:22:44.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch1-计算机网络和因特网"><a href="#Ch1-计算机网络和因特网" class="headerlink" title="Ch1 计算机网络和因特网"></a>Ch1 计算机网络和因特网</h1><h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h2><h3 id="1-1-1-具体构成描述"><a href="#1-1-1-具体构成描述" class="headerlink" title="1.1.1 具体构成描述"></a>1.1.1 具体构成描述</h3><ul><li>因特网：世界范围的计算机网络，一个互联了遍历全世界的数以亿计的计算设备的网络。</li><li>连接到因特网的设备一般称为<strong>主机（host）</strong>或<strong>端系统（end system）</strong>，端系统通过通信链路（communication link）和分组交换机（packet switch）连接到一起。</li><li>链路的<strong>传输速率</strong>以比特/秒度量（bit/s或bps）</li><li><strong>分组（packet）</strong>是发送端系统将数据分段，并为每段加上首部字节，由此形成的信息包。</li><li><strong>路由器（router）</strong>和<strong>链路层交换机（link-layer switch）</strong>是两种著名的分组交换机，它们朝着最终目的地转发分组。</li><li><strong>路径（route或path）</strong>：从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机。</li><li>端系统通过<strong>因特网服务提供商（Internet service provider，ISP）</strong>接入因特网。</li><li><strong>TCP</strong>（传输控制协议）和<strong>IP</strong>（网际控制协议）协议是因特网中两个最为重要的协议，后者定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为<strong>TCP/IP</strong>。</li><li><strong>因特网标准</strong>由<strong>因特网工程任务组（IETF）</strong>研发，IETF的标准文档称为<strong>请求评论（RFC）</strong></li></ul><h3 id="1-1-2-服务描述"><a href="#1-1-2-服务描述" class="headerlink" title="1.1.2 服务描述"></a>1.1.2 服务描述</h3><ul><li><strong>分布式应用程序</strong>：涉及多台相互交换数据的端系统的应用程序。</li><li><strong>套接字接口</strong>：与因特网相连的端系统提供，规定了端系统上的程序 请求因特网基础设施 向另一个端系统上程序 交付数据的方式</li></ul><h3 id="1-1-3-协议"><a href="#1-1-3-协议" class="headerlink" title="1.1.3 协议"></a>1.1.3 协议</h3><ul><li><strong>协议（protocol）</strong>定义了在两个或多个通信实体之间交换的<strong>报文格式和次序</strong>，以及报文发送和/或接收一条报文或其它事件所采取的动作。</li></ul><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><ul><li>因特网的边缘：端系统（=主机）</li><li>主机可以划分为客户和服务器两类</li><li>P2S模型<ul><li>客户端: 发送请求, 接受服务</li><li>服务器: 响应请求, 提供服务, 始终在线, 性能更强</li></ul></li><li>P2P模型<ul><li>无专用服务器, 每设备既是客户端也是服务器</li></ul></li></ul><h3 id="1-2-1-接入网"><a href="#1-2-1-接入网" class="headerlink" title="1.2.1 接入网"></a>1.2.1 接入网</h3><ul><li><strong>接入网</strong>：将端系统物理连接到其<strong>边缘路由器</strong>的网络<ul><li>边缘路由器：端系统到任何其他端系统的路径上的第一台路由器</li></ul></li><li>家庭接入：DSL、电缆、FTTH、拨号和卫星（Maxwell更详细）<ul><li>宽带住宅接入：数字用户线（DSL）和电缆</li><li>DSL：用户的本地电话公司也是它的ISP；调制解调器使用现有电话线；FDM；下行信道比上行信道快；</li><li>电缆因特网接入：利用有线电视公司现有基础设施；电缆调制解调器；下行信道比上行信道快；重要特征：共享广播媒体</li><li>光纤到户（FTTH）：从本地中心局直接到家庭提供一条光纤路径；主动光纤网络AONv.s.被动光纤网络PON</li><li>卫星链路：超过1Mbps</li><li>拨号：电话线接入ISP，慢的一比（56kbps）</li></ul></li><li>企业(家庭)接入<ul><li>LAN<ul><li>介质: 双绞线</li><li>拓扑: 设备接入以太网交换机, 通过路由器接入因特网</li><li>速率: 10Mbps 100Mbps, 1Gbps, 10Gbps</li></ul></li><li>WiFi(802.11b/g/ac)<ul><li>11Mbps, 54Mbps, 100Mbps+</li><li>用户需位于接入点的几十米范围内</li></ul></li></ul></li><li>广域无线接入: 通信运营商<ul><li>应用与蜂窝移动电话相同的无线基础设施，蜂窝网提供商运营的基站</li><li>与WiFi的不同：用户仅需要距离基站数万米内</li><li>3G: 1Mbps</li><li>4G LTE（长期演进） / WiMAX(淘汰): 10Mbps+</li><li>5G: 20Gbps?</li></ul></li></ul><h3 id="1-2-2-物理媒体"><a href="#1-2-2-物理媒体" class="headerlink" title="1.2.2 物理媒体"></a>1.2.2 物理媒体</h3><ul><li><strong>物理媒体（physical medium）</strong>传播电磁波或光脉冲来发送比特。</li><li>分为两类：导引型媒体和非导引型媒体</li><li>导引型媒体：电波沿固体媒体前行，如光缆、双绞铜线（最便宜且使用最为普遍）或同轴电缆（导引型共享媒体）</li><li>非导引型媒体：在空气或外层空间中传播，如无线局域网或数字卫星频道。陆地无线电信道、卫星无线电信道。</li></ul><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><ul><li>网络核心：由互联因特网端系统的分组交换机和链路构成的网状网络。</li><li>分组以等于该链路最大传输速率的速度传输通过通信链路。若某源端系统或分组交换机经过一条链路发送一个L比特的分组，链路的传输速率为R比特/秒，则传输该分组的时间为L/R秒。<ul><li><strong>分组交换</strong>：多数分组交换机在链路的输入端使用<strong>存储转发传输（store-and-forward transmission）</strong>机制。在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。通过由$N$条速率均为$R$的链路组成的路径（即从源到目的地有$N-1$台路由器），从源到目的地发送一个分组，端到端时延为$$d_{端到端}=N\frac{L}{R}$$</li><li>排队时延和分组丢失：对于每条相连的链路，分组交换机具有一个输出缓存，用于存储路由器准备发往那条链路的分组。除了存储转发时延，分组还要承受输出缓存的<strong>排队时延</strong>。因为缓存空间大小有限，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下，将出现<strong>分组丢失（丢包）（package lost）</strong>，到达的分组或已经排队的分组之一将被丢弃。</li><li>转发表和路由选择协议：每个端系统具有一个称为IP地址的地址。当源主机要向目的端系统发送一个分组时，源在该分组的首部中包含了目的地的IP地址。每台路由器具有一个<strong>转发表（forwarding table）</strong>，用于将目的地址映射成为输出链路。</li></ul></li><li>通过网络链路和交换机移动数据的两种基本方法：电路交换和分组交换。<ul><li>电路交换网络中，预留了端系统间通信沿路径所需要的资源（缓存、链路传输速率），而分组交换网络中不预留。当网络创建这种电路时，它也在连接期间在该网络链路上预留了恒定的传输速率，如此发送方能够以恒定速率向接收方传送数据。</li><li>链路中的电路通过频分复用FDM或时分复用TDM来实现。FDM中链路的频谱由跨越链路创建的所有连接所共享。在连接期间链路为每条连接专用一个频段，该频段的宽度称为带宽。对于一条TDM链路，时间被分为固定区间的帧，每帧被划分为固定数量的时隙。</li><li>分组交换不适合实时服务如电话和视频会议，因为它的端到端时延是可变而不可预测的。分组交换比电路交换有更好的带宽共享，比电路交换更简单，实现成本更低。</li><li><strong>对比</strong><ul><li>电路: 时延固定，恒定速率，没有拥塞；</li><li>分组: 时延不可预测, 共享带宽更高, 更简单有效成本低</li><li>电路预先分配, 分组按需分配</li></ul></li></ul></li></ul><h2 id="1-4-分组交换网中的时延、丢包和吞吐量"><a href="#1-4-分组交换网中的时延、丢包和吞吐量" class="headerlink" title="1.4 分组交换网中的时延、丢包和吞吐量"></a>1.4 分组交换网中的时延、丢包和吞吐量</h2><ul><li><strong>结点总时延 = 结点处理时延 + 排队时延 + 传输时延 + 传播时延</strong><ul><li>处理时延：检查分组首部和决定将该分组导向何处、检查比特级别的差错等所需要的时间。处理结束后，路由器将该分组引向通往路由器B链路之前的队列。</li><li>排队时延：分组在链路上等待传输，取决于先期到达的正在排队等待向链路传输的分组数量。</li><li><strong>传输时延</strong>：当该分组到达队首时，设L比特表示该分组的长度，用R bps表示从路由器A到路由器B的链路传输速率。传输时延是L/R。这是将所有分组的比特推向链路所需的时间。</li><li><strong>传播时延</strong>：一个比特从链路的起点到路由器B传播所需的时间。等于两台路由器之间的距离除以传播速率，即d/s。</li></ul></li><li>刻画排队时延可以用<strong>流量强度（traffic intensity）</strong>。设所有分组由L比特组成，a表示分组到达队列的平均速率，R表示传输速率即从队列中推出比特的速率。则流量强度为La/R。流量工程中有一条金科玉律：设计系统时流量强度不大于1，否则队列无穷增加。随着流量强度接近1，平均排队长度变得越来越长。见P28图1-18。</li><li>假定在源主机和目的主机之间有N-1台路由器，此时网络无阻塞，在每台路由器和源主机上的处理时延为$d_{proc}$，每台路由器和源主机的输出速率为$R$ bps，每条链路的传播时延为$d_{prop}$，则端到端时延为$$d_{end-end} = N(d_{proc} + d_{trans} + d_{prop})$$其中有$d_{trans} = L/R$。</li><li>从主机A到主机B跨越计算机网络传送一个大文件，在任何时间瞬间的瞬时吞吐量是主机B接收到该文件的速率。若该文件由F比特组成，主机B接收到所有F比特用了T秒，则文件传送的平均吞吐量为F/T。</li></ul><h2 id="1-5-协议层次及服务模型"><a href="#1-5-协议层次及服务模型" class="headerlink" title="1.5 协议层次及服务模型"></a>1.5 协议层次及服务模型</h2><ul><li><p>因特网协议栈层次：物理层、链路层、网络层、运输层、应用层。</p><ul><li><strong>应用层</strong>：网络应用程序及它们的应用层协议存留的地方。位于应用层的信息分组称为<strong>报文（message）</strong></li><li><strong>运输层</strong>：在应用程序端点之间传送应用层报文。运输层分组称为<strong>报文段（segment）</strong></li><li><strong>网络层</strong>：负责将称为<strong>数据报（datagram）</strong>的网络层分组从一台主机移动到另一台主机</li><li><strong>链路层</strong>：将分组从一个结点移动到下一个结点。在每个结点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一结点。下个结点，链路层将数据报上传给网络层。链路层分组称为<strong>帧（frame）</strong></li><li><strong>物理层</strong>：将帧中的一个个比特从一个结点移动到下一个结点。</li></ul></li><li><p><strong>OSI模型</strong>：应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。表示层：使通信的应用程序能够解释交换数据的含义。会话层：提供数据交换定界和同步功能，包括建立检查点和恢复方案的方法。</p></li><li>主机实现所有五个层次，链路层交换机实现第一层和第二层，路由器实现了一到三层。</li></ul><h2 id="1-6-面对攻击的网络"><a href="#1-6-面对攻击的网络" class="headerlink" title="1.6 面对攻击的网络"></a>1.6 面对攻击的网络</h2><ul><li>攻击个人电脑<ul><li>恶意软件<ul><li>大多数都是自我复制的</li><li><strong>病毒</strong>: 需要某种形式的用户交互来感染用户设备</li><li><strong>蠕虫</strong>: 无需任何明显用户交互就能进入设备</li><li><strong>木马</strong>: 伪装成无害程序, 吸引用户点击</li><li>后门: 绕过授权验证</li><li>广告软件: 访问弹出广告</li><li>间谍软件: 收集用户的输入, 记录用户活动</li></ul></li></ul></li><li>攻击服务器和网络基础设施<ul><li><strong>拒绝服务攻击DoS</strong><ul><li>使得服务不能由合法用户使用</li><li>弱点攻击: 针对易受攻击的程序或操作系统, 引发停止运行或崩溃</li><li>带宽洪泛: 大量发送分组到目标, 使链路拥塞</li><li>连接洪泛: 创建大量半开或全开的TCP连接, 耗尽资源</li></ul></li><li><strong>分布式DoS(DDoS)</strong><ul><li>攻击者控制多个源</li><li>僵尸网路: 攻击者用恶意软件控制大量计算机, 作为DDoS的源头等</li></ul></li></ul></li><li>嗅探分组<ul><li>分组嗅探器: 记录每个流经的分组副本的被动接收机</li><li>防范: 加密</li></ul></li><li>伪装<ul><li>IP欺骗: 将具有虚假源地址的分组注入因特网</li><li>重放攻击</li><li>中间人攻击</li><li>连接劫持</li><li>解决方案: 加密, 数字签名, MAC</li></ul></li></ul><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h1 id="Ch3-运输层"><a href="#Ch3-运输层" class="headerlink" title="Ch3 运输层"></a>Ch3 运输层</h1><p>运输层为运行在不同主机上的应用程序之间提供了<strong>逻辑通信</strong>功能。通过逻辑通信，运行不同进程的主机好像直接相连一样。<br>应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些报文的物理基础设施的细节。</p><p>运输层只工作在端系统中。在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（即网络层）。<br>运输层能够提供的服务常常受制于底层网络协议的服务模型（带宽时延等），但底层网络协议不可靠、非机密性的情况下，运输层也能提供可靠性和机密性。</p><p>UDP和TCP最基本的责任是：将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。<br>将主机间交付扩展到进程间交付被称为运输层的<strong>多路复用</strong>与<strong>多路分解</strong><br>网络层：主机$\Leftrightarrow$主机<br>运输层：进程$\Leftrightarrow$进程</p><h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><p>进程使用套接字作为与网络交互数据的门户，运输层将数据交付给套接字。<br>每个套接字有唯一标识符，标识符格式取决于它是UDP还是TCP套接字。</p><p>每个运输层报文段中具有几个字段。<br><strong>多路分解</strong>：（拆包）将运输层报文段中的数据交付到正确的套接字<br><strong>多路复用</strong>：（打包）从源主机的不同套接字中收集数据块，并为每个数据块封上首部信息从而生成报文段，然后将报文段传递到网络层</p><p>套接字要有唯一标识符、每个报文段有特殊字段来只是该报文段所要交付到的套接字，特殊字段即<strong>源端口号字段&amp;目的端口号字段</strong></p><p>端口号</p><ul><li>16比特数，大小在0~65535</li><li>0~1023称为<strong>周知端口号</strong>，保留给注入HTTP（80）和FTP（21）之类的周知应用层协议</li><li>开发新应用程序时必须为其分配一个端口号</li></ul><h3 id="UDP的多路复用与多路分解"><a href="#UDP的多路复用与多路分解" class="headerlink" title="UDP的多路复用与多路分解"></a>UDP的多路复用与多路分解</h3><p>创建套接字时，端口号有两种产生方式：</p><ul><li>运输层自动为套接字分配一个端口号，从1024~65535内选择一个当前未被该主机中任何其他UDP端口使用的号</li><li>通过套接字<code>bind()</code>(Python)方法为这个UDP套接字关联一个特定的端口号<br>通常应用程序自动，服务器手动</li></ul><p>一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号。<br>因此只要两个UDP报文段具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。</p><p>源端口号用于接收方发回给发送方</p><h3 id="TCP的多路复用与多路分解"><a href="#TCP的多路复用与多路分解" class="headerlink" title="TCP的多路复用与多路分解"></a>TCP的多路复用与多路分解</h3><p>TCP套接字由四元组（源IP地址、源端口号、目的IP地址、目的端口号）来标识<br>与UDP不同，两个不同源IP和或源端口号的TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求</p><ul><li>TCP服务器应用程序有一个“欢迎套接字”，在某个特定端口上等待来自TCP客户的连接建立请求</li><li>TCP客户创建一个套接字并发送一个连接建立请求报文段</li><li>一条连接建立请求只不过是一个目的端口号为12000，TCP首部的特定“连接建立位”置位的TCP报文段，这个报文段也包含一个由客户选择的源端口号</li><li>当运行服务器进程的计算机的主机操作系统接收到具有目的端口号为12000的入连接请求报文段后，它就定位服务器进程，该进程正在端口号12000等待接收连接。该服务器进程会创建一个新的套接字。</li><li>新创建的报文设置好4个标识符，之后的报文段按照这4个标识符来定向。</li></ul><p>服务器主机支持很多并行的TCP套接字，每个套接字与一个进程相联系。</p><p>连接套接字与进程之间并非总是有着一一对应的关系（线程</p><h2 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h2><p>发送方和接收方的运输层实体之间没有握手——无连接的</p><p>e.g.DNS通常使用UDP应用层协议</p><h3 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h3><ul><li>关于发送什么数据以及何时发送的应用层控制更为精细。<ul><li>实时应用通常要求最小发送速率，不希望过分地延迟报文段的传送，且能容忍一些数据丢失</li></ul></li><li>无须连接建立，不会引入建立连接的时延</li><li>无连接状态，节约存储空间，可以支持更多活跃用户。</li><li>分组首部开销小，TCP20字节，UDP8自己</li></ul><h3 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h3><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/udp.png" alt=""></p><ul><li>源端口号/目的端口号（各16比特）</li><li>长度（16比特）：首部+数据的字节数</li><li>检验和</li><li>应用数据</li></ul><h3 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h3><p>实际包括一些IP首部字段，此处忽略</p><p>16比特字的反码运算，求和时遇到的任何溢出都被回卷（加到末尾去）<br>详见作业题CH6 P3</p><p>端到端原则：如果端到端传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测<br>“与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的”</p><p>不进行差错恢复，只能丢弃/交给应用程序并发出警告</p><h2 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h2><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>两个进程在发送数据之前必须先相互“握手”，即它们必须互相发送某些预备报文段，以建立确保数据传输的参数</p><p>TCP连接是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中，中间网络元素不会维持TCP连接状态。</p><ul><li>全双工服务（full-duplex service）：如果进程A与进程B存在一条TCP连接，则应用层数据可以在这两台主机间双向流动</li><li>点对点：单个发送方与单个接收方之间的连接</li></ul><p>发起连接的称为客户进程，另一个进程被称为服务器连接</p><ul><li>客户进程通过套接字（该进程之门）传递数据流，TCP将这些数据引导到该连接的<strong>发送缓存</strong>里</li><li>TCP会时不时从发送缓存里取出一块数据，并将数据传递到网络层<ul><li>TCP可放入报文段的最大数据数量受限于<strong>最大报文段长度</strong>(MSS)</li><li>MSS通常根据最初确定的由本地发送主机的最大链路层帧长度（最大传输单元MTU）来设置</li><li>MSS要保证一个TCP报文段+TCP/IP首部长度（通常40字节）小于等于单个链路层帧长度</li><li>MSS指报文段里<strong>应用层数据</strong>的最大长度，不包括首部</li></ul></li><li>TCP在另一端接收到报文段后，该报文段的数据就被放入该TCP连接的接收缓存中</li></ul><p>TCP连接组成包括：两台主机上的缓存、变量与进程连接的套接字</p><h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/tcp.png" alt=""></p><ul><li>源端口号和目的端口号（各16比特）</li><li>序号和确认号（各32比特）：用来实现可靠数据传输服务</li><li>接收窗口字段（16比特）：用于流量控制，表示接收方 愿意接收的字节数量</li><li>首部长度字段（4比特）：指示了以32比特为单位的TCP首部长度。TCP首部长度可变，但通常是20字节。</li><li>标志字段（6比特）：一些flag<ul><li>ACK：用于指示确认字段中的值是有效的</li><li>RST、SYN、FIN：用于连接的建立和拆除</li><li>CER、ECE：明确拥塞通告中使用</li><li>PSH：指示接收方应该立即将数据交给上层</li><li>URG：指示报文段里存在着被发送端的上层实体置为“紧急的数据”，紧急数据指针指出紧急数据的最后一个字节。当紧急数据存在并给出紧急数据指针时，TCP必须通知接收端的上层实体。</li></ul></li><li>因特网检验和（16比特）</li><li>可选与变长的选项字段：用于发送方与接收方协商MSS，或在高速网络环境下用作窗口调节因子</li></ul><h4 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h4><p>TCP把数据看成无结构的、有序的字节流。一个报文段的序号是该报文段首字节的字节流编号。</p><p>主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。</p><p>TCP只确认流中至第一个丢失字节为止的字节，这个称为提供<strong>累计确认</strong>。    </p><p>主机在一条TCP连接中收到失序报文段视为UB。</p><p>一条TCP连接的双方均可随机地选择初始号。</p><p>和（16比特）</p><p>可选与变长的选项字段：用于发送方与接收方协商MSS，或在高速网络环境下用作窗口调节因子举例：Telnet的回显</p><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/telnet.png" alt=""></p><p>（解释见书p157)</p><p>对客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段，这种确认被称为是被<strong>捎带</strong>在服务器到客户的数据报文段中的。</p><h3 id="往返时间估计与超时"><a href="#往返时间估计与超时" class="headerlink" title="往返时间估计与超时"></a>往返时间估计与超时</h3><ul><li>报文段的样本RTT(SampleRTT)：从某报文段被发出大多数TCP仅在某个时刻做一次SampleRTT测量<ul><li>在任意时刻，仅为一个已发送但目前尚未被确认的报文段估计SampleRTT，从而产生一个接近每个RTT值的新SampleRTT</li><li>TCP绝不为已被重传的报文段计算SampleRTT，仅为传输一次的报文段测量</li></ul></li><li>EstimatedRTT：TCP维护的SampleRTT的均值，为了应对SampleRTT的波动<ul><li>一旦获得新的SampleRTT，更新公式为 $$\text{EstimatedRTT}=(1-\alpha)\cdot\text{EstimatedRTT}+\alpha\cdot\text{SampleRTT}$$，$\alpha$的推荐值为0.125(1/8)</li><li>EstimatedRTT是对SampleRTT的<strong>指数加权移动平均</strong>（EWMA，Exponential Weighted Moving Average），指一个给定的SampleRTT的权值在更新过程中呈指数型快速衰减</li></ul></li><li>DevRTT：RTT偏差，用于估算SampleRTT一般会偏离EstimatedRTT的程度<ul><li>计算公式为$$\text{DevRTT}=(1-\beta)\cdot\text{DevRTT}+\beta\cdot|\text{SampleRTT}-\text{EstimatedRTT}|$$，$\beta$的推荐取值为0.25</li></ul></li><li>超时间隔TimeoutInterval：EstimatedRTT加上一定余量，与SampleRTT的波动正相关<ul><li>计算公式为$$\text{TimeoutInterval}=\text{EstimatedRTT}+4\cdot\text{DevRTT}$$</li><li>推荐的TimeoutInterval的初始值为1s</li><li>当出现超时后，TimeoutIntetval将加倍，以免即将被确认的后继报文段过早出现超时。</li><li>只要收到报文段并更新EstimatedRTT，就更新TimeoutInterval</li></ul></li></ul><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>TCP的差错恢复机制是GBN和SR的混合体</p><p>发送方：switch(事件)</p><ul><li><p>从上面应用程序接收到数据</p><ul><li>生成具有序号NextSeqNum的TCP报文段</li><li>如果定时器没有运行，启动定时器</li><li>向IP传递报文段</li><li>NextSeqNum=NextSeqNum+length(data)</li></ul></li><li><p>定时器超时</p><ul><li>重传具有最小序号但仍未应答的报文段</li><li>超时间隔<s>超级</s>加倍</li><li>启动定时器</li></ul></li><li><p>收到ACK，ACK字段值为y</p><ul><li><p>如果 y&gt;SendBase，则该ACK是在确认一个或多个先前未确认的报文段</p><ul><li>更新SendBase</li><li>如果当前有未被确认的报文段，  重新启动定时器</li></ul></li><li><p>如果 y&lt;=SendBase，则该ACK是对已经确认的报文段的一个冗余ACK</p><ul><li>如果累计收到相同ACK值的3个冗余ACK（累计4个相同ACK），则重新发送具有序号y的报文段（快速重传）</li></ul></li></ul></li></ul><p>接收方：  <img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/tcp_rcv.png" alt=""></p><p>超时间隔加倍提供了一个形式受限的拥塞控制，因为定时器过期很可能是网络拥塞引起的。</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>冗余ACK：再次确认某个报文段的ACK</p><p>当TCP接收方接收到一个序号大于下一个所期望按序报文段的报文段时，就说明有报文段丢失，因此会产生一个冗余ACK对已经收到的最后一个按序字节数据进行重复确认。</p><p>如果发送方接收到对相同数据的3个冗余ACK，就将其视为一种指示，说明这个被确认了3次的报文段之后的报文段已经被丢失。发送方会进行<strong>快速重传</strong>，即在该报文段的定时器过期之前重传丢失的报文段。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>接收方如果读数据不够快，就会导致接收缓存溢出。TCP提供了<strong>流量控制服务</strong>以消除发送方使接收方缓存溢出的可能性。（区分流量控制与拥塞控制）</p><p>TCP发送方维护一个称为<strong>接收窗口</strong>的变量，指示接收方还有多少可用空间，需要满足</p><ul><li>$$\text{LastByteRcvd}-\text{LastByteRead}\le \text{RcvBuffer}$$</li><li>接收窗口长度用rwnd表示，$$\text{rwnd}=\text{RcvBuffer}-[\text{LastByteRcvd}-\text{LastByteRead}]$$</li><li>$$\text{LastByteSent}-\text{LastByteAcked}\le\text{rwnd}$$</li><li>人话：主机Ａ发送但未被确认的数据大小　不会超过　主机Ｂ接收缓存的剩余可用空间</li></ul><p>为了防止主机A被阻塞，当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存开始清空，并且确认报文里包含一个非0的rwnd值。</p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><h4 id="建立TCP连接：三次握手"><a href="#建立TCP连接：三次握手" class="headerlink" title="建立TCP连接：三次握手"></a>建立TCP连接：三次握手</h4><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/start_tcp.png" alt=""></p><ul><li>第一步：客户端的TCP向服务器的TCP发送一个<strong>SYN报文段</strong>。首部中SYN标志位被置为1。客户随机选择一个初始序号（client_isn），并将此序号放置于SYN报文段的序号字段。该报文段不包含应用层数据。</li><li>第二步：服务器主机收到该TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段（<strong>SYNACK报文段</strong>）。该报文段不包含应用层数据。SYN比特被置为1。首部确认号字段为client_isn+1。服务器选择自己的初始序号（server_isn），并将其放到序号字段中。</li><li>第三步：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机向服务器发送另一个报文段，将server_isn+1放到首部的确认字段，来对服务器的允许连接的报文段进行确认。连接已经建立了，所以SYN比特被置为0，且之后的每一个报文段的SYN比特都为0。该报文段可以携带应用层数据。</li></ul><h3 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h3><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/close_tcp.png" alt=""></p><ul><li>客户进程发出一个关闭连接命令，引起客户TCP向服务器进程发送一个特殊的TCP报文段。该报文段首部FIN比特被置为1。</li><li>服务器接收到该报文段后，向发送方回送一个ACK报文段。</li><li>然后，服务器发送自己的终止报文段，FIN置为1。</li><li>最后，客户对这个服务器的终止报文段进行确认。此时，两台主机上用于该连接的所有资源都被释放了。</li></ul><h4 id="TCP状态"><a href="#TCP状态" class="headerlink" title="TCP状态"></a>TCP状态</h4><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/tcp_client.png" style="zoom:70%;"></p><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/tcp_server.png" style="zoom:70%;"></p><p>如果一台主机接收到的一个TCP报文段端口号或源IP地址与该主机上进行中的套接字都不匹配，则该主机向源发送一个特殊重置报文段，RST标志被置为1。（“我没有那个报文段的套接字，请不要再发了。”）</p><h4 id="nmap端口扫描工具"><a href="#nmap端口扫描工具" class="headerlink" title="nmap端口扫描工具"></a>nmap端口扫描工具</h4><p>nmap对目标主机的某个端口发送一个特殊的TCP SYN数据报，有3种可能</p><ul><li>源主机从目标主机接收到一个TCP SYNACK报文段。这意味着目标主机上一个应用程序使用该TCP端口运行，nmap返回“打开”。</li><li>源主机从目标主机接收到一个TCP RST报文段。这意味着目标主机上没有一个应用程序使用该TCP端口运行，但至少发送向该端口的报文段没有被防火墙阻拦。</li><li>源什么也没有收到。防火墙GG。</li></ul><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>让每一个发送方根据所感知到的网络拥塞成都来限制其发送流量的速率。</p><p>发送方TCP跟踪一个<strong>拥塞窗口</strong>变量cwnd，它对一个TCP发送方能向网络中发送流量的速率进行了限制。</p><p>$$\text{LastByteSent}-\text{LastByteAcked}\le\min{\text{cwnd},\text{rwnd}}$$</p><p>发送方的速率大概是cwnd/RTT字节/秒。</p><p>丢包事件：出现超时，或收到来自接收方的3个冗余ACK。此时发送方认为出现了拥塞指示。</p><p>自计时：TCP使用收到的ACK（或计时）增大它的拥塞窗口长度。</p><h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p>具体看图</p><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/congestion_control.png" alt=""></p><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><ul><li>当一条TCP连接开始时，cwnd通常设为一个MSS的较小值，初始发送速率大约为MSS/RTT。</li><li>每当传输的报文段首次被确认，cwnd增加一个MSS（指数增长</li><li>结束方式<ul><li>当cwnd==ssthresh时，结束慢启动并转移到拥塞避免模式。cwnd最多只能取到ssthresh，即使不是2的幂次</li><li>超时丢包（拥塞）：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2</li><li>检测到3个冗余ACK：执行一次快速重传并进入快速恢复状态</li></ul></li></ul><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul><li>每个RTT只将cwnd的值增加MSS。一种通用实现方法：发送方无论何时收到一个新的确认，就将cwnd增加一个$\text{MSS}\frac{\text{MSS}}{\text{cwnd}}$字节。</li><li>结束方式<ul><li>超时：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2</li><li>3个冗余ACK：cwnd减半，对收到的3个冗余ACK再加上3个MSS；将ssthresh的值改为cwnd/2；进入快速恢复状态</li></ul></li></ul><h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><ul><li>对于引起TCP进入快速恢复状态的缺失报文段，对每个收到的冗余ACK，cwnd增加一个MSS</li><li>当最终对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态</li><li>超时：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2，进入慢启动状态</li></ul><p>忽略慢启动，TCP的拥塞控制：每个RTT内线性增加1MSS，出现3个冗余ACK时cwnd减半——加性增，乘性减（AIMD）</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>一条连接的平均吞吐量$$=\frac{0.75\times W}{\text{RTT}}$$</p><ul><li>$W$：丢包事件发生时的窗口长度</li><li>TCP的发送速率大约是$w/RTT$,$w$为窗口长度</li><li>TCP的传输速率在$W/(2\times\text{RTT})$和$W/\text{RTT}$之间线性变化</li></ul><p>考虑丢包率（$L$）和MSS，一条连接的平均吞吐量$$=\frac{1.22\times\text{MSS}}{\text{RTT}\sqrt{L}}$$</p><h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>如果每条连接都得到相同份额的带宽，则认为该拥塞控制机制是公平的。</p><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/fair.png" style="zoom:50%;"></p><p>实际情况下具有较小RTT的连接能够更快地抢到可用带宽。</p><p>UDP是无法无天的，并行TCP连接是“作弊”</p><h1 id="CH4-网络层：数据平面"><a href="#CH4-网络层：数据平面" class="headerlink" title="CH4 网络层：数据平面"></a>CH4 网络层：数据平面</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据平面：从输入链路向输出链路转发数据报<br>控制平面：协调本地的每个路由器的转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送</p><table><thead><tr><th style="text-align:center">转发</th><th style="text-align:center">路由选择</th></tr></thead><tbody><tr><td style="text-align:center">将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作</td><td style="text-align:center">分组从源到目的地所采取的端到端路径的网络范围</td></tr><tr><td style="text-align:center">时间尺度短(ns)</td><td style="text-align:center">时间尺度长(s)</td></tr><tr><td style="text-align:center">通常硬件实现</td><td style="text-align:center">通常软件实现</td></tr></tbody></table><p>路由选择算法决定插入该路由器转发表的内容</p><p>软件定义网络(SDN): 路由选择设备仅执行转发，远程控制器计算并分发转发表(软件实现)</p><p>网络服务模型：尽力而为服务</p><h2 id="路由工作原理"><a href="#路由工作原理" class="headerlink" title="路由工作原理"></a>路由工作原理</h2><p>假设：转发决定仅基于分组的目的地址，而非基于通用的分组首部字段</p><p>路由器组成部分：输入端口，交换结构、输出端口、路由选择处理器</p><h3 id="输入端口处理"><a href="#输入端口处理" class="headerlink" title="输入端口处理"></a>输入端口处理</h3><p>数据报-&gt;线路端接-&gt;数据链路处理(协议、拆封)-&gt;查找、转发、排队-&gt;交换结构</p><p>使用<strong>转发表</strong>查找输出端口，转发表由路由选择处理器计算和更新，从路由选择处理器经过独立总线复制到线路卡。使用每个输入端口的影子副本，转发决策能在每个输入端口本地做出，无须基于每个分组调用集中式路由选择处理器，避免集中式处理的瓶颈。</p><p>转发表：前缀匹配，最长前缀匹配规则</p><p>在某些设计中，一个分组可能会在进入交换结构时被暂时阻塞</p><p>查找外必须采取许多其他动作</p><ul><li>必须出现物理层和链路层处理</li><li>必须检查分组的版本号、检验以及寿命字段，并且重写后两个字段</li><li>必须更新用于网络管理的计数器</li></ul><p><strong>“匹配加动作”</strong></p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><ul><li>经内存交换<ul><li>类似传统计算机</li><li>在CPU(路由选择处理器)的直接控制下完成</li><li>输入与输出端口的功能像传统I/O设备</li><li>分组到达输入端口-&gt;中断-&gt;分组被复制到处理器内存-&gt;CPU提取目的地址，在转发表中找到适当的输出端口-&gt;CPU将分组复制到输出端口的缓存中</li><li>若内存带宽为$B$个分组/秒，则总的转发吞吐量必然小于$B/2$</li><li>不能同时转发两个分组</li></ul></li><li>经总线交换<ul><li>输入端口经共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预</li><li>输入端口为分组预先计划一个交换机内部标签(首部)，指示本地输出端口-&gt;分组能被所有输出端口收到，但只有标签匹配的端口才能保存分组-&gt;标签在输出端口被去除</li><li>一次只有一个分组能跨越总线，因此多个分组同时到达路由器时，除了一个分组外其他都必须等待</li></ul></li><li>经互联网络交换<ul><li>纵横式交换机：$2N$条总线，连接$N$个输入端口和$N$个输出端口</li><li>交缠点通过交换结构控制器实现开启闭合</li><li>分组到达输入端口-&gt;交叉点-&gt;输出端口</li><li>非阻塞：能够并行转发多个分组</li></ul></li><li>多级交换元素</li></ul><h3 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h3><p>交换结构-&gt;排队(缓存管理)-&gt;数据链路处理(协议，封装)-&gt;线路端接-&gt;</p><p>###　排队</p><p>丢包：排队导致路由器的缓存空间耗尽</p><ul><li>输入排队<ul><li>线路前部(HOL)阻塞：在一个输入队列中排队的分组必须等待通过交换结构发送(即使输出端口是空闲的)，因为它被位于线路前部的另一个分组所阻塞 – 对纵横式交换结构而言</li></ul></li><li>输出排队<ul><li>主动队列管理：在缓存填满之前丢弃一个分组（或在首部加上标记），可以向发送方提供一个拥塞信号</li><li>缓存数量$B$与平均往返时延$RTT$、链路容量$C$、TCP流$N$的关系：$B=RTT\cdot C$, ($N$较大时)$B=RTT\cdot C/\sqrt{N}$</li></ul></li></ul><h3 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h3><ul><li>FIFO</li><li>优先权排队<ul><li>有多个优先权类，分开排队</li><li>每次选择非空的最高优先权类队列中的分组进行传输</li><li>非抢占式优先权排队：一旦分组开始传输就不能打断</li></ul></li><li>循环排队<ul><li>没有服务优先权，循环调度器在类之间轮流提供服务</li><li>保持工作排队规则：在有分组排队等待传输时不允许链路保持空闲–当寻找给定类的分组但没有找到时立即检查下一个类</li></ul></li><li>加权公平排队(WFQ)<ul><li>循环方式</li><li>每个类在任何时间间隔都可能收到不同数量的服务，每个类$i$被分配一个权$w_i$</li><li>第$i$类 将确保接收到的服务部分等于$w_i/(\sum w_i)$</li><li>最坏情况下第$i$类也能分得上述那么多带宽</li></ul></li></ul><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h3><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/ipv4.png" alt=""></p><ul><li>版本号：4比特，规定了数据报的IP协议版本，不同IP版本使用不同的数据报格式。</li><li>首部长度：4比特，IPv4数据报包含可变数量的选项，所以需要确定首部长度。大多数IP数据报不包含选项，所以一般具有20字节的首部。</li><li>服务类型(TOS)：8比特，使不同类型的IP数据报能相互区别开来。</li><li>数据报长度：16比特，IP数据报首部+数据的总长度，单位字节。理论最大长度为65535字节，但实际上很少有超过1500的。这个长度使得IP数据报能容纳最大长度以太网帧的载荷字段。</li><li>标识、标志、片偏移：与IP分片有关。</li><li>寿命(TTL)：确保数据报不会永远（如由于长时间的路由选择环路）在网络中循环。每当一台路由器处理时该字段的值-1，为0时自动丢弃。</li><li>协议：仅当到达最终目的地时才会有用，指示了IP数据报需要交给哪个特定的运输层协议。协议号是将网络层与运输层绑定到一起的黏合剂。（端口号是将运输层和应用层绑定到一起的黏合剂）</li><li>首部检验和：首部中的每两个字节当成一个数，用反码算术求和。每台路由器上必须重新计算检验和并再次存放到远处，因为TTL字段以及可能的选项字段会改变。【为什么TCP/IP都执行差错检测？–因为TCP和IP可以分别运行在不同的协议栈上</li><li>源和目的地IP地址：源主机通过DNS查找来决定目的地址。</li><li>选项：允许IP首部被扩展，很少使用。</li><li>数据(有效载荷)：大多数时候承载运输层报文，也可承载其他类型的数据,e.g.ICMP报文</li></ul><p>20字节IP首部+20字节TCP首部=40字节数据报首部</p><h3 id="数据报分片"><a href="#数据报分片" class="headerlink" title="数据报分片"></a>数据报分片</h3><p>原因：发送方与目的地路径上的每段链路可能使用不同的链路层协议<br>最大传送单元(MTU)：一个链路层帧能承载的最大数据量<br>每个较小的数据报称为片(fragment)</p><ul><li>发送主机将发送的每个数据报的标识号+1</li><li>路由器对数据报分片时，每个片具有初始数据报的源地址、目的地址和标识号</li><li>目的地主机能够检查数据报的标识号以确定哪些数据报实际上是同一较大数据报的片</li><li>IP是不可靠服务–初始数据报的最后一篇标志比特为0，其他片为1</li><li>为了让目的主机确定是否丢了一个片且按正确顺序组装片，使用偏移字段制定该片应该放在初始IP数据报的哪个位置</li></ul><h3 id="编址"><a href="#编址" class="headerlink" title="编址"></a>编址</h3><p>一台主机通常只有一条链路连接到网络，主机与物理链路之间的边界叫作<strong>接口</strong>。<br>路由必须拥有多条链路与之相连接，路由器与它任意一条链路之间的边界也叫作<strong>接口</strong>。<br>一个IP地址与一个接口相关联。</p><p>IP地址长32比特，采用点分十进制记法书写<br>格式：$a.b.c.d/x$</p><ul><li>子网掩码：32位中前$x$比特全取1</li><li>最高$x$比特构成了网络部分，也称<strong>前缀</strong></li><li>组织内部的设备的IP共享相同的前缀</li><li>减少了子网外路由器中转发表的长度</li></ul><p>子网：分开主机和路由器的每个接口，产生几个隔离的网络孤岛，使用接口端接这些隔离的网络的端点。这些隔离的网络中的每一个都叫作一个子网。<br>在给定子网上的所有设备都具有相同的子网地址。<br>因特网地址的分配策略称为<strong>无类别域间路由选择</strong>(CIDR, Classless Interdomain Routing)<br>寻址：<strong>最长前缀匹配</strong>，选择与目的地址相匹配的最长地址前缀<br>IP广播地址：255.255.255.255，当报文的目的地址是广播地址时会被交付给同一个网络中的所有主机，路由器也会有选择地向临近的子网转发该报文</p><h3 id="获取一块地址"><a href="#获取一块地址" class="headerlink" title="获取一块地址"></a>获取一块地址</h3><p>ISP从自己的大地址块中提供一些地址给组织<br>IP地址由因特网名字和编号分配机构(ICANN)管理，ICANN还管理DNS根服务器</p><h3 id="获取主机地址：DHCP"><a href="#获取主机地址：DHCP" class="headerlink" title="获取主机地址：DHCP"></a>获取主机地址：DHCP</h3><ul><li>动态主机配置协议(DHCP)允许主机获取一个IP地址，还允许主机得知子网掩码、第一跳路由器地址(默认网关)、本地DNS服务器的地址</li><li>即插即用协议/零配置协议</li><li>客户-服务器协议<ul><li>每个子网将具有一台DHCP服务器</li><li>如果某子网中没有DHCP服务器，则需要一个DHCP中继代理（通常是一台路由器），这个代理用于知道该网络的DHCP服务器的地址</li></ul></li></ul><h4 id="DHCP协议4步"><a href="#DHCP协议4步" class="headerlink" title="DHCP协议4步"></a>DHCP协议4步</h4><ul><li>DHCP服务器发现<ul><li>使用<strong>DHCP发现报文</strong></li><li>源地址：0.0.0.0(“本主机”)，目的地址：255.255.255.255(广播地址)</li><li>用于一个新到达的主机发现一个要与其交互的DHCP服务器</li></ul></li><li>DHCP服务提供<ul><li>DHCP服务器收到DHCP发现报文后对客户做出响应</li><li>使用<strong>DHCP提供报文</strong>，包含发现报文的事物ID、向客户推荐的IP地址、网络掩码、IP地址租用期(即IP地址的有效时间量，通常为几小时或几天)</li><li>源地址：自己的IP地址，目的地址：255.255.255.255(广播地址)</li><li>子网中可能存在多个DHCP服务器，客户需要选择一个</li></ul></li><li>DHCP请求<ul><li>客户向选中的服务器提供<strong>DHCP请求报文</strong>进行响应，回显配置的参数</li><li>源地址：0.0.0.0.，目的地址:255.255.255.255</li></ul></li><li>DHCP ACK<ul><li>服务器用<strong>DHCP ACK报文</strong>对DHCP请求报文进行响应，证实所要求的参数</li><li>源地址：DHCP服务器自己的地址，目的地址:255.255.255.255</li><li>客户收到DHCP ACK后交互完成</li></ul></li></ul><p>不能维持与远程应用之间的TCP连接</p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换(NAT)"></a>网络地址转换(NAT)</h2><ul><li>NAT使能路由器<ul><li>4个接口具有相同的网络地址10.0.0/24</li><li>地址空间10.0.0.0/8是在RFC 198中保留的三部分IP地址空间之一，用于家庭网络等专用网络或具有专用地址的地域，仅在给定的网络中才有意义</li></ul></li><li>NAT使能路由器对外界的行为如同一个具有单一IP地址的单一设备<ul><li>所有流向外界/进入家庭的报文都拥有同一个源/目的IP地址</li><li>NAT使能路由器对外界隐藏了家庭网络的细节</li></ul></li><li>NAT转化表<ul><li>NAT收到家庭主机发送向外界的数据报后，为其生成一个新的源端口号，将源IP替代为其广域网一侧接口的IP地址，且将源端口号替换为新生成的端口号</li><li>端口号字段16字节，NAT协议可支持超过60000个并行使用路由器广域网一侧单个IP地址的连接</li><li>路由器中的NAT在其NAT转换表中增加一个表项，记录WAN端和LAN段IP地址及端口的对应关系</li></ul></li></ul><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h3 id="数据报格式-1"><a href="#数据报格式-1" class="headerlink" title="数据报格式"></a>数据报格式</h3><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/ipv6.png" alt=""></p><p>定长<strong>40字节(320比特)</strong>首部</p><ul><li>版本(4比特)：标识IP版本号，IPv6将其设置为6<ul><li>设置为4不能得到合法的IPv4数据报</li></ul></li><li>流量类型(8比特)：与IPv4的TOS类似，使不同类型的IP数据报能相互区别开来</li><li>流标签(20比特)：标识一条数据报的流<ul><li>对一条流中的某些数据报给出优先权</li><li>也能够用来对来自某些应用的数据报给出更高的优先权</li></ul></li><li><p>有效载荷长度(16比特无符号整数)：定长40字节数据报首部后的字节数量</p></li><li><p>下一个首部(8比特)：表示数据报中的内容要交付给哪个协议(e.g.TCP or UDP)，取值同IPv4</p></li><li>跳限制(8比特)：相当于IPv4的TTL，转发的每台路由器对该字段的值-1，到0自动丢弃</li><li>源地址和目的地址(各128比特)</li><li>数据</li></ul><h3 id="相对IPv4的变化"><a href="#相对IPv4的变化" class="headerlink" title="相对IPv4的变化"></a>相对IPv4的变化</h3><p>新增了：</p><ul><li>扩大的地址容量<ul><li>地址长度：32 bits -&gt; 128 bits</li><li>引入任播地址：可以使数据报交付给一组主机中的任意一个</li></ul></li><li>流定义</li></ul><p>删去了：</p><ul><li>分片/重新组装：因为太耗时了<ul><li>如果路由器收到的IPv6数据报太大不能转发到出链路上的话，路由器只需丢弃该数据报，并向发送方发回一个“分组太大”的ICMP差错报文</li><li>大大加快了IP转发速度</li></ul></li><li>首部检验和：因为太耗时了，而且多余</li><li>选项：不属于首部的一部分，但没有消失，可能出现在“下一个首部”指出的位置上<ul><li>使得IPv6的首部是定长的</li></ul></li></ul><h3 id="IPv4到IPv6的迁移"><a href="#IPv4到IPv6的迁移" class="headerlink" title="IPv4到IPv6的迁移"></a>IPv4到IPv6的迁移</h3><p><strong>建隧道</strong></p><p><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/tunnel.png" alt=""></p><p>隧道：两台IPv6路由器之间的中间IPv4路由器集合</p><ul><li>隧道发送端的IPv6节点(B)将整个IPv6数据报放到一个IPv4数据报中,将源地址设为自己，目的地址设为隧道接收端的IPv6节点(E)</li><li>中间的IPv4路由器照常转发IPv4数据报</li><li>隧道接收端通过观察IPv4数据报中<strong>协议号字段</strong>是<strong>41</strong>确定该数据报含有一个IPv6数据报，并将其取出</li></ul><h1 id="CH5-网络层：控制平面"><a href="#CH5-网络层：控制平面" class="headerlink" title="CH5 网络层：控制平面"></a>CH5 网络层：控制平面</h1><h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><p>目的：从发送方到接收方的过程中确定一条通过路由器网络的好的路径(等价于路由)</p><ul><li><ul><li>集中式路由选择算法：具有全局状态信息的算法，必须知道每条链路的开销，常被称为链路状态(LS)算法</li><li>分布式路由选择算法：以迭代、分布式的方式计算最小开销路径，每个节点只有与其相邻节点的信息</li></ul></li><li><ul><li>静态路由选择算法：路由随时间变化缓慢</li><li>动态路由选择算法：随着网络流量负载或拓扑发生变化而改变路由选择路径</li></ul></li><li><ul><li>负载敏感算法：链路开销会动态地变化反映出底层链路的当前拥塞水平</li><li>负载迟钝算法</li></ul></li></ul><h3 id="链路状态路由选择算法"><a href="#链路状态路由选择算法" class="headerlink" title="链路状态路由选择算法"></a>链路状态路由选择算法</h3><p>输入：让每个节点向网络中所有其他节点广播链路状态分组——链路状态广播算法<br><strong>Dijksra算法</strong><br><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/ls.png" alt=""><br>最差情况下复杂性为$O(n^2)$</p><p>问题：链路开销非对称，即链路开销对应于承载的流量<br>会出现振荡：所有的流量都被导向同一个方向<br>路由器的自同步：即使它们在初始时以同一周期但在不同时刻执行算法，算法执行时机最终会在路由器上变为同步并保持<br>解决方案：让每台路由器发送链路通告的时间随机化</p><h3 id="距离向量-DV-路由选择算法"><a href="#距离向量-DV-路由选择算法" class="headerlink" title="距离向量(DV)路由选择算法"></a>距离向量(DV)路由选择算法</h3><p>分布式的、迭代的（能自我终止）、异步的<br>距离向量：$\bf{D}_x$$=\left[D_x(x), D_x(y), D_x(z) \right]$<br><strong>Bellman-Ford算法</strong><br>Bellman-Ford方程：$d_x(y)=\min_v{c(x,v)+d_v(y)}$<br><img src="/2019/12/29/network-review/home/mengzelev/Documents/blog/blog/source/_posts/network-notes/dv.png" alt=""></p><p>每个节点等待来自任何邻居的更新，当接收到一个更新时计算它的新距离向量并向它的邻居分布其新距离向量</p><p>当一个节点检测到从它自己到邻居的链路开销发生变化时，它就更新其距离向量——可能会出现路由选择环路：y通过z到x，同时z通过y到x<br>因为开销改变的链路在其他节点的距离表中的信息仍没有被抹去</p><p>链路开销的增加会导致坏消息传播得很慢——无穷计数问题</p><p>毒性逆转：撒谎设置$D_z(x)=\infty$，这样y就永远不会试图经由z路由选择到x<br>Wiki: In computer networking, split-horizon route advertisement is a method of preventing routing loops in distance-vector routing protocols by prohibiting a router from advertising a route back onto the interface from which it was learned.(从哪里学习来的，就拒绝发回到哪里去)<br>依然无法解决无穷计数问题</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table><thead><tr><th style="text-align:center">维度</th><th style="text-align:center">LS</th><th style="text-align:center">DV</th></tr></thead><tbody><tr><td style="text-align:center">报文复杂性</td><td style="text-align:center">发送$O(\</td><td style="text-align:center">NE\</td><td>)$个报文，每次改变向所有节点发送新开销</td><td>每次迭代邻居间交换报文</td></tr><tr><td style="text-align:center">收敛速度</td><td style="text-align:center">还行(?)，多项式时间</td><td style="text-align:center">收敛较慢，且会出现路由选择环路</td></tr><tr><td style="text-align:center">健壮性</td><td style="text-align:center">路由器某种程度上分离</td><td style="text-align:center">一个不正确节点的计算值会扩散到整个网络</td></tr></tbody></table><h2 id="因特网自治系统内部的路由选择：OSPF"><a href="#因特网自治系统内部的路由选择：OSPF" class="headerlink" title="因特网自治系统内部的路由选择：OSPF"></a>因特网自治系统内部的路由选择：OSPF</h2><p>规模(无穷计数)和管理自治(ISP按自己意愿运行路由器)问题——解决：自治系统(AS)<br>每个AS由一组通常处在相同管理控制下的路由器组成<br>一个自治系统由其全局唯一的AS号(ASN)所标识，ASN由ICANN区域注册机构发放</p><p>OSPF：开放最短路优先，Open Shortest Path First<br>开放：公众可用<br>LS协议，使用洪泛链路状态信息和Dijkstra最短路径算法<br>各条链路开销为网络管理员手动配置</p><ul><li>路由器向AS内所有其他路由器广播路由选择信息</li><li>每当一条链路状态发生变化时，路由器就会广播链路状态信息；即使未变化，也会至少每隔30min一次广播链路状态——增加鲁棒性</li><li>OSPF报文由IP承载，对上层协议的值为89，因此OSPF协议必须自己实现诸如可靠报文传输、链路状态广播等功能。</li><li>还要检查链路正在运行(通过向邻居发送HELLO报文)，并允许OSPF路由器获得相邻路由器的网络范围链路状态的数据库</li></ul><p>优点：</p><ul><li>安全：能鉴别和加密(简单的orMD5)</li><li>支持选择多条相同开销的路径</li><li>对单播与多播路由选择的综合支持</li><li>支持在单个AS中的层次结构<ul><li>区域边界路由器：为流向该区域以外的分组提供路由选择</li><li>主干区域：为该AS中其他区域之间的流量提供路由选择，所有区域边界路由器+一些非边界路由器</li></ul></li></ul><h2 id="AS间的路由选择协议：BGP"><a href="#AS间的路由选择协议：BGP" class="headerlink" title="AS间的路由选择协议：BGP"></a>AS间的路由选择协议：BGP</h2><p>BGP：边界网关协议, Broder Gateway Protocol<br>分布式、异步<br>分组不是路由到特定地址，而是路由到CIDR化的前缀，每个前缀表示一个子网或一个子网的集合</p><p>BGP为每台路由器提供了一种完成以下任务的手段：</p><ul><li>从邻居AS获得前缀的可达性信息</li><li>确定到该前缀的“最好的”路由</li></ul><h3 id="通告BGP路由信息"><a href="#通告BGP路由信息" class="headerlink" title="通告BGP路由信息"></a>通告BGP路由信息</h3><p>对于每个AS，每台路由器要么是一台网关路由器，要么是一台内部路由器。<br>网关路由器：位于AS边缘，直接连接到在其他AS中的路由器<br>内部路由器：仅连接在它自己AS中的主机和路由器</p><p>每对路由器通过使用179端口的半永久TCP连接交换路由选择信息。<br>每条直线连接以及所有通过该连接发送的BGP报文，称为<strong>BGP连接</strong><br>跨越两个AS的BGP连接称为<strong>外部BGP连接</strong>(eBGP)<br>在相同AS中的两台路由器之间的BGP称为<strong>内部BGP连接</strong>(iBGP)<br>直接连接在不同AS中的网关路由器的每条链路通常有一条eBGP连接，在每个AS中的路由器之间还有多条iBGP连接，iBGP连接不总是与物理链路对应</p><p>前缀中包含一些BGP属性<br>前缀+其属性称为路由</p><ul><li>AS-PATH属性：包含了通告已经通过的AS的列表<ul><li>当一个前缀通过某AS时，该AS将其ASN加入AS-PATH的现有列表</li><li>BGP路由器还使用AS-PATH属性来检测和防止通告环路，如果一台路由器在路径列表中看到了包含它自己的AS，则它将拒绝该通告</li></ul></li><li>NEXT-HOP属性：AS-PATH起始路由器接口的IP地址（到达前缀$x$路径上的第一台路由器的地址</li></ul><h3 id="热土豆路由选择"><a href="#热土豆路由选择" class="headerlink" title="热土豆路由选择"></a>热土豆路由选择</h3><p><s>实际上明明是烫手山芋</s></p><p>从所有可能的路由中选择到开始该路由的NEXT-HOP路由器具有最小开销的路由<br>路由器尽可能快地将分组送出其AS，而不担心AS外部到目的地的余下部分的开销<br>对于在相同AS中的两台路由器，可能对相同前缀选择两条不同的AS路径</p><h3 id="路由选择算法-1"><a href="#路由选择算法-1" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p>输入：到某前缀的所有路由的集合</p><p>当有多条路由时，顺序调用以下消除规则：</p><ul><li>路由被指派一个<strong>本地偏好</strong>值属性。该属性为策略决定，取决于网管，高的被优先选择（可能会有多条）。</li><li>从余下的路由中选择具有<strong>最短AS-PATH</strong>的路由。如果这是唯一路由选择规则，使用DV算法决定路径，其中距离测度为AS跳的跳数。</li><li>从余下的路由中使用热土豆路由选择，即最靠近NEXT-HOP路由器的路由</li><li>如果仍留下多条路由，使用BGP标识符来选择路由</li></ul><h3 id="IP任播"><a href="#IP任播" class="headerlink" title="IP任播"></a>IP任播</h3><p>通常用于DNS中<br>DNS服务器为多台服务器指派相同的IP地址，并且使用标准的BGP从这些服务器来通告该IP地址。<br>当某台BGP路由器收到对于该IP地址的多个路由通告，它将这些通告处理为对相同的物理位置提供不同的路径。<br>当配置其路由表时，每台路由器将本地化地使用BGP路由选择算法来挑选到该IP地址的“最好的”路由。<br>无论客户位于何处，当想向DNS服务器的某个IP地址发送一个请求时，因特网路由器则向那个“最近的”服务器转发该请求分组，最近的服务器是有BGP路由选择算法所定义的。</p><h3 id="路由选择策略"><a href="#路由选择策略" class="headerlink" title="路由选择策略"></a>路由选择策略</h3><p>多宿接入ISP：经由两个不同的ISP连接到网络的其余部分的<br>经验法则：任何穿越某ISP主干网的流量必须是其源或目的（或两者）位于该ISP的某个客户网络中</p><h2 id="5-6-ICMP因特网控制报文协议"><a href="#5-6-ICMP因特网控制报文协议" class="headerlink" title="5.6 ICMP因特网控制报文协议"></a>5.6 ICMP因特网控制报文协议</h2><ul><li>ICMP报文<ul><li>用于主机和路由器彼此沟通网络层信息</li><li>承载在IP分组中</li><li>类型字段+编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8个字节</li></ul></li><li>ping<ul><li>发送一个ICMP类型8编码0（回显请求）到指定主机</li><li>目的主机发回一个类型0编码0的ICMP回显应答</li></ul></li><li>traceroute<ul><li>跟踪从一台主机到世界上任意一台主机之间的路由</li><li>源主机发送一些列数据报，每个都携带一个具有不可达UDP端口号的UDP报文段，且第$n$个数据报的TTL为$n$</li><li>第$n$台路由器丢弃该数据报并发送一个ICMP告警报文（类型11编码0）给源主机</li><li>目的主机会向源主机发送一个端口不可达的ICMP报文（类型3编码3），源主机收到时就知道不需要再发送另外的探测分组。</li></ul></li></ul><h1 id="Ch6-链路层和局域网"><a href="#Ch6-链路层和局域网" class="headerlink" title="Ch6 链路层和局域网"></a>Ch6 链路层和局域网</h1><h2 id="6-3-多路访问链路和协议"><a href="#6-3-多路访问链路和协议" class="headerlink" title="6.3 多路访问链路和协议"></a>6.3 多路访问链路和协议</h2><ul><li>点对点链路：单个发送方和单个接收方</li><li>广播链路：多个发送方和多个接收方，连接到相同、单一、共享的信道上</li><li>多路访问协议：节点通过这些协议来规范它们在共享的广播信道上的传输行为<ul><li>信道划分协议、随机接入协议、轮流协议</li></ul></li><li>碰撞：节点同时收到多个帧</li><li>多路访问协议特性：<ul><li>当仅有一个节点发送数据时，该节点具有$R$ bps的吞吐量</li><li>当有$M$个节点发送数据时，每个节点的平均传输速率为$R/M$ bps</li><li>协议是<strong>分散</strong>的：不会因为某主节点故障而使整个系统崩溃</li><li>协议是<strong>简单</strong>的，使实现不昂贵</li></ul></li></ul><h3 id="6-3-1-信道划分协议"><a href="#6-3-1-信道划分协议" class="headerlink" title="6.3.1 信道划分协议"></a>6.3.1 信道划分协议</h3><ul><li><strong>时分多路复用（TDM）</strong><ul><li>将时间划分为时间帧，每个时间帧划分为$N$个时隙</li><li><strong>优点</strong>：消除碰撞；非常公平</li><li><strong>缺点</strong>：节点被限制于$R/N$的平均速率；节点必须总是等待它在传输系列中的轮次</li></ul></li><li><strong>频分多路复用（FDM）</strong><ul><li>将$R$bps信道划分为$N$个不同的频段，每个频段的带宽为$R/N$</li><li><strong>优点</strong>：避免碰撞；带宽公平划分</li><li><strong>缺点</strong>：限制一个节点的带宽；</li></ul></li><li>码分多址（CDMA）<ul><li>对每一个节点分配一种不同的代码</li><li>优点（特性）：不同节点能够同时传输，接收方仍能正确接收</li></ul></li></ul><h3 id="6-3-2-随机接入协议"><a href="#6-3-2-随机接入协议" class="headerlink" title="6.3.2 随机接入协议"></a>6.3.2 随机接入协议</h3><ul><li><p>一个传输节点总是以信道全部速率发送，有碰撞时等待一个随机时延后反复重发。</p></li><li><p><strong>时隙ALOHA</strong></p><ul><li>有新帧要发送时等在下一个时隙开始传输，发生碰撞则之后每个时隙以概率$p$重传</li><li>有ACK</li><li>假设：一个时隙=一帧的传输时间，节点只在时隙起点开始传输，节点同步，节点在时隙结束之前能检测到碰撞</li><li>优点：唯一活跃节点独享带宽；高度分散，每个节点独立决定重传时机（但是需要同步时隙）</li><li>缺点：有多个节点时，效率为$Np(1-p)^{N-1}$（$N\to\infty$时为$1/e$)</li><li>效率定义：当有大量活跃节点且每个节点总有大量的帧要发送时，长期运行中成功时隙（刚好只有一个节点传输的时隙）的份额</li></ul></li><li><p><strong>ALOHA</strong></p><ul><li>帧首次到达节点立刻传输；若发生碰撞立刻以概率$p$重传，如未重传则在接下来每一个帧传输时间以概率$p$重传</li><li>有ACK，非时隙、完全分散</li><li>一个给定节点成功传输一次的概率$p(1-p)^{2(N-1)}$，$N\to\infty$时为$1/2e$（完全分散的代价）</li></ul></li><li><p><strong>载波侦听多路访问（CSMA）</strong></p><ul><li>（说话之前先听）节点等待直到检测到一小段时间没有传输才开始传输</li><li>（如果与他人同时开始说话，停止说话）检测到另一个节点在传输干扰帧就停止传输</li><li><strong>端到端信道传播时延</strong>（信号从一个节点到另一个节点所花费的时间）是决定性能的<strong>关键</strong>；时延越大检测不到另一个节点开始传输的机会越大。</li></ul></li><li><p><strong>具有碰撞检测的载波侦听多路访问（CSMA/CD）</strong></p><ul><li><p>碰撞检测：如果检测到其他适配器的信号能量，停止传输，<strong>等待一个随机时间量</strong>后重新开始侦听信道空闲。</p></li><li><p>无ACK，不同步</p></li><li><p>二进制指数后退：经历了一连串$n$次碰撞后，随机选择整数$K\in[0, 2^n-1]$，以太网中一个节点等待的实际时间量为$512K$比特时间（发送512比特进入以太网所需时间的$K$倍），$n\le 10$。</p></li><li><p>$K$的选择集合随着碰撞次数呈指数增长，满足碰撞节点越多，时间间隔越长的需求。</p></li><li><p>不考虑近期过去的时间内可能已经发生的任何碰撞。</p></li><li><p>效率：大量节点大量帧，帧在信道中无碰撞地传输那部分时间在长期运行时间中所占份额。</p></li><li><p>效率近似为<br>$$<br>\frac{1}{1+5d_{prop}/d_{trans}}<br>$$</p></li><li>$d_{prop}$：信号能量在任意两个适配器中所占份额；$d_{trans}$：传输一个最大长度的以太网帧的时间</li><li>具体过程（By Maxwell）<ul><li>监听: 监听信道是否空闲, 空闲时才开始传输；<strong>传输前要等96比特时间（最小帧间隔）</strong></li><li>传输: 传输时也不断监听是否有其他结点的信号能量<ul><li>成功: 未发现其他能量, 认为发送成功</li></ul></li><li>失败: 发现其他能量, 立刻停止; <strong>发送48bit干扰信号</strong></li><li>等待(非持续): 等待一个随机时间, 回到”监听”重传</li><li>回退(p持续): 之后的时间当中以概率p重传</li><li>回退(1持续, 以太网): 使用二进制指数后退：经历过了$n$次碰撞, 就从$[0,\ldots,2^n-1]$中选一个$K$值, 等待$512K$个比特时间；$n$最大为10；最多尝试16次发送</li></ul></li><li>最小帧长: 检测冲突的时长不超过端到端传播时延的2倍, 取这一值为最小帧长（不然还没检测到碰撞一帧就发完了</li><li>ALOHA和CSMA具备特性一（独占信道），不具备特性二（平均信道）</li></ul></li></ul><h3 id="6-3-3-轮流协议"><a href="#6-3-3-轮流协议" class="headerlink" title="6.3.3 轮流协议"></a>6.3.3 轮流协议</h3><ul><li><strong>轮询协议</strong><ul><li>主节点循环轮询每个节点，告诉每个节点最多能够传输帧的数量（主节点能观察信道上是否缺乏信号来决定一个节点何时完成了帧的发送）</li><li>优点：消除碰撞和空时隙，效率高</li><li>缺点：引入轮询时延（通知一个节点可以传输所需的时间），不满足特性一；不分散，主节点挂了全挂</li></ul></li><li><strong>令牌传递协议</strong><ul><li>没有主节点，一个称为令牌的小的特殊帧在节点间以某种固定次序交换</li><li>当一个节点收到令牌时，仅当它有一些帧要发送时，它持有令牌并发送最大数目的帧，发完后将令牌转发给下一个节点；没有帧要发送就立即将令牌转发给下一个节点。</li><li>优点：分散的，效率高</li><li>缺点：一个节点故障可能会使这个信道崩溃；一个节点忘了释放令牌就需要调用某些恢复步骤；令牌传播时延</li></ul></li></ul><h2 id="6-4-交换局域网"><a href="#6-4-交换局域网" class="headerlink" title="6.4 交换局域网"></a>6.4 交换局域网</h2><h3 id="6-4-1-链路层寻址和ARP"><a href="#6-4-1-链路层寻址和ARP" class="headerlink" title="6.4.1 链路层寻址和ARP"></a>6.4.1 链路层寻址和ARP</h3><ul><li><strong>MAC地址</strong><ul><li>每个适配器（网络接口）都具有链路层地址，即LAN地址、物理地址或MAC地址。（路由器有多个接口就有多个MAC地址）</li><li><strong>链路层交换机</strong>的任务：在主机与路由器之间承载数据报，因此<strong>不具有MAC地址</strong>，主机和路由器也不必明确地将帧寻址到其间的交换机</li><li>MAC地址通常为6字节，十六进制表示，e.g.MAC广播地址：FF-FF-FF-FF-FF-FF</li><li>扁平结构：每台适配器的MAC地址都不同，且不会因为在哪里而改变</li><li>发送适配器将MAC地址插入发送的帧；适配器接收到帧使检查是否与本机MAC地址匹配，不匹配则丢弃</li></ul></li><li><strong>地址解析协议</strong>：在网络层地址和链路层地址之间进行转换的协议<ul><li>主机中的ARP模块：取在<strong>相同子网</strong>上的任何IP地址作为输入，然后返回相应的MAC地址</li><li>每台主机和路由器都维护<strong>ARP表</strong>：包含IP地址到MAC地址的映射关系，每个表项都有寿命（TLL）</li><li>解析不在表中的地址：发送方广播<strong>ARP查询分组</strong>（广播帧）$\to$所有适配器检查自身IP地址，匹配者返回一个响应ARP分组（标准帧）$\to$查询方更新ARP表</li><li>ARP表即插即用，自动建立</li></ul></li><li><strong>发送数据报到子网外</strong><ul><li>主机获得的子网外IP的MAC地址是子网内路由器接口的MAC地址（直接发的数据报会到达数据报天国）</li><li>路由器在网络层查询转发表，将数据报转发到正确的接口，此时目的MAC地址是最终目的地的MAC地址</li></ul></li></ul><h3 id="6-4-2-以太网"><a href="#6-4-2-以太网" class="headerlink" title="6.4.2 以太网"></a>6.4.2 以太网</h3><ul><li><p><strong>集线器（hub）</strong>：物理层设备，当一个比特到达接口时重新生成该比特，并向其他所有接口传出去——采用星形拓扑的以太网也是广播局域网</p></li><li><p><strong>以太网帧结构</strong></p><ul><li><code>前同步码|目的地址|源地址|类型|数据|CRC</code></li><li><p>前同步码（8）：前7字节10101010用于唤醒接收适配器并同步接收方和发送方的时钟；最后一字节10101011，最后两比特警告接收适配器</p></li><li><p>目的地址（6）：目的地址是自己的MAC地址或广播地址就直接将数据字段内容传递给网络层；否则丢弃</p></li><li><p>源地址（6）</p></li><li><p>类型（2）：允许以太网复用多种网络层协议。</p></li><li><p>数据（46~1500）：承载IP数据报；最小长度46（不够就填充），最大1500（多了就分片）；网络层使用IP数据报首部中的长度字段除去填充部分。</p></li><li><p>CRC（4）：出错的帧直接丢弃</p></li><li><p>无连接服务：不需要握手</p></li><li><p>不可靠服务：无ACK和NACK——简单和便宜，数据报流可以有间隙</p></li></ul></li><li><p><strong>以太网技术</strong></p><ul><li>命名: [速率]BASE[距离 或 介质], T指铜双绞线, FX/SX/BX指光纤</li><li>10Mbps: 10BASE[%d], 距离, 使用同轴电缆</li><li>100Mbps: 100BASE-TX/T4/T2双绞线, -FX/SX/BX光纤</li><li>1000Mbps: 1000BASE-T等, 又名802.3z, 双绞线, 兼容旧标准, 点对点(交换机)信道全双工, 另有广播(集线器)</li><li>10Gbps: 10GBASE-T</li></ul></li></ul><h3 id="6-4-3-链路层交换机"><a href="#6-4-3-链路层交换机" class="headerlink" title="6.4.3 链路层交换机"></a><strong>6.4.3</strong> 链路层交换机</h3><ul><li>交换机对于子网中的主机和路由器是<strong>透明的</strong></li><li>交换机输出接口设有缓存</li><li><strong>交换机转发和过滤</strong><ul><li>过滤：决定帧转发到某个接口还是丢弃</li><li>转发：决定帧被导向哪个接口</li><li>交换机表（地址-接口-时间）</li><li>工作过程：（帧从接口$x$来）<ul><li>对于没有的表项，交换机向$x$之外所有接口广播</li><li>存在表项将目的地址与$x$对应，直接丢弃</li><li>存在正常的目的地址对应接口，放到对应输出缓存里</li></ul></li></ul></li><li><strong>自学习</strong><ul><li>交换机表初始为空</li><li>对于每个接口收到的每个入帧，存储（源地址-接口-当前时间）</li><li>在老化期后，交换机没有收到这个地址发来的帧就删除这个地址</li><li>即插即用、双工（同时发送和接收）</li></ul></li><li><strong>链路层交换机的性质（优点）</strong><ul><li>消除碰撞：绝不会在网段上同时传输多于一个帧，不浪费带宽；<strong>最大聚合带宽</strong>=所有接口速率之和</li><li>异质链路：不同链路能以不同速率运行在不同的媒体上</li><li>管理：能检查并断开异常适配器</li></ul></li><li><strong>交换机v.s.路由器</strong><ul><li>路由器网络层，交换机链路层</li><li>交换机<ul><li>优点：即插即用；相对高的分组过滤和转发速率；</li><li>缺点：交换网络活跃拓扑限制为一颗生成树（防止广播帧循环）；对广播风暴不提供保护措施</li></ul></li><li>路由器<ul><li>优点：网络寻址分层，分组不会循环（除非路由表配错了），不会限制于生成树；对链路层广播风暴提供防火墙保护</li><li>缺点：不即插即用；处理分组响应时间长；争论单词发音</li></ul></li></ul></li></ul><h3 id="网桥（From-ppt，-By-Maxwell）"><a href="#网桥（From-ppt，-By-Maxwell）" class="headerlink" title="网桥（From ppt， By Maxwell）"></a>网桥（From ppt， By Maxwell）</h3><ul><li>功能: 读取A网(总线)的所有帧, 在B(总线)上重发每个帧; B-&gt;A同理</li><li>特点: 不更改帧, 原样转发; 带缓存; 路由寻址能力(基于MAC, 只转发需要转发的帧)</li><li>协议体系<ul><li>层次: 数据链路层 - MAC层</li><li>链接模式<ol><li><code>局域网 - 网桥 - 局域网</code>, 原样转发</li><li><code>局域网 - 网桥 - [网络或链路] - 网桥 - 局域网</code>, 需要适当封装, 但原始MAC帧不修改</li></ol></li></ul></li><li>固定路由选择<ul><li>每对点均有一条选定的路由, 跳数最少, 仅在拓扑变化时改变(生成树算法)</li></ul></li><li>生成树方法<ul><li>帧转发<ul><li>x收到帧</li><li>检查目的地址: 若在某一端口的列表中, 且非阻塞, 发送; 不在任何列表, 则x除以外的端口全部转发</li></ul></li><li>地址探索: 同交换机<ul><li>收到帧, 则帧源地址MAC与此端口关联, 加入此端口数据库</li><li>数据库项带计时器, 超时删除</li></ul></li><li>最小生成树算法: Prim<ul><li>Prim算法流程<ul><li>选取起始点(根网桥), 加入集合S</li><li>对于S中所有点(网桥), 在他们所有邻居里面找离S中点最短的距离, 把这个邻居加入S, 这条边(网桥间的最短距离)加入生成树</li><li>直到所有点都加入S, 边集合构成生成树</li></ul></li><li>网桥阻塞规则<ul><li>选择根网桥: ID最小的网桥</li><li>为每个网桥选择root port: 到根网桥最低开销的端口</li><li>为每个LAN指定网桥: 拥有到根网桥最低开销路径的, 与这个LAN相连的网桥</li><li>Designated port: 这个指定网桥与这个LAN相连的端口</li><li>Designated port 和 root port 不阻塞, 别的都阻塞</li></ul></li></ul></li></ul></li></ul><h3 id="6-4-4-虚拟局域网"><a href="#6-4-4-虚拟局域网" class="headerlink" title="6.4.4 虚拟局域网"></a>6.4.4 虚拟局域网</h3><ul><li>树形（等级结构）局域网的缺点<ul><li>缺乏流量隔离：广播无法隔离，拉低局域网性能，缺乏安全隐私保护</li><li>交换机无效使用：分组造成交换机端口浪费，单一交换机不能提供流量隔离</li><li>管理用户：用户在组间移动时需要改变物理布线</li></ul></li><li><strong>虚拟局域网（VLAN）</strong>：<ul><li>支持VLAN的交换机允许经一个单一的物理局域网定义多个虚拟局域网</li><li>交换机端口由网管划分为组，每个组构成一个VLAN，在每个VLAN中的端口形成一个广播域</li><li>交换机维护端口-VLAN映射表</li><li>跨VLAN通过路由器实现通讯</li><li>VLAN干线连接：属于所有VLAN，发送到任何VLAN都经干线链路转发到其他交换机</li><li>以太网帧格式802.1Q，在源地址与类型字段间加入标签协议标识符（2）、标签控制信息（2）</li></ul></li></ul><h1 id="Ch7-无线网络和移动网络"><a href="#Ch7-无线网络和移动网络" class="headerlink" title="Ch7 无线网络和移动网络"></a>Ch7 无线网络和移动网络</h1><h2 id="7-1-概述（非考点，By-hyc）"><a href="#7-1-概述（非考点，By-hyc）" class="headerlink" title="7.1 概述（非考点，By hyc）"></a>7.1 概述（非考点，By hyc）</h2><ul><li><strong>无线主机</strong>：运行应用程序的端系统设备，如便携机、掌上机、智能手机或桌面计算机</li><li><strong>无线链路</strong>：连接无线主机或基站或另一台无线主机的链路</li><li><strong>基站</strong>：无线网络基础设施的一个关键部分，负责向与之关联的无线主机发送数据和从主机那里接收数据，负责协调与之相关联的多个无线主机的传输。</li><li><strong>相关联</strong>：该主机位于该基站的无线通信覆盖范围内；该主机使用该基站中继它和更大网络之间的数据。</li><li><strong>无线网络的分类依据：是否跨越了一个无线跳或多个无线跳；网络中是否有诸如基站这样的基础设施。</strong><ul><li>单跳，基于基础设施：802.11网络、3G蜂窝网络</li><li>单跳，无基础设施：蓝牙网络、具有自组织模式的802.11网络</li><li>多跳，基于基础设施：无线传感网络、无线网状网络</li><li>多跳，无基础设施：移动自组织网络（如车载自组织网络）</li></ul></li></ul><h2 id="7-3-WiFi-802-11-无线LAN"><a href="#7-3-WiFi-802-11-无线LAN" class="headerlink" title="7.3 WiFi:802.11 无线LAN"></a>7.3 WiFi:802.11 无线LAN</h2><h3 id="7-3-1-802-11体系结构"><a href="#7-3-1-802-11体系结构" class="headerlink" title="7.3.1 802.11体系结构"></a>7.3.1 802.11体系结构</h3><ul><li><strong>基本服务集（Basic Service Set，BSS）</strong>：802.11体系结构的基本构件模块，一个BSS包含一个或多个无线站点和一个称为<strong>接入点（Access Point，AP）</strong>的中央基站，AP可以连接到互联设备（如交换机或路由器）并连接到因特网中。</li><li>信道与关联<ul><li>在802.11中每个无线站点在能够发送或者接收网络层数据之前，必须与一个AP相关联。<ul><li>当安装一个AP时，网管会给该AP分配一个单字或双字的<strong>服务集标识符（Service Set Identifier，SSID）</strong>，和一个<strong>信道号</strong>。</li><li>每个AP周期性地发送<strong>信标帧（beacon frame）</strong>，每个信标帧包括该AP的SSID和MAC地址，一个无线站点扫描11个信道找出可能来自该区域的信标帧。通过信标帧了解到可用AP，选择一个与之关联。这个过程被称为<strong>被动扫描</strong>。主动扫描是通过向位于无线主机范围内的所有AP广播探测帧。</li><li>在选定与之关联的AP后，无线主机向AP发送一个关联请求帧，并且该AP以一个关联响应帧进行回应。</li><li><strong>WiFi丛林</strong>：一个任意物理位置，在这里无线站点能从两个或多个AP中收到很强的信号</li></ul></li></ul></li></ul><h3 id="7-3-2-802-11MAC协议"><a href="#7-3-2-802-11MAC协议" class="headerlink" title="7.3.2 802.11MAC协议"></a>7.3.2 802.11MAC协议</h3><ul><li>站点：无线设备或AP</li><li>使用<strong>带碰撞避免的CSMA（CSMA/CA）</strong>。不使用碰撞检测，一旦站点开始发送就不会停下来了<s>（奥尔加狂喜）</s></li><li>不同于以太网，使用<strong>链路层确认/重传方案（ARQ）</strong><ul><li>目的站点收到一个通过CRC校验的帧后等待一个<strong>短帧间间隔（SIFS）</strong>，然后发回一个确认帧。</li><li>如果发送站点在给定时间内未收到ACK就重传，使用CSMA/CA协议访问该信道</li><li>若干固定次重传后仍无确认就丢弃该帧</li></ul></li><li>不实现碰撞检测的原因：<ul><li>检测碰撞的能力要求站点具有同时发送和接收的能力，制造这样的硬件代价较大；</li><li>隐藏终端问题和衰减问题导致适配器无法检测到所有的碰撞。</li></ul></li><li><strong>CSMA/CA协议</strong><ol><li>如果站点最初监听到信道空闲，在一个<strong>分布式帧间间隔（DIFS）</strong>后发送该帧<ol start="2"><li>否则选取一个随机回退值，并在信道空闲时递减该值，信道忙时保持不变。</li><li>计数值减为0时发送整个数据帧并等待确认</li><li>如果收到确认，从第二步重新开始（等待一个随机回退值）；否则从一个更大的范围选取随机回退值并进入第二步中的回退阶段。</li></ol></li></ol></li><li>在倒计数时抑制传输的原因：无论如何尽可能避免高代价碰撞</li><li>处理隐藏终端RTS和CTS<ul><li>隐藏终端：两个无线站点在AP信号覆盖范围内，但彼此之间无法信号覆盖</li><li><strong>请求发送（RTS）控制帧</strong>和<strong>允许发送（CTS）控制帧</strong>来预约对信道的访问</li><li>发送方首先向AP发送RTS帧，指示传输数据帧和ACK帧需要的总时间；AP收到后广播一个CTS帧作为响应（给发送方明确的发送许可+只是其他站点在预约期内不要发送）；其他站点在CTS期内将抑制发送</li><li>优点：解决隐藏终端问题；RTS和CTS较短，涉及这两者的碰撞持续较短，只要正确传输，后续的数据和ACK都能无碰撞发送。</li><li>缺点：引入了时延，消耗了信道资源。</li><li>实际无线站点会设置RTS门限值，超过该值的帧才使用RTS/CTS序列。</li></ul></li><li>使用802.11作为一个点对点链路<ul><li>定向天线, 没其他站点, 相当于是AP与站点的点对点</li></ul></li></ul><h3 id="7-3-3-IEEE-802-11帧"><a href="#7-3-3-IEEE-802-11帧" class="headerlink" title="7.3.3 IEEE 802.11帧"></a>7.3.3 IEEE 802.11帧</h3><p>【p353图7-13】</p><ul><li>有四个地址字段。第四个地址在自组织模式中互相转发时使用。地址1：接收该帧的无线站点的MAC地址；地址2:传输该帧的站点的MAC地址；地址3:包含路由器接口的MAC地址。</li><li>序号用于区分新传输的帧和以前帧的重传</li><li>类型和子类型用于区分关联、RTA、CTS、ACK和数据帧</li><li>To, From字段用于定义不同地址字段的含义</li><li>WEP字段指示了是否使用加密</li></ul><h3 id="7-3-5-802-11中的高级特色"><a href="#7-3-5-802-11中的高级特色" class="headerlink" title="7.3.5 802.11中的高级特色"></a>7.3.5 802.11中的高级特色</h3><ul><li>速率自适应：原理类似于TCP拥塞控制</li><li><p>功率管理：一个结点能够明显地在睡眠和唤醒状态之间交替</p><h3 id="7-3-6蓝牙和ZigBee"><a href="#7-3-6蓝牙和ZigBee" class="headerlink" title="7.3.6蓝牙和ZigBee"></a>7.3.6蓝牙和ZigBee</h3></li><li><p>蓝牙（IEEE 802.15.1）：小范围、低功率、低成本，自组织网络，有一个主结点控制皮可网并确定时钟</p></li><li>ZigBee（IEEE 802.14.5）</li></ul><h1 id="Ch9-多媒体网络"><a href="#Ch9-多媒体网络" class="headerlink" title="Ch9 多媒体网络"></a>Ch9 多媒体网络</h1><h2 id="支持多媒体的网络"><a href="#支持多媒体的网络" class="headerlink" title="支持多媒体的网络"></a>支持多媒体的网络</h2><h3 id="提供多种类型的服务"><a href="#提供多种类型的服务" class="headerlink" title="提供多种类型的服务"></a>提供多种类型的服务</h3><p>链路调度规则：选择在链路上传输排队分组的方式</p><h4 id="监管：漏桶"><a href="#监管：漏桶" class="headerlink" title="监管：漏桶"></a>监管：漏桶</h4><p>3个准则：平均速率、峰值速率、突发长度</p><ul><li>漏桶由一个能容纳$b$个令牌的桶组成</li><li>新令牌总是以每秒$r$个速率产生</li><li>当产生一个令牌时，如果桶中少于$b$个令牌，则新产生的令牌加入到桶中，否则忽略</li><li>一个分组向网络传输之前，必须首先从令牌桶中去除一个令牌，如果令牌桶是空的，分组必须等待一个令牌。</li><li>漏桶监管的流的<strong>最大突发长度</strong>是$b$个分组，任何长度为$t$的时间间隔内能够进入网络中的最大分组数目为$rt+b$（<strong>平均速率</strong>）</li><li>在原漏桶下方再加一个令牌产生速率为$p$漏桶可以实现限制<strong>峰值速率</strong>到$p$</li></ul><h4 id="漏桶-加权公平排队-队列中可证明的最大时延"><a href="#漏桶-加权公平排队-队列中可证明的最大时延" class="headerlink" title="漏桶+加权公平排队=队列中可证明的最大时延"></a>漏桶+加权公平排队=队列中可证明的最大时延</h4><p>$$d_{max}=\frac{b_i}{R\cdot \frac{w_i}{\sum w_j}}$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ch1-计算机网络和因特网&quot;&gt;&lt;a href=&quot;#Ch1-计算机网络和因特网&quot; class=&quot;headerlink&quot; title=&quot;Ch1 计算机网络和因特网&quot;&gt;&lt;/a&gt;Ch1 计算机网络和因特网&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是因特网&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="notes" scheme="https://mengzelev.github.io/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>托福首考日记</title>
    <link href="https://mengzelev.github.io/2019/11/03/tofel-1st-exp/"/>
    <id>https://mengzelev.github.io/2019/11/03/tofel-1st-exp/</id>
    <published>2019-11-03T03:38:49.000Z</published>
    <updated>2019-11-03T07:07:09.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="考场情况"><a href="#考场情况" class="headerlink" title="考场情况"></a>考场情况</h1><p>听别人安利选了<strong>南京大学鼓楼校区C考场</strong><br>就在天津路校门口，地铁出去最近的一个小门进去就是计算中心<br>虽然楼在外面看上去挺破的，但是里面还行<br>C考场里面是一人一个小隔间这样子，感觉挺安心的，虽然戴上耳机还是能听到其他人的听力和口语声音，但是音量调到最大我个人感觉就完全没有影响了<br>总体觉得考场还不错</p><h1 id="考试流程"><a href="#考试流程" class="headerlink" title="考试流程"></a>考试流程</h1><h2 id="上路"><a href="#上路" class="headerlink" title="上路"></a>上路</h2><p>六点起床，七点出发<br>从南大仙林校区叫了辆出租车，三个人拼车打了82大洋，还行吧，至少比考场房便宜很多了</p><h2 id="进场"><a href="#进场" class="headerlink" title="进场"></a>进场</h2><p>进场前有个工作人员在发一张纸让你填个人信息，声称是“学校要填的”，但那张单子非常随便，而且ETS已经有我的全部报名信息了，很显然是像把我们的个人信息卖给什么留学机构的，所以我就拒绝了，她也没有纠缠<br>不过被“忽悠”了填的同学真的很多诶，大家对自己个人信息的保护意识也太差了吧www</p><p>八点不到就开始放人进去了，在一楼门口就要把身上的东西掏得只剩<strong>吃的、喝的、身份证</strong>，女孩子的话<strong>卫生巾</strong>也是可以带的，餐巾纸和药（我当天带了止痛药）是不让带的。</p><p>剩下的东西都要装到一个标有序号的大麻袋(x)里面去，大麻袋的钥匙可以（而且必须）带走</p><p>然后就是搜身，要把口袋里东西都掏出来全身金属探测器一下。我穿的衣服上金属饰品太多了让工作人员很无语hhhh姨妈巾拿多了还被勒令最多带一个，求了一下情才能带俩进去（中场休息换一个不是合情合理吗）。工作人员还让我把扎头发的大蝴蝶结摘下来（我觉得也不是很大啊），这也太严格了…..</p><p>搜完身之后就要填一个保密协议单，桌子上有模板，照着填就行了（我一开始还没注意到模板的存在</p><p>填完之后带着单子上三楼。水杯和吃的都要放在一张大桌子上（姨妈巾也要），要上厕所的话赶紧现在去上一个。之后就要去排队等拍照，拍完照就不能碰吃的喝的，也不能上厕所了，直接进考场坐下</p><p>以上就是南大鼓楼考场的进场流程了，我8点10分进的楼，中间出了不少小意外，等拍照的时候前面也正好人有点多，所以是8点40左右才进的考场，索性不影响考试</p><h2 id="开考前"><a href="#开考前" class="headerlink" title="开考前"></a>开考前</h2><p>开考前，考场里的监考老师会说一堆注意事项，我虽然都听了，但是考试时候还是没有全记起来，大概有以下几点：</p><ul><li>草稿纸和两只铅笔用完了要换，但是要保证桌上只有3张草稿纸。草稿纸要两面都用完了才给换</li><li>有事举手的时候举高一点，因为没人一个隔间老师可能会看不见</li><li>中场休息一定要看见倒计时了再出去</li><li>中场休息只有十分钟，女厕所坑位比较少，所以一定要先去上厕所，最好提早一点回来，因为还要拍照什么的</li><li>中场休息倒计时还剩二三十秒的时候就要叫监考老师来输入密码开锁，不然可能会自动生成缺考报告（我就忘了，多亏老师发现orz</li><li>阅读instruction的时间有时候也算在考试时间里面的，基本模考时候都看过了就不要管了(x)</li><li>休息走的时候要把门带上，因为每个人结束上半场的时间不一样</li><li>P.S.在考场里脱衣服的话老师会过来把你的衣服收走，你冷了还得举手要，所以不是特别热就尽量自己忍忍吧(那我怀疑夏天去考觉得空调冷了还要举手问老师要外套)</li></ul><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>老师输完密码解锁后第一项就是阅读</p><p>我这次考试的阅读难度感觉有个别（3道左右）比较难，对应原文读不太懂，也可能是因为上考场有点简单。TPO里的阅读题还是偏简单的。</p><p>还有我最后一大题真的很薄弱orz选的三项里都至少有一项很不确定</p><p>还有考试环境里竟然都不能鼠标选中高亮，不像在网页上模考那样，经常看看题目就忘了自己考到哪了。这阅读考试也太反人类了，更别说高考那套记号系统完全废了。</p><p>我的时间分配大概是19+18+16+1min检查，因为第一篇还没进入状态，比较紧张，读起来很慢。不过可能也是依赖于二三难度比一低一点，不然可能要时间地狱了www</p><p>索性阅读没被加试</p><h2 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h2><p>这次听力总体来说感觉好难，刷TPO我基本能控制到最多2题没印象，但是这次没印象的题比例特别高，感觉是不是出题点出现偏移了，导致我留意的没考到，考到的没留意orz(给自己菜找借口ing)</p><p>我听力被加试了，1对话+1授课，11min</p><p>听力时候由于每个section是紧连着的，我草稿纸写完了，点了下一题下一篇听力直接开始了，结果忘了举手换草稿纸了，唉…最后一题真的是插空式到处搜刮空间记笔记，记得七零八落的，下次一定要记得</p><p>我听到答案的题基本都是秒选，不确定的题最多纠结1分钟，时间还是比较充裕的。大家安排时间的时候最好把找老师换纸的时间算进去呀</p><h2 id="中场休息"><a href="#中场休息" class="headerlink" title="中场休息"></a>中场休息</h2><p>要把身份证带走，一会儿还要拍照<br>女厕果然排队<br>我上个厕所回来喝了两口水吃了点东西再拍照回去，就已经只剩40s了，时间还是有点局促的呀<br>sb如我忘了在计时器还剩几十秒的时候叫老师解锁了，幸好老师发现了</p><h2 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h2><p>本来对这部分就没什么信心…</p><p>Task1独立口语问的是….我忘了orz<br>Task2是想让学生和老师的食堂合并起来。这里有个奇怪的地方是，main speaker第一个理由是赞同的，觉得这样可以腾出空间缓解拥挤，因为老师不怎么吃食堂；第二个理由却说学生会在吃饭时被老师问学习，老师可能也不想和学生聊天，反而有点反对的意思了<br>Task3大概是生态大坝，很常规的题目。可惜我没控制好时间，没说完（自卑<br>Task4也很典型，没什么印象了….</p><p>总的来说感觉自己一旦专注于内容就顾及不了语音语调了，还是缺乏练习，二刷之前要专攻口语了</p><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>综合写作也很常规，关于天然气，阅读说它不好，听力说好，没太大问题</p><p>综合写作这次的题目我佛了<br>考前准备了很多个人与社会方面的常用论点，身体健康、社会平等什么的，结果这次给我来了一个<strong>名人该不该表明自己的政治观点</strong><br>我怎么觉得这个好针对啊，<s>N*A的事情才刚刚过去</s>，好吧其实国外也是这样的<br>透露着出题组满满的恶意……<br>我是写了不应该，一个是会煽动无知群众，一个是会造成表达政治立场蹭热度的风气（这个好难写），不可否认的是对宣传好的主张有帮助。然后，突然想不起来主张怎么说(自裁)<br>时间还是紧，有一段没写完草草收尾了，也没来得及检查拼写(再次自裁)</p><p>写作也是下次来之前要恶补的项目了……</p><h2 id="考完"><a href="#考完" class="headerlink" title="考完"></a>考完</h2><p>我是十二点多出考场的，考试时间缩短还是好（嘿嘿<br>出考场才意识到自己有点饿了，要是跟原来一样考到一点估计要饿瘫了<br>在新街口浪了一整天（其实只有大半天</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之感觉就是<strong>非常严格</strong>，高考都相形见绌，看来天朝还是比老美相信自己人的(雾)<br>考场里不让喝水real难受，思考很消耗水分的啊kora<br>本来有把握的阅读听力没发挥好，口语写作又不出所料的烂，这次就权当体验生活了，上交2k大洋下次再来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;考场情况&quot;&gt;&lt;a href=&quot;#考场情况&quot; class=&quot;headerlink&quot; title=&quot;考场情况&quot;&gt;&lt;/a&gt;考场情况&lt;/h1&gt;&lt;p&gt;听别人安利选了&lt;strong&gt;南京大学鼓楼校区C考场&lt;/strong&gt;&lt;br&gt;就在天津路校门口，地铁出去最近的一个小门进去就
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络-课程笔记</title>
    <link href="https://mengzelev.github.io/2019/10/12/network-notes/"/>
    <id>https://mengzelev.github.io/2019/10/12/network-notes/</id>
    <published>2019-10-12T03:25:20.000Z</published>
    <updated>2020-01-01T10:22:45.880Z</updated>
    
    <content type="html"><![CDATA[<p><u>【工事中】</u></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li>ISP：因特网服务提供商</li><li>协议：定义了两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接受一条报文或其他事件所采取的动作</li><li>主机=端系统</li><li>以太网：以太网交换机-机构路由器-ISP</li><li>WiFi:接入点-企业网-有限因特网</li></ul><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><ul><li>分组交换机：路由器/链路交换机</li><li>存储转发传输：交换机能够开始向输出链路传输该分组的第一个比特钱，必须接收到整个分组<ul><li>时延：$2L/R$，不存储是$L/R$</li><li>通过$N$条速率均为$R$的链路组成的路径，端到端时延$d_{\text{端到端}}=N\frac{L}{R}$</li></ul></li><li>输出缓存/输出队列：链路上进入交换机前分组等待的地方</li><li>排队时延，丢包</li><li>转发表：将目的地址（或一部分）映射为输出链路</li><li>路由选择协议：自动设置转发表</li></ul><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><ul><li>预留资源，按需使用</li><li>频分复用FDM，时分复用TDM</li><li>带宽：频分复用的宽度</li></ul><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><ul><li>处理时延$d_{proc}$：检查分组首部决定讲该分组导向何处所需要的时间<ul><li>也包括检查比特级别的差错需要的时间</li><li>微秒或更低数量级</li></ul></li><li>排队时延$d_{queue}$：在队列中，分组在链路上等待传输的时间<ul><li>取决于先期到达的正在排队等待向链路传输的分组数量</li><li>到达分组期望发现的分组数量是到达该队列的流量的强度和性质的函数</li><li>毫秒到微秒量级</li></ul></li><li>传输时延$d_{trans}$：将所有分组的比特推向链路所需要的时间<ul><li>毫秒到微秒量级</li></ul></li><li>传播时延$d_{prop}$：一个比特从该链路的起点到路由器B的传播所需要的时间<ul><li>不需要等推完了再上路，有一个比特传一个比特</li><li>两台路由器之间的距离/传播速率</li><li>毫秒量级</li></ul></li><li>节点总时延$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$</li><li>时延成分所起的作用可能会有很大不同</li></ul><h2 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h2><ul><li>$a$:分组的到达队列的平均速率(pkt/s)</li><li>流量强度=$La/R$<ul><li>$La/R&gt;1$：到达得比传输得快，队列无限增加，排队时延趋向无穷大</li></ul></li><li>流量强度越大，丢包的比例越大</li><li>假设没有排队时延的端到端时延：$d_{end-to-end}=N(d_{proc}+d_{trans}+d_{prop})$</li></ul><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><ul><li>瓶颈链路</li><li><p>吞吐量取决于数据流过的链路的传输速率</p></li><li><p>吞吐量：每秒能够传送的数据量</p></li></ul><h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>服务模型：向上一层提供的服务<br>协议栈：各层的所有协议、</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul><li>网络应用程序及它们的应用层协议存留的地方</li><li>一个端系统的应用程序与另一个端系统中的应用程序交换信息分组</li><li>HTTP,SMTP,FTP,DNS</li><li>报文(message)</li></ul><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><ul><li>在应用程序端点之间传送应用层报文</li><li>TCP, UDP</li><li>报文段(segment)</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>将数据报从一台主机移动到另一台主机</li><li>数据报(datagram)</li><li>网际协议IP</li></ul><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><ul><li>将分组从一个节点(主机或路由器)移动到路径上的下一个节点</li><li>以太网、WiFi、电缆接入网DOCSIS、PPP</li><li>帧(frame)</li></ul><p>###　物理层</p><ul><li>将帧中的一个个比特从一个节点移动到下一个节点</li><li>协议是链路相关的，并进一步与实际传输媒体相关</li></ul><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>运输层和应用层之间多了表示层和会话层</p><ul><li>表示层：使通信的应用程序能够解释交换数据的含义<ul><li>数据压缩、数据加密、数据描述</li></ul></li><li>会话层：数据交换的定界和同步功能<ul><li>建立检查点和恢复方案</li></ul></li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>链路交换机只实现链路层和物理层</li><li>路由器只实现网络层、链路层和物理层</li><li>路由器能实现IP协议，链路交换机不行</li><li>分组=首部字段+有效载荷字</li></ul><h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><ul><li>恶意软件：进入设备干坏事</li><li>僵尸网络：受害设备网络</li><li>病毒：需要某种形式的用户交互来感染用户设备的恶意软件</li><li>蠕虫：无须任何明显用户交互就能进入设备的恶意软件</li><li>DoS：拒绝服务攻击<ul><li>弱点攻击、带宽洪泛、连接洪泛</li><li>分布式Dos:DDoS</li></ul></li><li>嗅探分组：分组嗅探器（被动接收机</li><li>IP哄骗：将具有虚假源地址的分组注入因特网</li></ul><h1 id="Ch6-链路层和局域网"><a href="#Ch6-链路层和局域网" class="headerlink" title="Ch6 链路层和局域网"></a>Ch6 链路层和局域网</h1><p>节点：运行链路层协议的任何设备<br>链路：沿着相邻结点的通信信道</p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><ul><li>成帧：把网络层数据报封装成链路层帧</li><li>链路接入：媒体访问控制(MAC)协议</li><li>可靠交付：确认和重传</li><li>差错检测和纠正</li></ul><p>实现：网络适配器（网络接口卡），硬件实现</p><h2 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h2><p>EDC：差错检测和纠正比特</p><p>###　奇偶校验</p><ul><li>二位奇偶校验：可以纠正单比特错，可检测但不能纠正两个比特错</li><li>前向纠错FEC:接收方检测和纠正差错的能力</li></ul><h3 id="Internet-checksum"><a href="#Internet-checksum" class="headerlink" title="Internet checksum"></a>Internet checksum</h3><ul><li>将数据的字节作为16比特的整数对待并求和:进位加法，最高位进位需要加到末尾</li><li>相对弱的差错保护</li></ul><h3 id="循环冗余检测CRC"><a href="#循环冗余检测CRC" class="headerlink" title="循环冗余检测CRC"></a>循环冗余检测CRC</h3><ul><li>又称多项式编码：将发送的比特串看成多项式系数</li></ul><p>$D\cdot 2^r \text{ XOR } R = nG$<br>$D\cdot 2^r=nG \text{ XOR }  R$<br>$R=\text{remainder}\frac{D\cdot 2^r}{G}$</p><p>转自阿姨博客的表示方法：<br>$$\frac{X^{n-k}D(X)}{P(X)}=Q(X)+\frac{R(X)}{P(X)}$$<br>$$T(X)=X^{n-k}D(X)+R(X)$$<br>其中，$X$是二进制串对应的多项式，如$P=11001, P(X)=X^4+X^3+1$<br>接收方用$T/P$，如果不能整除，说明存在差错。</p><ul><li>$P\to G$</li><li><p>位数：$P/G: n-k+1, D:k, T:n-k$</p></li><li><p>可以检测小于$r+1$比特的错($r=|R|$)</p></li></ul><h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><ul><li>点对点链路</li><li>广播链路</li><li>碰撞：多个节点同时传输帧导致所有节点同时接到多个帧</li><li>多路访问协议的特性(p294)<ul><li>当仅有一个节点发送数据时，该节点具有$R$ bps的吞吐量</li><li>当有$M$个节点发送数据时，每个节点的吞吐量为$R/M$ bps</li><li>协议是分散的：不会因为某主节点故障而使整个系统崩溃</li><li>协议是简单的，使实现不昂贵</li></ul></li></ul><h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><ul><li>TDM：将时间划分为时间帧，并进一步划分每个时间帧喂$N$个时隙(slot)</li><li>FDM：将$R$ bps信号划分为不同的频段，并把每个频率分给$N$个节点中的一个</li><li>CDMA(码分多址)：对每个节点分配一种不同的编码，不同的节点能够同时传输，并且各自接收方能正确接收</li></ul><h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><ul><li>传输节点总是以信道的全部速率进行发送</li><li>当有碰撞时，涉及碰撞的每个节点反复地重发它的帧</li><li>重发之前等待一个随机时延</li></ul><h4 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h4><ul><li>所有节点要同步传输</li><li>如果有碰撞，该节点以概率$p$在后续的每个时隙中重传它的帧，直到无碰撞地传出去</li><li>时隙多路访问协议的效率：当有大量的活跃节点且每个节点总有大量的帧要发送时，长期运行中成功时隙的份额</li><li>效率：$Np(1-p)^{N-1}$, 最大$1/e$</li></ul><h4 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h4><ul><li>一个给定节点成功传输一次的概率是$p(1-p)^{2(N-1)}$<ul><li>在$[t_0-1,t_0]$和$[t_0, t_0+1]$时间段内都不可以有别的节点传输</li></ul></li><li>最大效率$1/2e$</li></ul><h4 id="CSMA-载波侦听多路访问"><a href="#CSMA-载波侦听多路访问" class="headerlink" title="CSMA(载波侦听多路访问)"></a>CSMA(载波侦听多路访问)</h4><ul><li>载波侦听：说话之前先听，如果其他人正在说话，等到他们说完为止</li><li>碰撞检测：如果与他人同时开始说话，停止说话</li><li>广播信道的端到端信道传播时延在决定性能方面起到关键作用<ul><li>越大，XSMA节点不能侦听到另一个节点已经开始传输的机会越大</li></ul></li></ul><h4 id="CSMA-CD-具有碰撞检测的载波侦听多路访问"><a href="#CSMA-CD-具有碰撞检测的载波侦听多路访问" class="headerlink" title="CSMA/CD(具有碰撞检测的载波侦听多路访问)"></a>CSMA/CD(具有碰撞检测的载波侦听多路访问)</h4><ul><li>如果适配器在传输时检测到来自其他适配器的信号能量，就中止传输，并随机等待一个随机时间量再次传输</li><li>期望：碰撞节点数较少时，时间间隔较短；反之亦然<ul><li>二进制指数后退算法：经历了一连串的$n$次碰撞后，节点随机地从${0,1,2,\cdots,2^n-1}$中选择一个$K$值，$n$最大为10</li></ul></li><li>不考虑近期过去时间内可能已经发生的任何碰撞</li><li>效率$= n\frac{1}{1+5d_{prop}/d_{trans}}$</li></ul><h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><h4 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h4><ul><li>主节点轮询告诉每个节点能够传输的帧的最多数量</li><li>缺点：引入了轮询时延、主节点坏了就全坏了</li></ul><h4 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h4><ul><li>一个称为令牌(token)的小的特殊帧在节点之间以某种固定的次序进行交换</li><li>一个节点收到令牌时，仅当它有一些帧要传输，它才持有这个令牌，否则立即向下一个节点转发该令牌</li><li>有帧要传输时，发送最大数目的帧数，然后把令牌转发给下一个节点</li><li>缺点：一个节点坏了就全坏了，一个节点忘了释放令牌</li></ul><h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><ul><li>链路层地址</li><li>6个字节，$2^48$个可能，每个字节表示为一堆十六进制数</li><li>没有两块适配器具有相同的地址–IEEE管理</li></ul><p>###　地址解析协议ARP</p><ul><li>ARP表：包含IP地址到MAC地址的映射关系</li><li>TTL寿命值：表示从表中删除每个映射的时间</li><li>ARP分组：包含发送和接受IP地址及MAC地址<ul><li>查询分组：询问子网上所有其他主机和路由器，以确定对应于要解析的IP地址的那个MAC地址</li><li>响应分组</li><li>查询分组和响应分组格式相同</li><li>查询 ARP在广播帧中发送，响应ARP在标准帧中发送</li></ul></li><li>ARP即插即用，不需要手动配置</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul><li>发送方向其适配器发送一个ARP查询分组</li><li>适配器在链路层帧中封装这个ARP分组，并讲该帧传输进子网中</li><li>（广播地址）每个适配器把在该帧中的ARP分组向上传递给ARP模块，每个ARP模块检查它的IP地址是否与ARP分组中的目的IP地址相匹配，与之相匹配的一个给查询主机发送回一个带有所希望映射的响应ARP分组</li><li>查询主机更新ARP表，并发送IP数据报</li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li>集线器(hub)：物理层设备，作用于比特，放大收到的比特的能量强度并向其他所有借口传输出去</li><li>广播局域网：无论何时集线器从它的一个接口接收到一个比特，它向所有其他接口发送该比特的副本</li><li>碰撞：某集线器同时从两个不同的接口接收到帧，将出现一次碰撞，生成该帧的节点必须重新传输该帧</li><li>交换机(switch)代替hub</li></ul><h4 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前同步码|目的地址|源地址|类型|数据|CRC</span><br></pre></td></tr></table></figure><ul><li>数据字段：承载IP数据报，最小长度46字节，最大长度1500字节</li><li>目的地址：目的适配器的MAC地址。是自己的地址/广播地址就丢给网络层，否则直接丢弃</li><li>源地址：顾名思义</li><li>类型字段：允许以太网复用多种网络层协议</li><li>CRC</li><li>前同步码<ul><li>前7字节都是10101010，最后一个字节为10101011</li><li>发送方的额定速率会产生漂移，所以前7字节用来同步接收方的时钟</li><li>最后两个字节用于警告接收方重要的东西要 来 了</li></ul></li></ul><p>以太网技术向网络层提供的服务：</p><ul><li>无连接：没有事先握手</li><li>不可靠：接收方不发送确认帧和否定确认帧，只丢弃没通过校验的帧</li></ul><h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><p>交换机的任务：接收入链路层帧并将它们转发到出链路<br>交换机对于子网中的主机和路由器是透明的<br>交换机输出接口设有缓存</p><h4 id="交换机表"><a href="#交换机表" class="headerlink" title="交换机表"></a>交换机表</h4><p>转发和过滤借助于交换机表实现<br>过滤：决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能<br>转发：决定一个帧应该被导向哪个接口，并把该帧移动到哪些接口</p><p>一个表项包括：</p><ul><li>一个MAC地址</li><li>通向该MAC地址的交换机接口</li><li>表项放置在表中的时间</li></ul><p>工作过程</p><ul><li>对于没有目的地址的表项，交换机广播该帧</li><li>存在到达接口与目标地址相联系的表项，丢弃该帧（过滤）</li><li>存在非到达接口与目标地址相联系的表项，交换机将帧放到目标接口的输出缓存完成转发功能</li></ul><h4 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h4><ul><li>交换机表初始为空</li><li>对于每个接口接收到的每个入帧，该交换机在其表中存储</li><li>在一段时间(老化时间)后交换机没有接受到以该地址作为源地址的帧，就在表中删除这个帧</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>即插即用</li><li>消除碰撞<ul><li>绝不会在网段上同时传输多于一个帧</li><li>最大聚合带宽：该交换机所有接口速率之和（交换机间的接口不算</li></ul></li><li>异质链路<ul><li>能够以不同速率运行并且能够在不同的介质上运行</li></ul></li><li>便于管理</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>活跃拓扑限制为一棵生成树</li><li>对于广播风暴不提供保护措施</li></ul><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">集线器</th><th style="text-align:center">路由器</th><th style="text-align:center">交换机</th></tr></thead><tbody><tr><td style="text-align:center">流量隔离</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">即插即用</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">优化路由</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr></tbody></table><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><h1 id="CH7-无线网络和移动网络"><a href="#CH7-无线网络和移动网络" class="headerlink" title="CH7 无线网络和移动网络"></a>CH7 无线网络和移动网络</h1><p>无线$\neq$移动</p><ul><li>无线主机：到处都是</li><li>无线链路：主机通过无线通信链路连接到一个基站或者另一台无线主机；<ul><li>覆盖区域和链路速率</li></ul></li><li>基站：负责向与之关联的无线主机发送数据和从主机那里接收数据，协调与之相关联的多个无线主机的传输；e.g.蜂窝网络中的蜂窝塔、无限LAN中的接入点AP</li><li>基础设施模式</li></ul><h2 id="无线链路和网络特征"><a href="#无线链路和网络特征" class="headerlink" title="无线链路和网络特征"></a>无线链路和网络特征</h2><p>有线和无线网络的主要区别在链路层，网络层及以上都是相同的</p><ul><li>递减的信号强度：距离$\uparrow$,信号强度$\downarrow$</li><li>来自其他源的干扰</li><li>多径传播：使得接收方收到的信号变得模糊</li></ul><p>信噪比(SNR)</p><ul><li>单位分贝(dB)</li><li>收到的信号的振幅与噪声的振幅的以10为敌的对数的比值</li><li>较大的SNR是接收方更容易从背景噪声中提取传输的信号</li><li>对于给定的调制方案，SNR越高，BER(比特差错)越低</li></ul><h2 id="CDMA"><a href="#CDMA" class="headerlink" title="CDMA"></a>CDMA</h2><ul><li>码分多址信道划分协议</li><li>要发送的每个比特都通过乘以一个信号(编码)的比特来进行编码，这个信号的变化速率(码片速率)比初始数据比特序列的变化速率快很多</li><li>CDMA工作假设：干扰的传输比特信号是加性的</li><li>划分编码空间</li></ul><h2 id="WiFi-802-11无线LAN"><a href="#WiFi-802-11无线LAN" class="headerlink" title="WiFi: 802.11无线LAN"></a>WiFi: 802.11无线LAN</h2><p>基本服务集(BSS): 802.11体系结构的基本构建模块，包含一个或多个无线站点和一个称为AP的中央基站<br>每个无线站点具有一个6字节的MAC地址</p><h3 id="信道与关联"><a href="#信道与关联" class="headerlink" title="信道与关联"></a>信道与关联</h3><p>网络管理员安装AP时</p><ul><li>为AP分配一个单字或双字的服务及标识符(SSID)</li><li>分配一个信道号</li></ul><p>WiFi丛林：任意一个物理位置，在这里无线站点能从两个或多个AP中收到很强的信号<br>关联：无线站点在自身和AO之间创建一个虚拟线路</p><ul><li>被动扫描<ul><li>每个AP周期性地发送信标帧</li><li>每个信标帧包括该AP的SSID和MAC地址</li><li>无线站点扫描11个信道，找出可能位于该区域的AP所发出的信标帧</li></ul></li><li>主动扫描<ul><li>无线主机向位于其范围内的所有AP广播探测帧</li><li>选定与之关联的AP后，无线主机向AP发送一个关联请求帧，并且该AP以一个关联响应帧进行响应</li><li>需要二次请求/响应握手</li><li>主机通常将通过关联的AP向该子网发送一个DHCP发现报文，以获取在该子网中的一个IP地址</li></ul></li></ul><p>用户名和口令</p><ul><li>AP与一个鉴别服务器进行通信</li><li>一个鉴别服务器可以服务于多个AP</li></ul><h1 id="CH4-网络层：数据平面"><a href="#CH4-网络层：数据平面" class="headerlink" title="CH4 网络层：数据平面"></a>CH4 网络层：数据平面</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据平面：从输入链路向输出链路转发数据报<br>控制平面：协调本地的每个路由器的转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送</p><table><thead><tr><th style="text-align:center">转发</th><th style="text-align:center">路由选择</th></tr></thead><tbody><tr><td style="text-align:center">将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作</td><td style="text-align:center">分组从源到目的地所采取的端到端路径的网络范围</td></tr><tr><td style="text-align:center">时间尺度短(ns)</td><td style="text-align:center">时间尺度长(s)</td></tr><tr><td style="text-align:center">通常硬件实现</td><td style="text-align:center">通常软件实现</td></tr></tbody></table><p>路由选择算法决定插入该路由器转发表的内容</p><p>软件定义网络(SDN): 路由选择设备仅执行转发，远程控制器计算并分发转发表(软件实现)</p><p>网络服务模型：尽力而为服务</p><h2 id="路由工作原理"><a href="#路由工作原理" class="headerlink" title="路由工作原理"></a>路由工作原理</h2><p>假设：转发决定仅基于分组的目的地址，而非基于通用的分组首部字段</p><p>路由器组成部分：输入端口，交换结构、输出端口、路由选择处理器</p><h3 id="输入端口处理"><a href="#输入端口处理" class="headerlink" title="输入端口处理"></a>输入端口处理</h3><p>数据报-&gt;线路端接-&gt;数据链路处理(协议、拆封)-&gt;查找、转发、排队-&gt;交换结构</p><p>使用<strong>转发表</strong>查找输出端口，转发表由路由选择处理器计算和更新，从路由选择处理器经过独立总线复制到线路卡。使用每个输入端口的影子副本，转发决策能在每个输入端口本地做出，无须基于每个分组调用集中式路由选择处理器，避免集中式处理的瓶颈。</p><p>转发表：前缀匹配，最长前缀匹配规则</p><p>在某些设计中，一个分组可能会在进入交换结构时被暂时阻塞</p><p>查找外必须采取许多其他动作</p><ul><li>必须出现物理层和链路层处理</li><li>必须检查分组的版本号、检验以及寿命字段，并且重写后两个字段</li><li>必须更新用于网络管理的计数器</li></ul><p><strong>“匹配加动作”</strong></p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><ul><li>经内存交换<ul><li>类似传统计算机</li><li>在CPU(路由选择处理器)的直接控制下完成</li><li>输入与输出端口的功能像传统I/O设备</li><li>分组到达输入端口-&gt;中断-&gt;分组被复制到处理器内存-&gt;CPU提取目的地址，在转发表中找到适当的输出端口-&gt;CPU将分组复制到输出端口的缓存中</li><li>若内存带宽为$B$个分组/秒，则总的转发吞吐量必然小于$B/2$</li><li>不能同时转发两个分组</li></ul></li><li>经总线交换<ul><li>输入端口经共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预</li><li>输入端口为分组预先计划一个交换机内部标签(首部)，指示本地输出端口-&gt;分组能被所有输出端口收到，但只有标签匹配的端口才能保存分组-&gt;标签在输出端口被去除</li><li>一次只有一个分组能跨越总线，因此多个分组同时到达路由器时，除了一个分组外其他都必须等待</li></ul></li><li>经互联网络交换<ul><li>纵横式交换机：$2N$条总线，连接$N$个输入端口和$N$个输出端口</li><li>交缠点通过交换结构控制器实现开启闭合</li><li>分组到达输入端口-&gt;交叉点-&gt;输出端口</li><li>非阻塞：能够并行转发多个分组</li></ul></li><li>多级交换元素</li></ul><h3 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h3><p>交换结构-&gt;排队(缓存管理)-&gt;数据链路处理(协议，封装)-&gt;线路端接-&gt;</p><p>###　排队</p><p>丢包：排队导致路由器的缓存空间耗尽</p><ul><li>输入排队<ul><li>线路前部(HOL)阻塞：在一个输入队列中排队的分组必须等待通过交换结构发送(即使输出端口是空闲的)，因为它被位于线路前部的另一个分组所阻塞 – 对纵横式交换结构而言</li></ul></li><li>输出排队<ul><li>主动队列管理：在缓存填满之前丢弃一个分组（或在首部加上标记），可以向发送方提供一个拥塞信号</li><li>缓存数量$B$与平均往返时延$RTT$、链路容量$C$、TCP流$N$的关系：$B=RTT\cdot C$, ($N$较大时)$B=RTT\cdot C/\sqrt{N}$</li></ul></li></ul><h3 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h3><ul><li>FIFO</li><li>优先权排队<ul><li>有多个优先权类，分开排队</li><li>每次选择非空的最高优先权类队列中的分组进行传输</li><li>非抢占式优先权排队：一旦分组开始传输就不能打断</li></ul></li><li>循环排队<ul><li>没有服务优先权，循环调度器在类之间轮流提供服务</li><li>保持工作排队规则：在有分组排队等待传输时不允许链路保持空闲–当寻找给定类的分组但没有找到时立即检查下一个类</li></ul></li><li>加权公平排队(WFQ)<ul><li>循环方式</li><li>每个类在任何时间间隔都可能收到不同数量的服务，每个类$i$被分配一个权$w_i$</li><li>第$i$类 将确保接收到的服务部分等于$w_i/(\sum w_i)$</li><li>最坏情况下第$i$类也能分得上述那么多带宽</li></ul></li></ul><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h3><p><img src="/2019/10/12/network-notes/ipv4.png" alt=""></p><ul><li>版本号：4比特，规定了数据报的IP协议版本，不同IP版本使用不同的数据报格式。</li><li>首部长度：4比特，IPv4数据报包含可变数量的选项，所以需要确定首部长度。大多数IP数据报不包含选项，所以一般具有20字节的首部。</li><li>服务类型(TOS)：8比特，使不同类型的IP数据报能相互区别开来。</li><li>数据报长度：16比特，IP数据报首部+数据的总长度，单位字节。理论最大长度为65535字节，但实际上很少有超过1500的。这个长度使得IP数据报能容纳最大长度以太网帧的载荷字段。</li><li>标识、标志、片偏移：与IP分片有关。</li><li>寿命(TTL)：确保数据报不会永远（如由于长时间的路由选择环路）在网络中循环。每当一台路由器处理时该字段的值-1，为0时自动丢弃。</li><li>协议：仅当到达最终目的地时才会有用，指示了IP数据报需要交给哪个特定的运输层协议。协议号是将网络层与运输层绑定到一起的黏合剂。（端口号是将运输层和应用层绑定到一起的黏合剂）</li><li>首部检验和：首部中的每两个字节当成一个数，用反码算术求和。每台路由器上必须重新计算检验和并再次存放到远处，因为TTL字段以及可能的选项字段会改变。【为什么TCP/IP都执行差错检测？–因为TCP和IP可以分别运行在不同的协议栈上</li><li>源和目的地IP地址：源主机通过DNS查找来决定目的地址。</li><li>选项：允许IP首部被扩展，很少使用。</li><li>数据(有效载荷)：大多数时候承载运输层报文，也可承载其他类型的数据,e.g.ICMP报文</li></ul><p>20字节IP首部+20字节TCP首部=40字节数据报首部</p><h3 id="数据报分片"><a href="#数据报分片" class="headerlink" title="数据报分片"></a>数据报分片</h3><p>原因：发送方与目的地路径上的每段链路可能使用不同的链路层协议<br>最大传送单元(MTU)：一个链路层帧能承载的最大数据量<br>每个较小的数据报称为片(fragment)</p><ul><li>发送主机将发送的每个数据报的标识号+1</li><li>路由器对数据报分片时，每个片具有初始数据报的源地址、目的地址和标识号</li><li>目的地主机能够检查数据报的标识号以确定哪些数据报实际上是同一较大数据报的片</li><li>IP是不可靠服务–初始数据报的最后一篇标志比特为0，其他片为1</li><li>为了让目的主机确定是否丢了一个片且按正确顺序组装片，使用偏移字段制定该片应该放在初始IP数据报的哪个位置</li></ul><h3 id="编址"><a href="#编址" class="headerlink" title="编址"></a>编址</h3><p>一台主机通常只有一条链路连接到网络，主机与物理链路之间的边界叫作<strong>接口</strong>。<br>路由必须拥有多条链路与之相连接，路由器与它任意一条链路之间的边界也叫作<strong>接口</strong>。<br>一个IP地址与一个接口相关联。</p><p>IP地址长32比特，采用点分十进制记法书写<br>格式：$a.b.c.d/x$</p><ul><li>子网掩码：32位中前$x$比特全取1</li><li>最高$x$比特构成了网络部分，也称<strong>前缀</strong></li><li>组织内部的设备的IP共享相同的前缀</li><li>减少了子网外路由器中转发表的长度</li></ul><p>子网：分开主机和路由器的每个接口，产生几个隔离的网络孤岛，使用接口端接这些隔离的网络的端点。这些隔离的网络中的每一个都叫作一个子网。<br>在给定子网上的所有设备都具有相同的子网地址。<br>因特网地址的分配策略称为<strong>无类别域间路由选择</strong>(CIDR, Classless Interdomain Routing)<br>寻址：<strong>最长前缀匹配</strong>，选择与目的地址相匹配的最长地址前缀<br>IP广播地址：255.255.255.255，当报文的目的地址是广播地址时会被交付给同一个网络中的所有主机，路由器也会有选择地向临近的子网转发该报文</p><h3 id="获取一块地址"><a href="#获取一块地址" class="headerlink" title="获取一块地址"></a>获取一块地址</h3><p>ISP从自己的大地址块中提供一些地址给组织<br>IP地址由因特网名字和编号分配机构(ICANN)管理，ICANN还管理DNS根服务器</p><h3 id="获取主机地址：DHCP"><a href="#获取主机地址：DHCP" class="headerlink" title="获取主机地址：DHCP"></a>获取主机地址：DHCP</h3><ul><li>动态主机配置协议(DHCP)允许主机获取一个IP地址，还允许主机得知子网掩码、第一跳路由器地址(默认网关)、本地DNS服务器的地址</li><li>即插即用协议/零配置协议</li><li>客户-服务器协议<ul><li>每个子网将具有一台DHCP服务器</li><li>如果某子网中没有DHCP服务器，则需要一个DHCP中继代理（通常是一台路由器），这个代理用于知道该网络的DHCP服务器的地址</li></ul></li></ul><h4 id="DHCP协议4步"><a href="#DHCP协议4步" class="headerlink" title="DHCP协议4步"></a>DHCP协议4步</h4><ul><li>DHCP服务器发现<ul><li>使用<strong>DHCP发现报文</strong></li><li>源地址：0.0.0.0(“本主机”)，目的地址：255.255.255.255(广播地址)</li><li>用于一个新到达的主机发现一个要与其交互的DHCP服务器</li></ul></li><li>DHCP服务提供<ul><li>DHCP服务器收到DHCP发现报文后对客户做出响应</li><li>使用<strong>DHCP提供报文</strong>，包含发现报文的事物ID、向客户推荐的IP地址、网络掩码、IP地址租用期(即IP地址的有效时间量，通常为几小时或几天)</li><li>源地址：自己的IP地址，目的地址：255.255.255.255(广播地址)</li><li>子网中可能存在多个DHCP服务器，客户需要选择一个</li></ul></li><li>DHCP请求<ul><li>客户向选中的服务器提供<strong>DHCP请求报文</strong>进行响应，回显配置的参数</li><li>源地址：0.0.0.0.，目的地址:255.255.255.255</li></ul></li><li>DHCP ACK<ul><li>服务器用<strong>DHCP ACK报文</strong>对DHCP请求报文进行响应，证实所要求的参数</li><li>源地址：DHCP服务器自己的地址，目的地址:255.255.255.255</li><li>客户收到DHCP ACK后交互完成</li></ul></li></ul><p>不能维持与远程应用之间的TCP连接</p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换(NAT)"></a>网络地址转换(NAT)</h2><ul><li>NAT使能路由器<ul><li>4个接口具有相同的网络地址10.0.0/24</li><li>地址空间10.0.0.0/8是在RFC 198中保留的三部分IP地址空间之一，用于家庭网络等专用网络或具有专用地址的地域，仅在给定的网络中才有意义</li></ul></li><li>NAT使能路由器对外界的行为如同一个具有单一IP地址的单一设备<ul><li>所有流向外界/进入家庭的报文都拥有同一个源/目的IP地址</li><li>NAT使能路由器对外界隐藏了家庭网络的细节</li></ul></li><li>NAT转化表<ul><li>NAT收到家庭主机发送向外界的数据报后，为其生成一个新的源端口号，将源IP替代为其广域网一侧接口的IP地址，且将源端口号替换为新生成的端口号</li><li>端口号字段16字节，NAT协议可支持超过60000个并行使用路由器广域网一侧单个IP地址的连接</li><li>路由器中的NAT在其NAT转换表中增加一个表项，记录WAN端和LAN段IP地址及端口的对应关系</li></ul></li></ul><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h3 id="数据报格式-1"><a href="#数据报格式-1" class="headerlink" title="数据报格式"></a>数据报格式</h3><p><img src="/2019/10/12/network-notes/ipv6.png" alt=""></p><p>定长<strong>40字节(320比特)</strong>首部</p><ul><li>版本(4比特)：标识IP版本号，IPv6将其设置为6<ul><li>设置为4不能得到合法的IPv4数据报</li></ul></li><li>流量类型(8比特)：与IPv4的TOS类似，使不同类型的IP数据报能相互区别开来</li><li>流标签(20比特)：标识一条数据报的流<ul><li>对一条流中的某些数据报给出优先权</li><li>也能够用来对来自某些应用的数据报给出更高的优先权</li></ul></li><li><p>有效载荷长度(16比特无符号整数)：定长40字节数据报首部后的字节数量</p></li><li><p>下一个首部(8比特)：表示数据报中的内容要交付给哪个协议(e.g.TCP or UDP)，取值同IPv4</p></li><li>跳限制(8比特)：相当于IPv4的TTL，转发的每台路由器对该字段的值-1，到0自动丢弃</li><li>源地址和目的地址(各128比特)</li><li>数据</li></ul><h3 id="相对IPv4的变化"><a href="#相对IPv4的变化" class="headerlink" title="相对IPv4的变化"></a>相对IPv4的变化</h3><p>新增了：</p><ul><li>扩大的地址容量<ul><li>地址长度：32 bits -&gt; 128 bits</li><li>引入任播地址：可以使数据报交付给一组主机中的任意一个</li></ul></li><li>流定义</li></ul><p>删去了：</p><ul><li>分片/重新组装：因为太耗时了<ul><li>如果路由器收到的IPv6数据报太大不能转发到出链路上的话，路由器只需丢弃该数据报，并向发送方发回一个“分组太大”的ICMP差错报文</li><li>大大加快了IP转发速度</li></ul></li><li>首部检验和：因为太耗时了，而且多余</li><li>选项：不属于首部的一部分，但没有消失，可能出现在“下一个首部”指出的位置上<ul><li>使得IPv6的首部是定长的</li></ul></li></ul><h3 id="IPv4到IPv6的迁移"><a href="#IPv4到IPv6的迁移" class="headerlink" title="IPv4到IPv6的迁移"></a>IPv4到IPv6的迁移</h3><p><strong>建隧道</strong></p><p><img src="/2019/10/12/network-notes/tunnel.png" alt=""></p><p>隧道：两台IPv6路由器之间的中间IPv4路由器集合</p><ul><li>隧道发送端的IPv6节点(B)将整个IPv6数据报放到一个IPv4数据报中,将源地址设为自己，目的地址设为隧道接收端的IPv6节点(E)</li><li>中间的IPv4路由器照常转发IPv4数据报</li><li>隧道接收端通过观察IPv4数据报中<strong>协议号字段</strong>是41确定该数据报含有一个IPv6数据报，并将其取出</li></ul><h2 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h2><p>链路层和路由器的中间盒(e.g.防火墙、NAT、深度分组检测DPI等)过多，需要一个统一的设备来提供功能——分组交换机</p><p>匹配加动作表(在OpenFlow中称为流表)</p><ul><li>远程控制器计算、安装和更新</li><li>包括：首部字段值的集合、计数器集合(当分组与流表项匹配是更新计数值)、匹配时所采取的动作集合</li></ul><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p><img src="/2019/10/12/network-notes/openflow.png" alt=""></p><p>(据说不考，先不抄了)</p><h1 id="CH5-网络层：控制平面"><a href="#CH5-网络层：控制平面" class="headerlink" title="CH5 网络层：控制平面"></a>CH5 网络层：控制平面</h1><h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><p>目的：从发送方到接收方的过程中确定一条通过路由器网络的好的路径(等价于路由)</p><ul><li><ul><li>集中式路由选择算法：具有全局状态信息的算法，必须知道每条链路的开销，常被称为链路状态(LS)算法</li><li>分布式路由选择算法：以迭代、分布式的方式计算最小开销路径，每个节点只有与其相邻节点的信息</li></ul></li><li><ul><li>静态路由选择算法：路由随时间变化缓慢</li><li>动态路由选择算法：随着网络流量负载或拓扑发生变化而改变路由选择路径</li></ul></li><li><ul><li>负载敏感算法：链路开销会动态地变化反映出底层链路的当前拥塞水平</li><li>负载迟钝算法</li></ul></li></ul><h3 id="链路状态路由选择算法"><a href="#链路状态路由选择算法" class="headerlink" title="链路状态路由选择算法"></a>链路状态路由选择算法</h3><p>输入：让每个节点向网络中所有其他节点广播链路状态分组——链路状态广播算法<br><strong>Dijksra算法</strong><br><img src="/2019/10/12/network-notes/ls.png" alt=""><br>最差情况下复杂性为$O(n^2)$</p><p>问题：链路开销非对称，即链路开销对应于承载的流量<br>会出现振荡：所有的流量都被导向同一个方向<br>路由器的自同步：即使它们在初始时以同一周期但在不同时刻执行算法，算法执行时机最终会在路由器上变为同步并保持<br>解决方案：让每台路由器发送链路通告的时间随机化</p><h3 id="距离向量-DV-路由选择算法"><a href="#距离向量-DV-路由选择算法" class="headerlink" title="距离向量(DV)路由选择算法"></a>距离向量(DV)路由选择算法</h3><p>分布式的、迭代的（能自我终止）、异步的<br>距离向量：$\bf{D}_x$$=\left[D_x(x), D_x(y), D_x(z) \right]$<br><strong>Bellman-Ford算法</strong><br>Bellman-Ford方程：$d_x(y)=\min_v{c(x,v)+d_v(y)}$<br><img src="/2019/10/12/network-notes/dv.png" alt=""></p><p>每个节点等待来自任何邻居的更新，当接收到一个更新时计算它的新距离向量并向它的邻居分布其新距离向量</p><p>当一个节点检测到从它自己到邻居的链路开销发生变化时，它就更新其距离向量——可能会出现路由选择环路：y通过z到x，同时z通过y到x<br>因为开销改变的链路在其他节点的距离表中的信息仍没有被抹去</p><p>链路开销的增加会导致坏消息传播得很慢——无穷计数问题</p><p>毒性逆转：撒谎设置$D_z(x)=\infty$，这样y就永远不会试图经由z路由选择到x<br>Wiki: In computer networking, split-horizon route advertisement is a method of preventing routing loops in distance-vector routing protocols by prohibiting a router from advertising a route back onto the interface from which it was learned.(从哪里学习来的，就拒绝发回到哪里去)<br>依然无法解决无穷计数问题</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table><thead><tr><th style="text-align:center">维度</th><th style="text-align:center">LS</th><th style="text-align:center">DV</th></tr></thead><tbody><tr><td style="text-align:center">报文复杂性</td><td style="text-align:center">发送$O(\</td><td style="text-align:center">NE\</td><td>)$个报文，每次改变向所有节点发送新开销</td><td>每次迭代邻居间交换报文</td></tr><tr><td style="text-align:center">收敛速度</td><td style="text-align:center">还行(?)，多项式时间</td><td style="text-align:center">收敛较慢，且会出现路由选择环路</td></tr><tr><td style="text-align:center">健壮性</td><td style="text-align:center">路由器某种程度上分离</td><td style="text-align:center">一个不正确节点的计算值会扩散到整个网络</td></tr></tbody></table><h2 id="因特网自治系统内部的路由选择：OSPF"><a href="#因特网自治系统内部的路由选择：OSPF" class="headerlink" title="因特网自治系统内部的路由选择：OSPF"></a>因特网自治系统内部的路由选择：OSPF</h2><p>规模(无穷计数)和管理自治(ISP按自己意愿运行路由器)问题——解决：自治系统(AS)<br>每个AS由一组通常处在相同管理控制下的路由器组成<br>一个自治系统由其全局唯一的AS号(ASN)所标识，ASN由ICANN区域注册机构发放</p><p>OSPF：开放最短路优先，Open Shortest Path First<br>开放：公众可用<br>LS协议，使用洪泛链路状态信息和Dijkstra最短路径算法<br>各条链路开销为网络管理员手动配置</p><ul><li>路由器向AS内所有其他路由器广播路由选择信息</li><li>每当一条链路状态发生变化时，路由器就会广播链路状态信息；即使未变化，也会至少每隔30min一次广播链路状态——增加鲁棒性</li><li>OSPF报文由IP承载，对上层协议的值为89，因此OSPF协议必须自己实现诸如可靠报文传输、链路状态广播等功能。</li><li>还要检查链路正在运行(通过向邻居发送HELLO报文)，并允许OSPF路由器获得相邻路由器的网络范围链路状态的数据库</li></ul><p>优点：</p><ul><li>安全：能鉴别和加密(简单的orMD5)</li><li>支持选择多条相同开销的路径</li><li>对单播与多播路由选择的综合支持</li><li>支持在单个AS中的层次结构<ul><li>区域边界路由器：为流向该区域以外的分组提供路由选择</li><li>主干区域：为该AS中其他区域之间的流量提供路由选择，所有区域边界路由器+一些非边界路由器</li></ul></li></ul><h2 id="AS间的路由选择协议：BGP"><a href="#AS间的路由选择协议：BGP" class="headerlink" title="AS间的路由选择协议：BGP"></a>AS间的路由选择协议：BGP</h2><p>BGP：边界网关协议, Broder Gateway Protocol<br>分布式、异步<br>分组不是路由到特定地址，而是路由到CIDR化的前缀，每个前缀表示一个子网或一个子网的集合</p><p>BGP为每台路由器提供了一种完成以下任务的手段：</p><ul><li>从邻居AS获得前缀的可达性信息</li><li>确定到该前缀的“最好的”路由</li></ul><h3 id="通告BGP路由信息"><a href="#通告BGP路由信息" class="headerlink" title="通告BGP路由信息"></a>通告BGP路由信息</h3><p>对于每个AS，每台路由器要么是一台网关路由器，要么是一台内部路由器。<br>网关路由器：位于AS边缘，直接连接到在其他AS中的路由器<br>内部路由器：仅连接在它自己AS中的主机和路由器</p><p>每对路由器通过使用179端口的半永久TCP连接交换路由选择信息。<br>每条直线连接以及所有通过该连接发送的BGP报文，称为<strong>BGP连接</strong><br>跨越两个AS的BGP连接称为<strong>外部BGP连接</strong>(eBGP)<br>在相同AS中的两台路由器之间的BGP称为<strong>内部BGP连接</strong>(iBGP)<br>直接连接在不同AS中的网关路由器的每条链路通常有一条eBGP连接，在每个AS中的路由器之间还有多条iBGP连接，iBGP连接不总是与物理链路对应</p><p>前缀中包含一些BGP属性<br>前缀+其属性称为路由</p><ul><li>AS-PATH属性：包含了通告已经通过的AS的列表<ul><li>当一个前缀通过某AS时，该AS将其ASN加入AS-PATH的现有列表</li><li>BGP路由器还使用AS-PATH属性来检测和防止通告环路，如果一台路由器在路径列表中看到了包含它自己的AS，则它将拒绝该通告</li></ul></li><li>NEXT-HOP属性：AS-PATH起始路由器接口的IP地址（到达前缀$x$路径上的第一台路由器的地址</li></ul><h3 id="热土豆路由选择"><a href="#热土豆路由选择" class="headerlink" title="热土豆路由选择"></a>热土豆路由选择</h3><p><s>实际上明明是烫手山芋</s></p><p>从所有可能的路由中选择到开始该路由的NEXT-HOP路由器具有最小开销的路由<br>路由器尽可能快地将分组送出其AS，而不担心AS外部到目的地的余下部分的开销<br>对于在相同AS中的两台路由器，可能对相同前缀选择两条不同的AS路径</p><h3 id="路由选择算法-1"><a href="#路由选择算法-1" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p>输入：到某前缀的所有路由的集合</p><p>当有多条路由时，顺序调用以下消除规则：</p><ul><li>路由被指派一个<strong>本地偏好</strong>值属性。该属性为策略决定，取决于网管，高的被优先选择（可能会有多条）。</li><li>从余下的路由中选择具有<strong>最短AS-PATH</strong>的路由。如果这是唯一路由选择规则，使用DV算法决定路径，其中距离测度为AS跳的跳数。</li><li>从余下的路由中使用热土豆路由选择，即最靠近NEXT-HOP路由器的路由</li><li>如果仍留下多条路由，使用BGP标识符来选择路由</li></ul><h3 id="IP任播"><a href="#IP任播" class="headerlink" title="IP任播"></a>IP任播</h3><p>通常用于DNS中<br>DNS服务器为多台服务器指派相同的IP地址，并且使用标准的BGP从这些服务器来通告该IP地址。<br>当某台BGP路由器收到对于该IP地址的多个路由通告，它将这些通告处理为对相同的物理位置提供不同的路径。<br>当配置其路由表时，每台路由器将本地化地使用BGP路由选择算法来挑选到该IP地址的“最好的”路由。<br>无论客户位于何处，当想向DNS服务器的某个IP地址发送一个请求时，因特网路由器则向那个“最近的”服务器转发该请求分组，最近的服务器是有BGP路由选择算法所定义的。</p><h3 id="路由选择策略"><a href="#路由选择策略" class="headerlink" title="路由选择策略"></a>路由选择策略</h3><p>多宿接入ISP：经由两个不同的ISP连接到网络的其余部分的<br>经验法则：任何穿越某ISP主干网的流量必须是其源或目的（或两者）位于该ISP的某个客户网络中</p><h2 id="5-6-ICMP因特网控制报文协议"><a href="#5-6-ICMP因特网控制报文协议" class="headerlink" title="5.6 ICMP因特网控制报文协议"></a>5.6 ICMP因特网控制报文协议</h2><ul><li>ICMP报文<ul><li>用于主机和路由器彼此沟通网络层信息</li><li>承载在IP分组中</li><li>类型字段+编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8个字节</li></ul></li><li>ping<ul><li>发送一个ICMP类型8编码0（回显请求）到指定主机</li><li>目的主机发回一个类型0编码0的ICMP回显应答</li></ul></li><li>traceroute<ul><li>跟踪从一台主机到世界上任意一台主机之间的路由</li><li>源主机发送一些列数据报，每个都携带一个具有不可达UDP端口号的UDP报文段，且第$n$个数据报的TTL为$n$</li><li>第$n$台路由器丢弃该数据报并发送一个ICMP告警报文（类型11编码0）给源主机</li><li>目的主机会向源主机发送一个端口不可达的ICMP报文（类型3编码3），源主机收到时就知道不需要再发送另外的探测分组。</li></ul></li></ul><h1 id="CH3-运输层"><a href="#CH3-运输层" class="headerlink" title="CH3 运输层"></a>CH3 运输层</h1><p>运输层为运行在不同主机上的应用程序之间提供了<strong>逻辑通信</strong>功能。通过逻辑通信，运行不同进程的主机好像直接相连一样。<br>应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些报文的物理基础设施的细节。</p><p>运输层只工作在端系统中。在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（即网络层）。<br>运输层能够提供的服务常常受制于底层网络协议的服务模型（带宽时延等），但底层网络协议不可靠、非机密性的情况下，运输层也能提供可靠性和机密性。</p><p>UDP和TCP最基本的责任是：将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。<br>将主机间交付扩展到进程间交付被称为运输层的<strong>多路复用</strong>与<strong>多路分解</strong><br>网络层：主机$\Leftrightarrow$主机<br>运输层：进程$\Leftrightarrow$进程</p><h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><p>进程使用套接字作为与网络交互数据的门户，运输层将数据交付给套接字。<br>每个套接字有唯一标识符，标识符格式取决于它是UDP还是TCP套接字。</p><p>每个运输层报文段中具有几个字段。<br><strong>多路分解</strong>：（拆包）将运输层报文段中的数据交付到正确的套接字<br><strong>多路复用</strong>：（打包）从源主机的不同套接字中收集数据块，并为每个数据块封上首部信息从而生成报文段，然后将报文段传递到网络层</p><p>套接字要有唯一标识符、每个报文段有特殊字段来只是该报文段所要交付到的套接字，特殊字段即<strong>源端口号字段&amp;目的端口号字段</strong></p><p>端口号</p><ul><li>16比特数，大小在0~65535</li><li>0~1023称为<strong>周知端口号</strong>，保留给注入HTTP（80）和FTP（21）之类的周知应用层协议</li><li>开发新应用程序时必须为其分配一个端口号</li></ul><h3 id="UDP的多路复用与多路分解"><a href="#UDP的多路复用与多路分解" class="headerlink" title="UDP的多路复用与多路分解"></a>UDP的多路复用与多路分解</h3><p>创建套接字时，端口号有两种产生方式：</p><ul><li>运输层自动为套接字分配一个端口号，从1024~65535内选择一个当前未被该主机中任何其他UDP端口使用的号</li><li>通过套接字<code>bind()</code>(Python)方法为这个UDP套接字关联一个特定的端口号<br>通常应用程序自动，服务器手动</li></ul><p>一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号。<br>因此只要两个UDP报文段具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。</p><p>源端口号用于接收方发回给发送方</p><h3 id="TCP的多路复用与多路分解"><a href="#TCP的多路复用与多路分解" class="headerlink" title="TCP的多路复用与多路分解"></a>TCP的多路复用与多路分解</h3><p>TCP套接字由四元组（源IP地址、源端口号、目的IP地址、目的端口号）来标识<br>与UDP不同，两个不同源IP和或源端口号的TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求</p><ul><li>TCP服务器应用程序有一个“欢迎套接字”，在某个特定端口上等待来自TCP客户的连接建立请求</li><li>TCP客户创建一个套接字并发送一个连接建立请求报文段</li><li>一条连接建立请求只不过是一个目的端口号为12000，TCP首部的特定“连接建立位”置位的TCP报文段，这个报文段也包含一个由客户选择的源端口号</li><li>当运行服务器进程的计算机的主机操作系统接收到具有目的端口号为12000的入连接请求报文段后，它就定位服务器进程，该进程正在端口号12000等待接收连接。该服务器进程会创建一个新的套接字。</li><li>新创建的报文设置好4个标识符，之后的报文段按照这4个标识符来定向。</li></ul><p>服务器主机支持很多并行的TCP套接字，每个套接字与一个进程相联系。</p><p>连接套接字与进程之间并非总是有着一一对应的关系（线程</p><h2 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h2><p>发送方和接收方的运输层实体之间没有握手——无连接的</p><p>e.g.DNS通常使用UDP应用层协议</p><h3 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h3><ul><li>关于发送什么数据以及何时发送的应用层控制更为精细。<ul><li>实时应用通常要求最小发送速率，不希望过分地延迟报文段的传送，且能容忍一些数据丢失</li></ul></li><li>无须连接建立，不会引入建立连接的时延</li><li>无连接状态，节约存储空间，可以支持更多活跃用户。</li><li>分组首部开销小，TCP20字节，UDP8自己</li></ul><h3 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h3><p><img src="/2019/10/12/network-notes/udp.png" alt=""></p><ul><li>源端口号/目的端口号（各16比特）</li><li>长度（16比特）：首部+数据的字节数</li><li>检验和</li><li>应用数据</li></ul><h3 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h3><p>实际包括一些IP首部字段，此处忽略</p><p>16比特字的反码运算，求和时遇到的任何溢出都被回卷（加到末尾去）<br>详见作业题CH6 P3</p><p>端到端原则：如果端到端传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测<br>“与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的”</p><p>不进行差错恢复，只能丢弃/交给应用程序并发出警告</p><h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>可靠数据传输协议服务抽象：数据通过可靠信道传输，传输数据比特不会受到损坏或丢失，而且所有数据都是按照其发送顺序进行交付</p><p>前提假设：底层信道不会对分组重排序</p><h3 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h3><p>肯定确认(ACK), 否定确认(NAK)<br>自动重传请求(ARQ)<br>停等协议：除非发送方确信接收方已经正确接收当前分组，否则发送方将不会发送一块新数据<br>一个ACK丢失、或者只是该分组或ACK过度延时，发送方都进行重传<br>比特交替协议：rdt3.0</p><h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><p> 停等协议：发送方利用率低</p><p>$$U_{\text{sender}}=\frac{L/R}{RTT+L/R}$$</p><p>流水线：不以停等方式运行，允许发送放发送多个分组而无须等待确认</p><h4 id="回退N步（GBN）"><a href="#回退N步（GBN）" class="headerlink" title="回退N步（GBN）"></a>回退N步（GBN）</h4><p>$N$：在流水线中未确认分组数的最大允许数</p><p>base：最早未确认分组的序号</p><p>nextseqnum: 最小的未使用序号（即下一个待发分组的序号</p><p>GBN也称滑动窗口协议，$N$也被称为窗口长度</p><p>分组序号用$k$位表示，所有涉及序号的运算采用模$2^k$运算</p><p><img src="/2019/10/12/network-notes/gbn_snd.png" alt=""></p><p><img src="/2019/10/12/network-notes/gbn_rcv.png" alt=""></p><p>GBN发送方必须响应三种类型的事件：</p><ul><li>上层的调用</li><li>收到一个ACK。 累积确认</li><li>超时事件。发送方重传所有已发送单未被确认过的分组。</li></ul><p>GBN接收方：</p><ul><li>如果正确接到一个按序分组，则为该分组发送一个ACK</li><li>否则丢弃该分组，并为最近按序接收的一个分组重新发送ACK</li><li>丢弃所有失序分组</li></ul><p>发送方维护窗口的上下边界及nextseqnum在该窗口中的位置</p><p>接收方维护下一个按序接收的分组的序号(expectedseqnum)</p><p>问题：单个分组的差错就能引起重传大量分组，许多分组根本没有必要重传</p><h4 id="选择重传（SR）"><a href="#选择重传（SR）" class="headerlink" title="选择重传（SR）"></a>选择重传（SR）</h4><p>发送方：</p><ul><li>从上层收到数据。检查下一个可用于该分组的序号，如果序号位于发送方窗口内，则将数据打包发送。</li><li>超时。每个分组有自己的逻辑定时器，超时发生后只发送一个分组。</li><li>收到ACK。如果收到ACK的序号在窗口内，则SR发送方将那个被确认的分组标记为已接收。如果该分组序号等于send base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。</li></ul><p>接收方：</p><ul><li>序号在$[$rcv_base, rcv_base+$N$-1$]$内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，一个选择ACK被会送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号，则该分组以及以前缓存的序号连续的分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。</li><li>序号在$[$rcv_bas-$N$,  rcv_base-1$]$内的分组被正确收到。必须产生一个ACK，即使该分组是接收方以前已确认过的分组。（如果不确认，则发送窗口将永远不能向前滑动）</li><li>其他情况。忽略该分组。</li></ul><p>SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组皆被收到为止。</p><p>SR协议对于哪些分组已经被正确接收，哪些没有，发送方和接收方并不总是能看到相同的结果。发送方和接收方的窗口并不总是一致。</p><p>窗口长度必须小于等于序号空间大小的一半。</p><p>考虑分组重排</p><ul><li>当连接两端的信道是一个网络时会发生</li><li>信道可以看成基本上是在缓存分组，并在将来任意时刻自然地释放出这些分组。</li><li>通过假定一个分组在网络中“存活”的时间不会超过某个固定最大时间量来做到这一点。</li></ul><h2 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h2><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>两个进程在发送数据之前必须先相互“握手”，即它们必须互相发送某些预备报文段，以建立确保数据传输的参数</p><p>TCP连接是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中，中间网络元素不会维持TCP连接状态。</p><ul><li>全双工服务（full-duplex service）：如果进程A与进程B存在一条TCP连接，则应用层数据可以在这两台主机间双向流动</li><li>点对点：单个发送方与单个接收方之间的连接</li></ul><p>发起连接的称为客户进程，另一个进程被称为服务器连接</p><ul><li>客户进程通过套接字（该进程之门）传递数据流，TCP将这些数据引导到该连接的<strong>发送缓存</strong>里</li><li>TCP会时不时从发送缓存里取出一块数据，并将数据传递到网络层<ul><li>TCP可放入报文段的最大数据数量受限于<strong>最大报文段长度</strong>(MSS)</li><li>MSS通常根据最初确定的由本地发送主机的最大链路层帧长度（最大传输单元MTU）来设置</li><li>MSS要保证一个TCP报文段+TCP/IP首部长度（通常40字节）小于等于单个链路层帧长度</li><li>MSS指报文段里<strong>应用层数据</strong>的最大长度，不包括首部</li></ul></li><li>TCP在另一端接收到报文段后，该报文段的数据就被放入该TCP连接的接收缓存中</li></ul><p>TCP连接组成包括：两台主机上的缓存、变量与进程连接的套接字</p><h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="/2019/10/12/network-notes/tcp.png" alt=""></p><ul><li>源端口号和目的端口号（各16比特）</li><li>序号和确认号（各32比特）：用来实现可靠数据传输服务</li><li>接收窗口字段（16比特）：用于流量控制，表示接收方 愿意接收的字节数量</li><li>首部长度字段（4比特）：指示了以32比特为单位的TCP首部长度。TCP首部长度可变，但通常是20字节。</li><li>标志字段（6比特）：一些flag<ul><li>ACK：用于指示确认字段中的值是有效的</li><li>RST、SYN、FIN：用于连接的建立和拆除</li><li>CER、ECE：明确拥塞通告中使用</li><li>PSH：指示接收方应该立即将数据交给上层</li><li>URG：指示报文段里存在着被发送端的上层实体置为“紧急的数据”，紧急数据指针指出紧急数据的最后一个字节。当紧急数据存在并给出紧急数据指针时，TCP必须通知接收端的上层实体。</li></ul></li><li>因特网检验和（16比特）</li><li>可选与变长的选项字段：用于发送方与接收方协商MSS，或在高速网络环境下用作窗口调节因子</li></ul><h4 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h4><p>TCP把数据看成无结构的、有序的字节流。一个报文段的序号是该报文段首字节的字节流编号。</p><p>主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。</p><p>TCP只确认流中至第一个丢失字节为止的字节，这个称为提供<strong>累计确认</strong>。    </p><p>主机在一条TCP连接中收到失序报文段视为UB。</p><p>一条TCP连接的双方均可随机地选择初始号。</p><p>和（16比特）</p><p>可选与变长的选项字段：用于发送方与接收方协商MSS，或在高速网络环境下用作窗口调节因子举例：Telnet的回显</p><p><img src="/2019/10/12/network-notes/telnet.png" alt=""></p><p>（解释见书p157)</p><p>对客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段，这种确认被称为是被<strong>捎带</strong>在服务器到客户的数据报文段中的。</p><h3 id="往返时间估计与超时"><a href="#往返时间估计与超时" class="headerlink" title="往返时间估计与超时"></a>往返时间估计与超时</h3><ul><li>报文段的样本RTT(SampleRTT)：从某报文段被发出大多数TCP仅在某个时刻做一次SampleRTT测量<ul><li>在任意时刻，仅为一个已发送但目前尚未被确认的报文段估计SampleRTT，从而产生一个接近每个RTT值的新SampleRTT</li><li>TCP绝不为已被重传的报文段计算SampleRTT，仅为传输一次的报文段测量</li></ul></li><li>EstimatedRTT：TCP维护的SampleRTT的均值，为了应对SampleRTT的波动<ul><li>一旦获得新的SampleRTT，更新公式为 $$\text{EstimatedRTT}=(1-\alpha)\cdot\text{EstimatedRTT}+\alpha\cdot\text{SampleRTT}$$，$\alpha$的推荐值为0.125(1/8)</li><li>EstimatedRTT是对SampleRTT的<strong>指数加权移动平均</strong>（EWMA，Exponential Weighted Moving Average），指一个给定的SampleRTT的权值在更新过程中呈指数型快速衰减</li></ul></li><li>DevRTT：RTT偏差，用于估算SampleRTT一般会偏离EstimatedRTT的程度<ul><li>计算公式为$$\text{DevRTT}=(1-\beta)\cdot\text{DevRTT}+\beta\cdot|\text{SampleRTT}-\text{EstimatedRTT}|$$，$\beta$的推荐取值为0.25</li></ul></li><li>超时间隔TimeoutInterval：EstimatedRTT加上一定余量，与SampleRTT的波动正相关<ul><li>计算公式为$$\text{TimeoutInterval}=\text{EstimatedRTT}+4\cdot\text{DevRTT}$$</li><li>推荐的TimeoutInterval的初始值为1s</li><li>当出现超时后，TimeoutIntetval将加倍，以免即将被确认的后继报文段过早出现超时。</li><li>只要收到报文段并更新EstimatedRTT，就更新TimeoutInterval</li></ul></li></ul><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>TCP的差错恢复机制是GBN和SR的混合体</p><p>发送方：switch(事件)</p><ul><li><p>从上面应用程序接收到数据</p><ul><li>生成具有序号NextSeqNum的TCP报文段</li><li>如果定时器没有运行，启动定时器</li><li>向IP传递报文段</li><li>NextSeqNum=NextSeqNum+length(data)</li></ul></li><li><p>定时器超时</p><ul><li>重传具有最小序号但仍未应答的报文段</li><li>超时间隔<s>超级</s>加倍</li><li>启动定时器</li></ul></li><li><p>收到ACK，ACK字段值为y</p><ul><li><p>如果 y&gt;SendBase，则该ACK是在确认一个或多个先前未确认的报文段</p><ul><li>更新SendBase</li><li>如果当前有未被确认的报文段，  重新启动定时器</li></ul></li><li><p>如果 y&lt;=SendBase，则该ACK是对已经确认的报文段的一个冗余ACK</p><ul><li>如果累计收到相同ACK值的3个冗余ACK（累计4个相同ACK），则重新发送具有序号y的报文段（快速重传）</li></ul></li></ul></li></ul><p>接收方：  <img src="/2019/10/12/network-notes/tcp_rcv.png" alt=""></p><p>超时间隔加倍提供了一个形式受限的拥塞控制，因为定时器过期很可能是网络拥塞引起的。</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>冗余ACK：再次确认某个报文段的ACK</p><p>当TCP接收方接收到一个序号大于下一个所期望按序报文段的报文段时，就说明有报文段丢失，因此会产生一个冗余ACK对已经收到的最后一个按序字节数据进行重复确认。</p><p>如果发送方接收到对相同数据的3个冗余ACK，就将其视为一种指示，说明这个被确认了3次的报文段之后的报文段已经被丢失。发送方会进行<strong>快速重传</strong>，即在该报文段的定时器过期之前重传丢失的报文段。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>接收方如果读数据不够快，就会导致接收缓存溢出。TCP提供了<strong>流量控制服务</strong>以消除发送方使接收方缓存溢出的可能性。（区分流量控制与拥塞控制）</p><p>TCP发送方维护一个称为<strong>接收窗口</strong>的变量，指示接收方还有多少可用空间，需要满足</p><ul><li>$$\text{LastByteRcvd}-\text{LastByteRead}\le \text{RcvBuffer}$$</li><li>接收窗口长度用rwnd表示，$$\text{rwnd}=\text{RcvBuffer}-[\text{LastByteRcvd}-\text{LastByteRead}]$$</li><li>$$\text{LastByteSent}-\text{LastByteAcked}\le\text{rwnd}$$</li><li>人话：主机Ａ发送但未被确认的数据大小　不会超过　主机Ｂ接收缓存的剩余可用空间</li></ul><p>为了防止主机A被阻塞，当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存开始清空，并且确认报文里包含一个非0的rwnd值。</p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><h4 id="建立TCP连接：三次握手"><a href="#建立TCP连接：三次握手" class="headerlink" title="建立TCP连接：三次握手"></a>建立TCP连接：三次握手</h4><p><img src="/2019/10/12/network-notes/start_tcp.png" alt=""></p><ul><li>第一步：客户端的TCP向服务器的TCP发送一个<strong>SYN报文段</strong>。首部中SYN标志位被置为1。客户随机选择一个初始序号（client_isn），并将此序号放置于SYN报文段的序号字段。该报文段不包含应用层数据。</li><li>第二步：服务器主机收到该TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段（<strong>SYNACK报文段</strong>）。该报文段不包含应用层数据。SYN比特被置为1。首部确认号字段为client_isn+1。服务器选择自己的初始序号（server_isn），并将其放到序号字段中。</li><li>第三步：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机向服务器发送另一个报文段，将server_isn+1放到首部的确认字段，来对服务器的允许连接的报文段进行确认。连接已经建立了，所以SYN比特被置为0，且之后的每一个报文段的SYN比特都为0。该报文段可以携带应用层数据。</li></ul><h3 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h3><p><img src="/2019/10/12/network-notes/close_tcp.png" alt=""></p><ul><li>客户进程发出一个关闭连接命令，引起客户TCP向服务器进程发送一个特殊的TCP报文段。该报文段首部FIN比特被置为1。</li><li>服务器接收到该报文段后，向发送方回送一个ACK报文段。</li><li>然后，服务器发送自己的终止报文段，FIN置为1。</li><li>最后，客户对这个服务器的终止报文段进行确认。此时，两台主机上用于该连接的所有资源都被释放了。</li></ul><h4 id="TCP状态"><a href="#TCP状态" class="headerlink" title="TCP状态"></a>TCP状态</h4><p><img src="/2019/10/12/network-notes/tcp_client.png" style="zoom:70%;"></p><p><img src="/2019/10/12/network-notes/tcp_server.png" style="zoom:70%;"></p><p>如果一台主机接收到的一个TCP报文段端口号或源IP地址与该主机上进行中的套接字都不匹配，则该主机向源发送一个特殊重置报文段，RST标志被置为1。（“我没有那个报文段的套接字，请不要再发了。”）</p><h4 id="nmap端口扫描工具"><a href="#nmap端口扫描工具" class="headerlink" title="nmap端口扫描工具"></a>nmap端口扫描工具</h4><p>nmap对目标主机的某个端口发送一个特殊的TCP SYN数据报，有3种可能</p><ul><li>源主机从目标主机接收到一个TCP SYNACK报文段。这意味着目标主机上一个应用程序使用该TCP端口运行，nmap返回“打开”。</li><li>源主机从目标主机接收到一个TCP RST报文段。这意味着目标主机上没有一个应用程序使用该TCP端口运行，但至少发送向该端口的报文段没有被防火墙阻拦。</li><li>源什么也没有收到。防火墙GG。</li></ul><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h3 id="情况1：两个发送方和一台具有无穷大缓存的路由器"><a href="#情况1：两个发送方和一台具有无穷大缓存的路由器" class="headerlink" title="情况1：两个发送方和一台具有无穷大缓存的路由器"></a>情况1：两个发送方和一台具有无穷大缓存的路由器</h3><p><img src="/2019/10/12/network-notes/case1.png" style="zoom:60%;"></p><p><img src="/2019/10/12/network-notes/case1_2.png" style="zoom:60%;"></p><ul><li>图一为每连接的吞吐量（接收方每秒接收的字节数）与该连接发送速率之间的函数关系。上限$R/2$是由共享链路容量造成的。</li><li>图二为时延与发送速率的关系。当发送速率接近$R/2$时，平均时延就会越来越大。当发送速率超过$R/2$，路由器中 的平均排队分组数就会无限增长。</li><li>当分组到达的速率接近链路容量时，分组会经历巨大的排队时延。</li></ul><h3 id="情况2：两个发送方和一台具有有限缓存的路由器"><a href="#情况2：两个发送方和一台具有有限缓存的路由器" class="headerlink" title="情况2：两个发送方和一台具有有限缓存的路由器"></a>情况2：两个发送方和一台具有有限缓存的路由器</h3><p><img src="/2019/10/12/network-notes/case2.png" style="zoom:60%;"></p><p>$\lambda_{in}$（字节/秒）：应用程序将初始数据发送到套接字的速率</p><p>$\lambda_{in}’$：运输层想网络中发送报文段（初始+重传）的速率，又称<strong>供给载荷</strong></p><ul><li>图a为主机A成精，仅当路由器缓存空闲时发送分组的理想情况，平均速率不会超过$R/2$</li><li>图b为发送方仅当在确定了一个分组已经丢失时才重传的情况。$R/3$是术师数据，$R/2-R/3=R/6$是重传数据。说明拥塞时发送方必须执行重传以补偿因为缓存溢出而丢失的分组。</li><li>图c为发送方提前发生超时并重传未被丢失的分组。由于每个分组被转发两次，当其供给载荷接近$R/2$时，吞吐量接近$R/4$。说明拥塞时发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。</li></ul><h3 id="情况3-4个发送方和具有有限缓存的多台路由器及多跳路径"><a href="#情况3-4个发送方和具有有限缓存的多台路由器及多跳路径" class="headerlink" title="情况3:4个发送方和具有有限缓存的多台路由器及多跳路径"></a>情况3:4个发送方和具有有限缓存的多台路由器及多跳路径</h3><p><img src="/2019/10/12/network-notes/case3.png" style="zoom:60%;"></p><ul><li>对于较小的$\lambda_{in}$，$\lambda_{in}$的增大会导致$\lambda_{out}$的增大</li><li>当$\lambda_{in}$很大的时候，不同路径的流量会在同一个路由器上为有限缓存空间竞争，导致一条路径成功通过的流量越来越少。</li><li>在极限重载情况下，端到端吞吐量会趋近于0。</li><li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量全部木大了。</li></ul><h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><ul><li>端到端拥塞控制：网络没有为运输层拥塞控制提供显示支持</li><li>网络辅助的拥塞控制：路由器发送方提供关于网络中拥塞状态的显示反馈信息。可以用拥塞分组直接反馈给发送方，或通过标记接收方来的分组来通知发送方。</li></ul><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>让每一个发送方根据所感知到的网络拥塞成都来限制其发送流量的速率。</p><p>发送方TCP跟踪一个<strong>拥塞窗口</strong>变量cwnd，它对一个TCP发送方能向网络中发送流量的速率进行了限制。</p><p>$$\text{LastByteSent}-\text{LastByteAcked}\le\min{\text{cwnd},\text{rwnd}}$$</p><p>发送方的速率大概是cwnd/RTT字节/秒。</p><p>丢包事件：出现超时，或收到来自接收方的3个冗余ACK。此时发送方认为出现了拥塞指示。</p><p>自计时：TCP使用收到的ACK（或计时）增大它的拥塞窗口长度。</p><h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p>具体看图</p><p><img src="/2019/10/12/network-notes/congestion_control.png" alt=""></p><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><ul><li>当一条TCP连接开始时，cwnd通常设为一个MSS的较小值，初始发送速率大约为MSS/RTT。</li><li>每当传输的报文段首次被确认，cwnd增加一个MSS（指数增长</li><li>结束方式<ul><li>当cwnd==ssthresh时，结束慢启动并转移到拥塞避免模式。cwnd最多只能取到ssthresh，即使不是2的幂次</li><li>超时丢包（拥塞）：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2</li><li>检测到3个冗余ACK：执行一次快速重传并进入快速恢复状态</li></ul></li></ul><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul><li>每个RTT只将cwnd的值增加MSS。一种通用实现方法：发送方无论何时收到一个新的确认，就将cwnd增加一个$\text{MSS}\frac{\text{MSS}}{\text{cwnd}}$字节。</li><li>结束方式<ul><li>超时：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2</li><li>3个冗余ACK：cwnd减半，对收到的3个冗余ACK再加上3个MSS；将ssthresh的值改为cwnd/2；进入快速恢复状态</li></ul></li></ul><h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><ul><li>对于引起TCP进入快速恢复状态的缺失报文段，对每个收到的冗余ACK，cwnd增加一个MSS</li><li>当最终对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态</li><li>超时：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2，进入慢启动状态</li></ul><p>忽略慢启动，TCP的拥塞控制：每个RTT内线性增加1MSS，出现3个冗余ACK时cwnd减半——加性增，乘性减（AIMD）</p><h4 id="吞吐量-1"><a href="#吞吐量-1" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>一条连接的平均吞吐量$$=\frac{0.75\times W}{\text{RTT}}$$</p><ul><li>$W$：丢包事件发生时的窗口长度</li><li>TCP的发送速率大约是$w/RTT$,$w$为窗口长度</li><li>TCP的传输速率在$W/(2\times\text{RTT})$和$W/\text{RTT}$之间线性变化</li></ul><p>考虑丢包率（$L$）和MSS，一条连接的平均吞吐量$$=\frac{1.22\times\text{MSS}}{\text{RTT}\sqrt{L}}$$</p><h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>如果每条连接都得到相同份额的带宽，则认为该拥塞控制机制是公平的。</p><p><img src="/2019/10/12/network-notes/fair.png" style="zoom:50%;"></p><p>实际情况下具有较小RTT的连接能够更快地抢到可用带宽。</p><p>UDP是无法无天的，并行TCP连接是“作弊”</p><h1 id="CH9-多媒体网络"><a href="#CH9-多媒体网络" class="headerlink" title="CH9 多媒体网络"></a>CH9 多媒体网络</h1><h2 id="多媒体网络应用"><a href="#多媒体网络应用" class="headerlink" title="多媒体网络应用"></a>多媒体网络应用</h2><ul><li>视频的性质<ul><li>最显著的特点：高比特率</li><li>能被压缩。在视频质量与比特率间折中</li></ul></li><li>音频的性质<ul><li>脉冲编码调制(PCM)：数字信号速率=每秒的采样个数×每个样本的表示比特数</li></ul></li><li>多媒体网络应用的性质<ul><li>流式存储音频和视频<ul><li>流：边看边接收后续部分</li><li>相互作用：暂停、快进、快退</li><li>连续播放：减少帧停滞或帧跳过</li></ul></li><li>实时会话式语音<ul><li>因特网电话，IP语音（VoIP）</li><li><strong>定时考虑</strong>很重要，高度时延敏感</li><li>容忍丢包：偶尔的丢失只会在音频视频回放时出现干扰信号</li></ul></li><li>流式实况音频视频（直播）<ul><li>类似流式存储</li></ul></li></ul></li></ul><h2 id="流式存储视频"><a href="#流式存储视频" class="headerlink" title="流式存储视频"></a>流式存储视频</h2><p>三种形式的视频流，共同特点：广泛使用了客户端应用缓存，以此来缓解端到端时延的变化和服务器和客户之间可用带宽量的影响。</p><p><img src="/2019/10/12/network-notes/9-1.png" style="zoom:50%;"></p><p>客户缓存的优点：</p><ul><li>能够吸收服务器到客户端时延中的波动</li><li>如果服务器到客户端带宽暂时低于视频消耗速率，用户能够继续享受连续的播放，只要客户缓存没有耗尽</li></ul><h3 id="UDP流"><a href="#UDP流" class="headerlink" title="UDP流"></a>UDP流</h3><p>服务器通过UDP以一宗稳定的速率记录下视频块，用于客户的视频消耗速率相匹配的速率传输视频。<br>UDP流通常使用很小的客户端缓存，空间维持小于1s视频就够了。<br>服务器和客户间还并行地维护一个单独的控制连接，客户可发送有关会话状态变化的命令（暂停、重开、重定位等）。</p><p>不足：</p><ul><li>可用带宽变化且无法预测，恒定速率UDP流不能够提供连续的播放。</li><li>要求如RTSP服务器一样的媒体控制服务器，增加了部署的总体成本和复杂性。</li><li>许多防火墙和NAT阻塞UDP流量</li></ul><h3 id="HTTP流"><a href="#HTTP流" class="headerlink" title="HTTP流"></a>HTTP流</h3><p>视频直接作为具有一个特定URL（统一资源定位符）的普通文件存储在HTTP服务器上。<br>用户要看视频时，客户和服务器之间建立一个TCP连接，并且发送一个对该URL的HTTP GET请求，服务器尽可能快地发送该视频文件；客户端把字节收集在一个客户应用缓存中。一旦缓存数量超过预先设定的阈值就开始播放。</p><ul><li><strong>预取</strong>视频：客户能够尝试以高于消耗速率的速率下载视频，预取将来会被消耗的视频帧。</li><li><strong>客户端应用缓存和TCP缓存</strong>：<ul><li><img src="/2019/10/12/network-notes/9-2.png" style="zoom:50%;"></li><li>暂停期间，客户缓存会变满，对服务器造成“反向压力”。服务器被阻塞，直到用户恢复该视频。因此服务器发送速率不能比客户端视频消耗速率更高。一个满的客户应用缓存间接地对服务器到客户能够发送的视频速率增加了限制。</li></ul></li><li>流式视频的分析<ul><li>$B$：客户端应用缓存的长度（比特）；$Q$：客户应用缓存开始播放之前必须被缓存的比特数量；$r$：视频消耗速率；$x$：服务器发送速率</li><li>初始缓存时延$t_p=Q/x$</li><li>客户应用缓存变慢时间$t_f$：显然。</li></ul></li><li>视频的早期中止和定位<ul><li>利用HTTP GET请求报文中的<strong>HTTP字节范围首部</strong>：指示了客户当前要从所希望的视频中获取的字节范围。</li><li>当用户重新定位到一个新位置时，客户发送一个新的HTTP请求，用字节范围首部指出服务器应当从文件的哪个字节起发送数据</li><li>预取的数据没看会导致网络带宽和服务器资源的浪费，因此许多流系统仅使用长度适当的客户应用缓存或者限制字节范围首部预取的视频数量。</li></ul></li></ul><h2 id="IP语音"><a href="#IP语音" class="headerlink" title="IP语音"></a>IP语音</h2><h3 id="尽力而为的服务限制"><a href="#尽力而为的服务限制" class="headerlink" title="尽力而为的服务限制"></a>尽力而为的服务限制</h3><p>什么时候播放一个块&amp;如何处理一个丢失块</p><h4 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h4><p>TCP的重传机制增加了端到端时延，拥塞控制可能导致“缓存饥饿”，因此所有现有的VoIP应用默认运行在UDP上</p><h4 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h4><p>时延超过某阈值的分组等效于丢弃</p><h4 id="分组时延抖动"><a href="#分组时延抖动" class="headerlink" title="分组时延抖动"></a>分组时延抖动</h4><p>时延抖动：不同的分组端到端时延可能会有波动<br>通常可以通过序号、时间戳和播放时延来消除</p><h3 id="在接收方消除音频的时延抖动"><a href="#在接收方消除音频的时延抖动" class="headerlink" title="在接收方消除音频的时延抖动"></a>在接收方消除音频的时延抖动</h3><p>通常结合以下两种机制：</p><ul><li>每个块预先计划一个时间戳</li><li>在接收方延迟播放块</li></ul><h4 id="固定播放时延"><a href="#固定播放时延" class="headerlink" title="固定播放时延"></a>固定播放时延</h4><p>接收方试图在块产生正好$q$ms后播放它<br>如果端到端时延经常发生比较大的变化，用一个大的$q$更好；如果时延很小并且时延变化也很小，用一个较小的、可能小于150ms的$q$更好</p><h4 id="适应性延迟播放"><a href="#适应性延迟播放" class="headerlink" title="适应性延迟播放"></a>适应性延迟播放</h4><p>目标：播放时延最小化，使丢包低于一定的百分比<br>估计网络时延和变化，在每个话音突峰期的开始相应地调整播放时延</p><ul><li>$t_i$：第$i$个分组的时间戳，该分组在发送方产生的时间</li><li>$r_i$：分组$i$被接收方接收的时间</li><li>$p_i$：分组$i$在接收方播放的时间</li><li>$d_i=(1-u)d_{i-1}+u(r_i-t_i)$：接收到第$i$分组时的平均网络时延的估计值，$u$为固定的常数</li><li>$v_i=(1-u)v_{i-1}+u|r_i-t_i-d_i$：与估计平均时延的绝对偏差的估计值</li><li>$p_i=t_i+d_i+Kv_i$</li><li>在一个话音突峰期中任何后续分组的播放点被计算为相对于这个话音突峰期第一个分组播放时间点的偏移</li><li>类似TCP的拥塞控制</li></ul><h3 id="从丢包中恢复"><a href="#从丢包中恢复" class="headerlink" title="从丢包中恢复"></a>从丢包中恢复</h3><h4 id="前向纠错（FEC）"><a href="#前向纠错（FEC）" class="headerlink" title="前向纠错（FEC）"></a>前向纠错（FEC）</h4><p>基本思想：给初始分组增加冗余信息<br>第一种机制：每发送$n$个块之后发送一个冗余编码的块（前$n$个块的异或和）。增加了播放时延。<br>第二种机制：发送一个较低分辨率的音频作为冗余信息。接收方在播放前只需接收两个分组，因此增加的时延小，且传输速率的额外增加并不大。</p><h4 id="交织"><a href="#交织" class="headerlink" title="交织"></a>交织</h4><p><img src="/2019/10/12/network-notes/9-6.png" style="zoom:30%;"></p><p>优点：能够明显提高音频流可感觉到的质量；不增加流的带宽要求<br>缺点：增加了时延</p><h4 id="差错掩盖"><a href="#差错掩盖" class="headerlink" title="差错掩盖"></a>差错掩盖</h4><p>为丢失的分组产生一个替代物（如重复）<br>音频信号呈现出大量的短期自相似性<br>适合于工作在相对小的丢包率和小分组的情况</p><h2 id="实时会话式应用的协议"><a href="#实时会话式应用的协议" class="headerlink" title="实时会话式应用的协议"></a>实时会话式应用的协议</h2><p><u>此处懒得抄</u></p><h2 id="支持多媒体的网络"><a href="#支持多媒体的网络" class="headerlink" title="支持多媒体的网络"></a>支持多媒体的网络</h2><h3 id="提供多种类型的服务"><a href="#提供多种类型的服务" class="headerlink" title="提供多种类型的服务"></a>提供多种类型的服务</h3><p>链路调度规则：选择在链路上传输排队分组的方式</p><h4 id="监管：漏桶"><a href="#监管：漏桶" class="headerlink" title="监管：漏桶"></a>监管：漏桶</h4><p>3个准则：平均速率、峰值速率、突发长度</p><ul><li>漏桶由一个能容纳$b$个令牌的桶组成</li><li>新令牌总是以每秒$r$个速率产生</li><li>当产生一个令牌时，如果桶中少于$b$个令牌，则新产生的令牌加入到桶中，否则忽略</li><li>一个分组向网络传输之前，必须首先从令牌桶中去除一个令牌，如果令牌桶是空的，分组必须等待一个令牌。</li><li>漏桶监管的流的<strong>最大突发长度</strong>是$b$个分组，任何长度为$t$的时间间隔内能够进入网络中的最大分组数目为$rt+b$（<strong>平均速率</strong>）</li><li>在原漏桶下方再加一个令牌产生速率为$p$漏桶可以实现限制<strong>峰值速率</strong>到$p$</li></ul><h4 id="漏桶-加权公平排队-队列中可证明的最大时延"><a href="#漏桶-加权公平排队-队列中可证明的最大时延" class="headerlink" title="漏桶+加权公平排队=队列中可证明的最大时延"></a>漏桶+加权公平排队=队列中可证明的最大时延</h4><p>$$d_{max}=\frac{b_i}{R\cdot \frac{w_i}{\sum w_j}}$$</p><h1 id="口嗨考题"><a href="#口嗨考题" class="headerlink" title="口嗨考题"></a>口嗨考题</h1><ul><li>IPv4的首部的哪些字段经过中间路由器的时候不会被修改？考虑NAT和不考虑NAT。（以前出过，可能还会考到</li><li>(ppt p28)SYNj</li><li>5道大题*20分</li><li>TCP拥塞控制</li><li>路由表</li></ul><h1 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a>划重点</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>好好看看</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>不考</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ul><li>3.2,3.3：看看概念</li><li>3.4：不考</li><li>3.5~7: 注意一下</li></ul><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>4.2,4.3</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ul><li>5.2， 5.3</li><li>5.4：基本概念</li><li>5.6：简单知道ping和traceroute怎么用</li></ul><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ul><li>6.3（6.3.4除外）</li><li>以太网，CSMA/CD</li></ul><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p>7.3：主要是概念，不会考太细，CSMA/CA</p><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><p>QoS</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;【工事中】&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ISP：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数字图像处理课程笔记</title>
    <link href="https://mengzelev.github.io/2019/10/11/dip-notes/"/>
    <id>https://mengzelev.github.io/2019/10/11/dip-notes/</id>
    <published>2019-10-11T12:31:15.000Z</published>
    <updated>2019-12-27T02:30:55.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="期末考试"><a href="#期末考试" class="headerlink" title="期末考试"></a>期末考试</h1><ul><li>题型：选择（不定选）、判断、问答、计算</li></ul><h1 id="Ch01-数字图像处理简介"><a href="#Ch01-数字图像处理简介" class="headerlink" title="Ch01 数字图像处理简介"></a>Ch01 数字图像处理简介</h1><h2 id="图像采样、图像量化"><a href="#图像采样、图像量化" class="headerlink" title="图像采样、图像量化"></a>图像采样、图像量化</h2><p>基本问题：如何将现实物理信号离散化、数字化<br><strong>采样</strong>：用有限的样本数目去近似无限的现实物理信号（有限近似无限）<br><strong>量化</strong>：用离散计算机表示去近似连续的现实物理信号（离散近似连续）</p><p>采样数量越多，图像越清晰（1024<em>1024$\to$ 16</em>16）<br>量化级别越高，图像越真实（256灰度级$\to$4灰度级，低灰度级会出现<strong>伪轮廓</strong>）</p><p>图像有M*N个像素，每个像素有$Q$个灰度级别。<br>M,N,Q通常总是取为2的整数幂。<br>$Q=2^b$，称为图像的b bit量化，或称$Q$级灰度。<br>存在量化误差，b越大重建图像失真越小。</p><p>有<strong>大量细节</strong>的图，需要的量化级数<strong>较少</strong></p><p>最佳量化：使量化误差（均方误差测度）最小的量化方法<br>均方误差$\delta^2=\sum\limits_{k=1}^{K}\int_{Z_k}^{Z_{k+1}}(Z_k-q_k)^2p(Z)dZ$<br>取$q_k=\frac{1}{2}(Z_k+Z_{k+1})$达到最佳量化</p><h1 id="Ch02-空间域图像增强（Part-1）"><a href="#Ch02-空间域图像增强（Part-1）" class="headerlink" title="Ch02 空间域图像增强（Part 1）"></a>Ch02 空间域图像增强（Part 1）</h1><p>考点：灰度变换、直方图</p><h2 id="基本灰度变换"><a href="#基本灰度变换" class="headerlink" title="基本灰度变换"></a>基本灰度变换</h2><p>三类基本函数：线性、对数、幂律</p><ul><li>线性函数<ul><li>可以实现图像反转$s=L-1-r$——增强嵌入在暗区域中的白色或灰色细节</li></ul></li><li>对数变换$s=c\log(1+r)$<ul><li>$1+r$：函数图像经过原点，对数值恒大于0</li><li>低灰度值拉伸，高灰度值压缩</li><li>还可以把超大的数字变小，变换后可以看到图像更多的细节</li></ul></li><li>幂律变换$s=cr^\gamma$<ul><li>低灰度值压缩，高灰度值拉伸</li><li>伽马参数减小，细节增加，对比度降低；反之亦然</li></ul></li><li>分段线性函数<ul><li>只拉伸某些灰度级上的对比度</li><li>阈值处理$r_1=r_2$</li><li>灰度级分层：突出特定灰度范围的亮度</li><li><img src="/2019/10/11/dip-notes/fenceng.png" alt=""></li></ul></li><li>比特平面分层<ul><li>突出特定比特的作用</li><li>8个比特可认为由8个1比特平面组成</li><li>高阶比特平面包含视觉上的重要数据，低阶比特平面贡献了更精细的灰度细节</li><li>应用：确定量化该比特数的充分性；图像压缩可能会导致伪轮廓</li></ul></li></ul><h2 id="直方图处理"><a href="#直方图处理" class="headerlink" title="直方图处理"></a>直方图处理</h2><h3 id="灰度直方图"><a href="#灰度直方图" class="headerlink" title="灰度直方图"></a>灰度直方图</h3><ul><li>图像中每种灰度级的像素个数</li><li>灰度直方图的横坐是灰度级，纵坐标表示该灰度级出现的<strong>频率</strong></li><li>阈值面积函数$A(D)$：连续图像中具有灰度级$\ge D$的轮廓线所包围的面积$$A(D)=\int_{D}^{\infty}H(p)dp$$</li><li>概率密度函数$PDF$：归一化到单位面积的直方图（每种灰度值出现的概率密度函数） $$PDF=P(D)=\frac{1}{A_0}H(D)$$</li><li>累计分布函数$CDF$：归一化后灰度级$\le D$的轮廓线所包围的面积 $$CDF=P(D)=\int\limits_0^D p(u)du=\frac{1}{A_0}\int\limits_{0}^{D}H(u)du$$</li><li>$H(D)=A(D)-A(D+1)$</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>图像具有$L$级灰度，大小为$M*N$的灰度图像$f(x,t)$的灰度直方图$hist[0,\ldots L-1]$的算法</p><ol><li>初始化$hist[k]=0$</li><li>统计$hist[f(x,y)]$</li><li>归一化$hist[f(x,y)]/(M*N)$</li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>图像快速检测：判断一幅图像是否合理利用率全部被允许的灰度范围，从而及早发现数字化中出现的问题</li><li>分割前景背景：以直方图双峰之间的谷地$T$为阈值来确定边界，可以把图像分为前景背景两部分</li><li>面积计算：背景灰度大体一致且背景与物体对比度很强时$\int\limits_{D_1}^{\infty}H(D)dD=$物体的面积</li></ul><h1 id="Ch03-直方图处理"><a href="#Ch03-直方图处理" class="headerlink" title="Ch03 直方图处理"></a>Ch03 直方图处理</h1><p>考点：直方图均衡</p><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>直方图呈均匀分布时，对比度会有明显增加。<br>通过灰度变换函数，将原图像直方图的分布均衡化，这一过程称为<strong>直方图均衡化</strong></p><p>输出图像的概率密度$$p_s(s)=p_r(T^{-1}(s))\frac{1}{|T’(T^{-1}(s))|}$$<br>若$s=T(r)$为单调递增函数：<br>$$p_s(s)=p_r(r)\frac{dr}{ds}$$<br>($r$用$s$表示)</p><p>e.g. $s=T(r)=ar+b$,即$r=\frac{s-b}{a}$，则有$p_s(s)=\frac{1}{a}p_r(\frac{s-b}{a})$.</p><p>直方图均衡化变换函数：<br>$$s=T(r)=(L-1)\int_{0}^{r}p_r(w)dw$$<br>离散近似：<br>$$p_r(r_k)=\frac{n_k}{MN}$$<br>$$s_k=T(r_k)=(L-1)\sum\limits_{j=0}^{k}p_r(r_j)=\frac{(L-1)}{MN}\sum\limits_{j=0}^{k}n_j$$</p><p><strong>步骤</strong>：</p><ul><li>给定$L$和$p_r(r_k),k=0,1,\ldots, L-1$</li><li>用上述公式计算$s_k$</li><li>将$s_k$四舍五入取整</li><li>计算$p_s(s_k)$——均衡后的</li><li>把$r_k$一一替换成$s_k$得到新图像</li></ul><h1 id="Ch04-空间滤波、算数操作增强"><a href="#Ch04-空间滤波、算数操作增强" class="headerlink" title="Ch04 空间滤波、算数操作增强"></a>Ch04 空间滤波、算数操作增强</h1><p>考点：</p><ul><li>空间相关/卷积：区别和联系，怎么算（计算题</li><li>平滑/锐化空间滤波器：特点，干啥用</li><li>锐化拉普拉斯梯度算子大概知道</li><li>算术操作，大概知道加减乘除有什么道理</li></ul><h2 id="相关和卷积"><a href="#相关和卷积" class="headerlink" title="相关和卷积"></a>相关和卷积</h2><p>都是对应点相乘然后把所有乘积加起来</p><ul><li>相关<ul><li>平移计算模板，计算每个位置乘积之和</li><li>补零、计算、滑动、裁剪</li><li><img src="/2019/10/11/dip-notes/correlation.png" alt=""></li><li>符号：☆</li></ul></li><li>卷积<ul><li>与相关类似，但滤波器要旋转180度</li><li>旋转、补零、计算、滑动、裁剪</li><li>符号：$\star$</li></ul></li></ul><h2 id="平滑空间滤波器"><a href="#平滑空间滤波器" class="headerlink" title="平滑空间滤波器"></a>平滑空间滤波器</h2><h3 id="平滑线性滤波器"><a href="#平滑线性滤波器" class="headerlink" title="平滑线性滤波器"></a>平滑线性滤波器</h3><ul><li><strong>均值滤波器</strong><ul><li>附近9格的均值，先求和再归一化</li><li>优点：降低噪声</li><li>缺点：边缘模糊</li></ul></li><li><strong>加权线性滤波器</strong><ul><li>非均匀权重</li><li>降低模糊</li></ul></li></ul><h3 id="统计排序滤波器"><a href="#统计排序滤波器" class="headerlink" title="统计排序滤波器"></a>统计排序滤波器</h3><p>非线性滤波器：对滤波器覆盖的像素排序，用排序决定的值替代中心像素</p><ul><li>中值滤波器：中位数</li><li>最大值滤波器</li><li>最小值滤波器</li></ul><h2 id="锐化空间滤波器"><a href="#锐化空间滤波器" class="headerlink" title="锐化空间滤波器"></a>锐化空间滤波器</h2><h3 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h3><table><thead><tr><th style="text-align:center">一阶导数</th><th style="text-align:center">二阶导数</th></tr></thead><tbody><tr><td style="text-align:center">在恒定灰度区域为0</td><td style="text-align:center">在恒定灰度区域为0</td></tr><tr><td style="text-align:center">在突变（斜坡、台阶）的起点非0</td><td style="text-align:center">在突变的的起点和终点非0</td></tr><tr><td style="text-align:center">沿着斜坡非0</td><td style="text-align:center">沿着恒定斜率斜坡为0</td></tr><tr><td style="text-align:center">$f(x+1)-f(x)$</td><td style="text-align:center">$f(x+1)+f(x-1)-2f(x)$</td></tr><tr><td style="text-align:center">产生较粗的边缘</td><td style="text-align:center">产生两个有间距的双边缘（由0分开，单像素宽）</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">增强细节方面更好</td></tr></tbody></table><h3 id="拉普拉斯算子"><a href="#拉普拉斯算子" class="headerlink" title="拉普拉斯算子"></a>拉普拉斯算子</h3><p>$$\nabla^2f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}$$<br>离散化<br>$$\frac{\partial^2f}{\partial x^2}=f(x+1,y)+f(x-1,y)-2f(x,y)$$<br>$$\frac{\partial^2f}{\partial x^2}=f(x,y+1)+f(x,y-1)-2f(x,y)$$<br><strong>注意减的是2倍的</strong><br>$$\nabla^2f=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$$<br>还有对角线形式的</p><p>拉普拉斯算子结果叠加到图像中<br>$$g(x,y)=f(x,y)+c[\nabla^2f(x,y)]$$</p><ul><li>采用负的中心系数，$c=-1$</li><li>采用正的中心系数，$c=1$</li></ul><h3 id="非锐化掩蔽"><a href="#非锐化掩蔽" class="headerlink" title="非锐化掩蔽"></a>非锐化掩蔽</h3><p>原图像-非锐化版本</p><ol><li>模糊原图像</li><li>从原图像减去模糊图像得到模板</li><li>将模板加到原图像</li></ol><p>具体公式<br>$$g_{mask}(x,y)=f(x,y)-\overline{f}(x,y)$$<br>$$g(x,y)=f(x,y)+kg_{mask}(x,y)$$<br>非锐化掩蔽$k=1$；高提升滤波$k&gt;1$</p><h3 id="使用一阶导数锐化图像"><a href="#使用一阶导数锐化图像" class="headerlink" title="使用一阶导数锐化图像"></a>使用一阶导数锐化图像</h3><p>利用梯度的大小<br>$$M(x,y)=\sqrt{(\frac{\partial f}{\partial x})^2+(\frac{\partial f}{\partial y})^2}$$<br>近似计算<br>$$M(x,y)=|g_x|+|g_y|$$</p><ul><li>sobel算子（实验写过）</li></ul><h2 id="算数操作增强"><a href="#算数操作增强" class="headerlink" title="算数操作增强"></a>算数操作增强</h2><ul><li>加法<ul><li>多次曝光：将不同时间曝光照片进行得加，得到一张具有特殊效果的照片</li><li>加法运算常用于减少图像中的随机噪声</li><li>对$M$幅加性噪声图形进行平均，可以使图像的平方信噪比提高$M$倍，信噪比定义见后面</li></ul></li><li>减法<ul><li>作差后对比度会增强，提取轮廓（指纹），强调细节</li><li>负数规范化：$y=(x+255)/2$或$y=(x-min)/(max-min)*255$</li></ul></li><li>乘法<ul><li>掩模运算</li></ul></li><li>除法<ul><li>归一化  </li></ul></li></ul><h1 id="Ch05-集合逻辑操作、空间操作、灰度内插"><a href="#Ch05-集合逻辑操作、空间操作、灰度内插" class="headerlink" title="Ch05 集合逻辑操作、空间操作、灰度内插"></a>Ch05 集合逻辑操作、空间操作、灰度内插</h1><p>考点：</p><ul><li>仿射变换：什么，特点</li><li>灰度内插：最近邻，线性，双线性</li></ul><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>包括了旋转、伸缩、平移、倾斜等变换<br>$$x=t_{11}v+t_{21}w+t_{31}$$<br>$$y=t_{12}v+t_{22}w+t_{32}$$</p><ul><li>$t_{31},t_{32}$刻画了平移量</li><li>$t_{11},t_{22}$刻画了伸缩比例</li><li>$t_{12},t_{21}$刻画了倾斜程度</li><li>整体组合刻画了平移、旋转角度、倾斜程度</li></ul><p><strong>优点</strong>：</p><ul><li>保持共线性（共线的点变换后依然共线）</li><li>保持距离比例（线的中心变换后仍然是线的中心）</li></ul><h3 id="几种常见仿射变换"><a href="#几种常见仿射变换" class="headerlink" title="几种常见仿射变换"></a>几种常见仿射变换</h3><ul><li>恒等变换</li><li>伸缩变换：$x=c_xv, y=c_yw$</li><li>旋转变换：$x=v\cos\theta-w\sin\theta, y=v\sin\theta+w\cos\theta$</li><li>平移变换：$x=v+t_x, y=w+t_y$</li><li>（垂直）倾斜变换：$x=v+s_vw, y=w$</li><li>（水平）倾斜变换：$x=v,y=s_hv+w$</li></ul><p><img src="/2019/10/11/dip-notes/matrix.png" alt=""></p><p>复杂仿射变换：一系列仿射变换操作（因为仿射变换的组合还是仿射变换）<br>逆仿射变换：对矩阵求逆（基本变换矩阵都是可逆矩阵）</p><h2 id="灰度内插"><a href="#灰度内插" class="headerlink" title="灰度内插"></a>灰度内插</h2><ul><li>前向映射<ul><li>通过输入图像限速位置，计算输出图像对应的像素位置</li><li>将该位置像素的灰度值分配给其相邻四个网格位置</li></ul></li><li>反向映射<ul><li>用过输出图像像素位置，计算输入图像中涉及到所有对应的像素位置</li><li>根据输入图像四个像素的灰度值计算该位置的像素的灰度值</li></ul></li></ul><h3 id="最近邻内插"><a href="#最近邻内插" class="headerlink" title="最近邻内插"></a>最近邻内插</h3><p>取离得最近的值作为自己的值<br>e.g. $f(0)=10, f(1)=12, f(0.4)=f(0), f(0.6)=f(1)$</p><h3 id="线性内插"><a href="#线性内插" class="headerlink" title="线性内插"></a>线性内插</h3><p>连接相邻两点的直线<br>e.g. $f(0)=10, f(1)=12, f(x)=10+2x, x\in[0,1]$，i.e.$f(0.4)=10.8$. 或写成$f(x)=(1-x)f(0)+(x-0)f(1)$</p><h3 id="双线性内插"><a href="#双线性内插" class="headerlink" title="双线性内插"></a>双线性内插</h3><p><img src="/2019/10/11/dip-notes/bilinear.png" alt=""></p><p>用附近4个点的值来表示$P$点的值</p><h1 id="Ch06-傅里叶变换"><a href="#Ch06-傅里叶变换" class="headerlink" title="Ch06 傅里叶变换"></a>Ch06 傅里叶变换</h1><p>考点：</p><ul><li>傅里叶变换：基本知识，概念</li><li><strong>卷积定理和采样定理</strong></li><li>背DFT和IDFT的公式</li><li>原理东西掌握</li></ul><h2 id="傅里叶变换基本知识"><a href="#傅里叶变换基本知识" class="headerlink" title="傅里叶变换基本知识"></a>傅里叶变换基本知识</h2><h3 id="冲激与采样"><a href="#冲激与采样" class="headerlink" title="冲激与采样"></a>冲激与采样</h3><p>连续：在0点值特别大，其余点为0，$[0,1]$上积分为1<br>离散：在0点值为1，其余点为0，$(-\infty,+\infty)$上的级数和为1</p><p>采样性质：<br>$$\int_{-\infty}^{\infty}f(t)\delta(t-t_0)dt=f(t_0)$$<br>$$\sum\limits_{x=-\infty}^{\infty}f(x)\delta(x-x_0)=f(x_0)$$</p><p>冲激串：无穷个以$\Delta T$为间距的周期性冲激之和</p><p>傅里叶级数：周期为$T$的连续函数$f(t)$可以表示为正弦和余弦函数的加权之和</p><h2 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h2><ul><li>空间域卷积的傅里叶变换$\Leftrightarrow$傅里叶变换在频率域的乘积 $$f(t)\star h(t)\Leftrightarrow H(\mu)F(\mu)$$</li><li>空间域乘积的傅里叶变换$\Leftrightarrow$傅里叶变换在频率域的卷积 $$f(t)h(t)\Leftrightarrow H(\mu)F(\mu)$$</li></ul><h2 id="采样定理"><a href="#采样定理" class="headerlink" title="采样定理"></a>采样定理</h2><p>连续函数采样：把冲激串与原函数相乘<br>$$\tilde{f}(t)=f(t)s_{\Delta T}(t)=\sum\limits_{n=-\infty}^{\infty}f(t)\delta(t-n\Delta T)$$<br>$$\tilde{F}(\mu)=F(\mu)\star S(\mu), S(\mu)=\frac{1}{\Delta T}\sum\limits_{n=-\infty}^{\infty}\delta(\mu-\frac{n}{\Delta T})$$<br>采样值$f_k=f(k\Delta T)$</p><p><img src="/2019/10/11/dip-notes/caiyang.png" alt=""><br><img src="/2019/10/11/dip-notes/caiyangthm.png" alt=""></p><p><strong>采样定理</strong>：如果以超过函数最高频率的两倍采样率来获得样本，连续的带限函数可以完美地从它的样本集来恢复。<br>即如果<br>$$<br>\frac{1}{2\Delta T}&gt;\mu_{\max}\Leftrightarrow \frac{1}{\Delta T}&gt;2\mu_{\max}<br>$$<br>就可以从$\tilde F(\mu)$中分离出$F(\mu)$. $2\mu_{\max}$称为奈奎斯特频率。<br><strong>二维采样定理</strong>：在两个维度上都要满足一维采样定理</p><h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3><ul><li>欠采样：以低于奈奎斯特频率采样。无法分离，无法补救。</li><li>采样是有限的，所以实际中难以避免混淆。</li><li>一个带限函数一定是从$-\infty$扩展到$\infty$，没有有限持续时间的函数是带限的。有限长度的采样，混淆是不可避免的。</li><li>抗混淆：<ul><li>事先防止或减轻混淆</li><li>平滑输入函数，减少高频分量</li></ul></li></ul><h3 id="有限长度采样"><a href="#有限长度采样" class="headerlink" title="有限长度采样"></a>有限长度采样</h3><ul><li>采样时间限制在$[0,T]$，可以写成一个只在$[0,T]$为1其余地方为0的函数$h(t)$</li><li>$f(t)\Rightarrow f(t)h(t)\Leftrightarrow H(\mu)\star F(\mu)$</li></ul><h3 id="由样本恢复原函数"><a href="#由样本恢复原函数" class="headerlink" title="由样本恢复原函数"></a>由样本恢复原函数</h3><p>$$<br>f(t)=\sum\limits_{n=-\infty}^{\infty}f(n\Delta T)sinc[(t-n\Delta T)/\Delta T]<br>$$</p><ul><li>函数内插：无限个样本的内插，实际中只能近似</li><li>$t=k\Delta T, f(t)=f(k\Delta T)$</li></ul><h2 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h2><h3 id="一维DFT"><a href="#一维DFT" class="headerlink" title="一维DFT"></a>一维DFT</h3><p>DFT：<br>$$<br>F(u)=\sum\limits_{n=0}^{M-1}f(x)e^{-j2\pi ux/M}, u=0,1,2,\ldots, M-1<br>$$<br>IDFT:<br>$$<br>f(x)=\frac{1}{M}\sum\limits_{u=0}^{M-1}F(u)e^{j2\pi ux/M}， x=0,1,2\ldots M-1<br>$$<br>$x$是整数<br>$\mu=\frac{m}{M\Delta T}$ 对 $\tilde{F}(\mu)$ 的一个周期 $[0,1/\Delta T]$采集$M$个样本</p><ul><li><p>离散卷积<br>  $$<br>  f(x)\star h(x)=\sum\limits_{m=0}^{M-1}f(m)h(x-m)<br>  $$</p><ul><li>周期函数，也被称为循环卷积</li><li>与之前的卷积不一样，主要区别是$x$（之前的卷积对不够的地方补零，这个是取循环值）</li><li>卷积定理依然成立</li></ul></li><li><p>倒数关系：</p><ul><li>对连续函数$f(t)$采样，总时间长度为$T=M\Delta T$，离散频域中的间隔$\Delta u=\frac{1}{M\Delta T}=\frac{1}{T}$</li><li>离散频域范围$\Omega = M\Delta U=\frac{1}{\Delta T}$</li></ul></li></ul><h3 id="二维DFT"><a href="#二维DFT" class="headerlink" title="二维DFT"></a>二维DFT</h3><p>$$<br>F(u,v)=\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}f(x,y)e^{-2j\pi (ux/M+vx/N)},<br>u=0,1,\ldots,M-1; v= 0,1,\ldots, N-1<br>$$</p><ul><li>$f(x,y)$是大小为$M\times N$的二维图像</li></ul><p>二维IDFT<br>$$<br>f(x,y)=\frac{1}{MN}\sum\limits_{u=0}^{M-1}\sum\limits_{v=0}^{N-1}F(u,v)e^{j2\pi (ux/M+vx/N)}<br>$$</p><ul><li>对连续$f(x,y)$采样，两个方向上的总时间$T=M\Delta T, Z=N\Delta Z$</li><li>离散频域中的间隔$\Delta u=\frac{1}{M\Delta T}, \Delta v=\frac{1}{N\Delta Z}$</li><li>离散频域范围$\frac{1}{\Delta T}, \frac{1}{\Delta Z}$</li></ul><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>平移不影响幅值：$f(x-x_0, y-y_0)\Leftrightarrow F(u-u_0, v-v_0)$</li><li>旋转性：$F(u,v)$ 和$f(x,y)$旋转相同的角度</li><li>$f(x,y)(-1)^{x+y}\Leftrightarrow F(u-M/2, v-N/2)$</li><li>对称性：相对于序列中心而言<ul><li>$w_e(x,y)=w_e(M-x, N-y)$</li><li>$w_o(x,y)=-w_o(M-x, N-y)$</li></ul></li><li>实函数的傅里叶变换共轭对称：$F^*(u,v)=F(-u,-v)$</li><li>虚函数的傅里叶变换共轭反对称</li></ul><h3 id="傅里叶谱和相角"><a href="#傅里叶谱和相角" class="headerlink" title="傅里叶谱和相角"></a>傅里叶谱和相角</h3><ul><li>幅度（傅里叶谱）：$|F(u,v)|$</li><li>相角$[-\pi, pi]$：$\pi(u,v)=\arctan\left[\frac{I(u,v)}{R(u,v)} \right]$</li><li>傅里叶谱决定了正弦波的幅度，表示灰度</li><li>相角表示正弦波的位移，携带了定位信息</li></ul><h3 id="二维卷积定理"><a href="#二维卷积定理" class="headerlink" title="二维卷积定理"></a>二维卷积定理</h3><p>和一维一样。</p><p>要让卷积定理和直接卷积一致，需要0填充，避免缠绕错误</p><p><img src="/2019/10/11/dip-notes/0tianchong.png" style="zoom:50%;"></p><h1 id="Ch08-频率域滤波、平滑图像"><a href="#Ch08-频率域滤波、平滑图像" class="headerlink" title="Ch08 频率域滤波、平滑图像"></a>Ch08 频率域滤波、平滑图像</h1><p>考点：</p><ul><li>频域滤波基本流程</li><li>3种低通滤波器特点，不会考公式</li></ul><h2 id="频域滤波基本流程"><a href="#频域滤波基本流程" class="headerlink" title="频域滤波基本流程"></a>频域滤波基本流程</h2><ol><li>给定大小为$M\times N$的输入图像$f(x,y)$，选择0填充参数$P,Q$，一般$P=2M, Q=2N$</li><li>对$f(x,y)$进行0填充，得到$f_p(x,y)$</li><li>$f_p(x,y)$乘上$(-1)^{x+y}$移到变换中心</li><li>计算上一步中函数的DFT，得到$F(u,v)$</li><li>生成一个实的、对称的滤波函数$H(u,v)$，大小为$P\times Q$，中心$(P/2, Q/2)$，用阵列相乘形成乘积$G(u,v)=H(u,v)F(u,v)$</li><li>得到处理后的图像$g_p(x,y)$，注意是$G(u,v)$IDFT后实部乘以$(-1)^{x+y}$</li><li>通过$g_p(x,y)$的左上象限提取$M\times N$区域，得到最终处理结果$g(x,y)$</li></ol><h2 id="低通滤波器"><a href="#低通滤波器" class="headerlink" title="低通滤波器"></a>低通滤波器</h2><ul><li>傅里叶变换的低频部分：灰度变化缓慢的地方（墙、地面、天空）</li><li>傅里叶变换的高频成分：灰度变化剧烈的地方（边缘、噪声）</li><li>低通滤波器：衰减高频，通过低频</li></ul><h3 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a>理想低通滤波器</h3><ul><li>理想：低频完全保留，高频完全抑制</li><li>图：一个向上的圆柱（不要问我圆柱为什么会有方向<br>+　图形显示：一块黑的中间一个白圆<br>+　硬件无法实现</li><li>利用半径构造的低通滤波器会产生振铃现象（一圈一圈<s>跟撸多了一样</s>）<ul><li>振铃原因：sinc函数两边振荡的小尾巴</li></ul></li><li>半径越大越清晰</li></ul><h3 id="巴特沃斯低通滤波器"><a href="#巴特沃斯低通滤波器" class="headerlink" title="巴特沃斯低通滤波器"></a>巴特沃斯低通滤波器</h3><ul><li>$D_0$为截止频率</li><li>透视图：MATLAB logo</li><li>利用半径构造的巴特沃斯滤波器($n=2$)：没有振铃现象</li><li>$n=2$是比较好的折中</li></ul><h3 id="高斯低通滤波器"><a href="#高斯低通滤波器" class="headerlink" title="高斯低通滤波器"></a>高斯低通滤波器</h3><ul><li>透视图：MATLAB logo</li><li>没有振铃现象</li></ul><h1 id="Ch09-锐化图像、选择性滤波、实现"><a href="#Ch09-锐化图像、选择性滤波、实现" class="headerlink" title="Ch09 锐化图像、选择性滤波、实现"></a>Ch09 锐化图像、选择性滤波、实现</h1><p>考点：</p><ul><li>3种高通</li><li>拉普拉斯算子，其他俩不用看</li><li>低通高通模糊锐化（基本常识</li></ul><h2 id="高通滤波器"><a href="#高通滤波器" class="headerlink" title="高通滤波器"></a>高通滤波器</h2><p>从低通构造高通：<br>$$<br>H_{HP}(u,v)=1-H_{LP}(u,v)<br>$$</p><p>图像都是低通倒过来</p><h3 id="理想高通滤波器"><a href="#理想高通滤波器" class="headerlink" title="理想高通滤波器"></a>理想高通滤波器</h3><ul><li>低频完全抑制，高频完全保留</li><li>产生振铃，随着$D_0$增大振铃会有所缓解</li></ul><h3 id="巴特沃斯高通滤波器"><a href="#巴特沃斯高通滤波器" class="headerlink" title="巴特沃斯高通滤波器"></a>巴特沃斯高通滤波器</h3><ul><li>轻微振铃现象</li></ul><h3 id="高斯高通滤波器"><a href="#高斯高通滤波器" class="headerlink" title="高斯高通滤波器"></a>高斯高通滤波器</h3><ul><li>结果更清晰一些</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="/2019/10/11/dip-notes/gaotong.png" alt=""></p><h2 id="频率域拉普拉斯算子"><a href="#频率域拉普拉斯算子" class="headerlink" title="频率域拉普拉斯算子"></a>频率域拉普拉斯算子</h2><p>频域滤波器（中心化）：<br>$$<br>H(u,v)=-4\pi^2D^2(u,v)<br>$$<br>$D(u,v)$为点$(u,v)$到中心点$(P/2,Q/2)$的距离</p><p>拉普拉斯图像<br>$$<br>\Delta^2f(x,y)=\mathcal{F}^{-1}{H(u,v)F(u,v)}<br>$$<br>图像锐化$g(x,y)=f(x,y)-\Delta^2 f(x,y)$，频率域写法<br>$$<br>g(x,y)=\mathcal{F}^{-1}{F(u,v)-H(u,v)F(u,v)}=\mathcal{F}^{-1}{[1+4\pi^2D^2(u,v)]F(u,v)}<br>$$</p><ul><li>$f(x,y)$归一到$[0,1]$，$\Delta^2f(x,y)$归一到$[-1,1]$，再计算DFT</li></ul><h1 id="CH10-图像复原"><a href="#CH10-图像复原" class="headerlink" title="CH10 图像复原"></a>CH10 图像复原</h1><p>考点：</p><ul><li>图像复原是干啥（建模），跟增强的区别</li><li>噪声的大概特点，不会考公式</li><li>均值滤波器、统计排序滤波器，自适应不考</li></ul><h1 id="图像复原"><a href="#图像复原" class="headerlink" title="图像复原"></a>图像复原</h1><h2 id="复原-v-s-增强"><a href="#复原-v-s-增强" class="headerlink" title="复原 v.s. 增强"></a>复原 v.s. 增强</h2><ul><li>图像复原<ul><li>以预先制定的目标改善图像，客观</li><li>对模糊的图像去模糊</li><li>利用退化现象的先验知识来恢复图像</li><li>建模退化过程-&gt;利用逆过程复原图像</li></ul></li><li>图像增强<ul><li>由人的主观感受来评判，主观</li><li>对比度拉伸、增强</li></ul></li></ul><h2 id="退化-复原建模"><a href="#退化-复原建模" class="headerlink" title="退化/复原建模"></a>退化/复原建模</h2><ul><li>输入$f(x,y)$</li><li>退化函数$H$</li><li>加性噪声$\eta(x,y)$</li><li>复原滤波器</li><li>输出$\hat{f}(x,y)$</li><li>目标：$f(x,y)\approx f(x,y)$</li></ul><p>空间域表示<br>$$<br>g(x,y)=h(x,y)\star f(x,y)+\eta(x,y)<br>$$<br>频率域表示<br>$$<br>G(u,v)=H(u,v)F(u,v)+N(u,v)<br>$$</p><h2 id="噪声模型"><a href="#噪声模型" class="headerlink" title="噪声模型"></a>噪声模型</h2><p><img src="/2019/10/11/dip-notes/noise.png" style="zoom:30%;"></p><p><img src="/2019/10/11/dip-notes/noise2.png" style="zoom:30%;"></p><ul><li>高斯噪声</li><li>瑞利噪声</li><li>爱尔兰（伽马）噪声</li><li>指数噪声</li><li>均匀噪声</li><li>脉冲（椒盐）噪声</li></ul><p>周期噪声：</p><ul><li>通常由电力或机电干扰产生</li><li>噪声与空间位置有关</li><li>可以通过频域滤波复原</li></ul><p>噪声参数估计：</p><ul><li>通过检查傅里叶谱、图像本身</li><li>一般噪声的PDF<ul><li>查看传感器说明书</li><li>主动成像去估计参数，如拍摄纯色物体</li><li>从图像的局部稳定区域来估计噪声</li><li>根据形状识别PDF的类型</li><li>根据均值和方差来计算具体参数</li><li>脉冲噪声直接估计概率</li></ul></li></ul><h2 id="均值滤波器"><a href="#均值滤波器" class="headerlink" title="均值滤波器"></a>均值滤波器</h2><ul><li>算术均值滤波器<ul><li>取当前点为中心的一个区域的算术平均数作为当前点的像素值</li><li>平滑图像中的局部变化</li></ul></li><li>几何均值滤波器<ul><li>取当前点为中心的一个区域的几何平均数作为当前点的像素值</li><li>丢失的细节少</li></ul></li><li>谐波均值滤波器<ul><li>难以文字描述…反正不考公式</li><li>适用于盐粒噪声，不适用于胡椒噪声</li></ul></li><li>逆谐波均值滤波器<ul><li>有个阶数$Q$</li><li>$Q&gt;0$：消除胡椒噪声</li><li>$Q=0$：算术均值噪声</li><li>$Q&lt;0$：消除盐粒噪声</li><li>$Q=-1$：谐波均值滤波器</li></ul></li></ul><h2 id="统计排序滤波器-1"><a href="#统计排序滤波器-1" class="headerlink" title="统计排序滤波器"></a>统计排序滤波器</h2><ul><li>中值滤波器<ul><li>$(x,y)$处的像素也参与计算</li><li>良好的去噪能力，并且模糊少</li><li>尤其适用于单极或双极的脉冲信号</li></ul></li><li>最大值滤波器<ul><li>寻找图像中的亮点</li><li>降低胡椒噪声</li><li>黑色物体会变细</li></ul></li><li>最小值滤波器<ul><li>寻找图像中的暗点</li><li>降低盐粒噪声</li><li>黑色物体会变粗</li></ul></li><li>中点滤波器（1/2(max+min))<ul><li>最大值和最小值的中点</li><li>结合了统计排序和求平均</li><li>适用于随机噪声（高斯噪声、均匀噪声</li></ul></li><li>$\alpha$截断的均值滤波<ul><li>去掉$S_{xy}$中灰度最高、最低各$d/2$个像素</li><li>适用于存在多种噪声的情况（高斯噪声、椒盐噪声混合</li></ul></li></ul><p>滤波次数太多，图像会变模糊</p><h1 id="Ch11-12-彩色图像处理"><a href="#Ch11-12-彩色图像处理" class="headerlink" title="Ch11-12 彩色图像处理"></a>Ch11-12 彩色图像处理</h1><p>考点：</p><ul><li>3种颜色模型，含义，特点，不考颜色模型转换</li></ul><h2 id="RGB彩色模型"><a href="#RGB彩色模型" class="headerlink" title="RGB彩色模型"></a>RGB彩色模型</h2><ul><li>笛卡尔坐标系<ul><li>红绿蓝在3个角(1,0,0),(0,1,0),(0,0,1)</li><li>黑色在原点(0,0,1)</li><li>白色在最远的角(1,1,1)</li><li>过原点的体对角线是灰色</li></ul></li><li>3幅分量图像<ul><li>每种主颜色对应一幅图像</li><li>叠加在一起合成一幅彩色图像</li></ul></li><li>像素深度：表示每个像素的比特数</li><li>全彩色图像：24比特的RGB图像，颜色数目$2^{24}$</li><li>高端设备支持24比特的RGB图像，低端设备通常只能显示256种彩色</li><li>稳定RGB色：真实展现、与硬件无关，通常包括$6^3=216$种</li></ul><h2 id="CMY-颜色模型"><a href="#CMY-颜色模型" class="headerlink" title="CMY 颜色模型"></a>CMY 颜色模型</h2><ul><li>青色(C)，洋红(M)，黄色(Y)</li><li>彩色打印机</li><li>转换公式：CMY=1-RGB（自行脑补列矩阵）</li><li>CMYK颜色模型：添加了黑色（表面说不纯其实是便宜</li></ul><h2 id="HSI颜色模型"><a href="#HSI颜色模型" class="headerlink" title="HSI颜色模型"></a>HSI颜色模型</h2><p>RGB/CMY颜色模型不够直观（人不会用<br>颜色相关的信息：色调、饱和度，对人而言更直观</p><ul><li>色调（Hue）：主波长，也就是感知到的颜色<ul><li>与<strong>红色轴</strong>的夹角，柱坐标中的$\theta$</li></ul></li><li>饱和度(Saturation)：反映白光的比例，白光越多越不饱和<ul><li>与强度轴的距离，柱坐标中的$r$</li></ul></li><li>亮度(Brightness)：主观描绘，类似于无色光的强度（Intensity)<ul><li>强度轴为体对角线，柱坐标中的$z$轴</li></ul></li></ul><p>会出现色调的不连续现象（因为色调以红色轴为基准）</p><h1 id="Ch13-14-图像分割"><a href="#Ch13-14-图像分割" class="headerlink" title="Ch13-14 图像分割"></a>Ch13-14 图像分割</h1><p>考点</p><ul><li>基本边缘检测</li><li>高级边缘检测（MH和Canny</li><li>拉普拉斯</li><li>算法的基本原理，算子的优点</li></ul><h2 id="基本边缘检测"><a href="#基本边缘检测" class="headerlink" title="基本边缘检测"></a>基本边缘检测</h2><h3 id="边缘检测三个基本步骤"><a href="#边缘检测三个基本步骤" class="headerlink" title="边缘检测三个基本步骤"></a>边缘检测三个基本步骤</h3><ol><li>为降噪对图像进行平滑处理：导数对噪声敏感</li><li>边缘点的检测：抽取所有潜在边缘点</li><li>边缘定位：选出真正的边缘点</li></ol><p>梯度的大小和方向（略）<br>边缘的方向和梯度正交</p><p>梯度计算模板：<img src="/2019/10/11/dip-notes/grad.png" style="zoom:50%;"></p><p>举例：<img src="/2019/10/11/dip-notes/grad_eg.png" style="zoom:50%;"></p><p>梯度向量和边缘法线：<img src="/2019/10/11/dip-notes/gdvector.png" style="zoom:50%;"></p><h3 id="梯度算子"><a href="#梯度算子" class="headerlink" title="梯度算子"></a>梯度算子</h3><ul><li>一维模板</li><li>二维模板：罗伯特交叉梯度算子，普鲁伊特算子（同上面截图中的），Sobel算子（刻在DNA里的）</li><li>阈值化：如果初始图像未平滑处理，则边缘可能会出现中断；如果平滑处理过，则边缘中断会缓解，但部分边缘会消失</li></ul><h2 id="Marr-Hildreth边缘检测器"><a href="#Marr-Hildreth边缘检测器" class="headerlink" title="Marr-Hildreth边缘检测器"></a>Marr-Hildreth边缘检测器</h2><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><ul><li>灰度变化和图像尺度有关<ul><li>需要用不同尺寸的算子</li></ul></li><li>灰度变化会影响导数<ul><li>一阶导数出现波峰或波谷</li><li>二阶导数出现零交叉</li></ul></li><li>理想的检测器具备如下功能<ul><li>能够近似１阶或2阶导数</li><li>能够被调整以在不同尺寸上起作用</li><li>大的算子检测模糊边缘、小的算子检测细节</li></ul></li></ul><p>滤波器：$\Delta^2 G$：拉普拉斯算子和高斯函数（LoG）<br>又名墨西哥草帽算子<br>类似空间域的<strong>高通滤波器</strong></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li>对$G(x,y)$进行采样，得到$n\times n$的模板</li><li>与拉普拉斯模板卷积——系数之和自动为0</li><li>将LoG滤波器和图像卷积，寻找零交叉来确定边缘位置</li><li>等价于先用高斯滤波器平滑图像，然后用拉普拉斯算子</li><li>$n$是$\ge 6\sigma$的最小奇数</li></ul><p><strong>优点</strong>：</p><ul><li>高斯部分会模糊图像，可以去掉尺寸小于$\sigma$的细节，比如噪声</li><li>二阶导数：各向同性，对任何方向的变化有相同的响应；符合人的视觉系统</li></ul><p><strong>缺点</strong>:</p><ul><li>可能会产生闭环，”意大利空心粉“效应——通过阈值化可以缓解</li></ul><h2 id="Canny边缘检测器"><a href="#Canny边缘检测器" class="headerlink" title="Canny边缘检测器"></a>Canny边缘检测器</h2><h3 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h3><ul><li>低错误率：所有边缘都被找到，并且没有伪响应</li><li>边缘点应被很好地定位：已定位的边缘必须尽可能接近真实边缘</li><li>单一的边缘点响应：对每个真实边缘点，检测器仅返回1个点</li></ul><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><ol><li>高斯函数平滑输入图像</li><li>计算图像$f_s$的梯度</li><li>非最大抑制<ul><li>目的：把梯度生成的粗边缘变细</li><li>指定梯度的4个离散方向（水平、垂直、$+45^{\circ}$、$-45^{\circ}$）</li><li>根据梯度的方向确定边缘的方向：<img src="/2019/10/11/dip-notes/grad_dir.png" style="zoom:50%;"></li><li>考虑$(x,y)$为中心的$3\times 3$区域和上述4个方向，确定和梯度$\alpha(x,y)$最接近的方向$d_k$</li><li>如果$M(x,y)$的值比$(x,y)$在$d_k$方向的任一邻居数值小，则抑制($g_N(x,y)=0)$；否则保留($g_N(x,y)=M(x,y)$)</li></ul></li><li>滞后阈值<ul><li>目的：减少伪边缘点</li><li>低阈值$T_L$，高阈值$T_H$，一边比例为2:1或3:1</li><li>大于等于$T_H$的为强边缘点，全部保留；小于$T_L$的全部抑制；剩下的是弱边缘点</li></ul></li><li>连通性分析（这里我怀疑讲义写反了）<ul><li>遍历弱边缘点，保留和强边缘点连通（随便是什么连通）的点</li></ul></li></ol><h1 id="Ch15-图像压缩"><a href="#Ch15-图像压缩" class="headerlink" title="Ch15 图像压缩"></a>Ch15 图像压缩</h1><p>考点：</p><ul><li>压缩的基本概念，相对冗余，压缩比</li><li>灰度图像中3种冗余</li><li>解决冗余问题的编码方式（霍夫曼要掌握，其他不考）</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>数据压缩：减少表示给定信息所需的数据量<br>冗余数据：包含不相关或重复信息的表示</p><p>$b$和$b’$（$b&gt;b’$）是两种不同表示方式的比特数<br><strong>相对数据冗余</strong>$R=1-\frac{1}{C}=1-\frac{b’}{b}$<br><strong>压缩比</strong>$C=\frac{b}{b’}&gt;1$（大的除以小的）<br>e.g.$C=10$意味着有90%的冗余</p><h2 id="灰度图像的3种冗余"><a href="#灰度图像的3种冗余" class="headerlink" title="灰度图像的3种冗余"></a>灰度图像的3种冗余</h2><h3 id="编码冗余"><a href="#编码冗余" class="headerlink" title="编码冗余"></a>编码冗余</h3><ul><li>编码：表示信息的符号系统</li><li>码字：符号序列</li><li>灰度图像的8位编码往往是冗余的</li><li>采用固定长度编码普遍存在冗余，因为灰度直方图不是均匀分布的</li></ul><h3 id="空间和时间冗余"><a href="#空间和时间冗余" class="headerlink" title="空间和时间冗余"></a>空间和时间冗余</h3><ul><li>图像中紧邻点是空间相关的</li><li>视频中连续帧是时间相关的</li><li>行程对：灰度值+该灰度值连续出现的次数</li><li>图像中的像素往往是空间和时间相关的：可以通过紧邻像素预测该像素的值</li><li>更加高效但是视觉不可见的表示：行程+相邻像素的灰度差（灰度差值具有规律性</li><li>映射：可逆/不可逆</li></ul><h3 id="不相关的信息"><a href="#不相关的信息" class="headerlink" title="不相关的信息"></a>不相关的信息</h3><ul><li>被视觉系统忽略的信息</li><li>与图像用途无关的信息</li><li>丢失信息，不可逆映射</li></ul><h2 id="霍夫曼编码"><a href="#霍夫曼编码" class="headerlink" title="霍夫曼编码"></a>霍夫曼编码</h2><ol><li>简化信源<ul><li>对符号的概率进行排序，合并低概率符号</li><li>重复该过程直到剩余2个符号</li></ul></li><li>对简化后的信息源编码<ul><li>从最小信源开始，返回到原信源</li><li>为每一个分支分配符号</li></ul></li></ol><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ul><li>构造霍夫曼编码</li><li>查表法编码、解码</li><li>瞬时性：每个编码独立解码</li><li>唯一可解码：序列的解码方式唯一</li></ul><h1 id="Ch16-形态学处理"><a href="#Ch16-形态学处理" class="headerlink" title="Ch16 形态学处理"></a>Ch16 形态学处理</h1><p>考点：</p><ul><li>腐蚀膨胀</li><li>开闭操作</li><li>定义概念，理解，效果</li></ul><h2 id="腐蚀与膨胀"><a href="#腐蚀与膨胀" class="headerlink" title="腐蚀与膨胀"></a>腐蚀与膨胀</h2><h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><ul><li>集合$B$对集合$A$的腐蚀：$A\ominus B={z|(B)_z\subseteq A}$<ul><li>$(B)_z$表示把$B$的原点平移到坐标$z$</li><li>通常假设$B$为结构元</li><li>等价定义：$A\ominus B={z|(B)_z\cap A^c=\emptyset}$</li></ul></li></ul><h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><ul><li>集合$B$对集合$A$的膨胀：$A\oplus B={z|(\hat{B})_z\cap A\neq\emptyset}$<ul><li>$\hat{B}$表示集合$B$的反射，反射指$\hat{B}={w|w=-b, b\in B}$（关于原点的中心对称）</li><li>通常假设$B$为结构元</li><li>等价定义：$A\oplus B=\bigcup\limits_{b\in B}(A)_b$</li></ul></li></ul><h3 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h3><p>$$<br>(A\ominus B)^c=A^c\oplus \hat{B}<br>$$</p><p>$$<br>(A\oplus B)^c=A^c\ominus \hat{B}<br>$$</p><h2 id="开闭操作"><a href="#开闭操作" class="headerlink" title="开闭操作"></a>开闭操作</h2><h3 id="开操作"><a href="#开操作" class="headerlink" title="开操作"></a>开操作</h3><p>$$<br>A\circ B=(A\ominus B)\oplus B<br>$$</p><ul><li>先腐蚀后膨胀</li><li>平滑物体的轮廓</li><li>断开窄的连接</li><li>消除细的突出</li></ul><p><img src="/2019/10/11/dip-notes/open.png" style="zoom:40%;"></p><h3 id="闭操作"><a href="#闭操作" class="headerlink" title="闭操作"></a>闭操作</h3><p>$$<br>A\bullet B=(A\oplus B)\ominus B<br>$$</p><ul><li>先膨胀后腐蚀</li><li>熔合窄的间断和长沟壑</li><li>消除小孔洞</li><li>填补轮廓中的空隙</li></ul><p><img src="/2019/10/11/dip-notes/close.png" style="zoom:40%;"></p><p><img src="/2019/10/11/dip-notes/openclose.png" style="zoom:50%;"></p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul><li>对偶性<ul><li>$(A\bullet B)^c=(A^c\circ \hat{B})$</li><li>$(A\circ B)^c=(A^c\bullet \hat{B})$</li></ul></li><li>开操作<ul><li>$A\circ B\subseteq A$</li><li>如果$C$是$D$的子集，那么$C\circ B$是$C\circ D$的子集</li><li><s>禁止套娃：</s>$(A\circ B)\circ B=A\circ B$</li></ul></li><li>闭操作<ul><li>$A\subseteq A\bullet B$</li><li>如果$C$是$D$的子集，那么$C\bullet B$是$C\bullet D$的子集</li><li><s>禁止套娃：</s>$(A\bullet B)\bullet B=A\bullet B$</li></ul></li></ul><p>举例：去噪（指纹）</p><h1 id="Ch17-目标识别"><a href="#Ch17-目标识别" class="headerlink" title="Ch17 目标识别"></a>Ch17 目标识别</h1><p>考点：</p><ul><li>最小距离分类器</li><li>最佳统计分类模型（贝叶斯高斯）</li></ul><h2 id="最小距离分类器"><a href="#最小距离分类器" class="headerlink" title="最小距离分类器"></a>最小距离分类器</h2><ul><li>把原型定义为每个类的平均向量：$m_j=\frac{1}{N_j}\sum\limits_{x_j\in \omega_j}x_j, j=1,\ldots W$<ul><li>$N_j$是类别$\omega_j$包含的模式数量</li><li>就是把这个类里面所有的向量加起来取平均</li></ul></li><li>利用欧式距离判断远近：$D_j(x)=||x-m_j||, j=1,\ldots W$<ul><li>$||a||=(a^Ta)^{1/2}$</li><li>如果$D_i(x)$是最短距离，那么$x\in\omega_i$</li><li>等价计算方式：$d_j(x)=x^Tm_j-\frac{1}{2}m_j^Tm_j$，如果$d_i(x)$是最大值，那么$x\in\omega_i$</li></ul></li><li>$\omega_i$和$\omega_j$之间的决策边界：$d_{ij}(x)=d_i(x)-d_j(x)=0$<ul><li>$n=2$对应直线，$n=3$对应平面</li></ul></li></ul><h2 id="最佳统计分类器"><a href="#最佳统计分类器" class="headerlink" title="最佳统计分类器"></a>最佳统计分类器</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><s>没学过ML我哭了</s></p><ul><li>把$\omega_i$的模式预测为属于$\omega_j$，遭受损失$L_{ij}$</li><li>模式$x$属于类别$\omega_i$的概率记为$p(\omega_i/x)$</li><li>条件平均风险（把$x$预测为$\omega_j$会遭受的损失：$r_j=\sum\limits_{k=1}^WL_{kj}p(\omega_k/x)$</li><li>根据贝叶斯公式可以写成：$r_j(x)=\frac{1}{p(x)}\sum\limits_{k=1}^WL_{kj}p(x/\omega_k)P(\omega_k)$</li><li>贝叶斯分类器：预测$x\in\omega_i$如果：$\forall j\neq i, r_j(x)&lt;r_i(x)$</li><li>一般使用0-1损失函数：正确无损失，错误损失为1</li><li>用0-1损失函数并经过一通计算，决策函数$d_j(x)=p(x/\omega_j)P(\omega_j)$</li><li>贝叶斯分类器：能够最小化平均损失<ul><li>前提：每个类$\omega_i$出现的概率$P(\omega_i)$已知（从数据中估计或直接$1/W$）；每个类的概率密度$p(x/\omega_i)$已知（困难，通常假设密度函数为某种解析形式e.g.高斯分布）</li></ul></li></ul><h3 id="针对高斯模式类的贝叶斯分类器"><a href="#针对高斯模式类的贝叶斯分类器" class="headerlink" title="针对高斯模式类的贝叶斯分类器"></a>针对高斯模式类的贝叶斯分类器</h3><p>假设概率密度$p(\bf{x}/\omega_j)$为高斯函数</p><ul><li><p>考虑一维空间内的二分类问题</p><ul><li><p>决策函数就一高斯函数</p></li><li><p>$$<br>d_j(\bf{x})=\frac{1}{\sqrt{2\pi}\sigma_j}e^{-\frac{(\bf{x}-m_j)^2}{2\sigma_j^2}}P(\omega_j)<br>$$</p></li><li><p>参数为均值和标准差</p></li><li><p><img src="/2019/10/11/dip-notes/2class.png" style="zoom:50%;"></p></li></ul></li><li><p>考虑$n$维空间内的$W$分类问题</p><ul><li>公式太多了，自己看图吧</li><li><img src="/2019/10/11/dip-notes/Wclass.png" style="zoom:50%;"></li><li><img src="/2019/10/11/dip-notes/Wclass2.png" style="zoom:50%;"></li><li>当协方差矩阵$C_j$都相等且为单位矩阵时，等价于最小距离分类器</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;期末考试&quot;&gt;&lt;a href=&quot;#期末考试&quot; class=&quot;headerlink&quot; title=&quot;期末考试&quot;&gt;&lt;/a&gt;期末考试&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;题型：选择（不定选）、判断、问答、计算&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Ch01-数字图像处理简介&quot;&gt;&lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库学习笔记</title>
    <link href="https://mengzelev.github.io/2019/10/09/database/"/>
    <id>https://mengzelev.github.io/2019/10/09/database/</id>
    <published>2019-10-09T11:41:22.000Z</published>
    <updated>2020-01-03T07:24:25.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch1-数据库系统概述"><a href="#Ch1-数据库系统概述" class="headerlink" title="Ch1 数据库系统概述"></a>Ch1 数据库系统概述</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>数据库（DB）</strong>：  <ul><li>长期存储在计算机内、有组织、大量的、共享的数据集合</li><li>是数据集合，具有统一的结构形式并存放于统一的存储介质内，它由多种应用数据集成，并可被应用所共享。</li></ul></li><li><strong>数据库管理系统（DBMS）</strong>：<ul><li>位于用户与OS之间的一层数据管理软件，为用户或应用程序提供访问数据库的方法和接口</li><li>能对持久性数据进行管理</li><li>能对大量数据进行有效存取</li><li>可为众多使用者使用同一数据（即数据共享）</li></ul></li><li><strong>数据库系统（DBS）</strong>：<ul><li>实现有组织地、动态地存储大量关联数据、方便多用户访问的计算机硬件、软件和数据资源组成的系统；采用数据库技术的计算机系统</li><li>是一个以对海量的、具有复杂数据结构的、可以持久保存的、可供多用户共享的数据进行统一管理为目标的计算机系统。</li><li>组成：DB，DBMS，DBA，软件平台，硬件平台</li></ul></li><li><strong>数据库管理员（DBA）</strong>：对数据库进行规划、设计、维护、监视的专职人员<ul><li>数据库设计、建立与调整<pre><code>+ 数据库维护</code></pre><ul><li>改善系统性能，提高系统效率</li></ul></li></ul></li></ul><h2 id="数据库系统的基本特点"><a href="#数据库系统的基本特点" class="headerlink" title="数据库系统的基本特点"></a>数据库系统的基本特点</h2><ul><li><strong>数据集成性</strong>：集多种应用数据于一体。表现：采用统一的数据结构，建立一个全局统一的数据模式，根据每个应用的数据需要构作局部模式。</li><li><strong>数据独立性</strong>：数据库中的数据与使用这些数据的应用程序之间的互不依赖性。<ul><li>物理独立性：物理结构（存储结构、存取方式等）</li><li>逻辑独立性：总体逻辑结构的改变，如修改数据模式，增加新的数据类型，改变数据间联系等，不需要修改相应应用程序</li></ul></li><li><strong>数据共享</strong>：可供多个应用程序使用，并可用于不同的目的；可以在已有的数据库系统上开发新的应用程序；可向外界提供信息服务功能</li><li><strong>数据冗余</strong>：同一个数据在不同的地方出现了重复存储</li><li><strong>数据的完整性检查</strong>：对数据库中数据正确性作检查以保证数据的正确。</li><li><strong>数据的安全性保护</strong>：对数据库访问者作检查以防止非法访问。</li><li><strong>并发控制</strong>：对多个应用并发访问所产生的相互干扰作控制以保证其正确性。</li><li><strong>故障恢复</strong>：对遭受破坏的数据具有恢复能力，使数据库具有抗破坏性。</li></ul><h2 id="数据库内部结构体系"><a href="#数据库内部结构体系" class="headerlink" title="数据库内部结构体系"></a>数据库内部结构体系</h2><p><strong>数据模式</strong>：数据库系统中数据结构的一种表示形式，它具有不同的层次与结构方式</p><h3 id="三级模式"><a href="#三级模式" class="headerlink" title="三级模式"></a>三级模式</h3><ul><li><strong>概念模式</strong>（简称模式）<ul><li>是关于整个数据库中数据的全局逻辑结构的描述。</li><li>是面向数据库系统的，它一般以某种数据模型为基础，利用具体的DBMS所提供的数据定义语言（DDL）来描述：<ul><li>数据的类型、长度、特征</li><li>数据间的联系</li><li>安全性、完整性等方面的要求</li></ul></li></ul></li><li><strong>外模式</strong>（也称子模式、用户模式）<ul><li>是关于某个（组）用户所需数据的逻辑结构的描述。</li><li>可由概念模式推导而出，是概念模式的一个子集。一个概念模式可对应着多个外模式。</li><li>有利之处：<ul><li>简化用户接口，便于使用</li><li>降低数据冗余度</li><li>有利于数据的安全性保护和保密</li></ul></li></ul></li><li><strong>内模式</strong>（也称物理模式）<ul><li>是关于数据库中数据的物理存储结构和物理存取方法的描述。</li><li>只有物理数据库真实存在于外存中，其它由物理数据库通过DBMS构造而成。</li></ul></li></ul><p>三级模式是对数据在三种不同的抽象级别上进行的描述。<br>上述三种模式可以构造出三个层次上的数据库概念：概念数据库、用户数据库、物理数据库</p><h3 id="二级映射"><a href="#二级映射" class="headerlink" title="二级映射"></a>二级映射</h3><ul><li><strong>概念模式到内模式的映射</strong><ul><li>该映射给出了概念模式中数据的全局逻辑结构到数据的物理存储结构间的对应关系</li><li>此种映射一般由<strong>DBMS</strong>实现。</li><li>可实现<strong>物理独立性</strong></li></ul></li><li><strong>外模式到概念模式的映射</strong><ul><li>该映射给出了外模式与概念模式的对应关系</li><li>这种映射一般也由<strong>DBMS</strong>实现。</li><li>一个概念模式可以定义多个外模式，而每个外模式是概念模式的一个基本视图。</li><li>概念模式是一个全局模式，而外模式则是用户的局部模式。</li><li>可实现“<strong>逻辑独立性</strong></li></ul></li></ul><h3 id="三级模式与数据独立性的关系"><a href="#三级模式与数据独立性的关系" class="headerlink" title="三级模式与数据独立性的关系"></a>三级模式与数据独立性的关系</h3><ul><li>数据库系统通过两级映射建立三级模式间的联系与转换，使得概念模式与外模式虽然在物理上并不存在，但也能通过映射而获得其存在的实体；</li><li>三级模式之间的两级映射也保证了数据库系统中的<strong>数据独立性</strong>的实现，即数据的内模式或概念模式的改变，并不影响用户实际使用到的外模式，只要调整它们之间的映射方式即可。</li></ul><h1 id="Ch2-数据模型"><a href="#Ch2-数据模型" class="headerlink" title="Ch2 数据模型"></a>Ch2 数据模型</h1><h2 id="数据模型的基本概念"><a href="#数据模型的基本概念" class="headerlink" title="数据模型的基本概念"></a>数据模型的基本概念</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>定义：描述数据的结构，定义在该数据结构上可以执行的操作以及数据之间必须满足的约束条件（结构+操作+约束）</p><ul><li><strong>数据结构（数据模式）</strong><ul><li>描述数据的类型、内容、性质以及数据间的联系</li><li>数据结构是一个数据模型的<strong>基础</strong>，数据操作与数据约束均是建立在相应的数据结构上的</li><li>为了便于区别，数据模型中的数据结构被称为“数据模式”</li><li>数据模式是划分不同类型的数据模型的<strong>依据</strong></li></ul></li><li><strong>数据操作</strong><ul><li>在相应数据结构上可以执行的操作类型与操作方式</li></ul></li><li><strong>数据约束</strong><ul><li>主要描述数据结构内数据间的相互关系，包括：<ul><li>数据间的语法/语义联系</li><li>数据间的制约与依存关系</li><li>数据（间）的动态变化规则</li></ul></li><li>其目的是确保数据的正确、有效与相容</li></ul></li><li><strong>数据模型的核心：数据结构</strong></li></ul><h3 id="三个抽象层次上的数据模型概念"><a href="#三个抽象层次上的数据模型概念" class="headerlink" title="三个抽象层次上的数据模型概念"></a>三个抽象层次上的数据模型概念</h3><ul><li><strong>概念数据模型</strong><ul><li>侧重于对客观世界中复杂事物的结构描述及它们之间内在联系的刻画，不涉及具体的描述细节和物理实现因素</li><li>是一种面向客观世界和用户的模型，与具体采用的DBMS及计算机实现无关</li><li>主要的几种概念模型：E-R模型，EE-R模型；面向对象模型；谓词模型</li><li>侧重于对客观对象的数据特征及其相互关系进行描述，包括<ul><li>有哪些客观对象？（e.g.学生、教师、课程……</li><li>每一类客观对象都有哪些数据特征？（e.g.学生：学号、姓名、专业、性别……</li><li>他们之间有哪些相互关系？</li><li>要了解每个数据项的语义含义，但并不需要定义其实现细节（如数据类型、取值约束等</li></ul></li></ul></li><li><strong>逻辑数据模型</strong><ul><li>着重于数据模型在数据库系一级的实现，即利用具体的DBMS所提供的工具(DDL)来定义的数据模型<ul><li>一种面向数据库系统的模型，概念数据模型只有在转换成逻辑数据模型后才能在数据库中得以表示</li><li>一个中介模型，具有承上启下的作用</li></ul></li><li>曾经流行过的：层次、网状、关系、面向对象、对象关系……</li><li>后来将数据模型划分为三类：<ul><li>结构化：模型一旦定下来就基本不会发生改变，传统数据库系统基本属于这一类。</li><li>半结构化：有模型定义但又易于变化，有自己的模型定义语言与数据操作语言。XML数据库。</li><li>非结构化：数据结构不规则或不完整，没有预定义的数据模型，如文档、图片、网页、音视频等</li></ul></li><li>现在一般分为结构化（关系模型）和非结构化（NoSQL）</li><li>客观事物的实现结构：表及其属性的定义；相互关系的实现结构：表及其外键</li></ul></li><li><strong>物理数据模型</strong><ul><li>用于描述数据是如何在计算机中进行存储，如何表达记录结构、记录顺序和访问路径等信息</li><li>面向计算机物理实现的模型</li><li>大都由DBMS来负责，但也向用户提供如：索引的定义、集簇的定义、存储区域的选择</li></ul></li></ul><h2 id="数据模型的四个世界"><a href="#数据模型的四个世界" class="headerlink" title="数据模型的四个世界"></a>数据模型的四个世界</h2><ul><li><strong>现实世界</strong>：在客观世界中根据用户的需求目标而划定边界的一个应用环境。为整个转换过程提供了客观基础与初始启动环境。</li><li><strong>概念世界</strong>：以现实世界为基础作进一步的抽象而形成的概念模型。DB设计人员进行用户需求分析，形成一些基本概念与基本关系，并用某一种<strong>概念数据模型</strong>中所提供的术语和方法来统一表示。<strong>概念世界与具体的DBMS和计算机无关。</strong></li><li><strong>信息世界</strong>：以概念世界为基础，选用特定的DBMS构造而成的<strong>逻辑数据模型</strong>。<strong>信息世界与具体的DBMS有关。</strong></li><li><strong>计算机世界</strong>：基于逻辑数据模型在计算机中的物理实现而形成的<strong>物理数据模型</strong>。侧重于数据库物理存储结构的描述，是DB的最终实现结构。</li></ul><h2 id="概念世界与概念模型"><a href="#概念世界与概念模型" class="headerlink" title="概念世界与概念模型"></a>概念世界与概念模型</h2><h3 id="E-R模型与E-R图"><a href="#E-R模型与E-R图" class="headerlink" title="E-R模型与E-R图"></a>E-R模型与E-R图</h3><ul><li>最核心的三个概念：<strong>实体（矩形）、属性（椭圆形）、联系（菱形）</strong></li><li><strong>实体</strong>：客观存在且又能相互区别的事物。是对现实世界中的客观事物的抽象，是概念世界中的基本单位。</li><li><strong>属性</strong>：实体所具有的某种特性或特征，属性可以有值。可以取的值的集合，被称为该属性的<strong>域 (domain)</strong>。<ul><li><strong>组合属性</strong>：用于描述实体或联系的性质的简单属性的集合</li><li><strong>多值属性</strong>：一个对于单个实体呈现多个值的属性</li></ul></li><li><strong>联系</strong>：一个实体集中的实体与另一个实体集中的实体之间存在着某种对应关系。在概念世界中，我们用两个实体集的联系来反映它们之间的这种关系。<ul><li>两个实体集间的联系（二元联系）</li><li>多个实体集间的联系（多元联系）</li><li>单个实体集内部的联系</li></ul></li><li><strong>联系的函数对应关系</strong><ul><li>一一对应</li><li>一多对应：一个A对应多个B，一个B只能对应一个A(e.g.宿舍vs.学生)</li><li>多多对应</li></ul></li><li><strong>实体集（联系）与属性间的连接关系</strong><ul><li>属性的描述：属性名</li><li>实体的描述：实体名+实体型（实体中的所有属性名所构成的集合）</li><li>实体集的描述：实体名+实体型+关键字（区分同一个实体集中不同实体的 ‘最小属性集合’）</li></ul></li><li><strong>联系与实体集间的连接关系</strong><ul><li>联系名</li><li>联系的属性</li><li>函数对应关系</li></ul></li><li>连接关系的表示：无向线段</li><li>属性依附实体or联系？<ul><li>实体中的属性：该实体的内在特征，不会因某些联系的出现而改变或消亡</li><li>联系上的属性：用于描述因联系的发生而需要记录、存储下来的信息，和联系同生同灭</li></ul></li></ul><h3 id="EE-R模型与EE-R图"><a href="#EE-R模型与EE-R图" class="headerlink" title="EE-R模型与EE-R图"></a>EE-R模型与EE-R图</h3><ul><li><strong>IS-A联系</strong><ul><li>如果实体集B是实体集A的一个子集，且具有比实体集A更多的属性，则我们称在实体集A与实体集B之间存在着一种特殊的‘IS-A联系’。其中实体集A被称为超(实体)集，实体集B被称为子(实体)集。子集B可以通过IS-A联系继承超集A中的所有属性。</li><li><strong>表示方法：用从‘子实体集’指向‘超实体集’的单向箭头表示</strong></li><li>继承性与传递性</li><li>覆盖约束：所有子集的并集=超集；一个实体至少隶属于某一个子集</li><li>不相交约束：任意两个子集都是互不相交的；一个实体至多隶属于某一个子集</li></ul></li><li><strong>弱实体</strong><ul><li>如果一个实体A的存在需要依赖于其他某个实体的存在，那么实体A被称为弱实体。弱实体(集)与所依赖的实体(集)之间的函数对应关系通常应该是“多对一”的关系。</li><li><strong>表示方法：从弱实体到联系的有向箭头</strong></li></ul></li></ul><p>不在考纲里的：</p><ul><li><strong>属性划分</strong></li><li>属性基数：可以用一个二元组 (x, y) 来描述一个实体在该属性上的取值数量特征。</li><li>标识符：关键字或候选关键字</li><li>描述符：非关键字的属性</li><li>属性基数<ul><li>用二元组(x,y)描述一个实体在该属性上的取值数量特征</li><li>(0, ?)：该属性可以取空值</li><li>(1, ?)：该属性必须有值</li><li>(?, 1)：每一个实体在该属性上最多只能有一个值，单值属性</li><li>(?, N)：多值属性</li><li>x表示能否取空值，y表示单值or多值</li></ul></li><li>参与基数<ul><li>画实体联系图（椭圆点-点椭圆）</li><li>最大参与基数max-card(E,R)：从左边一个点出发的最多的边数（1 or N)</li><li>最小参与基数min-card(E,R)：最少边数(0 or 1)</li><li>参与基数：card(E, R)=(min-card(E, R), max-card(E, R))</li><li>(?, 1) ：单值参与（只能有一个）；(?, N)：多值参与（可以有多个）</li><li>(1, ?)：强制参与（必须要有）；(0, ?)：可选参与（可以没有）</li><li>多对一关系：多值参与的是“一”，单值参与的是“多”（搞啥？？？</li></ul></li></ul><h3 id="面向对象模型"><a href="#面向对象模型" class="headerlink" title="面向对象模型"></a><strong>面向对象模型</strong></h3><ul><li><strong>对象</strong>：客观世界中能够相互区别开来的事物。OO模型中的最基本的概念。</li><li><strong>对象标识符（OID）</strong>：每个对象均具有的一个能相互区别的名字</li><li><strong>方法</strong>：是可以作用在对象上的一段程序。用于反映对象的行为特征，是对象的固有动态行为的表示，可用于审视并改变对象的内部状态（属性值）。</li><li><strong>类</strong>：具有相同属性、方法的对象集合。可以被抽象成一个对象，我们称其为‘类对象’或实例。</li><li><strong>继承</strong><ul><li>一个类的定义和实现建立在其它类的基础之上，并共享其它类的定义和实现</li><li>IS-A联系，被继承的是<strong>超类</strong>，继承的是<strong>子类</strong></li><li>继承关系构成单向不循环的层次结构</li><li>作用：支持代码的共享与重用；有助于系统的扩充</li></ul></li><li><strong>类的聚合与分解</strong><ul><li>类的聚合：由若干个简单类聚合成一个复杂的类的过程</li><li>类的分解：由复杂类分解成若干层次上的简单类的过程</li><li>三种语义：组成语义、嵌套语义、联系语义</li><li>实质上反应了类中对象之间的组合与分解关系</li></ul></li></ul><h2 id="信息世界和逻辑模型"><a href="#信息世界和逻辑模型" class="headerlink" title="信息世界和逻辑模型"></a>信息世界和逻辑模型</h2><ul><li>关系模型<ul><li>基本数据结构：二维表，简称‘表’</li><li>数据操纵：建立在二维表上的操作，包括查询、删除、插入、修改</li><li><strong>关系</strong>：由行和列组成的二维表格<ul><li>同一表中的属性名各不相同</li><li>表中的属性与属性的排放次序无关</li><li>表中的元组均不相同</li><li>表中的元组与元组的排列次序无关</li><li>表中的每一分量必须是一个不可分割的基本数据项<ul><li><strong>属性</strong>：实体所具有的某种特性或特征</li><li><strong>值域（域）</strong>：属性的取值范围</li></ul></li></ul></li><li><strong>元组</strong>：关系中的每一行</li><li>关系模式：一个关系的关系名及其属性名的集合</li><li><strong>关系数据库模式</strong>：该关系数据库中所有关系的关系模式的集合</li><li><strong>关键字</strong>：关系中的一个属性集的值能唯一标识关系中的一个元组，且又不含多余的属性值，则称该属性集为该关系的关键字。一个关系也可以有多个关键字，所以关键字也被称为‘候选关键字’。<ul><li><strong>主关键字</strong>：可以从关系的候选关键字中选取一个作为该关系的主关键字</li><li><strong>外关键字</strong>：设关系R中的属性集F，其取值来自于关系S中的主关键字K，则称属性集F是关系R的外关键字。关系R和关系S可以是同一个关系。 </li></ul></li><li><strong>五种基本操作：属性指定、元组选择、关系合并、元组插入、元组删除</strong></li></ul></li></ul><h2 id="计算机世界与物理模型"><a href="#计算机世界与物理模型" class="headerlink" title="计算机世界与物理模型"></a>计算机世界与物理模型</h2><h3 id="逻辑模型的数据存储"><a href="#逻辑模型的数据存储" class="headerlink" title="逻辑模型的数据存储"></a>逻辑模型的数据存储</h3><ul><li><strong>项</strong>：文件系统中最小基本单位，项内符号是不能继续分割的。</li><li><strong>记录</strong>：由若干项组成，记录内的各项间有内在语义联系</li><li><strong>文件</strong>：记录的集合</li><li><strong>索引</strong>：将文件中的记录与其物理地址(即磁盘块)间建立一张对应关系表以便于快速查找。可以有多级索引。<strong>B+树是关系数据库的物理实现中最常用的一种多级索引技术。</strong></li><li><strong>集簇</strong>：在记录查找中往往需要按某项的项值查找，将具有相同或相邻项值的记录聚集在相同磁盘块内或圆柱体内以减少读盘次数，提高查找速度。</li></ul><h3 id="提高文件访问效率的常用方法"><a href="#提高文件访问效率的常用方法" class="headerlink" title="提高文件访问效率的常用方法"></a>提高文件访问效率的常用方法</h3><ul><li>索引：见上</li><li>集簇：见上</li><li><strong>HASH法</strong>：一种函数转换法。通过一个hash函数将要查找的记录转换成该记录所在的物理地址，然后可以直接进行记录的定位读取操作。</li></ul><h1 id="Ch3-关系数据库系统"><a href="#Ch3-关系数据库系统" class="headerlink" title="Ch3 关系数据库系统"></a>Ch3 关系数据库系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>优点</p><ul><li>数据结构简单（二维表）</li><li>使用方便</li><li>功能强</li><li>数据独立性高</li><li>理论基础深</li><li>可移植性好</li><li>标准化程度高</li><li>分布式功能</li><li>开放性</li><li>其他方面的功能扩展</li></ul><h2 id="完全关系型的12条衡量准则"><a href="#完全关系型的12条衡量准则" class="headerlink" title="完全关系型的12条衡量准则"></a>完全关系型的12条衡量准则</h2><p>完全关系型的12条严格标准</p><ol><li><strong>信息准则</strong>(关系数据库的所有信息都应能在逻辑一级唯一地用‘表’中的值显式表示)</li><li><strong>确保访问准则</strong>(应能保证用逻辑方式依靠表名、关键字值与列名的组合来访问数据库中每一个原子<br>数据)</li><li><strong>空值的关系处理准则</strong>(系统应该具有处理空值的能力)</li><li><strong>基于资源管理的动态联机目录</strong>(数据库的描述信息(数据字典)与用户数据具有相同的表示形式与<br>操作方式)</li><li><strong>统一易用的数据子语言</strong>(至少有一种数据子语言能全面支持下列功能:数据定义、视图定义、数据<br>操纵、完整性约束能力、授权机制、事务处理能力)</li><li><strong>视图更新准则</strong>(通过视图不仅可以查询,还可以执行对数据的增、删、改等操作)</li><li><strong>高级的插入、删除及修改操作</strong>(一条命令可以插入、删除及修改操作多条元组)</li><li><strong>物理数据独立性</strong></li><li><strong>逻辑数据独立性</strong></li><li><strong>数据完整性准则</strong>(提供三类数据完整性约束的定义功能)</li><li><strong>分布独立性</strong>(数据分布的改变不影响原有的应用程序)</li><li><strong>无损害原则</strong>(对提供低级数据子语言的要求)</li></ol><p>关系数据库产品分类</p><ul><li>半关系型系统：满足12条中少量准则</li><li>基本关系型系统：满足12条中大部分</li><li>完全关系型：严格符合12条</li><li>基本数据结构都是关系</li></ul><p><strong>空值（NULL）的定义</strong>：<strong>无意义</strong>或<strong>当前未知</strong>的值。</p><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h3 id="关系模型（概念）"><a href="#关系模型（概念）" class="headerlink" title="关系模型（概念）"></a>关系模型（概念）</h3><h4 id="名词术语对应关系"><a href="#名词术语对应关系" class="headerlink" title="名词术语对应关系"></a>名词术语对应关系</h4><ul><li>关系–表</li><li>属性–列</li><li>元组–行</li><li>模式(schema)–表头（有名字的列的集合）</li></ul><h4 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h4><ul><li><strong>表框架</strong><ul><li>由$n$个命名的属性组成，$n$称为表的<strong>元数</strong>（$n$元表）</li><li>每个属性有一个取值范围，称为值域</li></ul></li><li><strong>元组</strong><ul><li>在表框架中按行存放数据，每一行数据被称为一个元组</li><li>$n$元表中，一个元组由$n$个分量组成，第$j$个分量是表框架中的第$i$个属性</li><li>一个表框架可存放$m$个元组，$m$称为表的<strong>基数</strong>（行数）</li></ul></li><li><strong>关系</strong><ul><li>对二维表的一种抽象，是关系模型的<strong>基本数据单位</strong></li><li>关系名($R$)及其所有的属性名($A_1,A_2\ldots, A_n$)构成了关系框架$R(A_1,A_2,\ldots, A_n)$</li><li>关系模型：以符合7个性质的二维表为基本数据结构所建立的模型</li><li><strong>性质</strong>：不能有多值属性（First Normal Form Rule）、行列无序性(Access row by  content only)、不能有完全相同的两行(The unique row rule)</li></ul></li><li><strong>关键字Key</strong><ul><li>在二维表中能唯一最小标识元组的属性集(要根据语义来判断</li><li>每张二维表都至少存在一个键</li><li><strong>候选键</strong>：候选关键字（关键字不一定唯一）</li><li><strong>主键</strong>：所有候选键中被选中的一个</li><li><strong>超键</strong>：a set of columns that has the uniqueness property，键是最小超键</li><li><strong>外键</strong>：如果表A中的属性集F是表B的键，则称该属性集F是表A的外键。（学生表里的学号vs选课表里的学号）<ul><li>表A是<u>引用表</u>，表B是<u>被引用表</u>。</li><li>表A和表B可以是同一张二维表</li></ul></li><li><strong>关系数据库</strong>：<strong>关系子模式-视图</strong>（没找到）</li></ul></li></ul><h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><p>建立在关系上的数据操纵功能</p><ul><li><strong>数据查询</strong>：两个关系的合并、单个关系内的元组选择（选择满足指定条件的元组）、单个关系内的属性指定（选择结果所需要的属性）</li><li><strong>数据删除</strong>：确定被删除的元组（满足给定逻辑条件）、执行删除操作（一次删除操作只能删除一个关系内的元组）</li><li><strong>数据插入</strong>：在指定关系中插入一个或多个新的元组（一条数据插入操作只能向一个关系中增加新的元组）</li><li><strong>数据修改</strong>：在指定关系中插入一个或多个新的元组（一条数据插入操作只能向一个关系中增加新的元组）。不是基本操作，可以由删除+插入实现</li><li><strong>空值处理</strong><ul><li>主键中不允许出现空值</li><li>算术表达式中出现空值则结果为空值</li><li>逻辑表达式中出现空值则结果为假</li><li>计算SUM，AVG，MAX，MIN，COUNT时空值不统计在内</li><li>对空值作SUM，AVG，MAX或MIN统计操作时，结果均为空值</li><li>对空集作COUNT统计操作时，结果为0</li></ul></li></ul><p>五种基本操作：</p><ul><li>元组选择</li><li>属性指定</li><li>两个关系的合并</li><li>元组插入</li><li>元组删除</li></ul><h3 id="关系中的数据约束"><a href="#关系中的数据约束" class="headerlink" title="关系中的数据约束"></a>关系中的数据约束</h3><p>三类数据完整性约束</p><ul><li><strong>实体完整性约束</strong>：主键中的属性不能有空</li><li><strong>参照完整性约束</strong>：外键要么取空值，要么是被引用表当前存在的某元组上的主键值</li><li><strong>用户定义的完整性</strong>：用户自己定义的属性取值约束</li></ul><h2 id="关系代数-1"><a href="#关系代数-1" class="headerlink" title="关系代数"></a>关系代数</h2><p>$(A, \pi, \sigma, \times, \cup, -)$<br>由关系的集合Ａ及关系间的五种基本运算所构成的代数系统被称为关系代数</p><h3 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h3><ul><li>$n$元关系$R$是一个$n$元有序组的集合</li><li>设$n$元关系$R$的属性域分别是$D_1,D_2,\dots, D_n$，那么这$n$个域的笛卡儿乘积也是</li></ul><h3 id="关系操作的表示"><a href="#关系操作的表示" class="headerlink" title="关系操作的表示"></a>关系操作的表示</h3><table><thead><tr><th style="text-align:center">关系上的五种基本操作</th><th style="text-align:center">关系代数中的五种基本运算</th></tr></thead><tbody><tr><td style="text-align:center">元组选择</td><td style="text-align:center">选择运算</td></tr><tr><td style="text-align:center">属性指定</td><td style="text-align:center">投影运算</td></tr><tr><td style="text-align:center">关系合并</td><td style="text-align:center">笛卡尔乘积</td></tr><tr><td style="text-align:center">元组插入</td><td style="text-align:center">并运算</td></tr><tr><td style="text-align:center">元组删除</td><td style="text-align:center">差运算</td></tr></tbody></table><h4 id="关系代数中的五种基本运算"><a href="#关系代数中的五种基本运算" class="headerlink" title="关系代数中的五种基本运算"></a>关系代数中的五种基本运算</h4><p><strong>每种运算的执行条件和结果关系</strong></p><ul><li><strong>并运算</strong>：<ul><li>条件：参与运算的两个关系必须是<strong>同类关系</strong>（具有相同的属性个数，且对应列所表示的属性应具有相同的值域）。</li><li>结果：关系模式不变，由所有属于关系$R$或属于关系$S$的元组所组成的集合。</li><li>相容表：有相同表头的表是相容表（属性相同，值域相同，含义相同）。并交差运算都只能作用在相容表上。</li></ul></li><li><strong>差运算</strong>：<ul><li>条件：参与运算的两个关系必须是同类关系。</li><li>结果：关系模式不变，由所有属于关系$R$但不属于关系$S$的元组所组成的集合。</li><li>差运算不满足交换律与结合律</li><li>交运算不是基本运算，可以由差运算得到：$R\cap S=R-(R-S)=S-(S-R)$</li></ul></li><li><strong>投影运算</strong>：$\pi_{B_1,B_2,\dots, B_m} (R)$，其中$B_i\in{ A_1,A_2,\dots, A_n } (i=1,2,\dots,m)$。<ul><li>结果：是一个由$B_1,B_2,\dots, B_m$所组成的$m$元关系。关系$R$中的每个元组$t$在$B_1,B_2,\dots, B_m$这$m$个属性上的取值$t_1,t_2,\dots, t_m$构成结果关系中的一个元组。</li><li>不满足交换律</li></ul></li><li><strong>选择运算</strong>：<ul><li>$\sigma_F(R)$，根据给定的条件$F$从关系$R$中选出符合条件的元组。</li><li>结果：结果关系的关系模式不变，由属于关系$R$且满足条件$F$的元组所组成。</li><li>先选择再投影 ，颠倒后的表达式不一定合法；$\pi_A\sigma_F(R)$默认运算顺序：从右向左</li><li>满足交换律</li></ul></li><li><strong>笛卡儿乘积</strong>：<ul><li>设关系$R$和$S$分别有$n$和$m$个属性，即：$R(A_1,A_2,\dots, A_n)$和$S(B_1,B_2,\dots, B_m)$，则它们的笛卡儿乘积$T = R\times S$有$(n+m)$个属性，即：$T(A_1,A_2,\dots, A_n, B_1,B_2,\dots, B_m)$。</li><li>若关系R和S分别有$p$和$q$个元组，那么它们的笛卡儿乘积中就含有$(p\times q)$个元组。</li><li>【<u>笛卡儿乘积满足交换律和结合律</u>】</li><li>如果存在相同属性名，必须对其中至少一个进行换名</li></ul></li></ul><p><strong>关系模型与关系代数</strong>：由关系的集合$A$及关系间的五种基本运算（$\pi, \sigma, \times, \cup, -$）所构成的代数系统被称为<strong>关系代数</strong>。</p><h3 id="扩充运算"><a href="#扩充运算" class="headerlink" title="扩充运算"></a>扩充运算</h3><ul><li><strong>交运算</strong><ul><li>条件：同类关系</li><li>结果：关系模式不变，由所有既属于关系$R$也属于关系$S$的元组所组成的集合</li></ul></li><li><strong>除运算</strong><ul><li>$T=R\div S$: $Head(T)=Head(R)-Head(S)$</li><li>能取遍关系$S$中所有值的$R$中的元组组成的集合（见例子）</li><li>若$R=T\times S$，则$T=R\div S$且$S=R\div T$。若$T=R\div S$，则$T\times S\subseteq R$</li><li>$T\times S\subseteq R$</li><li><strong>【记住！！！】</strong><u>$R\div S=\pi_{A_1,A_2\ldots A_n}(R)-\pi_{A_1,A_2\ldots A_n}((\pi_{A_1,A_2\ldots A_n}(R)\times S)-R)$</u></li></ul></li><li><strong>联接(join)运算</strong><ul><li>$R\underset{F}{\Join}S$: 将关系$R$和关系$S$根据联接条件$F$合并为一个关系，又称$\theta$-联接运算</li><li>不必消除它们之间的同名属性，但在结果中同名属性需要换名</li><li>$R\underset{F}{\Join}S=\sigma_F(R\times S)$</li></ul></li><li><strong>自然联接</strong>($R\Join S$)：根据同名属性进行等值联接，同名属性只保留一份<ul><li>条件：要求关系$R$和关系$S$有公共属性即$\textrm{Head}(R)\cap\textrm{Head}(S)\neq\emptyset$</li></ul></li><li><strong>外联接</strong>：允许外的<strong>另一边</strong>的有null</li></ul><h3 id="关系代数的一些栗子"><a href="#关系代数的一些栗子" class="headerlink" title="关系代数的一些栗子"></a>关系代数的一些栗子</h3><p>查询折扣最高的客户的编号</p><ul><li>$\pi_{C.cid}(C)-\pi_{C.cid}(\sigma_{C.discnt&lt;S.discnt}(C\times S)), S:=C$</li><li>$\pi_{C.cid,S.cid}(\sigma_{C.discnt&gt;=S.discnt}(C\times S))\div \pi_{cid}(C)$</li></ul><hr><h2 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h2><h3 id="基本概念（不在考纲里）"><a href="#基本概念（不在考纲里）" class="headerlink" title="基本概念（不在考纲里）"></a>基本概念（不在考纲里）</h3><ul><li>命题</li><li>个体词。个体域（个体变元的取值范围）</li><li>谓词</li><li>指派</li><li>量词：$\forall, \exists$</li><li>连接符：与或非蕴含</li></ul><h3 id="关系的表示（不在考纲里）"><a href="#关系的表示（不在考纲里）" class="headerlink" title="关系的表示（不在考纲里）"></a>关系的表示（不在考纲里）</h3><ul><li>元组关系演算：$R={t\mid P(t)}$, 可简写为$P(t)$<ul><li>公式中的每个变元的取值都是一个元组，称为元组变量</li><li>$n$元关系$R$可用一个谓词$R(t)$表示，$t$是元组变量，$t(i)$表示关系$R$中的第$i$个属性</li><li>用来描述由谓词$P(t)$的所有成真指派所构成的元组集合</li></ul></li><li>域关系演算：$R={&lt;x_1,x_2,…,x_n&gt;\mid P(x_1,x_2,…,x_n) }$<ul><li>每个变元的取值是单个的属性值，称为域变量</li><li>$n$元关系$R$用$n$元谓词$R(x_1,x_2,\cdots x_n)$表示</li></ul></li><li>通常混用</li></ul><h3 id="原子公式"><a href="#原子公式" class="headerlink" title="原子公式"></a>原子公式</h3><ol><li>谓词$R(t)$是原子公式</li><li>$u(i)\theta v(j)$是原子公式（其中：$u$，$v$是两个元组变量，$u(i)$代表元组$u$在第$i$个属性上的值，$v(j)$代表元组$v$在第$j$个属性上的值，$\theta$是比较运算符）</li><li>$u(i)\theta a$是原子公式（其中$a$是常量）</li></ol><h3 id="公式的定义"><a href="#公式的定义" class="headerlink" title="公式的定义"></a>公式的定义</h3><ol><li>原子公式是公式</li><li>如果$\varphi_1,\varphi_2$是公式，则$(\varphi_1\wedge\varphi_2),(\varphi_1\vee\varphi_2),(\varphi_1\rightarrow\varphi_2)$及$(\neg\varphi_2)$均为公式</li><li>如果$\varphi$是公式，$\varphi$中有自由变元$r$，则$\exists r(\varphi),\forall r(\varphi)$均为公式</li><li>公式由且仅由上面三种方式通过有限次组合构成</li></ol><h3 id="基于关系演算的数据查询表示"><a href="#基于关系演算的数据查询表示" class="headerlink" title="基于关系演算的数据查询表示"></a>基于关系演算的数据查询表示</h3><ul><li><strong>基于关系演算的数据查询表示</strong><ul><li>所有目标属性均以自由变元形式出现，其它属性以约束变元形式出现。(先写完查询标出目标属性，后填上约束变元)</li><li>一般情况下我们使用存在量词对变元作约束，根据题目的需要也可以使用全称量词来约束变元。</li><li>检索条件(元组选择条件）以合取形式(逻辑与）与谓词相联结。</li><li>当变元与常量进行相等比较时，可以用常量值代替变元直接出现在谓词中。</li></ul></li></ul><h4 id="关系操作的表示-1"><a href="#关系操作的表示-1" class="headerlink" title="关系操作的表示"></a>关系操作的表示</h4><p>关系模型有5种基本操作，分别对应5中基本关系运算</p><ul><li>$R\cup S={t\mid R(t)\vee S(t) }$</li><li>$R-S={t\mid R(t)\wedge \neg S(t) }$</li><li>$\sigma_F(R)={t\mid R(t)\wedge F }$</li><li>$\pi_{A_1,A_2}(R)={u^{(2)}\mid \exists t, (R(t)\wedge u(1)=t(1)\wedge u(2)=t(2))} $</li><li>$R\times S={t^{m+n}\mid\exists u^{(m)}\exists v^{(n)}(R(u)\wedge S(v)\wedge t(1)=u(1)\wedge t(2)=u(2)\wedge\ldots t(m)=u(m)\wedge t(m+1)=v(1)\wedge \ldots t(m+n)=v(n))}$</li></ul><p>${t\mid\Phi(t)}$可以简写为$\Phi(t)$</p><p>运算优先级： 比较运算符 &gt; 量词 &gt; 非 &gt; 与或蕴含</p><h5 id="关系的联结"><a href="#关系的联结" class="headerlink" title="关系的联结"></a>关系的联结</h5><ul><li>逻辑与实现笛卡尔乘积：$R(q)\wedge S(q)$</li><li>通过选择条件$F$实现$\theta$-联结：$R(q)\wedge S(q)\wedge F$</li><li>通过两个谓词中的公共变元（同名变元）实现两个关系的自然联结：$R(x,y,z)\wedge S(y,u,v)$</li><li>自联结：谓词名不变，对部分变元进行重命名</li></ul><h3 id="关系演算的例子"><a href="#关系演算的例子" class="headerlink" title="关系演算的例子"></a>关系演算的例子</h3><ul><li>检索所有学生的学号、姓名：$\exists sd,sa (S(\underline{sno}, \underline{sn}, sd ,sa))$ </li><li>检索修读课程号$C_1$的所有学生的姓名：$\exists sno, sd, sa, g (S(sno,\underline{sn},sd, sa)\wedge SC(sno, ‘C’, g))$</li><li>检索修读所有课程的学生的姓名：$\exists sno,sd,sa(S(sno,\underline{sn},sd,sa)\wedge \forall cno(\exists cn,pno(C(cno, cn, pno))\to \exists g(SC(sno, cno,g))) )$</li></ul><h3 id="关系演算的安全性问题（不在考纲里）"><a href="#关系演算的安全性问题（不在考纲里）" class="headerlink" title="关系演算的安全性问题（不在考纲里）"></a>关系演算的安全性问题（不在考纲里）</h3><p>无限关系、无穷验证<br>安全公式：不会产生无限关系和无穷验证现象的关系演算表达式<br>约束集$\text{DOM}(\varphi)$组成：</p><ul><li>公式$\varphi$中所出现的关系中的某些分量</li><li>公式$\varphi$中显式出现的常量符号</li></ul><p>安全公式的判定条件：</p><ul><li>若$t$满足公式$\varphi$，则$t$的每个分量必定是$\text{DOM}(\varphi)$的元素——不会产生无限关系</li><li>对$\varphi$中每一个形为$\exists t(W(t))$的子公式，若$t$满足$W$，则$t$的每个分量一定属于$\text{DOM}(\varphi)$——不会存在无穷验证</li><li>对$\varphi$中每一个形为$\forall t(W(t))$的子公式，如果$t$的任一分量不在$\text{DOM}(\varphi)$中，则$t$必定满足$W$.——不会存在无穷验证</li></ul><h2 id="关系代数与关系演算（不在考纲里）"><a href="#关系代数与关系演算（不在考纲里）" class="headerlink" title="关系代数与关系演算（不在考纲里）"></a>关系代数与关系演算（不在考纲里）</h2><p>关系代数：安全的关系演算</p><p><strong>关系演算→关系代数</strong>：</p><ul><li>$\phi_1\wedge \phi_2$：$R_1\Join R_2$（有公共变元）或$R_1\times R_2$（无公共变元）</li><li>$\phi_1\vee\phi_2$：$R_1\cup R_2$</li><li>$\phi_1\to \phi_2$：$R_1\div R_2$</li><li>$\neg\phi$： $(D_1\times D_2\ldots \times D_n)-R$</li><li>$\exists r, \varphi$：$\pi_{…}(R)$（下标为原公式中所有自由变元）</li><li>$\exists r, \varphi$： $R\div S$</li></ul><p>完备系统</p><ul><li>能够提供关系代数的五种基本运算功能的关系模型系统</li><li>具有安全的关系演算功能的关系模型系统</li></ul><hr><h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><p><u>这一块提纲有点乱，不做重新整理了，基本都覆盖到了，反正也是考计算就凑合着看吧</u></p><ul><li>结尾有分号</li><li>不区分大小写</li><li>字符(串)和日期时间类型的常量需要定界符’，数字不需要</li></ul><h3 id="SQL概貌"><a href="#SQL概貌" class="headerlink" title="SQL概貌"></a>SQL概貌</h3><ul><li>基本概念<ul><li>关系——基表；关系子模式——视图（虚表）；属性——列；元组——行</li><li>基表和虚表统称为表</li></ul></li><li>使用方式：<ul><li>自含式：独立的交互式命令行语言</li><li>嵌入式：嵌入到某种高级程序设计语言（主语言）中使用。嵌入方式：嵌入式SQL（ESQL），函数调用</li></ul></li></ul><h3 id="数据定义功能（DDL）"><a href="#数据定义功能（DDL）" class="headerlink" title="数据定义功能（DDL）"></a>数据定义功能（DDL）</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li>小整型SMALLINT：同C的<code>short</code>, $[-32768,32767]$</li><li>大整型INT: 同C</li><li>巨整型BIGINT: 同C的<code>long long</code></li><li>浮点数DEC(p,s), NUM(p,s): 精度p(最大31位)和小数位s(小数点右边数字的长度)</li><li>字符大对象字符串CLOB(n[K|M|G])</li><li>图形字符串</li><li>二进制串</li><li>日期DATE：年月日</li><li>时间TIME：时分秒</li><li>时间戳TIMESTAMP：年月日时分秒和微秒</li></ul><h4 id="基表创建"><a href="#基表创建" class="headerlink" title="基表创建"></a>基表创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">  colname, datatype [<span class="keyword">NOT</span> <span class="literal">NULL</span>]</span><br><span class="line">  &#123;, colname datatype [<span class="keyword">NOT</span> <span class="literal">NULL</span>]&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>[...]</code>仅允许出现0或1次</li><li><code>{...}</code>可以出现0或若干次</li></ul><p>e.g.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC(</span><br><span class="line">  sno <span class="built_in">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  cno <span class="built_in">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  g <span class="built_in">CHAR</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h4 id="基表修改"><a href="#基表修改" class="headerlink" title="基表修改"></a>基表修改</h4><ul><li><p>表中属性的增加/删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ADD</span> colname datatype;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">DROP</span> colname;</span><br></pre></td></tr></table></figure></li><li><p>删除整个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tablename</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据操纵功能"><a href="#数据操纵功能" class="headerlink" title="数据操纵功能"></a>数据操纵功能</h3><h4 id="SQL和关系代数的关系"><a href="#SQL和关系代数的关系" class="headerlink" title="SQL和关系代数的关系"></a>SQL和关系代数的关系</h4><h5 id="单个关系上的选择和投影"><a href="#单个关系上的选择和投影" class="headerlink" title="单个关系上的选择和投影"></a>单个关系上的选择和投影</h5><p>$\pi_{A_1, A_2,\cdots A_m}(\sigma_F(R_1\times R_2\times\cdots\times R_n))$</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A1, A2, ..., Am</span><br><span class="line"><span class="keyword">FROM</span> R1, R2, ..., Rn</span><br><span class="line"><span class="keyword">WHERE</span> F</span><br></pre></td></tr></table></figure><h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h5><p>$R\times S$</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> R.A1, R.A2, ..., R.An, S.B1, S.B2, ..., S.Bm</span><br><span class="line"><span class="keyword">FROM</span> R,S</span><br></pre></td></tr></table></figure><h5 id="theta-连接"><a href="#theta-连接" class="headerlink" title="$\theta$-连接"></a>$\theta$-连接</h5><p>$R\underset{F}{\Join}S$</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> R.A1, R.A2, ..., R.An, S.B1, S.B2, ..., S.Bm</span><br><span class="line"><span class="keyword">FROM</span> R,S</span><br><span class="line"><span class="keyword">WHERE</span> F</span><br></pre></td></tr></table></figure><h5 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h5><p>$R\Join S$</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> R.A1, R.A2, ..., R.An, </span><br><span class="line">       R.B1, R.B2, ..., R.Bk,</span><br><span class="line">       S.C1, S.C2, ..., S.Cm</span><br><span class="line"><span class="keyword">FROM</span> R,S</span><br><span class="line"><span class="keyword">WHERE</span> R.B1=S.B1 <span class="keyword">and</span> R.B2=S.B2 <span class="keyword">and</span> ... <span class="keyword">and</span> R.Bk=S.Bk</span><br></pre></td></tr></table></figure><p>很麻烦，一般用笛卡尔积+选择+投影</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> attr_1, attr_2, ..., attr_x </span><br><span class="line"><span class="keyword">FROM</span> R, S</span><br><span class="line"><span class="keyword">WHERE</span> F</span><br></pre></td></tr></table></figure><p>可以将两个关系按任意指定的方式F进行合并</p><h4 id="映像语句的结构"><a href="#映像语句的结构" class="headerlink" title="映像语句的结构"></a>映像语句的结构</h4><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">形式</th></tr></thead><tbody><tr><td style="text-align:center">目标子句</td><td style="text-align:center">`SELECT  * \</td><td>colname { , colname … }`</td></tr><tr><td style="text-align:center">范围子句</td><td style="text-align:center"><code>FROM  tablename { , tablename ... }</code></td></tr><tr><td style="text-align:center">条件子句</td><td style="text-align:center"><code>[WHERE  search_condition ]</code></td></tr><tr><td style="text-align:center">分组子句</td><td style="text-align:center"><code>[ GROUP BY  colname { , colname ... }</code></td></tr><tr><td style="text-align:center">分组查询子句</td><td style="text-align:center"><code>[ HAVING  group_condition ] ]</code></td></tr><tr><td style="text-align:center">排序输出子句</td><td style="text-align:center">`[ ORDER BY  colname [ ASC</td><td>DESC ] { , colname [ ASC</td><td>DESC ] … } ];`</td></tr></tbody></table><ul><li>两个必须有的子句：<code>SELECT</code>,<code>FROM</code></li><li><code>HAVING</code>子句前必须有<code>GROUP BY</code></li></ul><h5 id="目标子句"><a href="#目标子句" class="headerlink" title="目标子句"></a>目标子句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  * \| colname &#123; , colname ... &#125;</span><br></pre></td></tr></table></figure><ul><li>定义结果关系所需要的属性</li><li>给出结果属性的属性名<ul><li>表明.属性名</li><li>可以给结果属性<strong>重命名</strong>： <code>&lt;column_expr&gt; AS &lt;colname&gt;</code></li><li><code>*</code>表示表中所有属性</li><li><code>distinct</code>消除结果关系中的重复元组</li></ul></li></ul><h5 id="范围子句"><a href="#范围子句" class="headerlink" title="范围子句"></a>范围子句</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM  tablename &#123; , tablename ... &#125;</span><br></pre></td></tr></table></figure><ul><li>指定操作对象</li><li>可以在<code>FROM</code>子句中对一个关系重命名：<code>&lt;tablename&gt; &lt;aliasname&gt;</code></li><li>多个表通过笛卡尔乘积合并</li><li><code>SELECT</code>子句和<code>FROM</code>子句是一条映像语句中必不可少的两个组成部分</li></ul><h5 id="条件子句"><a href="#条件子句" class="headerlink" title="条件子句"></a>条件子句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE  search_condition</span><br></pre></td></tr></table></figure><ul><li>包括<u>单个关系中的元组选择条件</u> 和<u>关系与关系之间的联接条件</u></li></ul><p><strong>常用谓词</strong></p><ul><li><code>DISTINCT</code></li><li><code>BETWEEN...AND...</code></li><li><p><code>LIKE</code></p><ul><li><code>column [NOT] LIKE val1 [ESCAPE val2]</code></li><li>模板<code>val1</code>:任意字符<code>_</code>， 任意字符串<code>%</code>(包括空字符串)，其他字符匹配自身</li><li>转义指示字符<code>val2</code>：紧跟在<code>val2</code>字符后的<code>_</code>和<code>%</code>不再是通配符而是其自身</li><li>查询课程名中含有百分号的课程的课程号<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cno</span><br><span class="line"><span class="keyword">FROM</span> C</span><br><span class="line"><span class="keyword">WHERE</span> cn <span class="keyword">LIKE</span> <span class="string">'%A%%'</span> ESCAPE <span class="string">'A'</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>IS NULL</code>/<code>IS NOT NULL</code></p><ul><li>查询无课程分数的选课记录中的学号与课程号<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sno, cno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> g <span class="keyword">is</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>布尔运算<code>AND</code>,<code>OR</code>,<code>NOT</code></p></li></ul><h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><p>连接两张相同的表时，可以在<code>FROM</code>语句中对其中一张换名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tablename AS newname</span><br><span class="line">tablename newname</span><br></pre></td></tr></table></figure><p>(<code>AS</code>可以省略)</p><p>e.g.查询至少修读学号为S5的学生所修读的一门课程的学生的学号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SC1.sno</span><br><span class="line"><span class="keyword">FROM</span> SC SC1, SC SC2 //重命名</span><br><span class="line"><span class="keyword">WHERE</span> SC1.cno=SC2.cno <span class="keyword">AND</span> SC2.cno=<span class="string">'S5'</span>;</span><br></pre></td></tr></table></figure></p><h5 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ORDER BY colname [ASC | DESC] &#123;, ...&#125;</span><br><span class="line"><span class="comment">-- colname: 需要排序的列名</span></span><br><span class="line"><span class="comment">-- ASC/DESC 升序/降序， 默认升序</span></span><br></pre></td></tr></table></figure><h4 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><ul><li>在一条映像语句的某个子句中嵌入另一条映像语句(子查询)</li><li>通常在<code>WHERE</code>中</li><li><p>子查询的结果是一个集合——集合谓词</p><ul><li><code>IN</code>：元素和集合之间的关系</li><li><p>限定比较谓词<code>SOME|ANY|ALL</code>：标量与集合元素之间的量化比较</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查询有学生成绩大于C1课程号中所有学生成绩的学生学号</span><br><span class="line"><span class="keyword">SELECT</span> sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> g &gt; ALL(</span><br><span class="line"><span class="keyword">SELECT</span> g</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> cno=<span class="string">'C1'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>EXISTS</code>：是否为空集的判断谓词</p></li></ul></li></ul><h4 id="除法的表示"><a href="#除法的表示" class="headerlink" title="除法的表示"></a>除法的表示</h4><p>e.g.查询至少修读学号为S4的学生所修读的所有课程的学生的学号<br>关系代数表示：$\pi_{sno,cno}(SC)\div\pi_{cno}(\sigma_{sno=’S4’}(SC))$<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sno</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> SC x</span><br><span class="line">  <span class="keyword">WHERE</span> x.sno = <span class="string">'S4'</span> <span class="keyword">and</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">      <span class="keyword">SELECT</span> *</span><br><span class="line">      <span class="keyword">FROM</span> SC y</span><br><span class="line">      <span class="keyword">WHERE</span> y.cno = x.cno <span class="keyword">and</span> y.sno = S.sno</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//另一种表示</span><br><span class="line"><span class="keyword">SELECT</span> S.sno</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> SC x</span><br><span class="line">  <span class="keyword">WHERE</span> x.sno = <span class="string">'S4'</span> <span class="keyword">and</span> x.cno <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> y.cno //注意这里就要用别名</span><br><span class="line">    <span class="keyword">FROM</span> SC y</span><br><span class="line">    <span class="keyword">WHERE</span> y.sno = S.sno</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h4 id="子查询的合并"><a href="#子查询的合并" class="headerlink" title="子查询的合并"></a>子查询的合并</h4><ul><li>并：<code>UNION[ALL]</code></li><li>交: <code>INTERSECT[ALL]</code></li><li>差：<code>EXCEPT[ALL]</code></li></ul><h4 id="SQL统计功能"><a href="#SQL统计功能" class="headerlink" title="SQL统计功能"></a>SQL统计功能</h4><p>可以在同一条SQL语句中同时执行多个统计计算<br><strong>不能在<code>WHERE</code>子句中使用统计函数</strong>，需要嵌套子查询</p><h5 id="count"><a href="#count" class="headerlink" title="count"></a><code>count</code></h5><ul><li><code>count(*)</code>返回集合中元组的个数</li><li><code>count(colname)</code>: 返回在<code>colname</code>属性上取值非空的元组个数</li><li><code>count(distinct, colname)</code>: 返回<code>colname</code>取值非空且互不相同的元组个数</li></ul><h5 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h5><ul><li>统计函数将忽略空值元素</li><li>在空集上进行统计计算时，<code>COUNT()</code>返回0，<code>SUM,AVG,MIN,MAX</code>返回<code>NULL</code></li><li>插入记录是如果没有给出某个属性的取值，系统会自动为该属性赋上空值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给出学号为S1的学生修读的课程门数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> sno = <span class="string">'S1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给出学号为S7的学生所修读课程的平均成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(G)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> sno = <span class="string">'S7'</span></span><br></pre></td></tr></table></figure><h4 id="计算功能"><a href="#计算功能" class="headerlink" title="计算功能"></a>计算功能</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//给出计算机系下一年度学生的年龄</span><br><span class="line"><span class="keyword">SELECT</span>  sn, sa + <span class="number">1</span></span><br><span class="line"><span class="keyword">FROM</span>      S</span><br><span class="line"><span class="keyword">WHERE</span>  sd = <span class="string">'CS'</span>;</span><br></pre></td></tr></table></figure><h4 id="分类功能"><a href="#分类功能" class="headerlink" title="分类功能"></a>分类功能</h4><h5 id="分组查询子句"><a href="#分组查询子句" class="headerlink" title="分组查询子句"></a>分组查询子句</h5><p><code>GROUP BY colname {, colname ...}</code></p><ul><li>根据属性<code>colname</code>的取值不同，将满足<code>WHERE</code>条件的元组划分为不同的集合</li><li>可以在<code>SELECT</code>子句中针对不同的元组集合分别进行统计计算，实现分类统计查询</li><li>DBMS会自动对分组进行排序</li><li><strong>分组统计查询中，目标属性必须包含所有的分组属性</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//给出每个学生的平均成绩</span><br><span class="line"><span class="keyword">SELECT</span> sno, <span class="keyword">AVG</span>(G)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sno</span><br></pre></td></tr></table></figure><h5 id="分组选择子句"><a href="#分组选择子句" class="headerlink" title="分组选择子句"></a>分组选择子句</h5><p><code>HAVING group_condition</code></p><ul><li>根据<code>GROUP BY</code>子句的分组结果，定义分组选择条件</li><li>只有满足<code>group_condition</code>的元组才会被保留</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//给出选修人数超过5个的课程的课程号及其选修人数</span><br><span class="line"><span class="keyword">SELECT</span> cno,<span class="keyword">COUNT</span>(sno)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)  &gt;  <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="SELECT语句使用的一般规则（不在考纲中）"><a href="#SELECT语句使用的一般规则（不在考纲中）" class="headerlink" title="SELECT语句使用的一般规则（不在考纲中）"></a>SELECT语句使用的一般规则（不在考纲中）</h3><h4 id="处理顺序"><a href="#处理顺序" class="headerlink" title="处理顺序"></a>处理顺序</h4><ol><li>合并<code>FROM</code>子句中的表(笛卡尔乘积)</li><li>利用<code>WHERE</code>子句中的条件进行元组选择</li><li>根据<code>GROUP BY</code>子句对保留下来的元素进行分组</li><li>利用<code>HAVING</code>子句中的条件对分组后的元组集合进行选择</li><li>根据<code>SELECT</code>子句进行统计计算，生成结果关系</li><li>根据<code>ORDER BY</code>子句对查询结果进行排序</li></ol><h3 id="SQL更新功能"><a href="#SQL更新功能" class="headerlink" title="SQL更新功能"></a>SQL更新功能</h3><h4 id="元组删除"><a href="#元组删除" class="headerlink" title="元组删除"></a>元组删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tablename </span><br><span class="line">[<span class="keyword">WHERE</span> search_condition]</span><br></pre></td></tr></table></figure><ul><li>删除符合条件的元组</li><li>一条语句只能删除一张表中的元组</li><li>没有<code>WHERE</code>子句就删除表中所有元组</li><li><code>WHERE</code>中也可以嵌入子查询</li></ul><h4 id="元组插入"><a href="#元组插入" class="headerlink" title="元组插入"></a>元组插入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename[(colname&#123;, colname ...&#125;)] </span><br><span class="line"><span class="comment">-- 属性名列表，默认是基表定义中的顺序</span></span><br><span class="line"><span class="keyword">VALUES</span> (expr | <span class="literal">NULL</span> &#123;, expr | <span class="literal">NULL</span> ...&#125;) | subquery;</span><br><span class="line"><span class="comment">-- 被插入的常量元组值，属性值的数量与排列顺序必须与INTO子句中的一致</span></span><br><span class="line"><span class="comment">-- 也可以将子查询的结果插入表中，注意属性的数量和排列顺序</span></span><br></pre></td></tr></table></figure><p><strong>常量元组插入</strong>e.g.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'S10'</span>, <span class="string">'C25'</span>, <span class="string">'B'</span>)</span><br></pre></td></tr></table></figure></p><p><strong>带子查询的元组插入</strong>e.g.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入计算机系学号学生选修数据库的选课记录</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC(sno, cno)</span><br><span class="line"><span class="keyword">SELECT</span> sno, cno</span><br><span class="line"><span class="keyword">FROM</span> S, C</span><br><span class="line"><span class="keyword">WHERE</span> sd = <span class="string">'CS'</span> <span class="keyword">and</span> cn = <span class="string">'Database'</span>;</span><br></pre></td></tr></table></figure></p><h3 id="元组修改"><a href="#元组修改" class="headerlink" title="元组修改"></a>元组修改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tablename</span><br><span class="line"><span class="keyword">SET</span> colname = expr | <span class="literal">NULL</span> | subquery, ...</span><br><span class="line">[<span class="keyword">WHERE</span> search_condition];</span><br></pre></td></tr></table></figure><ul><li>修改指定基表中满足<code>WHERE</code>条件的元组<br>e.g<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将计算机系学生的成绩全置零</span></span><br><span class="line"><span class="keyword">UPDATE</span> SC</span><br><span class="line"><span class="keyword">SET</span> g = <span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> sno <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> sno</span><br><span class="line">  <span class="keyword">FROM</span> S</span><br><span class="line">  <span class="keyword">WHERE</span> sd = <span class="string">'CS'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> viewname [(colname&#123;, colname, ...&#125; )]</span><br><span class="line"><span class="keyword">AS</span> &lt;映像语句&gt; [<span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure><ul><li><strong>视图概念</strong>：由若干张表经映像语句构筑而成的表，又称“导出表”</li><li><strong>视图与基表的区别</strong>：<ul><li>视图的二维表本身（结构与数据）并不实际存在与数据库内，而仅仅保留了其构造信息（有关视图的定义信息），因此视图又被称为“虚表”</li><li>当用户执行视图上的访问操作时，DBMS将根据视图的定义命令把视图访问操作转换成相应的基表访问操作</li></ul></li><li><code>WITH OPTION CHECK</code>用于约束视图上的修改操作，使修改后的新元组仍能够通过视图上的查询操作查出来</li></ul><p>e.g.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义学生的学号、姓名及其平均成绩的视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> S_G(sno, sn, Avg_G)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> sno, sn, <span class="keyword">AVG</span>(G)</span><br><span class="line"><span class="keyword">FROM</span> S, SC</span><br><span class="line"><span class="keyword">WHERE</span> S.sno = SC.sno</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sno, sn</span><br></pre></td></tr></table></figure></p><h4 id="视图的嵌套定义"><a href="#视图的嵌套定义" class="headerlink" title="视图的嵌套定义"></a>视图的嵌套定义</h4><p>可以用已有的视图定义新的视图<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S_C_G是一个已经存在的视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> C_G(cn, Cavg)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> cn, <span class="keyword">AVG</span>(G)</span><br><span class="line"><span class="keyword">FROM</span> S_C_G</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cn</span><br></pre></td></tr></table></figure></p><h4 id="视图删除"><a href="#视图删除" class="headerlink" title="视图删除"></a>视图删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> viewname</span><br></pre></td></tr></table></figure><ul><li>将连带删除定义在该视图上的其他视图</li></ul><h4 id="可更新视图的判断标准"><a href="#可更新视图的判断标准" class="headerlink" title="可更新视图的判断标准"></a>可更新视图的判断标准</h4><ul><li>视图的每一行必须对应基表的惟一一行</li><li>视图的每一列必须对应基表的惟一一列</li></ul><h4 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h4><ul><li>提高了数据独立性</li><li>简化用户观点</li><li>提供自动的安全保护功能。</li></ul><h3 id="练习中的一些难题"><a href="#练习中的一些难题" class="headerlink" title="练习中的一些难题"></a>练习中的一些难题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 3.2 检索为居住在Duluth和Kyoto的所有客户订购过同一种商品的经销商的编号</span></span><br><span class="line"><span class="comment">-- 注意调用子查询时要加上外层查询的约束条件</span></span><br><span class="line"><span class="keyword">SELECT</span> a.aid</span><br><span class="line"><span class="keyword">FROM</span> Agents a</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> Orders o</span><br><span class="line">  <span class="keyword">WHERE</span> o.aid = a.aid <span class="keyword">and</span> o.pid <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> p.pid <span class="comment">-- 所有这两个城市的居民都买过的商品</span></span><br><span class="line">    <span class="keyword">FROM</span> Products p</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ( </span><br><span class="line">      <span class="keyword">SELECT</span> *</span><br><span class="line">      <span class="keyword">FROM</span> Customers c</span><br><span class="line">      <span class="keyword">WHERE</span> (c.city = <span class="string">'Duluth'</span> <span class="keyword">or</span> c.city = <span class="string">'Kyoto'</span>) <span class="keyword">and</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> Orders x</span><br><span class="line">        <span class="keyword">WHERE</span> x.pid = p.pid <span class="keyword">and</span> x.cid = c.cid <span class="keyword">and</span> x.aid = a.aid</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  ) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回每个客户的编号及最后两份订单的订购日期</span></span><br><span class="line"><span class="comment">-- 至少有2条订单的客户</span></span><br><span class="line"><span class="keyword">SELECT</span> o1.cid, o1.orddate <span class="keyword">AS</span> last_but_one_ord, o2.ordate <span class="keyword">AS</span> last_ord</span><br><span class="line"><span class="keyword">FROM</span> Orders o1, Orders o2</span><br><span class="line"><span class="keyword">WHERE</span> o1.cid = o2.cid <span class="keyword">and</span> o1.ordno &lt; o2.ordno <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> Orders o</span><br><span class="line">  <span class="keyword">WHERE</span> o.cid = o1.cid <span class="keyword">and</span> o.ordno &lt;&gt; o2.ordno <span class="keyword">and</span> o.ordno &gt; o1.ordno</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只有一条订单的客户</span></span><br><span class="line"><span class="keyword">SELECT</span> o1.cid, o1.orddate <span class="keyword">AS</span> last_but_one_ord, <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">FROM</span> orders o1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> orders o</span><br><span class="line">  <span class="keyword">WHERE</span> o.cid = o1.cid <span class="keyword">and</span> o.ordno &lt;&gt; o1.ordno</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 没有订单的客户（自己想吧）</span></span><br><span class="line"><span class="comment">-- 结果是把以上三个查询UNION起来</span></span><br></pre></td></tr></table></figure><ul><li>全称量词可以用<code>ALL</code>、<code>NOT EXISTS</code>、<code>NOT IN</code>或<code>MAX()/MIN()</code>来实现</li></ul><h1 id="CH4-数据库的安全性与完整性保护"><a href="#CH4-数据库的安全性与完整性保护" class="headerlink" title="CH4 数据库的安全性与完整性保护"></a>CH4 数据库的安全性与完整性保护</h1><h2 id="4-1-数据库的安全性保护"><a href="#4-1-数据库的安全性保护" class="headerlink" title="4.1 数据库的安全性保护"></a>4.1 数据库的安全性保护</h2><h3 id="数据库安全的基本概念与内容"><a href="#数据库安全的基本概念与内容" class="headerlink" title="数据库安全的基本概念与内容"></a>数据库安全的基本概念与内容</h3><ul><li><strong>主体</strong>：数据库中数据的访问者</li><li><strong>客体</strong>：数据库中的数据及其载体，如表、视图、快照、存储过程、数据文件等</li><li><strong>身份标识与鉴别</strong>：每个主体必须有一个标识自己身份的标识符（以区别不同的主体）以及一个用以验证其身份的访问口令。当主体访问客体时，TCB 将对主体所提交的身份标识符和口令进行鉴别，以阻止非法访问。</li><li><strong>自主访问控制（DAC）</strong>：是一种基于存取矩阵的安全控制模型。用户对信息的存取控制是基于“用户的鉴别”和“存取访问规则的确定”<ul><li>每个用户都要给以对系统中每个存取对象的存取权限</li><li>当一个主体要求访问一个客体时，系统将检查该主体在相应客体上是否拥有所需要的存储权限</li><li>存取权限：一个客体的所有者自动拥有该客体上的所有操作权限；拥有权限的用户可以自主地将他所拥有的权限传授给其它任意在系统登录的用户。用户只能通过这两种方式来获得在一个客体上的存取权限。</li><li>访问控制：在用户登录时进行用户的身份鉴别；在用户访问数据库时执行访问检查控制</li></ul></li><li><strong>审计</strong>：跟踪记录用户对数据的访问操作：访问时间/访问内容/用户名/终端名/操作类型/操作结果，并可根据审计结果给出报警信息。<ul><li>执行审计操作需要额外的时间和空间开销，因此在DBMS中，审计通常是一个可选择的安全保护手段，主要用于安全性要求较高的部门。</li></ul></li></ul><h3 id="SQL对数据库安全的支持"><a href="#SQL对数据库安全的支持" class="headerlink" title="SQL对数据库安全的支持"></a>SQL对数据库安全的支持</h3><ul><li>在SQL’92中提供的C1级数据库安全的支持：主体、客体及主客体分离；身份标识与鉴别；数据完整性；自主访问控制与授权功能；审计。</li><li><p>SQL的自主访问控制与授权功能：SQL中的自主访问控制是通过（<strong>用户、操作对象、操作权限</strong>）这样的三元组来定义用户对数据的访问权限的，并可通过授权（Grant）和回收（Revoke）语句来改变用户的访问权限。</p><ul><li><strong>SQL的存取权限（操作权限）</strong>：SELECT权，INSERT权，DELETE权，UPDATE权，REFERENCY权，EXECUTE权，USAGE权</li></ul></li><li><p><strong>SQL中的授权命令GRANT</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;操作权限列表&gt; <span class="keyword">ON</span> &lt;操作对象&gt; <span class="keyword">TO</span> &lt;用户名列表&gt; [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>]</span><br><span class="line"><span class="comment">--e.g.</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span> <span class="keyword">on</span> S <span class="keyword">to</span> XULIN <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span></span><br></pre></td></tr></table></figure></li><li><p><strong>SQL中的权限的回收命令REVOKE</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;操作权限列表&gt; <span class="keyword">ON</span> &lt;操作对象&gt; <span class="keyword">FROM</span> &lt;用户名列表&gt; [RESTRICT | <span class="keyword">CASCADE</span>]</span><br><span class="line"><span class="comment">--e.g.</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">UPDATE</span> <span class="keyword">on</span> S <span class="keyword">from</span> XULIN <span class="keyword">CASCADE</span></span><br></pre></td></tr></table></figure><ul><li><code>CASCADE</code>：连锁回收</li><li><code>RESTRICT</code>:在不存在连锁回收问题时才能回收权限，否则拒绝回收</li></ul></li></ul><h2 id="4-2-数据库的完整性保护"><a href="#4-2-数据库的完整性保护" class="headerlink" title="4.2 数据库的完整性保护"></a>4.2 数据库的完整性保护</h2><ul><li><strong>数据库完整性保护</strong><ul><li><strong>目的</strong>：及时发现错误；能够采取措施防止错误的进一步蔓延；最终将数据库回复到正确状态。</li><li><strong>常用实现措施</strong>：完整性约束条件的定义及审查；触发器；并发控制技术</li><li><strong>功能</strong>：三个基本功能：设置功能、检查功能、处理功能</li></ul></li><li>完整性规则<ul><li><strong>实体完整性规则</strong>：在一个基表的主关键字（主键）中，其属性的取值不能为空值。</li><li><strong>参照完整性</strong>：关系R中的每个元组在外关键字F上的值或者是空值（NULL），或必须引用在关系S中存在的元组，即不能引用不存在的实体。<ul><li>引用：若关系R中有属性集F与另一个关系S的关键字$K_s$相对应（具有相同的语义和取值范围），则称关系R引用关系S中的元组。</li></ul></li><li><strong>用户定义完整性</strong>：由用户来定义的数据库完整性要求。</li></ul></li><li><p><strong>完整的CREATE TABLE命令</strong></p><ul><li>需要定义的内容：模式名与表名。属性的定义：属性名与数据类型、缺省值、数据约束。表级（元组级）的数据约束定义。</li><li><p><strong>基表的创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT constraint_name]</span><br><span class="line">&#123; UNIQUE(colname &#123;, colname, ...&#125;)</span><br><span class="line">  | PRIMARY KEY (colname, &#123;, colname, ...&#125;)</span><br><span class="line">  | <span class="keyword">CHECK</span> (search_condition)</span><br><span class="line">  | FOREIGN <span class="keyword">KEY</span> (colname, &#123;, colname, ...&#125;)</span><br><span class="line">    <span class="keyword">REFERENCES</span> table_name[(colname &#123;, colname, ...&#125;)]</span><br><span class="line">      [<span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> | RESTRICT | <span class="keyword">SET</span> <span class="literal">NULL</span>]</span><br><span class="line">      [<span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> | RESTRICT | <span class="keyword">SET</span> <span class="literal">NULL</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 基于多个属性的取值约束</span></span><br></pre></td></tr></table></figure><ul><li><code>NOT NULL</code> v.s. <code>DEFAULT NULL</code></li><li>Constraint name：对某个数据约束条件进行命名（可选项），以利于以后使用<code>ALTER TABLE</code>命令来修改表中数据约束定义</li><li><code>UNIQUE</code> v.s. <code>NOT NULL</code>：UNIQUE属性可以取空值，候选键：<code>UNIQUE</code>+<code>NOT NULL</code></li><li><code>PRIMARY KEY</code> v.s. <code>NOT NULL</code>：主键定义自动蕴含着“非空”的约束要求</li><li><code>REFERENCES</code>：外键v.s.主键；外键上的取值约束及其一致性的保证措施</li><li><code>CHECK</code>：其他任意的属性取值约束</li><li><code>FOREIGN KEY</code>：定义主外键的引用关系。当对引用表中的外键进行赋值时，需要检查外键值的正确性。</li><li><code>ON DELETE/UPDATE</code>：当在被引用表中删除元组或修改主键值时，需要维护引用表中外键值的正确性，具体方式如下：<ul><li><code>CASCADE</code>：同步做连带更新/删除</li><li><code>RESTRICT</code>：如果在引用表中存在与被删除或修改的主键相关的元组，则拒绝本次对被引用表的<code>DELETE/UPDATE</code>操作</li><li><code>SET NULL</code>：如果在引用表中存在与被删除或修改的主键相关的元组，则自动地将相关元组上的外键值设置为空</li></ul></li></ul></li><li><p><strong>完整性约束的定义</strong>：主关键字，外关键字，CHECK约束，UNIQUE，NOT NULL, DEFAULT</p><ul><li>主键定义：<code>PRIMARY KEY (&lt;column-list&gt;)</code></li><li>唯一键定义：<code>UNIQUE(&lt;column-list&gt;)</code></li><li><p>外键定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FOREIGN KEY (&lt;fk-col-list&gt;)</span><br><span class="line">REFERENCES &lt;table-name&gt; (&lt;pk-col-list&gt;)</span><br><span class="line">[ON <span class="keyword">DELETE</span> [<span class="keyword">CASCADE</span> | RESTRICT | <span class="keyword">SET</span> <span class="literal">NULL</span>]]</span><br><span class="line">[<span class="keyword">ON</span> <span class="keyword">UPDATE</span> [<span class="keyword">CASCADE</span> | RESTRICT | <span class="keyword">SET</span> <span class="literal">NULL</span>]]</span><br></pre></td></tr></table></figure></li><li><p>e.g.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> EMP (</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> pk PRIMARY <span class="keyword">KEY</span>(Empno) <span class="comment">--主键定义</span></span><br><span class="line">  <span class="keyword">CONSTRAINT</span> uni_name <span class="keyword">UNIQUE</span>(PersonId) <span class="comment">--候选键的定义</span></span><br><span class="line">  <span class="comment">--外键Deptno的定义</span></span><br><span class="line">  <span class="keyword">CONSTRAINT</span> fk_depy</span><br><span class="line">  FOREIGN <span class="keyword">KEY</span>(Deptno)</span><br><span class="line">    <span class="keyword">REFERENCES</span> DEPT(Deptno)</span><br><span class="line">      <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="comment">--DEPT表中Deptno更新时同步更新EMP的Deptno</span></span><br><span class="line">      <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="comment">--删除某个部门的员工，禁止在部门表中删除该部门元组</span></span><br><span class="line">  <span class="keyword">CONSTRAINT</span> chk_1  <span class="keyword">CHECK</span> (...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>触发器及其创建命令</strong></p><ul><li><strong>定义</strong>：一个事件的发生会导致另外一些事件的发生</li><li><strong>功能</strong>：某个事件的发生会导致另外一些事件的执行，以消除前一个事件对数据完整性所起的影响。</li><li>组成：触发事件、结果事件、触发过程</li><li><strong>定义命令</strong><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name&#123;<span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span>&#125; <span class="comment">--触发事件</span></span><br><span class="line">  &#123; <span class="keyword">INSERT</span> | <span class="keyword">DELETE</span> | <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> &lt;<span class="keyword">col</span>-<span class="keyword">list</span>&gt;] <span class="keyword">ON</span> table_name &#125; <span class="comment">--执行方式</span></span><br><span class="line">  [<span class="keyword">REFERENCING</span> corr_name_def&#123;, ...&#125;]</span><br><span class="line">  [<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> | <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">STATEMENT</span>]</span><br><span class="line">  [<span class="keyword">WHEN</span> (search_condition)]</span><br><span class="line">    &#123;statement | BEGIN ATOMIC statement; &#123;statement; ...&#125;&#125;--结果事件</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--e.g</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> update_sal</span><br><span class="line">  <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">or</span> <span class="keyword">UPDATE</span>(sal, pos) <span class="keyword">ON</span> Teach</span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">    <span class="keyword">WHEN</span> (:new.Pos = <span class="string">'Prof.'</span>)</span><br><span class="line">      <span class="keyword">BEGIN</span> <span class="keyword">IF</span> :new.sal &lt; <span class="number">2000</span></span><br><span class="line">            <span class="keyword">THEN</span> :new.sal := <span class="number">2000</span>;</span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="CH5-事务处理、并发控制与故障恢复技术"><a href="#CH5-事务处理、并发控制与故障恢复技术" class="headerlink" title="CH5 事务处理、并发控制与故障恢复技术"></a>CH5 事务处理、并发控制与故障恢复技术</h1><h2 id="5-1-事务处理（概念）"><a href="#5-1-事务处理（概念）" class="headerlink" title="5.1 事务处理（概念）"></a>5.1 事务处理（概念）</h2><ul><li><strong>事务的定义</strong>：由某个用户所执行的一个不能被打断的对数据库的操作序列<ul><li>应用程序访问数据库的基本逻辑工作单位</li><li>通常由一组对于数据库的访问操作组成，在执行过程中按照预定的次序顺序执行</li><li>串行执行；中间状态可能会不一致，但结束时系统保证数据一致性</li></ul></li><li><strong>ACID性质</strong><ul><li><strong>原子性</strong>（Atomicity）：所有操作要么都不执行要么都执行；<ul><li>DBMS自动维护：DBMS的事务管理子系统　+　事务日志</li></ul></li><li><strong>一致性</strong>（Consistency）：一个事务的成功67执行总是将数据库从一个一致的状态转换到另一个一致的状态。<ul><li>状态：数据库中所有数据对象的当前取值情况</li><li>一致状态：数据必须满足1.在数据库中显式定义的各种完整性约束2.用户心目中的隐式数据约束</li><li>一致性原则基于假设：在一个事务开始执行之前数据库处于一个一致的状态，如果没有<strong>其它事务的干扰和系统故障</strong>，那么当该事务执行结束时数据库仍然处于一致的状态。</li><li>一致性由两方面完成：DBMS中的“数据完整性保护”子系统 + 编写事务的应用程序员</li></ul></li><li><strong>隔离性</strong>（Isolation）：一个事务的执行与并发执行的其它事务之间是相互独立的，互不干扰。<ul><li>多个事务并发执行的最终结果，应该与它们的某种串行执行的最终结果相等，这被称为并发事务的可串行化。</li><li>实现：DBMS的并发控制子系统（包含在事务管理子系统中）</li></ul></li><li><strong>持久性</strong>（Durability）：一个事务一旦完成其全部操作后，它对数据库的所有更新应永久地反映在数据库中，即使以后系统发生故障也应该能够通过故障恢复来保留这个事务的执行结果<ul><li>实现：DBMS的恢复管理子系统</li></ul></li></ul></li></ul><h3 id="事务活动及其状态转换图"><a href="#事务活动及其状态转换图" class="headerlink" title="事务活动及其状态转换图"></a>事务活动及其状态转换图</h3><p><img src="/2019/10/09/database/swhd.png" alt=""></p><ul><li>两组类型的读写操作：事务与Cache之间，Cache与Disk Files之间</li><li>活动状态<ul><li>事务在开始执行后立即进入“活动状态”，事务将执行对数据库的访问操作</li><li>在DBMS的事务管理子系统看来，用户事务对数据库的访问操作就是对数据库中数据的读写操作</li></ul></li><li>“预提交”状态<ul><li>当事务的最后一条访问语句执行结束之后，事务进入预提交状态。此时数据都在Cache里。</li><li>预提交阶段必须确保将当前事务的所有修改操作的执行结果被真正写入到数据库的磁盘中去。</li><li>在所有写磁盘操作执行结束后，事务就进入<strong>提交</strong>状态。</li><li>完成提交任务的过程中仍然会发生系统故障，导致当前事务执行失败。预提交失败后当前事务也将被放弃（abort），进入失败状态</li></ul></li><li>“失败”状态<ul><li>从活动状态转变为失败的原因：用户或应用程序主动放弃（abort）当前事务；因并发控制而被放弃的事务；发生系统故障</li><li>从预提交状态转变为失败的原因：发生系统故障</li></ul></li><li>“异常终止”状态<ul><li>失败状态下事务很可能修改了磁盘的一部分数据，为了保证原子性，需要撤销这些修改。撤销完成后，事务被打上aborted标志，转而进入异常终止”状态</li><li>回退（rollback）：对事务的撤销操作，也称为事务的“回退”或“回滚”；由DBMS的恢复子系统实现</li><li>进入异常终止后两种选择：作为一个新的事务重启；取消事务</li></ul></li><li>“提交”状态<ul><li>预提交后检查通过，系统执行commit操作，把数据修改写到磁盘上，并通知系统事务成功结束</li><li>为事务打上一个提交标志（commited），事务就进入提交状态</li></ul></li><li>“异常终止”和“提交”都意味着一个事务的执行结束</li><li>事务开始运行：活跃状态(active transaction);执行结束：不活跃状态(inactive transaction)</li><li>并发控制只针对活跃状态的事务</li></ul><h3 id="事务控制即相关的参数设置语句"><a href="#事务控制即相关的参数设置语句" class="headerlink" title="事务控制即相关的参数设置语句"></a>事务控制即相关的参数设置语句</h3><ul><li>事务的开始（考纲无）</li><li><strong>事务提交</strong>：提交当前事务，事务在执行过程中对于数据库的所有修改操作都将永久地反应到数据库中，并且不可被取消。</li><li><strong>事务回滚</strong>：取消在该事务执行过程中的所有操作，回滚该事务至事务的起点或某个保存点，以便重新执行或放弃（abort）该事务。<ul><li>保存点：事务中的存档点。用户事务可以使用Rollback命令将当前事务回退到前面某个保存点sp。不带保存点的回退操作将结束并放弃整个事务。</li></ul></li><li>设置事务的自动提交命令：<code>SET AUTOCOMMIT ON|OFF</code></li><li>设置<strong>事务的读写类型</strong>：<code>SET TRANSACTION READONLY|READWRITE</code><ul><li>只读型事务</li><li>读写型事务（缺省定义）</li></ul></li><li>设置<strong>事务的隔离级别</strong><ul><li><code>SET TRANSACTION ISOLATION LEVEL READUNCOMMITED | READCOMMITED | READREPEATABLE | SERIALIZABLE</code></li><li>隔离级别不同，系统所采用的封锁策略不同</li><li>未提交读：当前事务不需要申请任何类型的封锁，因而可能会读到未提交的修改结果。（写不可以这样）</li><li>提交读：在读数据对象A之前需要先申请对数据对象A的共享性封锁，在读操作执行结束之后<strong>立即释放</strong>该封锁，以避免读到其他并发事务未提交的修改结果。</li><li>可重复读：在读数据对象A之前需要先申请对数据对象A的共享性封锁，并将该封锁<strong>维持</strong>到当前事务的结束。可以避免其它的并发事务对当前事务正在使用的数据对象的修改。</li><li>可序列化（可串行化）：并发事务以一种可串行化的调度策略实现其并发执行，以避免它们相互之间的干扰现象。</li><li>不论何种隔离级别，“写”操作之前先要申请数据对象的“排他性”封锁，并将该封锁维持到当前事务的结束。</li><li>可能的并发错误现象：更新丢失、脏读、不可重复读、<strong>幻象读</strong>（同一个事务多次执行同一个查询返回的结果不同）</li></ul></li></ul><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻象读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读</td><td style="text-align:center">有</td><td style="text-align:center">有</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">提交读</td><td style="text-align:center">无</td><td style="text-align:center">有</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">无</td><td style="text-align:center">无</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">可串行化</td><td style="text-align:center">无</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr></tbody></table><h3 id="事务的语句组成成分"><a href="#事务的语句组成成分" class="headerlink" title="事务的语句组成成分"></a>事务的语句组成成分</h3><p>事务相关的操作包含两类：事务控制操作 &amp; 数据访问操作</p><ul><li>事务控制操作<ul><li>事务的开始：<code>START T0</code>（启动一个新事务时，DBMS自动分配一个唯一的事务标识符</li><li>提交事务：<code>COMMIT T0</code></li><li>回退（放弃）事务：<code>ABORT T0</code></li></ul></li><li>数据访问操作<ul><li>将数据对象A的值从磁盘中读入内存缓冲区：<code>INPUT(A)</code></li><li>将内存缓冲区中数据对象A的值写入磁盘：<code>OUTPUT(A)</code></li><li>将内存缓冲区中数据对象A的值读入内存变量t：<code>READ(A, t)</code>可能隐含<code>INPUT(A)</code></li><li>将内存变量t的值写入内存缓冲区中数据对象A：<code>WRITE(A, t)</code></li></ul></li></ul><h2 id="5-2-并发控制技术（概念）"><a href="#5-2-并发控制技术（概念）" class="headerlink" title="5.2 并发控制技术（概念）"></a>5.2 并发控制技术（概念）</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li><strong>事务的并发性</strong>：数据库是一个多用户共享系统，每个用户（或用户程序）都是以“事务”为单位访问数据库</li><li><strong>并发控制</strong>：用于实现多个用户的并发执行的技术。目标是实现并发事务的可串行化调度。</li><li><strong>调度</strong>：一个或多个事务中的数据库访问操作，按照这些操作在DBMS中被执行的时间先后，排序所形成的一个操作序列<ul><li>必须满足两个要求：必须包括所有事务的所有操作，包括每一个事务的结束命令 （commit或abort）；单个事务内部的操作顺序必须保持不变</li></ul></li><li><strong>串行调度</strong>：首先是一个事务的所有操作，然后是另一个事务的所有操作，依此类推，则我们称该调度是串行的</li><li><strong>可串行化调度</strong>：如果一个调度对<strong>数据库状态</strong>的影响和某个串行调度相同，则我们称该调度是可串行化的</li><li><strong>冲突</strong>：调度中的一对相邻操作，如果交换它们两者的执行顺序，那么涉及的事务中至少有一个的行为会改变<ul><li>来自同一个事务的任意两个相邻操作都是冲突，不可以交换执行顺序</li><li>来自不同事务的两个相邻操作除非涉及同一个数据对象且至少有一个是写操作，都可以交换顺序</li></ul></li><li><strong>冲突可串行化</strong>：对于初始给定的一个调度，如果通过一组<strong>非冲突</strong>操作的交换，能够将该调度转换成一个串行调度，则我们认为最初的调度就是一个可串行化调度<ul><li>冲突可串行是可串行化的<strong>充分不必要条件</strong></li></ul></li><li><strong>冲突可串行化的判定方法</strong><ul><li>优先：两个事务$T_1$和$T_2$，各有一个动作$A_1$和$A_2$。如果在调度$H$中，$A_1$在$A_2$之前，且$A_1$和$A_2$涉及同一个数据对象，且$A_1$和$A_2$至少有一个写操作，则称$T_1$优先于$T_2$，记作$T_1&lt;_sT_2$</li><li>优先图：$(i,j)\in E\quad iff.\quad T_i&lt;_sT_j$</li><li>调度$S$是冲突可串行化调度当且仅当事务优先图中无环</li></ul></li><li><strong>视图可串行化</strong><ul><li>相同的一组事务，两个不同的调度S与H。S和H被称为<strong>视图等价</strong>当且仅当满足下列三个条件：对每一个数据项D，<ol><li>如果在调度S中事务$T_k$读到D的初始值，则在调度H中事务$T_k$也必须读到D的初始值；（都读到初始值）<ol><li>如果在调度S中事务$T_k$执行了$r_k(D)$，并且读到的是由事务$T_j$写入的D的值，则在调度H中事务$T_k$的$r_k(D)$读到的也必须是由事务$T_j$写入的D的值；（读到的同一个数据对象的值都是同一个事务写入的）</li><li>如果在调度S中是由事务$T_k$来执行最后一条关于D的写操作$w_k(D)$，则在调度H中也一定是事务$T_k$执行最后一条关于D的写操作$w_k(D)$。（每个数据对象的最后一条写操作是同一个事务执行的）</li></ol></li></ol></li></ul></li><li>不正确的事务并发所导致的数据不一致现象：丢失修改、脏读、不可重复读<ul><li><strong>丢失修改</strong><ul><li>现象：一个事务的修改结果破坏了另一个事务的修改结果</li><li>原因：对多个事务的并发修改同一个数据对象的情况未加控制</li></ul></li><li><strong>脏读</strong><ul><li>现象：读到了错误的数据（与数据库中的情况不相符）</li><li>原因：一个事务读取了另一个事务未提交的修改结果</li></ul></li><li><strong>不可重复读</strong><ul><li>现象：在一个事务的执行过程中，前后两次读同一个数据对象所获得的指出现了不一致</li><li>原因：在两次读操作之间插入了另一个事务的写操作</li></ul></li><li><strong>幻象读</strong><ul><li>在同一个事务T中，同一条<strong>查询命令</strong>Q可能被多次执行。在此期间，如果有其他并发事务执行了元组插入操作并提交，那么事务T中的查询Q，前后执行可能返回不一样的结果集，这种现象被称为<strong>幻像读</strong>.</li></ul></li></ul></li></ul><h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><ul><li>常用封锁类型<ul><li><strong>共享锁（S锁）</strong>：只能读；其他事务也可以读（提高并发性）不能写；不必维持到事务执行结束。</li><li><strong>排它锁（X锁）</strong>：可读可写；其他事务禁止访问；维持到事务执行结束；缺点：降低了整个系统的并行性。</li></ul></li><li><strong>锁相容矩阵</strong>：把上面的锁的获得关系列成表，自己脑补吧</li><li><p><strong>锁申请/锁释放算法</strong>（OS再放送）</p><ul><li><p>申请对数据对象A的S锁：<code>read_lock(A)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">B： if  (LOCK(A) == ‘Unlocked&apos;) &#123;</span><br><span class="line">LOCK(A) = &apos;Read_locked&apos;;</span><br><span class="line">no_of_reads(A) = 1;</span><br><span class="line">&#125; </span><br><span class="line">    else &#123;</span><br><span class="line">if (LOCK(A) == &apos;Read_locked&apos;)</span><br><span class="line">no_of_reads(A) = no_of_reads(A) + 1;</span><br><span class="line">else &#123;</span><br><span class="line">wait ( until LOCK(A) != &apos;Write_locked&apos; and the lock manager wakes up the transaction);</span><br><span class="line">go to B;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>申请对数据对象A的X锁：<code>write_lock(A)</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  B：</span><br><span class="line">if  LOCK(A) = &apos;Unlocked&apos;&#123;</span><br><span class="line">LOCK(A) := &apos;Write_locked&apos;;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">wait ( until LOCK(A) = &apos;Unlocked&apos; and the lock manager wakes up the transaction);</span><br><span class="line">go to B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>释放对数据对象A的封锁：<code>unlock(A)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  if  LOCK(A) = &apos;Write_locked&apos;  &#123;</span><br><span class="line">LOCK(A) := &apos;Unlocked&apos;;</span><br><span class="line">wake up one of the waiting transaction, if any</span><br><span class="line">&#125;</span><br><span class="line">else  if  LOCK(A) = &apos;Read_locked&apos;  &#123;</span><br><span class="line">no_of_reads(A) := no_of_reads(A) - 1;</span><br><span class="line">if no_of_reads(A) = 0  &#123;</span><br><span class="line">LOCK(A) := &apos;Unlocked&apos;</span><br><span class="line">wake up one of the waiting transaction, if any</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在DBMS的“封锁管理器”中维护者一张锁表，记录当前封锁的持有情况和申请等待情况</p></li></ul></li></ul></li><li>基于封锁技术的并发控制实现方法<ul><li><strong>三级封锁协议</strong>以及与数据不一致现象之间的关系<ul><li><strong>一级封锁协议</strong>：事务T在写数据对象A之前，必须先申请并获得A上的X锁，并维持到事务T的执行结束(包括Commit与Rollback)才释放被加在A上的X锁。</li><li><strong>二级封锁协议</strong>：在一级封锁协议的基础上，事务T在读数据对象A之前，必须先申请并获得A上的S锁，在读操作完成后即可释放A上的S锁（没有规定释放S锁的时间）。<ul><li><strong>三级封锁协议</strong>：在一级封锁协议的基础上，事务T在读数据对象A之前，必须先申请并获得A上的S锁，并维持到事务T的执行结束(包括Commit与Rollback)才释放被加在A上的S锁。</li><li>一级：防止丢失修改；二级：防止丢失修改和脏读；三级：防止丢失修改、脏读和不可重复读</li></ul></li></ul></li></ul></li><li><strong>两阶段封锁协议</strong>以及与冲突可串行化之间的关系<ul><li>第一个阶段：申请并获得锁。事务可以申请整个执行过程中需要的所。但不能释放已经申请到的锁；也成为“锁的扩展阶段”</li><li>第二个阶段：释放持有的锁。“锁的收缩阶段”；一旦开始释放就不能再申请</li><li>两阶段封锁事务（2PL事务）：所有封锁请求都先于所有解锁请求</li><li>定理: 由2PL事务所构成的任意合法调度S都是<strong>冲突可串行化</strong>的</li></ul></li></ul><h3 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h3><h4 id="封锁粒度-并发度-并发控制实现开销之间的关系"><a href="#封锁粒度-并发度-并发控制实现开销之间的关系" class="headerlink" title="封锁粒度/并发度/并发控制实现开销之间的关系"></a>封锁粒度/并发度/并发控制实现开销之间的关系</h4><ul><li><strong>封锁粒度</strong>：一把锁可以封锁的数据对象的大小</li></ul><table><thead><tr><th style="text-align:center">封锁粒度</th><th style="text-align:center">系统并发度</th><th style="text-align:center">并发控制的开销</th></tr></thead><tbody><tr><td style="text-align:center">大</td><td style="text-align:center">低</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">小</td><td style="text-align:center">高</td><td style="text-align:center">大</td></tr></tbody></table><ul><li><strong>多粒度封锁</strong>：在一个系统中同时支持多种封锁粒度供事务选择使用的封锁方法。</li><li><strong>多粒度树</strong>： 可以按照封锁粒度的大小构造出一棵<strong>多粒度树</strong>，以树中的每个结点作为封锁对象，可以构成一个<strong>多粒度封锁协议</strong>。</li><li>基于意向锁的多粒度封锁协议<ul><li>可以对多粒度树中的每个节点独立加锁（显式封锁）</li><li>对一个节点加锁意味着该节点的所有后裔节点也被加以同样类型的锁（隐式封锁）</li></ul></li><li><strong>意向锁</strong>：<ul><li>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的上层结点加意向锁。</li><li>3种常见意向锁：意向共享锁（IS锁）, 意向排他锁（IX锁）, 共享意向排它锁（SIX锁）<ul><li><strong>意向共享锁（IS锁）</strong>：如果对结点N加IS锁，表示准备在结点N的某些后裔结点上加S锁</li><li><strong>意向排它锁（IX锁）</strong>：如果对结点N加IX锁，表示准备在结点N的某些后裔结点上加X锁</li><li><strong>共享意向排它锁（SIX锁）</strong>：如果对结点N加SIX锁，表示对结点N本身加S锁，并准备在N的某些后裔结点上加X锁</li></ul></li><li><strong>意向锁锁相容矩阵</strong>：S，X，IS, IX, SIX<ul><li><img src="/2019/10/09/database/yxs.png" alt=""></li></ul></li><li><strong>意向锁锁申请/释放算法</strong><ul><li>如果要对一个结点加锁，必须先对它的上层结点加意向锁</li><li>申请封锁的顺序：自上而下</li><li>释放封锁的顺序：由底向上</li></ul></li></ul></li></ul><h3 id="死锁的检测与预防"><a href="#死锁的检测与预防" class="headerlink" title="死锁的检测与预防"></a>死锁的检测与预防</h3><ul><li><strong>死锁</strong>：每个事务都可能拥有一部分锁，并因申请其它事务所持有的锁而等待，因此产生的循环等待现象被称为<strong>死锁</strong>。</li><li><strong>活锁</strong>：<strong>活锁</strong>：有部分事务因封锁申请得不到满足而处于长期等待状态，但其它的事务仍然可以继续运行下去，这种情况被称为<strong>活锁</strong>。（没死全的锁）</li><li>死锁的检测及其处理办法<ul><li><strong>等待图法</strong>：（ppt上无）使用一个协调者来集中检测系统状态，并消除出现的死锁。维护一个全局的等待图。有必要时检查者运行回路算法。</li><li><strong>超时死锁检测法</strong>：锁申请等待超时 &amp; 事务执行超时</li><li><strong>时间戳死锁检测法</strong>：每个事务都具有一个用于死锁检测的时间戳，该时间戳反映当前事务的新老程度（即已运行时间的长短）。如果事务T必须等待另一个事务U所持有的锁，那么有两种死锁检测策略（牺牲的往往是较年轻的事务）<ul><li>等待-死亡方案：如果T比U老，那么允许T等待U持有的锁；如果U比T老，那么事务T死亡（被回滚）。（年轻的在等待就回滚）</li><li>伤害-等待方案：如果T比U老，它将伤害U，U必须被回滚；如果U比T老，那么T等待U持有的锁。（年轻的被等待就回滚）</li></ul></li></ul></li></ul><h2 id="5-3-数据库恢复技术"><a href="#5-3-数据库恢复技术" class="headerlink" title="5.3 数据库恢复技术"></a>5.3 数据库恢复技术</h2><ul><li>数据库恢复<ul><li><strong>含义</strong>：在数据库遭受破坏后即使进行恢复的功能</li><li><strong>方法</strong>：利用数据冗余原理，将数据库中的数据在不同的存储介质上进行冗余存储，当数据库本身受到破坏时，可以利用这些冗余信息进行恢复。</li><li><strong>常用措施</strong>：数据转储、日志、数据库镜像</li></ul></li><li><strong>数据库故障的分类</strong>（三类六种）<ul><li><strong>小型故障（事务内部故障）</strong>：故障的影响范围在一个事务之内，不影响整个系统的正常运行</li><li><strong>中型故障（系统故障，外部影响）</strong>：可导致整个系统停止工作，但磁盘数据不受影响。在系统重启时，可通过当前的日志文件进行恢复</li><li><strong>大型故障（磁盘故障、计算机病毒、黑客入侵）</strong>：可导致内存及磁盘数据的严重破坏，需要对数据库做彻底的恢复’</li></ul></li></ul><h4 id="数据库故障恢复三大技术"><a href="#数据库故障恢复三大技术" class="headerlink" title="数据库故障恢复三大技术"></a>数据库故障恢复三大技术</h4><ul><li><strong>数据转储</strong>：定期地将数据库中的内容复制到其它存储设备中去的过程<ul><li>后备副本：经转储而得到的备份数据</li><li>分类：静态转储/动态转储；海量转储/增量转储</li><li>（动态转储）需要结合日志进行故障恢复</li></ul></li><li><strong>日志</strong>：是由数据库系统创建和维护的，用于自动记载数据库中<u>修改型操作</u>的数据更新情况的文件。<ul><li><strong>内容</strong>：每个更新操作的事务标识、更新对象、更新前的值和/或更新后的值；每个事务的开始、结束等执行情况；其他信息。</li><li><strong>组成</strong>：日志是<strong>日志记录</strong>的一个序列，每个<strong>日志记录</strong>记载有关某个事务已执行操作的情况（主要是事务的更新操作的执行情况）。由于事务通常是并发执行的，所以多个事务的日志记录通常是交错在一起的。</li><li><strong>作用</strong>：确保事务执行的原子性；实现增量转储；实现故障恢复（commit——redo，abort–撤销）。</li><li><strong>记载原则</strong>：按照操作执行的先后次序，遵循<strong>先写日志，后修改数据库</strong>的原则。</li><li><strong>在日志中设置检查点的作用</strong>：降低数据库故障恢复开销。在故障恢复时，只要逆向扫描到第一条<code>&lt;CKPT&gt;</code>记录(最后一个被记入的检查点)就可以结束故障恢复工作。</li><li><strong>事务的撤销（UNDO）</strong>：反向扫描日志文件，查找应该撤消的事务，查找这些事务的更新操作，对更新操作做逆操作（插入变删除、删除变重新插入、修改变修改前的值），如此反向扫描直到日志文件的头部。</li><li><strong>事务的重做（REDO）</strong>：正向扫描日志文件，查找应该重做的事务，查找这些事务的更新操作，对更新操作作重做处理（重新插入、重新删除、重新修改），如此正向扫描直到日志文件的尾部。</li></ul></li><li><strong>UNDO日志</strong><ul><li><strong>内容</strong>（记录格式）：<ul><li>开始一个事务：<code>&lt;Start T&gt;</code></li><li>提交事务T：<code>&lt;Commit T&gt;</code></li><li>放弃事务T：<code>&lt;Abort T&gt;</code></li><li>更新记录：<code>&lt;T,X,V&gt;</code>（事务T修改了数据库元素X的值，X的旧值是V）</li></ul></li><li><strong>记载规则</strong>：（更新前提交后）<ul><li>$U_1$：如果事务<code>T</code>修改了数据库元素<code>X</code>，则更新日志<code>&lt;T,X,V&gt;</code>必须在X的新值写到磁盘前写到磁盘</li><li>$U_2$：如果事务<code>T</code>提交，则日志记录<code>&lt;Commit T&gt;</code>必须在事务<code>T</code>改变的所有DB元素已写到磁盘后再写到磁盘（之后还要FLush一次确保事务T被提交</li></ul></li><li><strong>作用</strong>：用于被放弃事务（包括发生在故障时上位结束的事务）的撤销工作</li><li><strong>基于UNDO日志的故障恢复流程</strong><ol><li>将所有事务划分为两种类型：已提交事务（有<code>&lt;Start T&gt;</code>和<code>&lt;Commit T&gt;</code>），未提交事务（有Start无Commit）</li><li>从undo日志的尾部开始（最晚的）<strong>向后</strong>（向头部）开始扫描整个日志，对每一条更新记录<code>&lt;T,X,V&gt;</code>作如下处理：<ul><li>如果<code>&lt;Commit T&gt;</code>已被扫描到，则继续扫描下一条日志记录（基于规则U2）</li><li>否则，由恢复管理器将数据库中<code>X</code>的值改为<code>V</code>（基于规则U1）</li></ul></li><li>在日志的尾部为每个未结束的事务<code>T</code>写入一条日志记录<code>&lt;Abort T&gt;</code>，并刷新日志（Flush Log)</li></ol></li><li><strong>不足</strong>：将事务改变的所有数据写到磁盘前不能提交该事务，会导致在事务的提交过程中需要执行许多写磁盘操作，从而增加了事务提交的时间开销</li></ul></li><li><p><strong>REDO日志</strong></p><ul><li><strong>内容</strong>（记录格式）：同undo，唯一的区别是在<code>&lt;T,X,V&gt;</code>中记载的是更新后的值</li><li><p><strong>记载规则</strong>：（更新前提交前）</p><ul><li>$R_1$：在由于某个事务<code>T</code>所做的改变而修改磁盘上的数据库元素<code>X</code>之前，要保证所有与X这一修改有关的日志记录（包括更新记录和提交记录）都必须出现在磁盘上。（事务提交(Commit)和写数据库磁盘(Output)的操作顺序是随机的）</li></ul></li><li><strong>作用</strong>：用于已提交事务的重做工作</li><li><strong>基于REDO日志的故障恢复流程</strong><ol><li>先扫描一遍日志文件，确定所有已提交的事务</li><li>从日志文件的头部开始扫描日志，对遇到的每一条更新记录<code>&lt;T,X,V&gt;</code><ul><li>如果T是未提交事务，则继续扫描日志</li><li>如果T是已提交的事务，则为数据库元素X写入新值V</li></ul></li><li>对每个未完成的事务T，在日志的尾部写入结束标志<code>&lt;Abort T&gt;</code>并刷新日志</li></ol></li><li><strong>不足</strong>：要求事务提交和日志记录刷新之前所有修改过的数据保留在内存缓冲区中，可能增加事务需要的平均缓冲区数量</li><li>UNDO和REDO的<strong>不足</strong>：如果被访问的数据对象X不是完整的数据块，那么在Undo日志和Redo日志之间可能产生相互矛盾的请求。</li></ul></li><li><strong>UNDO/REDO日志</strong><ul><li><strong>内容（记录格式）</strong>：与undo或redo的公式基本一样，区别在于更新记录<code>&lt;T,X,v,w&gt;</code>，<code>v</code>为更新前的值，<code>w</code>为更新后的值。</li><li><strong>记载规则</strong>：（更新前）<ul><li>$UR_1$：在事务T修改磁盘上的数据库元素X之前，更新记录<code>&lt;T,X,v,w&gt;</code>必须出现在磁盘上。（事务提交(Commit)和写数据库磁盘(Output)的操作顺序是随机的）</li><li>为了确保在日志中写入<code>&lt;Commit T&gt;</code>记录的事务<code>T</code>确实被提交，在每一条<code>&lt;Commit T&gt;</code>后面必须紧跟一条Flush Log操作。</li></ul></li><li><strong>作用</strong>：解决UNDO和REDO日志的矛盾</li><li><strong>基于UNDO/REDO日志的故障恢复流程</strong><ul><li>根据<code>&lt;Commit T&gt;</code>是否已经出现在磁盘中来决定事务Ｔ是否已经被提交</li><li>按照从后往前的顺序，撤销所有未提交的事务</li><li>按照从前往后的顺序，重做所有已提交的事务</li></ul></li></ul></li><li><strong>UNDO/REDO日志的优点与缺点</strong>：优点没写，缺点见上</li><li><strong>恢复策略</strong><ul><li>小型故障：利用未结束事务的undo操作进行恢复</li><li>中型故障：<ul><li>非正常中止事务：执行undo操作</li><li>已完成提交的事务：其更新操作的修改结果还留在内存缓冲区中，尚未来得及写入磁盘，由于故障使内存缓冲区中的数据被丢失，故执行redo操作</li></ul></li><li>大型故障：先利用后备副本进行数据库恢复，再利用日志进行数据库的恢复。具体步骤如下——<ol><li>将后备副本中的数据拷贝到数据库中</li><li>检查日志文件：确定哪些事务已经执行结束，哪些尚未结束</li><li>按照日志的记载顺序：逆向：对尚未结束的事务作撤消处理(undo)；正向：对已经结束的事务作重做处理(redo) </li></ol></li></ul></li></ul><h1 id="Ch6-7-数据交换与存储"><a href="#Ch6-7-数据交换与存储" class="headerlink" title="Ch6-7 数据交换与存储"></a>Ch6-7 数据交换与存储</h1><p><s>题目是自己xjb起的</s></p><h2 id="游标管理"><a href="#游标管理" class="headerlink" title="游标管理"></a>游标管理</h2><ul><li><strong>游标的作用</strong>：将SQL变量中的集合型变量逐个取出后送入应用程序（标量型）变量内供其使用</li><li><p><strong>定义游标</strong></p><ul><li><p>为某一个映像语句（可能返回多个结果元组）的结果集合定义一个命名的游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> <span class="keyword">cursor</span>-<span class="keyword">name</span> <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">  subquery</span><br><span class="line">  [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</span><br><span class="line">  [<span class="keyword">FOR</span> &#123;<span class="keyword">READ</span> <span class="keyword">ONLY</span> | <span class="keyword">UPDATE</span>[<span class="keyword">OF</span> columnname ...]&#125;];</span><br><span class="line"><span class="comment">-- e.g.</span></span><br><span class="line">EXEC SQL <span class="keyword">DECLARE</span> agent_dollars <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">  <span class="keyword">SELECT</span> aid, <span class="keyword">SUM</span>(dollars)</span><br><span class="line">  <span class="keyword">FROM</span> orders</span><br><span class="line">  <span class="keyword">WHERE</span> cid = :cust_id <span class="comment">--主语言变量</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> aid;</span><br></pre></td></tr></table></figure></li><li><p>如果一条查询语句的执行返回多条结果元组，那么必须使用游标来获取结果集合中的每一个结果元组</p></li><li>仅当用户确信只可能返回单个结果元组的情况下才可以使用<code>SELECT... INTO...</code>形式的嵌入式SQL查询语句</li></ul></li><li><p><strong>打开游标</strong> </p><ul><li>执行相应的映像语句并打开获得结果集，此时游标处于活动状态并指向结果集合的第一条记录的前面<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL OPEN agent_dollars</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用游标</strong></p><ul><li>将游标推向结果集合中的下一条记录，读出游标所指向记录的值并赋给对应的主语言变量</li><li><p>fetch the result rows</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123; -- loop to fetch rows</span><br><span class="line">  exec sql fetch agent_dollars into :agent_id, :dollar_sum;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s %11.2f\n"</span>, agent_id, dollar_sum)l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>end fetch loop</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec sql whenever not found goto finish;</span><br><span class="line"><span class="comment">-- 声明'not found’事件处理</span></span><br><span class="line">...</span><br><span class="line">while(TRUE) &#123;</span><br><span class="line">  exec sql fetch ... into ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">finish: exec sql close agent_dollars;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>关闭游标</strong></p><ul><li><p>关闭所使用的游标，释放相关的系统资源</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CLOSE agent_dollars;</span><br></pre></td></tr></table></figure></li><li><p>游标一旦被定义(declare)，可以被重新使用(open-fetch-close)。每一次open一个游标，都将重新执行对应的query，并生成新的结果集。</p></li><li>一个游标结果集只能被比那里一次，其中的结果元组被fetch的顺序是随机的（如果游标定义中无order by子句）</li><li>应用程序可以通过“游标状态变量”来了解一个游标的当前状态（是否处于打开状态、结果元组的个数、是否fetch到结果元组…..)</li></ul></li><li><p><strong>可滚动游标</strong>的定义及其在数据更新命令中的使用</p><ul><li><p><strong>定义</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> cursor_name</span><br><span class="line">  [INSENSITIVE] [<span class="keyword">SCROLL</span>]</span><br><span class="line">  <span class="keyword">CURSOR</span> [<span class="keyword">WITH</span> HOLD] <span class="keyword">FOR</span></span><br><span class="line">    subquery &#123;<span class="keyword">UNION</span> subquery&#125;</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span>]</span><br><span class="line">  [<span class="keyword">FOR</span> <span class="keyword">READ</span> <span class="keyword">ONLY</span> | <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">OF</span> columnname];</span><br></pre></td></tr></table></figure></li><li><p>Fetch by scrollable Cursors</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL FETCH</span><br><span class="line">  [&#123;NEXT | PRIOR | FIRST | LAST | &#123;ABSOLUTE | RELATIVE&#125; value_spec&#125; FROM]</span><br><span class="line">cursor_name INTO ...</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="B-索引"><a href="#B-索引" class="headerlink" title="B+索引"></a>B+索引</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>叶节点构成的最下面的一级索引通常采用稠密索引，其他层次上的索引采用稀疏索引</li><li>特点：平衡性，过半性，顺序性，自适应性</li><li>结点：每个结点占用一个磁盘块，每棵B+树都有一个被称为秩的整型参数$n$。每个结点能容纳$n$个键和$n+1$个指针，将$n$取得尽可能大。</li><li><img src="/2019/10/09/database/b+index.png" alt=""></li></ul><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p><img src="/2019/10/09/database/b+search1.png" alt=""><br><img src="/2019/10/09/database/b+search2.png" alt=""></p><h1 id="CH8-关系数据库规范化理论"><a href="#CH8-关系数据库规范化理论" class="headerlink" title="CH8 关系数据库规范化理论"></a>CH8 关系数据库规范化理论</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li><strong>模式设计质量的评价指标</strong>：数据冗余度、插入/删除等更新异常<ul><li>好的设计方案：既具有合理的数据冗余度，又没有插入和删除等操作异常现象</li></ul></li><li><strong>关系的规范化</strong>：在每个关系中，属性与属性之间的语义联系（函数依赖、多值依赖）需要满足一定的要求</li><li><strong>范式</strong>：范式(Normal Form)：对一个关系中允许存在的依赖的要求</li><li><strong>规范化的途径</strong>：将一个关系分解形成多个子关系，在模式设计中，用分解后的这一组子关系代替原来的单个关系。<ul><li>竖向规范化：关系模式的分解。采用投影和联接运算，将一个关系模式的属性集分解构成若干个子关系模式。有关理论构成了<strong>关系数据库的规范化理论</strong>。</li><li>水平规范化：采用选择和并运算，将一个关系的元组集合分解成若干个子集，从而构成若干个与原来关系具有相同关系模式的子关系，尚未形成一个成熟的规范化理论。</li></ul></li><li><strong>规范化的目的</strong>：降低数据冗余度，消除插入、删除及修改异常</li><li><strong>规范化的手段</strong>：模式分解</li></ul><h2 id="规范化理论"><a href="#规范化理论" class="headerlink" title="规范化理论"></a>规范化理论</h2><h3 id="规范化途径（不在考纲里）"><a href="#规范化途径（不在考纲里）" class="headerlink" title="规范化途径（不在考纲里）"></a>规范化途径（不在考纲里）</h3><ul><li>将一个关系分解成多个子关系，用分解后的这一组子关系代替原来的单个关系。</li><li>竖向规范化<ul><li>关系模式的分解</li><li>投影和联接</li><li>将一个关系模式的属性集分解构成若干个子关系模式</li></ul></li><li>水平规范化<ul><li>元组集合的分解</li><li>选择和并</li></ul></li></ul><h3 id="函数依赖（FD）"><a href="#函数依赖（FD）" class="headerlink" title="函数依赖（FD）"></a>函数依赖（FD）</h3><ul><li><strong>定义</strong>：一个关系中两组属性之间的某种取值约束，简称FD</li><li>$X\to Y$: X函数决定Ｙ, Y函数依赖于X，关系$R$满足函数依赖$X\to Y$</li><li>即关系$R$中，每一个X值都有唯一的一个Y值与之相对应</li><li>$X$: 决定因素， $Y$: 依赖因素</li></ul><h4 id="符号说明（不在考纲里）"><a href="#符号说明（不在考纲里）" class="headerlink" title="符号说明（不在考纲里）"></a>符号说明（不在考纲里）</h4><ul><li>$ABC={A,B,C}$, ABC三个属性构成的集合</li><li>$XY=X\cup Y$， X,Y是关系的属性子集</li><li>$R(U,F)$： 关系名R，关系中的属性集合U，函数依赖集F</li><li>$r,s,t$: 关系实例</li><li>$r_1,s_1,t_1$: 关系中的元组</li><li>$r_1(A)$: 元组$r_1$在属性$A$上的取值</li></ul><h4 id="如何寻找函数依赖"><a href="#如何寻找函数依赖" class="headerlink" title="如何寻找函数依赖"></a>如何寻找函数依赖</h4><ul><li>语义联系</li><li>根据具体数据否定函数依赖</li><li>根据两组属性间的对应关系（一一对应和多一对应</li><li>分析数据完整性的约束条件</li></ul><h4 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h4><p><strong>（非）平凡函数依赖</strong>：$X\to Y$若满足$Y\not\subseteq X$，则称此函数依赖是非平凡函数依赖。否则是平凡函数依赖。提到函数依赖时默认非平凡。<br><strong>完全函数依赖</strong>: $X\to Y$，且对$X$的任意真子集$X’$都有$X’\not\to Y$，则称$Y$完全依赖于$X$，记为$X\overset{f}{\to}Y$.<br><strong>部分函数依赖</strong>: $X\to Y$且$Y$不完全依赖于$X$，记作$X\overset{p}{\to} Y$<br><strong>传递函数依赖</strong>: $X\to Y, Y\not\subset X, Y\not\to X, Y\to Z$, 则称$Z$传递函数依赖于$X$; 否则称为非传递函数依赖。</p><h4 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h4><ul><li>$R_1$自反规则：若$Y\subseteq X$, 则$X\to Y$</li><li>$R_2$增广规则：若$X\to Y$, 则$XZ\to YZ$</li><li>$R_3$传递规则：若$X\to Y, Y\to Z$, 则$X\to Z$</li><li>$R_4$分解规则：若$X\to YZ$, 则$X\to Y$且$X\to Z$</li><li>$R_5$合并规则：若$X\to Y$且$X\to Z$, 则$X\to YZ$</li><li>$R_6$伪传递规则: 若$X\to Y$且$WY\to Z$, 则$WX\to Z$</li></ul><p><s>数理逻辑复习</s>：</p><ul><li>$F$逻辑蕴含$X\to Y$($F\models X\to Y$)：能从$F$的已有函数依赖推导出$X\to Y$</li><li>闭包$F^+$: 被$F$逻辑蕴涵的所有函数依赖构成的集合</li></ul><h4 id="基于函数依赖的关键字定义"><a href="#基于函数依赖的关键字定义" class="headerlink" title="基于函数依赖的关键字定义"></a>基于函数依赖的关键字定义</h4><p><strong>关键字</strong>: 在关系模式$R(U,F)$中，如有$K\subseteq U$且满足$K\overset{f}{\to}U$，则称$K$为关系$R$的关键字。<br>关键字可能不唯一。</p><p><strong>主属性集</strong>: 由关系模式$R$的所有关键字中的属性所构成的集合。（所有关键字集合的并）<br><strong>主属性</strong>: 主属性集中的属性<br><strong>非主属性集</strong>: 主属性的补集</p><h4 id="寻找关键字（不在考纲里）"><a href="#寻找关键字（不在考纲里）" class="headerlink" title="寻找关键字（不在考纲里）"></a>寻找关键字（不在考纲里）</h4><ul><li><strong>方法一</strong>：用Armstrong公理系统推导</li><li><strong>方法二</strong>：运用属性集闭包的概念，寻找满足条件($K_F^+=U$)的最小属性集合$K$<ul><li>优点：有算法支持</li><li>缺点：计算工作量大</li></ul></li><li><strong>方法三</strong>：运用最小函数依赖集来优化方法二中的关键字计算算法</li></ul><p><strong>属性集闭包</strong>：$X_F^+={A\mid F\models X\to A }$，可以简写为$X^+$。所有函数依赖于$X$的属性所构成的集合。</p><h4 id="算法8-1：计算属性集-X-在函数依赖集-F-上的闭包："><a href="#算法8-1：计算属性集-X-在函数依赖集-F-上的闭包：" class="headerlink" title="算法8-1：计算属性集$X$在函数依赖集$F$上的闭包："></a>算法8-1：计算属性集$X$在函数依赖集$F$上的闭包：</h4><p>输入：函数依赖集$F$，属性集$X$<br>输出：闭包$X_F^+$</p><p>$X^+=X$<br>repeat:<br>&nbsp;&nbsp;&nbsp;&nbsp;  old$X^+ := X^+$<br>&nbsp;&nbsp;&nbsp;&nbsp;  for each functional dependency $Y\to Z$ in $F$ do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if $Y\subseteq X^+$ then $X^+=X^+\cup Z$<br>until(old$X^+=X^+$)</p><p>一言以蔽之：不断拉新的属性进来知道没有可拉的</p><p>若$K$是关系模式$R(U)$的一个关键字，则</p><ul><li>$K_F^+=U$</li><li>对于$K$的任意一个真子集都有$Z_F^+\neq U$<br>(可以用来验证公理推导的结果)</li><li>可以用来<strong>验证</strong>某个集合是不是关键字</li></ul><h4 id="算法8-2：寻找关系模式-R-U-F-的关键字-K"><a href="#算法8-2：寻找关系模式-R-U-F-的关键字-K" class="headerlink" title="算法8-2：寻找关系模式$R(U,F)$的关键字$K$"></a>算法8-2：寻找关系模式$R(U,F)$的关键字$K$</h4><p>set $K:=U$<br>for each attribute $A$ in $K$:<br>&nbsp;&nbsp;&nbsp;&nbsp; if $(K-A)_F^+ = U$<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then set $K:= K-A$<br>return $K$</p><p>一言以蔽之：遍历每个属性，如果删不删都一样就删掉<br><strong>注意</strong>：根据遍历属性的顺序不同，得到的关键字不唯一</p><h4 id="关键字计算优化算法"><a href="#关键字计算优化算法" class="headerlink" title="关键字计算优化算法"></a>关键字计算优化算法</h4><p>$F$是最小函数依赖集，可以将属性集$U$划分为三个子集</p><ul><li>$U_L$: 只在函数依赖的左边出现</li><li>$U_R$: 只在函数依赖的右边出现</li><li>$U_A$: 在两边都出现过</li></ul><p>其中，</p><ul><li>$U_L$中的属性是每一个关键字的组成部分</li><li>$U_R$中的属性不可能出现在任何一个关键字中</li><li><strong>关键字计算只需要遍历$U_A$中的属性</strong></li></ul><h3 id="与函数依赖有关的范式"><a href="#与函数依赖有关的范式" class="headerlink" title="与函数依赖有关的范式"></a>与函数依赖有关的范式</h3><ul><li><strong>第一范式(1NF)</strong>：如果关系模式$R(U)$中的每个属性值都是一个不可分割的数据量，则称该关系模式满足第一范式，记为$R\in 1\text{NF}$<ul><li>关系模式的基础，每个关系都必须满足$1\text{NF}$</li><li>可能有数据冗余，会产生更新异常</li></ul></li><li><strong>第二范式（2NF）</strong>: 设有关系模式 $R(U)\in 1\text{NF}$，且其每个非主属性都<strong>完全</strong>函数依赖于关键字，则称关系模式$R(U)$满足第二范式，并记作：$R\in 2\text{NF}$<ul><li>找到关系$R$的<strong>所有</strong>非主属性和<strong>所有</strong>的候选关键字（注意不唯一）</li><li>检查每一个非主属性和每一个候选关键字之间的函数依赖，判断是否存在“非主属性对关键字的部分函数依冗余</li><li>满足2NF仍可能有数据冗余，因为可能存在非主属性对关键字的传递函数依赖。</li></ul></li><li><strong>第三范式（3NF）</strong>：设有关系模式 $R(U)\in 2\text{NF}$，且其每个非主属性都<strong>不传递</strong>函数依赖于关键字，则称关系模式$R(U)$满足第三范式，并记作：$R\in 3\text{NF}$<ul><li>存在函数依赖$X\to Y$，其中$X$是关键字的真子集（不是2NF）或$X$不是关键字。</li></ul></li><li><strong>BCNF</strong>: 设关系模式$R(U)$满足1NF，且若 $X\to Y$时$X$必<strong>含有</strong>该关系模式的关键字，则称关系模式$R(U)$满足BCNF范式，并记作$R\in \text{BCNF}$<ul><li>如果关系模式$R(U)\in\text{BCNF}$, 则$R(U)\in 3\text{NF}$，反之不成立。</li></ul></li><li><strong>各级范式与数据冗余度、插入删除异常的关系</strong>（见上）<ul><li>1NF，2NF：有异常有冗余</li><li>3NF：无异常，小冗余</li></ul></li></ul><h4 id="模式分解-（不在考纲里但我觉得会考）"><a href="#模式分解-（不在考纲里但我觉得会考）" class="headerlink" title="模式分解 （不在考纲里但我觉得会考）"></a>模式分解 （不在考纲里但我觉得会考）</h4><p>目标：每个小的关系模式都能够满足2NF（更高要求的范式）的要求，消除因非主属性关键字对关键字的部分函数依赖而产生的数据冗余</p><p><strong>模式分解方法</strong>（对所有NF都适用）</p><ul><li>找出所有不满足范式$M$要求的函数依赖关系</li><li>选择一个不符合要求的函数依赖关系作如下分解：假设$X\overset{f}{\to}Y\in F^+$且不满足范式$M$的要求，则我们将关系模式$R$分解为如下两个子关系：<ul><li>$R_1(X\cup Y, {X\to Y})$</li><li>$R_2(Head(R)-Y, F_2)$, 其中：$F_2={A\to B\mid A\to B\in F^+ \text{ and }(A\cup B)\subseteq Head(R_2) }$</li><li>一言以蔽之：$Y$跟着$X$跑了，$Head(R)$就把$Y$给T了（$X$没T）</li></ul></li><li>对于分解得到的子关系模式$R_2$重复上述步骤1和2，直到<strong>所有</strong>的子关系模式都能满足范式$M$的要求</li><li>合并那些具有相同关键字的子关系模式</li></ul><h3 id="多值依赖与第四范式"><a href="#多值依赖与第四范式" class="headerlink" title="多值依赖与第四范式"></a>多值依赖与第四范式</h3><ul><li><strong>多值依赖</strong>(multivalued dependency, 简称MVD)<ul><li>对$X,Y\subseteq U$，对$X$的一个确定值，存在$Y$的一组值与之对应；且$Y$的这组值又与关系中的其他属性$(U-X-Y)$的取值不相关，此时称$Y$多值依赖于$X$，并记为$X\to\to Y$。（“不相关”可以理解为两个属之间构成完全二部图的交叉关系）</li><li>e.g. 一门课有多个任课老师，又有多本参考书，任课老师和参考书不相关</li><li>产生原因：存在<strong>两个相互独立</strong>的 属性间的一对多数量对应关系，合并起来就会产生多值依赖</li><li>会造成大量数据冗余</li></ul></li><li><strong>平凡多值依赖</strong>：$U-X-Y$是空集</li><li><strong>非平凡多值依赖</strong>：$U-X-Y$不是空集</li><li><strong>多值依赖与函数依赖的关系</strong>（性质）<ul><li>若$X\to\to Y$，则必有$X\to\to (U-X-Y)$（非平凡函数依赖总是成对出现的）</li><li>若$X\to Y$, 则必有$X\to\to Y$（函数依赖也是一种多值依赖，反之未必)</li></ul></li><li><strong>第四范式</strong><ul><li>在关系模式$R(U)$中，若$X\to\to Y$是非平凡多值依赖，则$X$必含有关键字，此时称关系模式$R$满足第四范式，并记作$R\in 4\text{NF}$</li><li>函数依赖要满足$\text{BCNF}$</li><li>不是FD的多值依赖一定是平凡的 </li></ul></li></ul><h4 id="推导规则（不在考纲里）"><a href="#推导规则（不在考纲里）" class="headerlink" title="推导规则（不在考纲里）"></a>推导规则（不在考纲里）</h4><ul><li>$IR_1$自反规则：同$R_1$</li><li>$IR_2$增广规则：同$R_2$</li><li>$IR_3$传递规则：同$R_3$</li><li>$IR_4$求补规则：若$X\to\to Y$, 则$X\to\to (U-X-Y)$</li><li>$IR_5$多值依赖的增广规则：若$X\to\to Y$且$W\subseteq Z$，则$WX\to\to YZ$</li><li>$IR_6$多值依赖的传递规则：若$X\to\to Y, Y\to\to Z$，则$X\to\to (Z-Y)$</li><li>$IR_7$转换规则：若$X\to Y$，则$X\to\to Y$</li><li>$IR_8$结合规则：若$X\to\to Y$，且存在另一个属性结合$W$满足：$W\cap Y=\emptyset, W\to Z, Z\subseteq Y$，则$X\to Z$</li></ul><h2 id="规范化所引起的一些问题"><a href="#规范化所引起的一些问题" class="headerlink" title="规范化所引起的一些问题"></a>规范化所引起的一些问题</h2><ul><li><strong>函数依赖的蕴含</strong><ul><li>设$F$是关系模式$R(U)$的一个函数依赖集，$X$, $Y$是关系模式$R$的属性子集，如果从$F$中的已有函数依赖关系利用Armstrong公理系统能够推出$X\rightarrow Y$，则称$F$逻辑蕴涵$X\rightarrow Y$，并记为：$F\models X\rightarrow Y$。</li></ul></li><li><strong>函数依赖集的等价</strong><ul><li>若两个函数依赖集的闭包是相等的，则这两个函数依赖集是等价的</li><li>如果其中任何一个函数依赖集中的每一个函数依赖都被另一个所蕴涵，则两个函数依赖集是等价的</li><li>函数依赖的闭包：由被$F$逻辑蕴涵的所有函数依赖关系构成的集合被称为函数依赖集$F$的闭包，并记为$F^+$，有$F^+={X\rightarrow Y │ F\models X\rightarrow Y }$。</li></ul></li></ul><h4 id="最小函数依赖集及其判定条件"><a href="#最小函数依赖集及其判定条件" class="headerlink" title="最小函数依赖集及其判定条件"></a>最小函数依赖集及其判定条件</h4><ul><li><strong>最小函数依赖集</strong><ul><li>$F$的<strong>最小函数依赖集</strong>： 与$F$的相等价的所有函数依赖集中的最小者</li></ul></li><li><strong>判定条件</strong>：对于$F$中的每一个FD关系$X\to A$均作如下判断：<ol><li>依赖因素$A$为单个属性（非必需）</li><li>令$F_1=F-{X\to A}$, 则$F_1^+\neq F^+$(<strong>不存在冗余的函数依赖</strong>)</li><li>对于决定因素$X$的每一个真子集$Y$($Y\subset X$)均作判断：令$F_2=F-{X\to A}\cup{Y\to A}$, 则$F_2^+\neq F^+$(<strong>不存在部分函数依赖</strong>)</li></ol></li></ul><h4 id="算法8-3：寻找与函数依赖集-F-等价的最小函数依赖集-G"><a href="#算法8-3：寻找与函数依赖集-F-等价的最小函数依赖集-G" class="headerlink" title="算法8-3：寻找与函数依赖集$F$等价的最小函数依赖集$G$"></a>算法8-3：寻找与函数依赖集$F$等价的最小函数依赖集$G$</h4><p>任务：</p><ul><li>消除$F$中的部分函数依赖</li><li>消除冗余的函数依赖</li></ul><p><s>懒得打字了</s></p><p>输入：函数依赖集$F$<br>输出：与$F$等价的最小函数依赖集</p><p>一言以蔽之：先删部分FD，再删冗余FD；</p><p><img src="/2019/10/09/database/alg8-3.png" alt=""></p><p>P.S.要证明两个只差一个函数依赖的集合的闭包相等，只需要证明互相蕴含自己不包含的那个函数依赖</p><p>最小依赖集可能<strong>不唯一</strong>，只需要计算一个(而函数依赖要写全)</p><h3 id="模式分解的研究"><a href="#模式分解的研究" class="headerlink" title="模式分解的研究"></a>模式分解的研究</h3><ul><li><strong>无损联接性</strong><ul><li>分解后，原关系中的信息不会丢失</li><li>设$R$是一个关系模式，$F$是关系模式上$R$的函数依赖集，$\rho = { R_1, R_2, …, R_k }$ 是对$R$的一个分解。如果对$R$中满足$F$的每一个关系实例$r$都有：$$r=\pi_{R_1}(r)\Join \pi_{R_2}(r)\Join \cdots\Join\pi_{R_k}(r)$$,则称该分解$\rho$相对于$F$是“无损联接分解”，或称分解$\rho$具有无损联接性 </li><li><strong>判定定理</strong>: 如果$R$的分解为$\rho={R_1, R_2}$，$F$为$R$所满足的函数依赖集合，分解$\rho$具有无损联接性的充要条件是$R_1\cap R_2\to(R_1-R_2)$或$R_1\cap R_2\to (R_2-R_1)$（公共部分可以推出剩余部分）</li></ul></li><li><strong>依赖保持性</strong><ul><li>原有的函数依赖关系在分解后的关系模式上依然存在</li><li><strong>判定方法：</strong>设$F$是属性集$U$上的函数依赖集，$Z$是$U$的一个子集，$F$在$Z$上的投影用$\pi_Z(F)$表示：$$\pi_{Z}(F)={X\to Y\mid X\to Y\wedge (X\cap Y)\subseteq Z }$$.设存在关系模式$R$的一个分解$\rho = { R_1, R_2, …, R_k }$,$F$是$R$上的函数依赖集，如果$$F^+=(\pi_{R_1}(F)\cup\pi_{R_2}(F)\cup\cdots\cup\pi_{R_k}(F))^+$$,则称分解$\rho$具有依赖保持性</li><li>一言以蔽之：<strong><u>（分解后的所有函数依赖并起来和原来的函数依赖等价）</u></strong></li></ul></li><li>在必须同时满足无损联接性和依赖保持性的要求下，一个关系模式<strong>最高</strong>可以被分解到满足<strong>第三范式</strong></li></ul><h4 id="算法8-4：把关系模式分解到满足第三范式并满足无损联接性和依赖保持性"><a href="#算法8-4：把关系模式分解到满足第三范式并满足无损联接性和依赖保持性" class="headerlink" title="算法8-4：把关系模式分解到满足第三范式并满足无损联接性和依赖保持性"></a>算法8-4：把关系模式分解到满足第三范式并满足无损联接性和依赖保持性</h4><ol><li>计算$F$的最小函数依赖集，并用来代替$F$进行下面的模式分解;</li><li>$S=\emptyset$</li><li>对 F 中的每一个函数依赖$X\to Y$做如下处理：<ul><li>如果在集合$S$中找不到满足下述条件的子关系模式$Z$：$$X\cup Y\subseteq Z$$</li><li>则由$X$和$Y$构成一个新的子关系加入到集合$S$中，即$S=S\cup  \text{Heading}(X\cup Y)$</li></ul></li><li>如果关系$R$的每一个候选关键字$K$都没有出现在分解后的子关系模式中，即：找不到一个关键字$K$和一个子关系模式$Z$，他们之间满足$K\subseteq Z$, 那么，就从关系R中任选一个候选关键字$K$, 由$K$中的属性单独构成一个子关系模式并加入到集合$S$中去，即：$S=S\cup\text{Heading}(K)$</li></ol><p>一言以蔽之：先把所有函数依赖的Headings都组起来，然后把关键字补上去</p><h1 id="Ch9-数据库设计"><a href="#Ch9-数据库设计" class="headerlink" title="Ch9 数据库设计"></a>Ch9 数据库设计</h1><h2 id="9-1-数据库设计概述"><a href="#9-1-数据库设计概述" class="headerlink" title="9.1 数据库设计概述"></a>9.1 数据库设计概述</h2><ul><li><strong>数据库设计的基本任务</strong><ul><li>根据用户对象的<strong>信息需求</strong>（用户的数据、结构及其要求）、<strong>处理需求</strong>（用户对数据的处理过程和方式）和数据库的<strong>支持环境</strong>（包括硬件、操作系统与DBMS）设计出数据模式。</li></ul></li><li><strong>数据库的生命周期</strong>：需求分析$\rightarrow$概念设计$\rightarrow$逻辑设计$\rightarrow$物理设计$\rightarrow$编码$\rightarrow$测试$\rightarrow$运行$\rightarrow$进一步修改（前四个为数据库设计的四个阶段）</li></ul><h2 id="9-2-数据库设计的需求分析"><a href="#9-2-数据库设计的需求分析" class="headerlink" title="9.2 数据库设计的需求分析"></a>9.2 数据库设计的需求分析</h2><ul><li><strong>需求说明书</strong>：从调查用户单位着手，深入了解用户单位的数据流程、数据使用情况，数据的数量、流量、流向、性质，并作出分析，确定需要在数据库保存其信息的<strong>客观事物</strong>（things）及其<strong>相互关系</strong>（relationship），最终按一定规范要求以文档形式写出数据的需求说明书。</li><li>三个角度<ul><li>Things</li><li>Attributses of Things</li><li>Relationships among Things</li></ul></li></ul><h2 id="9-3-数据库的概念设计"><a href="#9-3-数据库的概念设计" class="headerlink" title="9.3 数据库的概念设计"></a>9.3 数据库的概念设计</h2><ul><li><strong>数据库概念设计的过程</strong><ul><li><strong>用户分解</strong>：首先将所有用户划分为功能相对独立的若干个用户组，然后针对每个用户组进行视图设计。</li><li><strong>视图设计</strong>：针对每个用户组设计其数据视图，以反映该组用户对于数据的需求。</li><li><strong>视图集成</strong>：将设计好的若干个局部数据视图集成为一个完整的全局数据视图。<ul><li>等同：两个或多个数据对象具有相同的语义</li><li>聚合：数据对象之间的一种组成关系（属性聚合成实体，属性和实体聚合成新的实体）</li><li>抽取：将不同实体中的相同属性提取成一个新的实体，并构造成具有集成关系的结构</li><li>命名冲突（同义异名，同名异义）$\rightarrow$重命名</li><li>概念冲突（同一概念在一处为实体，而在另一处则为属性或联系）$\rightarrow$统一为同一个概念（一般为实体）</li><li>域冲突（类型冲突、度量单位冲突）$\rightarrow$统一 “数据类型” 和 “度量单位”</li><li>约束冲突$\rightarrow$统一数据约束，或者如果不同数据约束的语义之间有包含关系，可以尝试构建具有‘父子’关系的继承层次结构，子类可以有比父类更严格的数据约束。或构建不同的实体集。</li></ul></li></ul></li><li>E-R模型与扩充E-R模型的设计：见第二章</li></ul><h2 id="9-4-数据库的逻辑设计"><a href="#9-4-数据库的逻辑设计" class="headerlink" title="9.4 数据库的逻辑设计"></a>9.4 数据库的逻辑设计</h2><ul><li>从E-R模型和EE-R模型向关系模型的转换 <strong>（此处建议看原ppt/gtmd直接做）</strong><ul><li>基本方法：每个实体集$\to$一个关系模式；每个联系$\to$一个关系模式</li><li><strong>实体集的转换方法（规则R1）</strong>：每个实体集被转换成一个关系（模式），关系及其属性的命名采用原实体集及其属性的名称。</li><li><strong>联系的转换方法（规则R2）</strong>：在一般情况下，每个联系也被转换成一个关系模式，联系名被用作转换得到的关系模式的关系名。来自于相关实体集的标识属性也是相关实体集转换得到的关系模式的主关键字，因此它们也是联系转换得到的关系模式中的外关键字。</li><li><strong>命名与属性域的处理</strong><ul><li>关系及属性的命名：尽量采用在EE-R模型中原有的名称；可以重新命名，但要避免命名的冲突现象。</li><li>属性域的定义：根据DBMS的选型进行必要的数据类型转换</li></ul></li><li><strong>非原子属性的处理</strong><ul><li>集合属性的处理（规则R1.1）：关系模式不变，但原有关系的一个元组将被纵向展开成多个元组。转换得到的关系模式的主关键字由<u>原实体集的标识属性</u>和该<u>集合属性</u>联合构成。例如<strong>张三一个人选修了3门课就拆成3个元组</strong>。</li><li>元组属性的处理（规则R1.2）：将一个元组属性横向展开成多个属性。如实体集‘圆’有三个属性：圆标识符，圆心和半径，而圆心又由其X坐标轴和Y坐标轴的值组成。转换得到的关系模式即为（圆标识符，X轴，Y轴，半径）</li></ul></li><li><strong>联系的转换</strong><ul><li>全参与：如果$E_1$中的每个实体都与$E_2$中的某些实体有关联；否则是非全参与</li><li><strong>1:1二元关系</strong><ul><li><strong>若$E_1$和$E_2$都是非全参与</strong>  <pre><code>    可以转化为三个关系模式：      $E_1(k_1,a)$（关键字为$k_1$）      $E_2(k_2,b)$（关键字为$k_2$）      $R(k_1,k_2,r)$（关键字为$k_1$或$k_2$）  + **若$E_1$全参与，$E_2$非全参与**      可以转化为两个关系模式：      $E_1(k_1,a,k_2,r)$（关键字为$k_1$，外键为$k_2$）      $E_2(k_2,b)$（关键字为$k_2$）  + **若$E_1$和$E_2$都是全参与**      可以转化为一个关系模式：      $E(k_1,a,k_2,b,r)$（$k_1, k_2$是两个候选关键字）  </code></pre><ul><li><strong>1:n二元关系</strong><ul><li><strong>若多端$E_2$是全参与</strong><br>  可以转化为两个关系模式：<br>  $E_1(k_1,a)$（关键字为$k_1$）<br>  $E_2(k_2,b,k_1,r)$（关键字为$k_2$，外键为$k_1$）  </li><li><strong>若多端$E_2$是非全参与</strong><br>  可以转化为三个关系模式：<br>  $E_1(k_1,a)$（关键字为$k_1$）<br>  $E_2(k_2,b)$（关键字为$k_2$）<br>  $R(k_2,k_1,r)$（关键字为$k_2$，外键为$k_1$）  </li></ul></li><li><strong>m:n二元关系</strong><br>  可以转化为三个关系模式：<br>  $E_1(k_1,a)$（关键字为$k_1$）<br>  $E_2(k_2,b)$（关键字为$k_2$）<br>  $R(k_1,k_2,r)$（关键字为$(k_1,k_2)$，两者都为外键）  </li><li><strong>单个实体集内部的联系</strong><br>  将该联系转换成两个实体集之间的二元联系，再按照二元联系的处理方式转换成关系模式将两个实体集转换得到的关系模式合并为一个关系。<ul><li>1:1联系可合并为$E(k,a,k’,r)$</li><li>1:n联系可合并为$E(k,a,k’,r)$</li><li>m:n联系可合并为$E(k,a)$, $R(k_1,k_2,r)$</li></ul></li></ul></li></ul></li><li><strong>继承的转换</strong><ul><li>若$E_1,E_2$继承于$S$，$S$的属性有$(k,A_1,A_2,\dots,A_n)$，其中$k$为标识属性；实体集$E_1$的属性有$(B_{11},B_{12},\dots,B_{1i})$，实体集$E_2$的属性有$(B_{21},B_{22},\dots,B_{2j})$。有三种转换方式：<ul><li>每一个实体集都将被转换为一个关系：<br>  $S(k,A_1,A_2,\dots,A_n)$<br>  $E_1(k,B_{11},B_{12},\dots,B_{1i})$<br>  $E_2(k,B_{21},B_{22},\dots,B_{2j})$</li><li>只有最底层的叶子结点才会被转换为关系，并从其所有超实体集中继承属性：<br>  $E_1(k,A_1,A_2,\dots,A_n,B_{11},B_{12},\dots,B_{1i})$<br>  $E_2(k,A_1,A_2,\dots,A_n,B_{21},B_{22},\dots,B_{2j})$</li><li>被转换为单个关系，其中含有所有实体集中的属性：<br>  $E_1(k,A_1,A_2,\dots,A_n,B_{11},B_{12},\dots,B_{1i},B_{21},B_{22},\dots,B_{2j})$</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>对转换得到的关系模式进行规范化设计</strong>（见Ch8）——到3NF</p><ul><li>根据给定的数据完整性约束发现函数依赖（最小函数依赖集）</li><li>关键字的计算</li><li>范式的判断及分解<h2 id="9-5-数据库的物理设计"><a href="#9-5-数据库的物理设计" class="headerlink" title="9.5 数据库的物理设计"></a>9.5 数据库的物理设计</h2></li></ul></li><li><p>设计目标：对数据库内部物理结构作调整并选择合理的存取路径，以提高数据库访问速度及有效利用存储空间。</p></li><li><strong>索引设计的作用及设计策略</strong><ul><li><strong>在主关键字及外关键字上建立索引</strong>：提高关系联接查询的速度，有利于实体完整性及引用完整性的检查。</li><li><strong>以读为主的关系应尽可能多地建立索引</strong></li><li>如果根据某属性的等值查询所得到的结果元组数量较少，则可以考虑对该属性建立索引</li><li><strong>对经常用于统计查询的属性建立索引</strong>：可以根据索引数据直接获取统计结果，不必再去访问对应关系的数据块。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ch1-数据库系统概述&quot;&gt;&lt;a href=&quot;#Ch1-数据库系统概述&quot; class=&quot;headerlink&quot; title=&quot;Ch1 数据库系统概述&quot;&gt;&lt;/a&gt;Ch1 数据库系统概述&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>论文阅读笔记</title>
    <link href="https://mengzelev.github.io/2019/07/20/paper-reading/"/>
    <id>https://mengzelev.github.io/2019/07/20/paper-reading/</id>
    <published>2019-07-20T08:55:11.000Z</published>
    <updated>2019-11-15T12:23:07.081Z</updated>
    
    <content type="html"><![CDATA[<p>阅读一些论文的收获整理，全是私货(雾)</p><h1 id="A-Large-Scale-Empirical-Study-of-Compile-Errors-in-Continuous-Integration"><a href="#A-Large-Scale-Empirical-Study-of-Compile-Errors-in-Continuous-Integration" class="headerlink" title="A Large-Scale Empirical Study of Compile Errors in Continuous Integration"></a>A Large-Scale Empirical Study of Compile Errors in Continuous Integration</h1><p>这篇论文通过整理并筛选了github上的使用了一个名叫Travis CI的java项目，统计CI历史中出现的CE与各项因素的关系<br>主要遵循了采集数据-分析数据-发现联系-提出解释-给出建议的思路<br>整个项目的build分为多个过程，build的状态有success, error, fail, canceled和started等，maven和gradle的error和fail分别出现在不同的步骤<br>最后对developer,tool,researcher各自提出了自己的建议</p><h2 id="频率分析"><a href="#频率分析" class="headerlink" title="频率分析"></a>频率分析</h2><p>分析了CE频率与项目性质、分支、代码类型(production code or test code)、build state、trgerring events之间的关系</p><h2 id="分布分析"><a href="#分布分析" class="headerlink" title="分布分析"></a>分布分析</h2><p>作者使用了正则表达式匹配统计各种错误类型，并与google的结果进行了比较<br>因素作用关系基本同上</p><h2 id="fix-effort分析"><a href="#fix-effort分析" class="headerlink" title="fix effort分析"></a>fix effort分析</h2><p>通过分析CE出现到消失的时间来衡量fix某个CE所耗费的effort</p><ul><li>排除掉了多错误CE，因为研究难度过大</li><li>排除掉了超过12个小时的fix，因为这可能跟程序员的个人生活安排有关<br>设计到代码架构实现CE比个别地方写错的CE需要更多的时间fix<br>google的平均fix时长短一些，可能是因为google对fix时间有要求，而且还有数据集的区别</li></ul><h2 id="fix-pattern分析"><a href="#fix-pattern分析" class="headerlink" title="fix pattern分析"></a>fix pattern分析</h2><p>人工分析</p><h1 id="Programmers’-Build-Errors-A-Case-Study-at-Google"><a href="#Programmers’-Build-Errors-A-Case-Study-at-Google" class="headerlink" title="Programmers’ Build Errors: A Case Study(at Google)"></a>Programmers’ Build Errors: A Case Study(at Google)</h1><p>这篇论文研究了3个问题：</p><ol><li>编译错误的频率</li><li>编译错误的原因</li><li>修复错误编译的时间</li></ol><p>方法：一个parser，可以将报错分类</p><h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p>数据来源是build的log file<br>计算了以下维度的数据：</p><ul><li>编译次数</li><li>编译失败率：失败次数/总编译次数</li><li>编译错误类型<ul><li>count-all:一次编译中出现的多个同类错误算多个</li><li>count-distinct:….算一个</li><li>但是错误出现的次数权重是不对等的(比如漏写一个声明会报一堆符号错误)，所以采用count-distinct比较合理</li></ul></li><li>解决时间：第一次build fail结束到第一次build success开始之间的时间，同时记录了这期间build fail的次数<ul><li>只考虑单错误的fail building</li><li>只考虑在12个小时内解决的错误</li></ul></li></ul><h2 id="RQ1：错误频率"><a href="#RQ1：错误频率" class="headerlink" title="RQ1：错误频率"></a>RQ1：错误频率</h2><p>把开发者按照经验分类进行了数据分析<br>但是对经验程度的定义可能不够准确</p><h2 id="RQ2：错误原因"><a href="#RQ2：错误原因" class="headerlink" title="RQ2：错误原因"></a>RQ2：错误原因</h2><p>把各种编译错误分成了5个大类：Dependency, Type mismatch, Syntax, Semantic, Other<br>对于C++和Java来说，Dependency-related error都是最常见的错误类型</p><h2 id="RQ3：修复时间"><a href="#RQ3：修复时间" class="headerlink" title="RQ3：修复时间"></a>RQ3：修复时间</h2><p>把研究对象限定为单一类型的错误信息，排除多错误修复时间带来的误差</p><p>进一步分析，还进行了case study<br>首先随机选择了25个Java的cant.resolve类型的编译错误，这些错误都是在下一次build的时候就修复了的，对比了修复前后的文件来观察错误是如何被修复的，并将结果记入表格</p><h1 id="How-do-fixes-become-bugs"><a href="#How-do-fixes-become-bugs" class="headerlink" title="How do fixes become bugs?"></a>How do fixes become bugs?</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro."></a>Intro.</h2><ul><li>举例证明incorrect fix普遍存在性</li><li>提出了导致incorrect fix的三个可能原因</li><li>吹一下自己研究的重要性</li></ul><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><h3 id="software-projects-under-study"><a href="#software-projects-under-study" class="headerlink" title="software projects under study"></a>software projects under study</h3><p>四个OS(一个闭源商业OS，FreeBSD, OpenSolaris, Linux)<br>选择stable&amp;widely deployed的series<br>为了机密性把四个OSmap成了ABCD而不知道哪个是哪个</p><h3 id="find-incorrect-fixes"><a href="#find-incorrect-fixes" class="headerlink" title="find incorrect fixes"></a>find incorrect fixes</h3><p>def: introduce new problems or not completely fixed<br>identify bug fix: whether associatied with a bug report</p><ul><li>not always systematically maintained</li><li>leverage the verbal info in bug reports oir cahnge logs to reconstruct the links<br>semi-automatically check whether fixed correctly:<ul><li>automatically select potential incorrect fix candidates</li></ul></li><li>source code overlap between changes -&gt; the latter may be to correct the first(more comprehensive)</li><li>search for words in bug report indicating incorrect fixes<ul><li>manually check each candidate(unique challenge)</li></ul></li><li>even discuss with developers<br>may prune a few incorrect fixes out, but rare</li></ul><h3 id="target-bugs-to-study"><a href="#target-bugs-to-study" class="headerlink" title="target bugs to study"></a>target bugs to study</h3><p>Sample set1: post-release bugs<br>Sample set2: fixes to memory leaks, buffer overflow, data race, deadlock bugs</p><h3 id="Measuring-code-knowledge"><a href="#Measuring-code-knowledge" class="headerlink" title="Measuring code knowledge"></a>Measuring code knowledge</h3><p>略</p><h2 id="Significance"><a href="#Significance" class="headerlink" title="Significance"></a>Significance</h2><ul><li>proportion of incorrect bug fixes(14.8%~24.4%)</li><li>result what kinds of problems(crash, hang, data loss, …)</li></ul><h2 id="Incorrect-fix-patterns"><a href="#Incorrect-fix-patterns" class="headerlink" title="Incorrect fix patterns"></a>Incorrect fix patterns</h2><ul><li>concurrency bugs: hardest to fix</li><li>data race -&gt; add locks -&gt; deadlock</li><li>deadlock -&gt; new deadlock/hided bugs</li><li>buffer overflow: use safe string function is safest, enlarged buffer may not solve, dynamic allocation introduces memory leaks</li><li>memory leak -&gt; dangling pointer/null pointer dereference -&gt; good to nullify pointer after fix</li><li>semantic bugs: conditions are difficult to fix </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阅读一些论文的收获整理，全是私货(雾)&lt;/p&gt;
&lt;h1 id=&quot;A-Large-Scale-Empirical-Study-of-Compile-Errors-in-Continuous-Integration&quot;&gt;&lt;a href=&quot;#A-Large-Scale-Empiri
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows-Ubuntu双系统重装笔记</title>
    <link href="https://mengzelev.github.io/2019/07/08/system-rebuild-notes/"/>
    <id>https://mengzelev.github.io/2019/07/08/system-rebuild-notes/</id>
    <published>2019-07-08T05:49:57.000Z</published>
    <updated>2019-07-08T07:04:40.002Z</updated>
    
    <content type="html"><![CDATA[<p>之前Linux只给了20个G过于局促，Windows企图装WSL又出现了各种各样的问题，于是就脑子一发热把两个系统备份以后都重装了。期间查了很多教程，就统一汇总在这里了。</p><h1 id="Windows重装"><a href="#Windows重装" class="headerlink" title="Windows重装"></a>Windows重装</h1><ul><li>原来装的是win10家庭版，很多功能被阉割掉了，就决定重装学校买的win10教育版，几种版本的nb程度大概是教育版≈企业版&gt;专业版&gt;家庭版</li><li>如果是同一个版本内的重装，只需要到设置里找”重装windows”就可以了，甚至可以保留个人文件</li><li>下载windows的iso文件到U盘里(U盘不需要格式化)，解压，启动盘就做好了。因为现在的笔记本电脑基本都装有UEFI，可以自己选择启动方式，所以不需要再格式化做引导盘。</li><li>把原先C盘里的重要文件备份一下l电脑品牌的官网上去查找进入方式)，选择装了windows安装程序的U盘进入</li><li>接下来按照指示一步步做就可以了，需要注意的是如果是要重装系统，要选择“自定义安装”，然后选一个位置作为C盘安装windows</li><li>等20分钟左右系统就装好辣</li><li>进入windows后如果发现连不上wifi了/没有声音了，应该是相关驱动在格式化的时候被删掉了，只需要到电脑厂商的官网上下载对应型号的驱动程序就可以了</li><li>ps既然重装了windows，国产流氓软件例如3*0，驱动*灵就不要装了，我之前年少无知装了3*0卸载了几次都把自己给装回来了</li></ul><h1 id="Ubuntu重装与配置"><a href="#Ubuntu重装与配置" class="headerlink" title="Ubuntu重装与配置"></a>Ubuntu重装与配置</h1><p>因为打算以后常驻Ubuntu了，而且可以个性化的内容也比较多，所以这边要配置的东西会相对多一些</p><h2 id="重装"><a href="#重装" class="headerlink" title="重装"></a>重装</h2><p>首先要在磁盘上准备好一定的空间，Ubuntu比较小，往死里压的话20G都能装得下，但是后期使用会经常出现磁盘空间不足的问题（不要问我怎么知道的），所以这次我给了70G（磁盘总大小256G）<br>到windows的“磁盘格式化与压缩”（我忘了是不是叫这个了，欢迎纠正）中选择一个可以压缩的磁盘，右击“压缩卷”，选择需要压缩的大小。如果需要压缩的空间比可压缩空间小还是失败的话应该是当前磁盘的碎片太多，建议备份以后格式化一下。<br><strong>注意</strong>： 双系统重装选手一定要先装Windows再装Ubuntu，不然windows的引导会覆盖掉Ubuntu的引导，产生不必要的麻烦</p><p>然后就只需要重启进入UEFI像重装windows一样操作即可<br>从windows重启可能会出现进不了UEFI的情况，可能是windows快速启动优化导致的，解决方法是重启时按住shift键，会出现蓝色的屏幕，选择高级选项-&gt;进入UEFI</p><p>Ubuntu的安装程序也比较亲民，基本按照指示做点Continue就可以，唯一的稍微有困难的地方是磁盘分区那里，我只提供一下我的分区方案做参考，不保证一定是最好的：</p><ul><li>biosgrub：200M,用于放置引导</li><li>swap：交换分区，我也不清楚这个是做什么的，看到网上不少地方说和内存差不多大就可以了，我的内存是8G，所以我给了10G</li><li>剩下的空间全都给根目录”/“，挂载方式选择ext4文件系统，挂载点选择”/“</li></ul><p>20分钟不到你就可以看到船新的Ubuntu了</p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>拿到新系统第一件事是把基本的软件都装了<br>Linux系统装软件都很方便，直接<code>sudo apt install [软件名]</code>就可以了<br>一般必备的软件有：git, gcc, g++等，其他可以等用到了的时候再装，反正很方便</p><h3 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h3><p>在Ubuntu菜单里面找到”Software &amp; Updates”<br>“Download from”下拉条里面选择”Other…”, 国家找到China，然后选择你要换的网址，我用的是阿里云的镜像<br>确定并关闭之后应该会有更新提示，等就可以了</p><h3 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h3><p>由于我装的是英文系统，上百度搜教程非常不方便，所以第一件事是把中文输入法给装好<br>Ubuntu自带的中文输入法iBus非常反人类，所以建议自己装中文输入法，我装的是搜狗拼音输入法for Linux</p><p><a href="https://blog.csdn.net/fx_yzjy101/article/details/80243710" target="_blank" rel="noopener">解决Ubuntu 18.04中文输入法的问题，安装搜狗拼音</a></p><h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><p>Ubuntu自带的是Firefox浏览器，相比于IE来说也很好用了，但是舍不得chrome的同步功能所以还是决定用chrome</p><p>百度搜索chrome官网，下载.deb文件，完成后直接打开，Ubuntu的软件商店会跳出来，再点Install就可以了</p><h3 id="小飞机"><a href="#小飞机" class="headerlink" title="小飞机"></a>小飞机</h3><p>要想登录google账号肯定需要科学上网</p><p><a href="https://www.cnblogs.com/luzeming/p/10591624.html" target="_blank" rel="noopener">ubuntu配置小飞机</a></p><p>值得补充的是，如果从github上下载的SwitchyOmega的crx文件拖进chrome显示<code>INVALID_CRX_HEADER</code>，就把crx文件后缀直接改成zip，然后解压该zip文件，在chrome插件管理界面中打开开发者模式-&gt;导入(Load Unpacked)，选择一个名叫”SwitchyOmega_xxx”(xxx为版本号)的文件夹即可</p><h3 id="QQ-or-TIM"><a href="#QQ-or-TIM" class="headerlink" title="QQ or TIM"></a>QQ or TIM</h3><p><a href="https://github.com/wszqkzqk/deepin-wine-ubuntu" target="_blank" rel="noopener">wszqkzqk/deepin-wine-ubuntu</a></p><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>用惯了windows的人表示想要一个好康的GUI环境，Ubuntu原生的有点太死板了</p><p>美化桌面环境需要先下载<code>gnome-tweak-tools</code>，不要问，问就是apt</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>到<a href="https://www.opendesktop.org/s/Gnome" target="_blank" rel="noopener">gnome-look.org</a>上找喜欢的主题和icon主题就可以了<br>我装的是排名最高的<a href="https://www.opendesktop.org/s/Gnome/p/1013030/" target="_blank" rel="noopener">Flat Remix GNOME/Ubuntu/GDM theme</a><br>安装方法里面都有写<br>装完以后在菜单里面找Tweaks，在里面改Applications，icons等设置就可以了</p><h3 id="gnome插件"><a href="#gnome插件" class="headerlink" title="gnome插件"></a>gnome插件</h3><p>这次装机突然了解到一个很骚的直接在浏览器里管理gnome的插件的工具<br><a href="http://www.linux-ren.org/portal.php?mod=view&amp;aid=2473" target="_blank" rel="noopener">如何手动或通过浏览器轻松安装 GNOME Shell 扩展？</a></p><p>我装的插件有</p><ul><li>dash to dock(可以把任务栏一样的条拿到下面，还可以设置自动隐藏)</li><li>Hide top bar(设置上面那条东西自动隐藏)</li><li>User themes(让shell可以使用主题同样的风格)</li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Ubuntu本来的字体就还可以，不过我还是最喜欢苹果的monaco</p><p><a href="https://blog.csdn.net/qq_26990831/article/details/51847416" target="_blank" rel="noopener">ubuntu16.04安装monaco字体</a></p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>Ubuntu默认的终端是bash，但是zsh比bash好看，而且插件也很丰富，所以我把默认终端换成zsh了</p><p><a href="https://www.cnblogs.com/EasonJim/p/7863099.html" target="_blank" rel="noopener">Ubuntu 16.04下安装zsh和oh-my-zsh</a></p><p>主题我用的是powerlevel9k<br>值得提醒的是，改.zshrc之前一定要记得备份，我就把自己的zsh玩坏过还回不去orz</p><h3 id="vim和tmux"><a href="#vim和tmux" class="headerlink" title="vim和tmux"></a>vim和tmux</h3><p>我直接用了github上别人的配置文件，安装方法里面都有</p><p><a href="https://github.com/gpakosz/.tmux" target="_blank" rel="noopener">gpakosz/.tmux</a><br><a href="https://github.com/amix/vimrc" target="_blank" rel="noopener">amix/vimrc</a></p><p>说实话我已经用惯了vscode基本不碰vim了(x)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前Linux只给了20个G过于局促，Windows企图装WSL又出现了各种各样的问题，于是就脑子一发热把两个系统备份以后都重装了。期间查了很多教程，就统一汇总在这里了。&lt;/p&gt;
&lt;h1 id=&quot;Windows重装&quot;&gt;&lt;a href=&quot;#Windows重装&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统期末复习笔记</title>
    <link href="https://mengzelev.github.io/2019/06/21/os-review/"/>
    <id>https://mengzelev.github.io/2019/06/21/os-review/</id>
    <published>2019-06-21T12:58:41.000Z</published>
    <updated>2019-06-23T03:37:40.845Z</updated>
    
    <content type="html"><![CDATA[<p><s>这其实是jyy课程讲义摘抄</s></p><h1 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h1><p>维度：价格、容量、速度、可靠性</p><p>持久化存储介质统称Non-Volatile Memory</p><h1 id="IO设备与驱动"><a href="#IO设备与驱动" class="headerlink" title="IO设备与驱动"></a>IO设备与驱动</h1><p>设备：三种操作（发送命令、读取状态、传输数据）的集合</p><h2 id="管理IO设备"><a href="#管理IO设备" class="headerlink" title="管理IO设备"></a>管理IO设备</h2><p>查看系统IO设备：<code>lspci,lsblk</code><br>(实现： <code>open(&quot;/sys/bus/pci&quot;)</code>)</p><p>Loop Back Device(回路设备)：把一个文件模拟成一个块设备<br>a pseudo-device that makes a file accessible as a block device in Unix-like operating systems</p><p>IO设备类型众多、访问模式差距很大<br>解决：抽象层——设备驱动<br><strong>设备驱动</strong>：操作系统对设备进行的额外抽象，使得更上层的部分（通常是文件系统）能够以统一的接口访问这些设备，i.e.把文件API翻译成设备命令</p><ul><li>设备驱动层帮助我们屏蔽了底层设备的具体实现细节</li><li>使得创建“虚拟”设备非常容易(<code>/dev/random</code>,<code>/dev/null</code>)</li></ul><p>I/O设备最主要的功能：input/output(read/write)<br>还有一些设备相关设置(<code>ioctl</code>)</p><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>解决中断没能解决的问题<br>一个完成CPU和设备之间数据传输的I/O设备<br>这样CPU可以在传送数据时做别的事</p><h1 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h1><p>存储设备虚拟化<br>虚拟磁盘：一个可以读写的动态字节序列<br>传统理解：文件系统是保存在持久存储上的数据结构(存储格式规范+允许的操作)</p><p>文件系统【以下是我能找到的所有描述】</p><ul><li>存储设备的虚拟化机制</li><li>保存在持久存储上的数据结构</li><li>文件名到虚拟磁盘的映射</li><li>管理操作系统内部对象的中间层</li><li>连接应用程序与设备驱动的桥梁</li><li>管理操作系统中能够抽象成“虚拟磁盘”接口访问的任何数据</li></ul><p>文件系统实现 = 数据结构的查询/修改操作<br>文件：可读写的数据对象，相当于一个虚拟磁盘<br>文件操作</p><ul><li>打开（返回文件描述符），关闭</li><li>文件描述符操作：read,write,lseek,ioctl,mmap…</li></ul><p>目录：文件和目录的集合<br>目录操作</p><ul><li>改变进程工作目录(没有<code>/bin/cd</code>)</li><li>目录解析</li><li>读取目录</li><li>目录操作：link,unlink,rename</li></ul><h2 id="文件系统设计"><a href="#文件系统设计" class="headerlink" title="文件系统设计"></a>文件系统设计</h2><p>文件（扩展）：操作系统中的一个可读/写/控制的对象<br>文件描述符：指向操作系统对象的handle<br>管理操作系统对象的本质：传递数据的需求</p><blockquote><p>为什么<code>/proc</code>不是进程树？-方便根据pid查找进程</p></blockquote><p>虚拟文件系统：把read/write翻译成对操作系统对象(进程线程、文件目录、设备等)的读写</p><h1 id="文件系统API"><a href="#文件系统API" class="headerlink" title="文件系统API"></a>文件系统API</h1><h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><p>挂载：<code>mount -t type device dir</code><br>把一个设备和一个文件系统实现联系起来，在设备上创建一个文件系统实例，并且把创建的文件系统“放置”到文件系统中的一个路径里</p><h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>切换根目录<br>只影响路径解析<br>如果持有外部文件描述符很容易越狱</p><h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p>本质也是文件，只是操作系统在路径解析、目录遍历时对它的数据有特殊的解读</p><h3 id="硬♂链接"><a href="#硬♂链接" class="headerlink" title="硬♂链接"></a>硬♂链接</h3><ul><li>目标只能是文件(不能是目录)</li><li>不能跨越文件系统</li></ul><h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><ul><li>目标可以是任何相对/绝对路径</li><li>只是一个路径解析提示</li></ul><h2 id="文件管理：打开文件"><a href="#文件管理：打开文件" class="headerlink" title="文件管理：打开文件"></a>文件管理：打开文件</h2><p>打开目录：得到一个指向文件系统某个位置的指针</p><h2 id="文件操作：文件描述符"><a href="#文件操作：文件描述符" class="headerlink" title="文件操作：文件描述符"></a>文件操作：文件描述符</h2><ul><li>避免每次操作都要重新打开文件</li><li>帮助我们自动管理文件访问的偏移量</li></ul><h2 id="文件系统的同步"><a href="#文件系统的同步" class="headerlink" title="文件系统的同步"></a>文件系统的同步</h2><p>操作系统做了很多激进地缓存，所以多用<code>sync</code></p><h1 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h1><p>实现文件系统需要考虑以下因素</p><ul><li>虚拟磁盘的数据结构（链表，树…）</li><li>目录文件的数据结构</li><li>inode的表示和存储</li><li>balloc/bfree的实现</li></ul><h2 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h2><p>固定大小的block的数组<br>在<code>/sys/block</code>里可以找到<br>块设备API：进程/线程向存储设备提交I/O request, request首先进入设备队列，经过调度器调度后执行设备上的I/O<br>操作系统不管Block I/O调度，只管进程尽可能公平地获得I/O操作和请求优化</p><h2 id="虚拟磁盘"><a href="#虚拟磁盘" class="headerlink" title="虚拟磁盘"></a>虚拟磁盘</h2><p>数据结构：链表/树，提供<code>balloc/bfree</code><br>链表在文件小时表现较好，索引的lseek性能更好<br>block bitmap(联系L3)</p><p>文件应该有</p><ul><li>一个唯一的编号</li><li>元数据信息（类型，大小，权限，访问时间、链接数量、索引）</li></ul><h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><p>目录=文件名$\to$文件id的映射</p><h3 id="Inode的存储"><a href="#Inode的存储" class="headerlink" title="Inode的存储"></a>Inode的存储</h3><table><thead><tr><th style="text-align:left">存储方式</th><th style="text-align:center">好处</th><th style="text-align:center">坏处</th></tr></thead><tbody><tr><td style="text-align:left">在磁盘用单独区域统一存储和管理</td><td style="text-align:center">查找快速（可以快速计算出inode在磁盘中的位置）</td><td style="text-align:center">容易被破坏（备份）；浪费空间</td></tr><tr><td style="text-align:left">存储在目录文件中（如FAT）</td><td style="text-align:center">节约空间</td><td style="text-align:center">不支持硬链接</td></tr><tr><td style="text-align:left">存储在文件头部</td><td style="text-align:center">容错性</td></tr></tbody></table><h3 id="评价文件系统"><a href="#评价文件系统" class="headerlink" title="评价文件系统"></a>评价文件系统</h3><ul><li>性能<ul><li>存在超大文件、超大目录时各个操作的性能表现</li><li>在各种类型workload的读写（顺序/随机，读/写分布）、目录操作比例下的性能表现</li><li>多进程并发时的文件系统表现</li></ul></li><li>可靠性<ul><li>在系统可能意外崩溃时文件系统实现的正确性</li><li>在磁盘可能损坏的前提下文件系统的可靠性</li></ul></li></ul><h1 id="FAT和ext2"><a href="#FAT和ext2" class="headerlink" title="FAT和ext2"></a>FAT和ext2</h1><h2 id="File-Allocationg-Table"><a href="#File-Allocationg-Table" class="headerlink" title="File Allocationg Table"></a>File Allocationg Table</h2><p>链表实现文件，为每个block维护一个next block<br>文件分配表：集中存储next</p><p>PBR(Partition Boot Record)：存储在分区头部</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>读写序列不够连续</li><li>FAT容易被枪毙（一般都有两个备份）</li><li>文件系统可能碎片化（巨大的文件可能散落在磁盘的各个角落）</li><li><s>不支持链接只是因为手册里没写</s></li><li>FAT32最大文件只有4GB（因为是从小磁盘时代过来的）</li></ul><p>磁盘碎片整理：使文件尽可能在磁盘中占有连续的块</p><h2 id="ext2"><a href="#ext2" class="headerlink" title="ext2"></a>ext2</h2><p>索引实现文件：混合多种存储方式<br>inodes单独管理：支持硬链接<br>inodes连续存储：提高文件访问的局部性<br>相比于FAT空间浪费比较多</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li>分配分成了两级(组级、块级)<ul><li>不用管理全局的bitmap</li></ul></li><li>一定程度的性能优化<ul><li>尽量把相近的文件分配在同一个组里</li><li>尽量把同一个文件的数据块分配在同一个组里</li></ul></li><li>使磁盘大小容易动态调整</li></ul><h1 id="持久数据的可靠性"><a href="#持久数据的可靠性" class="headerlink" title="持久数据的可靠性"></a>持久数据的可靠性</h1><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>如何把虚拟磁盘映射到物理磁盘块</p><h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID-0"></a>RAID-0</h3><p>没有冗余</p><ul><li>方案1</li></ul><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>3</td></tr><tr><td>#1</td><td>1</td><td>4</td></tr><tr><td>#2</td><td>2</td><td>5</td></tr></tbody></table><ul><li>方案2</li></ul><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>1</td></tr><tr><td>#1</td><td>2</td><td>3</td></tr><tr><td>#2</td><td>4</td><td>5</td></tr></tbody></table><table><thead><tr><th></th><th>方案一</th><th>方案二</th></tr></thead><tbody><tr><td>顺序读写速度</td><td>1X</td><td>2X</td></tr><tr><td>随机读写速度</td><td>2X</td><td>2X</td></tr></tbody></table><p>实际使用中对目录访问较多（顺序读写），方案2中磁盘2等于没有</p><p>毫无容错</p><h3 id="RAID-1-镜像"><a href="#RAID-1-镜像" class="headerlink" title="RAID-1 镜像"></a>RAID-1 镜像</h3><p>维护两块数据完全一样的磁盘实现容错</p><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>0</td></tr><tr><td>#1</td><td>1</td><td>1</td></tr><tr><td>#2</td><td>2</td><td>2</td></tr><tr><td>#3</td><td>3</td><td>3</td></tr></tbody></table><h3 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID-4"></a>RAID-4</h3><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th><th>磁盘3</th><th>磁盘4</th><th>磁盘P</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>$0\oplus1\oplus2\oplus3$</td></tr><tr><td>#1</td><td>4</td><td>5</td><td>6</td><td>7</td><td>$4\oplus5\oplus6\oplus7$</td></tr><tr><td>#2</td><td>8</td><td>9</td><td>10</td><td>11</td><td>$8\oplus9\oplus10\oplus11$</td></tr><tr><td>#3</td><td>12</td><td>13</td><td>14</td><td>15</td><td>$12\oplus13\oplus14\oplus15$</td></tr></tbody></table><ul><li>顺序读：4X</li><li>顺序写：4X</li><li>随机读：4X</li><li>随机写：X/2(校验盘是性能瓶颈)</li></ul><h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID-5"></a>RAID-5</h3><p>RAID-4升级版</p><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th><th>磁盘3</th><th>磁盘4</th><th>磁盘P</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>P</td></tr><tr><td>#1</td><td>4</td><td>5</td><td>6</td><td>P</td><td>7</td></tr><tr><td>#2</td><td>8</td><td>9</td><td>P</td><td>10</td><td>11</td></tr><tr><td>#3</td><td>12</td><td>P</td><td>13</td><td>14</td><td>15</td></tr></tbody></table><ul><li>随机写可以并发</li></ul><h3 id="带宽分析"><a href="#带宽分析" class="headerlink" title="带宽分析"></a>带宽分析</h3><p>见OSTEP</p><h3 id="RAID硬件"><a href="#RAID硬件" class="headerlink" title="RAID硬件"></a>RAID硬件</h3><ul><li>缓冲&amp;日志</li><li>奇偶校验电池</li><li>保证数据写回</li></ul><h1 id="崩溃恢复与日志"><a href="#崩溃恢复与日志" class="headerlink" title="崩溃恢复与日志"></a>崩溃恢复与日志</h1><h2 id="磁盘上的数据结构"><a href="#磁盘上的数据结构" class="headerlink" title="磁盘上的数据结构"></a>磁盘上的数据结构</h2><p>读磁盘的请求：</p><ul><li>读一个已经写过的块，可以不从磁盘读取</li><li>读一个未被访问过的块，必须从磁盘读取（等待）</li></ul><p>写磁盘的请求：</p><ul><li>原则上可以无限排队，让磁盘的读请求先行</li><li>但同时最终应当被写入磁盘</li></ul><h2 id="原子性的丧失"><a href="#原子性的丧失" class="headerlink" title="原子性的丧失"></a>原子性的丧失</h2><p>崩溃=缓存数据丢失</p><h3 id="简单的workload-追加写"><a href="#简单的workload-追加写" class="headerlink" title="简单的workload: 追加写"></a>简单的workload: 追加写</h3><ol><li>$FAT[b’]\leftarrow EOF$</li><li>$data[b’]\leftarrow$ 数据</li><li>$FAT[f_{end}]\leftarrow b’$</li></ol><p>一下考虑所有可能的崩溃情况</p><ul><li>$FAT[b’]\to$❌ (dead block/leak)</li><li>$data[b’]\to$❌ (random writes, 写到了没办法再读到的地方)</li><li>$FAT[f{end}]\to$❌ (corrupted FAT, inconsistency)</li><li>$data[b’]\to FAT[f_{end}]\to$❌ (random writes + corrupted FAT)</li><li>$FAT[b’]\to data[b’]\to$❌ (dead block * 2)</li><li>$FAT[b’]\to FAT[f_{end}]\to$❌ (corrupted file, incorrect data)</li><li>$FAT[f_end’]\to FAT[b’]\to data[b’]$ ✅</li></ul><p>dead block不是个很大的问题所以$FAT[b’]\to FAT[f_{end}]\to data[b’]$是个相对可以接受的方案，但这只是追加写，一般情形就很困难了</p><h2 id="文件系统一致性"><a href="#文件系统一致性" class="headerlink" title="文件系统一致性"></a>文件系统一致性</h2><p>当磁盘上的数据结构不合法或不满足文件操作的语义，文件系统就处于不一致的状态，e.g.</p><ul><li>链接成环</li><li>FAT指向未被分配数据块</li><li>两个文件的索引共享数据块</li></ul><h2 id="FSCK"><a href="#FSCK" class="headerlink" title="FSCK"></a>FSCK</h2><p>File System Checking<br>在崩溃后扫描磁盘进行补救</p><p>缺陷：</p><ul><li>为了一点小事扫描整个磁盘，太花时间了</li><li>没人能证明这么做一定能回到一个一致的状态</li><li>fsck的时候也会崩溃</li></ul><h2 id="实现崩溃一致性"><a href="#实现崩溃一致性" class="headerlink" title="实现崩溃一致性"></a>实现崩溃一致性</h2><p>Key idea: 使磁盘上的状态能推导出某个过去时刻的文件系统状态<br>借助<code>sync()</code>保证数据写入磁盘后才返回</p><h3 id="日志-Journaling"><a href="#日志-Journaling" class="headerlink" title="日志(Journaling)"></a>日志(Journaling)</h3><p>把操作以append only的方式记下来：写入TXbegin和数据→sync→写入TXEND→sync<br>用一个额外的指针维护journal完成的时刻</p><p>崩溃恢复：从指针开始向后重做journal中记录的操作<br>优化：合并log，只对metadata做journaling(但可能导致应用程序丢失数据)</p><h1 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h1><h2 id="I-O设备模型"><a href="#I-O设备模型" class="headerlink" title="I/O设备模型"></a>I/O设备模型</h2><p>传输数据、发送命令、读取状态这三种操作的集合</p><p>设备驱动：操作系统对设备进行的额外抽象，使得更上层的程序能够以统一的接口访问这些设备</p><h2 id="main函数之前的故事"><a href="#main函数之前的故事" class="headerlink" title="main函数之前的故事"></a>main函数之前的故事</h2><p>hello的第一条指令：<code>ld.so</code>的<code>_start</code></p><p>hello的<code>main</code>函数执行之前</p><ol><li>加载器(<code>ld.so</code>)把hello进程的地址空间加载进来</li><li>加载器的<code>_start</code>加载libc到hello进程的地址空间</li><li>进入hello自己的<code>_start</code>, 调用<code>__libc_start_main</code></li></ol><h2 id="线程安全的printf"><a href="#线程安全的printf" class="headerlink" title="线程安全的printf"></a>线程安全的printf</h2><p>复习条件变量和信号量</p><h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h3><ul><li>维护了（可能不止）一份文件分配表，记录每个文件中每一个block的下一个block的编号，位于文件系统头部、super block之后</li><li>block被称为sector的cluster</li><li>文件的元数据(inode)保存在目录项里，不支持链接，目录项按顺序存储在文件中</li><li>缺陷：<code>lseek</code>困难，FAT块容易被枪毙，文件系统碎片化</li></ul><h3 id="ext2-1"><a href="#ext2-1" class="headerlink" title="ext2"></a>ext2</h3><ul><li>多级索引</li><li>inode单独管理，提高了文件访问的局部性</li><li>目录项顺序存储inode编号、该目录项长度、类型、文件名</li><li>分组：不用管理全局的bitmap，性能优化，简化磁盘大小动态调整</li></ul><h2 id="保护数据不受损害"><a href="#保护数据不受损害" class="headerlink" title="保护数据不受损害"></a>保护数据不受损害</h2><h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID"></a>RAID</h3><table><thead><tr><th style="text-align:center">RAID lv.</th><th style="text-align:center">容量</th><th style="text-align:center">容错</th><th style="text-align:center">顺序读</th><th style="text-align:center">顺序写</th><th style="text-align:center">随机读</th><th style="text-align:center">随机写</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">$n$</td><td style="text-align:center">0</td><td style="text-align:center">$n$</td><td style="text-align:center">$n$</td><td style="text-align:center">$n$</td><td style="text-align:center">$n$</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">$n/2$</td><td style="text-align:center">$1…n/2$</td><td style="text-align:center">$&gt;n/2$</td><td style="text-align:center">$n/2$</td><td style="text-align:center">$n$</td><td style="text-align:center">$n/2$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$n-1$</td><td style="text-align:center">1</td><td style="text-align:center">$n-1$</td><td style="text-align:center">$n-1$</td><td style="text-align:center">$n-1$</td><td style="text-align:center">$1/2$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$n-1$</td><td style="text-align:center">1</td><td style="text-align:center">$n-1$</td><td style="text-align:center">$n-1$</td><td style="text-align:center">$n$</td><td style="text-align:center">$n/4$</td></tr></tbody></table><h3 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h3><p>崩溃之后的补救措施</p><ul><li>扫描inodes里所有数据块，检查bitmap的一致性</li><li>检查inode数据是否看起来合法，否则删除</li><li>检查链接情况，没有链接的inode被移到lost+found目录</li></ul><p>缺陷：没事儿就扫描整个磁盘开销太大；也不一定能把文件系统恢复成一致的状态；fsck的时候崩溃了就完蛋了</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul><li>记录所有操作</li><li>维护一个指针，指向已经完成的checkpoint</li><li>崩溃后从指针处开始重做所有操作，向后恢复</li><li>优化：批处理；metadata journaling</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;s&gt;这其实是jyy课程讲义摘抄&lt;/s&gt;&lt;/p&gt;
&lt;h1 id=&quot;存储介质&quot;&gt;&lt;a href=&quot;#存储介质&quot; class=&quot;headerlink&quot; title=&quot;存储介质&quot;&gt;&lt;/a&gt;存储介质&lt;/h1&gt;&lt;p&gt;维度：价格、容量、速度、可靠性&lt;/p&gt;
&lt;p&gt;持久化存储介质统称No
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OSTEP阅读笔记-持久化部分</title>
    <link href="https://mengzelev.github.io/2019/06/21/OSTEP-persistence/"/>
    <id>https://mengzelev.github.io/2019/06/21/OSTEP-persistence/</id>
    <published>2019-06-21T02:23:27.000Z</published>
    <updated>2019-06-23T02:47:49.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch36-IO设备"><a href="#Ch36-IO设备" class="headerlink" title="Ch36 IO设备"></a>Ch36 IO设备</h1><h2 id="典型设备协议"><a href="#典型设备协议" class="headerlink" title="典型设备协议"></a>典型设备协议</h2><p>设备的两个重要组成部分：硬件接口+内部结构</p><p><img src="/2019/06/21/OSTEP-persistence/device.png"></p><p>OS通过读写状态、命令和数据寄存器来控制设备行为</p><p>协议模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(STATUS == BUSY);</span><br><span class="line">//wait until device is not busy(polling)</span><br><span class="line">write data to DATA reg;</span><br><span class="line">write cmd to cmd reg;</span><br><span class="line">  (Doing so starts the device and executes the cmd)</span><br><span class="line">while(STATUS == BUSY);</span><br><span class="line">//wait until device is done with your request</span><br></pre></td></tr></table></figure><p>缺陷：轮询浪费时间——用中断减少CPU浪费(概括一下：等待设备的时候去做别的事情)</p><p>使用中断还是轮询取决于设备的速度</p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>要传送数据的时候，OS告诉DMA数据在哪里、送多少、要送给谁，然后OS就可以去干别的事了，数据拷贝全部由DMA来完成</p><h2 id="OS与设备的交互"><a href="#OS与设备的交互" class="headerlink" title="OS与设备的交互"></a>OS与设备的交互</h2><h3 id="明确的I-O指令"><a href="#明确的I-O指令" class="headerlink" title="明确的I/O指令"></a>明确的I/O指令</h3><p>古代方法<br>e.g. <code>x86</code>的<code>in</code>,<code>out</code>指令<br>PA你都写过了<br>都是特权指令，只有OS可以使用</p><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>现代方法<br>但古代方法没有被抛弃</p><h2 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h2><p>by传统艺能：抽象<br>设备驱动：OS中的某一块(piece)知道设备的工作细节的软件，封装了所有与设备的交互行为(原话：a piece of software in the OS must know in detail how a device works)<br>但这样会使设备损失特殊功能(e.g SCSI有比ATA和IDE更丰富的error handling机制)<br>OS里70%的代码都是设备驱动程序，而且因为设备驱动主要都是野鸡程序猿(相对于内核代码)写的，所以是贡献内核bug的中坚力量</p><h1 id="Ch37-硬盘驱动"><a href="#Ch37-硬盘驱动" class="headerlink" title="Ch37 硬盘驱动"></a>Ch37 硬盘驱动</h1><p>虽然现代os会一次性往硬盘写很多数据，但是硬盘只保证一个sector(512字节)的写是原子的(要么写了要么没写)</p><h2 id="物理构造"><a href="#物理构造" class="headerlink" title="物理构造"></a>物理构造</h2><p>盘片(platter)的两个面称为盘面(surface)，盘片装在转轴(spindle)上。数据按磁道(track)排列在盘片上，由磁头(disk head)读写。每个盘面都有一个磁头(disk head)。磁头长在磁臂(disk arm)上<br>RPM(rotation per minute)</p><p>缓存(track buffer)</p><p>写判定</p><ul><li>写回(write back): 把数据放入磁盘缓冲就算写完</li><li>直写(write through): 把数据写入磁盘后才算写完</li></ul><p>下面都是磁盘读写调度我不看了啦</p><h1 id="Ch38-RAIDs"><a href="#Ch38-RAIDs" class="headerlink" title="Ch38 RAIDs"></a>Ch38 RAIDs</h1><p>Redundant Arrays of Inexpensive Disks廉价磁盘冗余阵列<br>RAID其实是一个firmware(编程硬件)，有自己的处理器、存储和磁盘</p><p>###评价标准<br>performance, capacity, reliability.<br>其中performance有两个判定尺度：single-request latency(单操作延迟), steady-state throughput(稳态吞吐量, the total bandwidth of many concurrent requests)</p><h2 id="故障模型-Fault-Model"><a href="#故障模型-Fault-Model" class="headerlink" title="故障模型(Fault Model)"></a>故障模型(Fault Model)</h2><h3 id="fail-stop"><a href="#fail-stop" class="headerlink" title="fail-stop"></a>fail-stop</h3><p>磁盘只有两个状态：wording &amp; failed(永远没有了)，不考虑坏了半块这样的情况</p><h2 id="RAID-Level-0-Striping-串列"><a href="#RAID-Level-0-Striping-串列" class="headerlink" title="RAID Level 0: Striping(串列)"></a>RAID Level 0: Striping(串列)</h2><p>毫无冗余，虚假的RAID</p><p>capacity: perfect<br>reliability: any disk failure will lead to data loss<br>performance:  excellent</p><p>【此处省略懒得截图的截图】<br>stripe: 排在同一行的blocks<br>chunk size(组块大小): 连续分布在同一块磁盘上的数据大小<br>chunk size对RAID的performance影响最大<br>小的chunk size能提高连续读的并发性，但是延长了把block分配到不同磁盘的时间<br>大的chunk size只有在读大文件时才能有较好的并发性，但缩短了分配时间<br>chunk size的选择依赖于workload</p><p>workload有两种：sequential和random</p><h2 id="RAID-Level-1-Mirroring"><a href="#RAID-Level-1-Mirroring" class="headerlink" title="RAID Level 1: Mirroring"></a>RAID Level 1: Mirroring</h2><p><img src="/2019/06/21/OSTEP-persistence/raid10.png"></p><p>图上那个又叫RAID-10</p><p>读：随机选一个<br>写：两份都要写（并发）</p><ul><li>capacity: N块磁盘，容量N/2</li><li>reliability: 可以忍受单块磁盘爆炸(只要不是同一块磁盘的两个备份同时爆炸)</li><li>performance: <ul><li>读延迟：速度同读单块磁盘</li><li>写延迟：同时写两份（并发），与同时写单块相同。但写时间由两块中时间长的决定，因此比写单块会慢一丢丢</li><li>连续读：同随机写</li><li>连续写：最大带宽$(\frac{N}{2}\cdot S)$，峰值带宽的一半</li><li>随机读：满带宽$N\cdot R$ MB/s</li><li>随机写：一半</li></ul></li></ul><h3 id="多块磁盘的一致性维护"><a href="#多块磁盘的一致性维护" class="headerlink" title="多块磁盘的一致性维护"></a>多块磁盘的一致性维护</h3><p>刚决定写一块磁盘，另一块磁盘写不写还没确定，就断电了，这时另一块磁盘完全没被写，导致两块磁盘数据不一致。也就是说希望镜像的两块盘的写操作是原子的。<br>解决：write-ahead log<br>大多数磁盘都带有电池供电的小型非易失性RAM</p><h2 id="RAID-Level-4-Saving-Space-With-Parity"><a href="#RAID-Level-4-Saving-Space-With-Parity" class="headerlink" title="RAID Level 4: Saving Space With Parity"></a>RAID Level 4: Saving Space With Parity</h2><p>用时间(performance)换空间(capacity)</p><p><img src="/2019/06/21/OSTEP-persistence/raid4.png"></p><p>给每个stripe加了一个parity check block(XOR)<br>当一块盘坏掉时，我们需要读同一个stripe中其他所有盘的数据才能恢复出这块盘的数据</p><ul><li>capacity： $N-1$</li><li>reliability: 能容忍每个stripe中有一块磁盘爆炸</li><li>performance<ul><li>连续读：只有校验盘没有被占用，$(N-1)\cdot S$ MB/s</li><li>连续写：full-stripe write很高效，因为写完一个stripe正好能写校验盘，$(N-1)\cdot S$ MB/s</li><li>随机读：除了校验盘，$(N-1)\cdot S$ MB/s</li><li>随机写：当修改了一块盘中的数据时，需要同时修改校验盘，这里有两种方法。一是additive parity，把同一个stripe中的块的数据全部读出来再算一遍校验位，然后并发地写入校验盘和数据盘，这种做法在RAID块比较多的时候会很慢；另一种是subtractive parity，从检验位中把原来的数据减去再加上新的数据，这种方法的瓶颈在于校验盘不能并发读写，带宽只有$R/2$ MB/s，即使加磁盘也不会加快。</li><li>读延迟：同读单块磁盘</li><li>写延迟：写单块时需要进行两次读和写(subtractive parity)，但读写都可以并发，因此写延迟为写单块磁盘的两倍（速度是一半）</li></ul></li></ul><h2 id="RAID-Level-5：-Rotating-Parity"><a href="#RAID-Level-5：-Rotating-Parity" class="headerlink" title="RAID Level 5： Rotating Parity"></a>RAID Level 5： Rotating Parity</h2><p><img src="/2019/06/21/OSTEP-persistence/raid5.png"></p><p>为了消除RAID-4校验盘的性能瓶颈</p><p>三围基本和RAID-4相同<br>随机读的performance会好一些，因为所有的磁盘都被占用了<br>随机写性能大大提升，因为写操作之间可以并发了。当有较大的随机写操作序列时，可以保证每块磁盘都能并发工作，但依然有2读2写，带宽是$\frac{N}{4}\cdot R$ MB/s.<br>在市场上已经基本取代了RAID-4</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>一张表格概括本章精髓</p><p><img src="/2019/06/21/OSTEP-persistence/sum.png"></p><p>方案选择取决于实际使用，对reliability、顺序或随机读写的不同需求</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ch36-IO设备&quot;&gt;&lt;a href=&quot;#Ch36-IO设备&quot; class=&quot;headerlink&quot; title=&quot;Ch36 IO设备&quot;&gt;&lt;/a&gt;Ch36 IO设备&lt;/h1&gt;&lt;h2 id=&quot;典型设备协议&quot;&gt;&lt;a href=&quot;#典型设备协议&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>难问题求解学习笔记-随机算法</title>
    <link href="https://mengzelev.github.io/2019/05/25/ps-4-13-Randomized-Algorithms/"/>
    <id>https://mengzelev.github.io/2019/05/25/ps-4-13-Randomized-Algorithms/</id>
    <published>2019-05-25T03:20:40.000Z</published>
    <updated>2019-06-19T12:33:02.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>输出为随机变量的算法称为蒙特卡洛算法(Monte Carlo)<br>输出总是正确的但时间复杂度为随机变量的算法称为拉斯维加斯算法(Las Vegas)</p><p>概率论理论引入了随机算法$A$与确定输入$x$构成的随机试验。试验可以被描述为概率空间$(S_{A,x},Prob)$，其中$S_{A,x}={C\mid C \text{is a computation (radom run) of } A \text{ on } x}$，$Prob$是$S_{A,x}$上的概率分布。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="一种新的复杂度度量"><a href="#一种新的复杂度度量" class="headerlink" title="一种新的复杂度度量"></a>一种新的复杂度度量</h2><p>$Random_A(x)$: 对于所有$A$在$x$上的随机计算中使用的random bits的最大数量<br>$Random_A(n)=\max{Random_A(x)\mid x \text{is a input of size }n}$</p><p>这么衡量的两点原因</p><ul><li>产生真随机数非常困难，且真随机序列越长越困难</li><li>如果一个算法的$Random_A(x)$是对数级的，那就可能可以在多项式时间内追踪它的所有运行的可能情况，做到去随机化(derandomization)</li></ul><p>$Prob_{A,x}(C)$: 某一次$A$对输入$x$的计算$C$, 由相应的随机序列的概率决定<br>$Prob(A(x)=y)$: $A$ outputs $y$ for an input $x$的概率<br>$Time(C)$: the time complexity of the run $C$ of $A$ on $x$</p><p>期望时间复杂度of $A$ on $x$(expected time complexity)<br>$$Exp-Time_A(x)=E[Time]=\sum\limits_{C}Prob_{A,x}(C)\cdot Time(C)$$</p><p>$A$的期望时间复杂度(worst case approach)<br>$$Exp-TIme_A(n)=\max{Exp-Time_A(x)\mid x \text{is an input of size } n}$$</p><p>$$Time_A(x)=\max{Time(C)\mid C \text{ is a run of} A \text{on} x }$$<br>$$Time_A(n)=\max{Time_A(x)\mid x \text{ is an input of size }n}$$</p><p>随机算法不一定会终止，可能会进行无限次计算，在实际情况下可以在某一时间后叫停，算法输出”?”，即无法在给定时间内解决该问题，然后重新开始</p><h1 id="随机算法的分类"><a href="#随机算法的分类" class="headerlink" title="随机算法的分类"></a>随机算法的分类</h1><h2 id="拉斯维加斯算法"><a href="#拉斯维加斯算法" class="headerlink" title="拉斯维加斯算法"></a>拉斯维加斯算法</h2><p>拉斯维加斯算法与其时间复杂度有两种定义方式，适用于不同的场景</p><h3 id="第一种定义"><a href="#第一种定义" class="headerlink" title="第一种定义"></a>第一种定义</h3><p>若对问题$F$的任意输入实例$x$，$Prob(A(x)=F(x))=1$,其中$F(x)$是问题$F$对于输入$x$的解，则称$A$是计算问题$F$的拉斯维加斯算法。这种定义下时间复杂度是$Exp-Time_A(n)$</p><h3 id="第二种定义"><a href="#第二种定义" class="headerlink" title="第二种定义"></a>第二种定义</h3><p>允许”?”输出<br>若对问题$F$的任意输入实例$x$，$Prob(A(x)=F(x))\ge\frac{1}{2}$且$Prob(A(x)=”?”)=1-Prob(A(x)=F(x))\le\frac{1}{2}$.<br>这种定义下时间复杂度采用$Time_A(n)$</p><p>第一种定义一般用于计算函数，第二种一般用于计算decision problem</p><h2 id="单边误差蒙特卡洛算法"><a href="#单边误差蒙特卡洛算法" class="headerlink" title="单边误差蒙特卡洛算法"></a>单边误差蒙特卡洛算法</h2><p>ONE-SIDED-ERROR MONTE CARLO ALGORITHMS</p><p>$L$的单边蒙特卡洛算法满足</p><ul><li>对任意$x\in L, Prob(A(x)=1)\ge 1/2$</li><li>对任意$x\notin L, Prob(A(x)=0)=1$</li></ul><p>重复次数越多，得到正确答案的可能性就越大</p><p>质数定理：集合${1,2,\cdots,m}$中质数的个数大约是$m/\ln m$，且当$m\ge 100$时至少是$m/\ln m$</p><h2 id="双边误差蒙特卡洛算法"><a href="#双边误差蒙特卡洛算法" class="headerlink" title="双边误差蒙特卡洛算法"></a>双边误差蒙特卡洛算法</h2><p>TWO-SIDED-ERROR MONTE CARLO ALGORITHMS</p><p>若存在实数$\varepsilon, 0\le\varepsilon &lt;1/2$，满足对于$F$的任意输入$x, Prob(A(x)=F(x))\ge\frac{1}{2}+\varepsilon$,则称该算法为$F$的双边蒙特卡洛算法</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/at.png"> </p><h2 id="无限制误差蒙特卡洛算法"><a href="#无限制误差蒙特卡洛算法" class="headerlink" title="无限制误差蒙特卡洛算法"></a>无限制误差蒙特卡洛算法</h2><p>UNBOUNDED-ERROR MONTE CARLO ALGORITHMS</p><p>若对于$F$的任意输入$x, Prob(A(x)=F(x))&gt;\frac{1}{2}$，则称这样的算法$A$是无限制蒙特卡洛算法</p><h2 id="随机最优化问题"><a href="#随机最优化问题" class="headerlink" title="随机最优化问题"></a>随机最优化问题</h2><p>判定问题的随机算法是选择出现最多的答案，而最优化问题是选择最接近(根据cost function)的答案</p><h3 id="随机近似算法"><a href="#随机近似算法" class="headerlink" title="随机近似算法"></a>随机近似算法</h3><p>随机算法可以看成是以高概率得到与最优解差别不大的解的近似算法</p><p><strong>定义5.2.2.10</strong>：设$U=$(略)是一个最优化问题。对任意正实数$\delta&gt;1$，随机算法$A$是$U$的<strong>随机$\delta-$近似算法</strong>，若$A$满足以下要求</p><ul><li>$Prob(A(x)=\mathcal{M}(x))=1$且</li><li>$Prob(R_A(x)\le\delta)\ge 1/2$</li></ul><p>对任意$x\in L_I$</p><p>类似可定义<strong>随机$f(n)-$近似算法</strong></p><p>随机多项式近似方案(RPTAS)</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/rptas1.png"></p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/rptas2.png"></p><p>还有随机 完全多项式近似方案(RFPTAS)</p><p>$\delta-$期望近似算法</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/52211.png"></p><p>以上两种定义互不包含</p><h1 id="随机算法设计"><a href="#随机算法设计" class="headerlink" title="随机算法设计"></a>随机算法设计</h1><h2 id="挫败对手"><a href="#挫败对手" class="headerlink" title="挫败对手"></a>挫败对手</h2><p>随机选择一系列算法中的一个，这样就无法特意构造一组最坏输入</p><h2 id="充分取证"><a href="#充分取证" class="headerlink" title="充分取证"></a>充分取证</h2><p>常用于判定问题</p><p>如Example5.2.2.6的取模运算</p><h2 id="指纹"><a href="#指纹" class="headerlink" title="指纹"></a>指纹</h2><p>用于判定等价问题</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/fp.png"></p><h2 id="随机采样"><a href="#随机采样" class="headerlink" title="随机采样"></a>随机采样</h2><h2 id="松弛与随机舍入"><a href="#松弛与随机舍入" class="headerlink" title="松弛与随机舍入"></a>松弛与随机舍入</h2><p>比如把线性规划的值舍入成整数规划</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;输出为随机变量的算法称为蒙特卡洛算法(Monte Carlo)&lt;br&gt;输出总是正确的但时间复杂度为随机变量的算法称为拉斯维加斯算法(Las 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>难问题求解学习笔记-近似算法</title>
    <link href="https://mengzelev.github.io/2019/05/18/ps-4-12-Approximation-Algorithms/"/>
    <id>https://mengzelev.github.io/2019/05/18/ps-4-12-Approximation-Algorithms/</id>
    <published>2019-05-18T03:03:30.000Z</published>
    <updated>2019-06-19T08:16:41.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>近似算法是能提供最优化问题的可行解的算法，所提供的解的质量不会与最优解相差太多</p><p><strong>形式化定义</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$是一个最优化问题，$A$是$U$的consistent algorithm. 对任意$x\in L_I$, $A$在$x$上的相对误差(relative error)$\varepsilon_A(x)$定义为<br>$$\varepsilon_A(x)=\frac{|cost(A(x))-Opt_U(x)|}{Opt_U(x)}$$<br>对任意$x\in\mathbb{N}$,定义$A$的相对误差$$\varepsilon_A(n)=\max{\varepsilon_A(x)|x\in L_I\cap (\Sigma_I)^n}$$<br>对每个$x\in L_I$,$A$在$x$上的的近似率(approximation ration)$R_A(x)$定义为$$R_A(x)=\max{\frac{cost(A(x))}{Opt_U(x)}, \frac{Opt_U(x)}{cost(A(x))}}$$<br>对任意$n\in\mathbb{N}$,定义$A$的近似率为$$R_A(n)=\max{R_A(x)|x\in L_I\cap (\Sigma_I)^n}$$<br>$R_A$又名最坏情况性能(worst case performance)，近似因子(approximation factor), 性能约束(performance bound)，性能率(performance ratio)，误差率(error ratio)</p><p>若$A$是最小化问题且$R_A(x)=\frac{Opt_U(x)}{cost(A(x))}$,则$R_A(x)=1+\varepsilon_A(x)$</p><p>对于任意正实数$\delta&gt;1$，若$R_A(x)\le\delta$对任意$x\in L_I$恒成立，则称$A$是$U$的$\delta-$近似算法<br>对任意函数$f:\mathbb{N}\to\mathbb{R}^+$,若$R_A(x)\le f(n)$对任意$n\in\mathbb{N}$恒成立，则称$A$是$U$的$f(n)-$近似算法</p><h1 id="近似方案-approximation-scheme"><a href="#近似方案-approximation-scheme" class="headerlink" title="近似方案(approximation scheme)"></a>近似方案(approximation scheme)</h1><p>用户可以指定一个小的相对误差值$\varepsilon$，程序可以提供出一个误差至多为$\varepsilon$的可行解</p><p><strong>定义4.2.1.6</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$是一个最优化问题。若对任意输入对$(x,\varepsilon)\in L_I\times\mathbb{R}^+$, $A$计算出一个相对误差至多为$\epsilon$的可行解$A(x)$, 且$Time_A(x,\varepsilon^{-1})$以某个$|x|$的多项式函数为界，则称$A$是$U$的<strong>多项式时间近似方案(polynomial-time approximation scheme, PTAS)</strong>. 若$Time_A(x,\varepsilon^{-1})$以某个同时是$|x|$和$\varepsilon^{-1}$的多项式的函数为界，则称$A$是$U$的<strong>完全多项式近似方案(fully polynomial-time approximation scheme, FPTAS)</strong></p><p>一般来说$Time_A(x,\varepsilon^{-1})$关于$|x|$和$\varepsilon^{-1}$都单调递增</p><p>好处：用户有权决定要快还是要精度</p><h1 id="最优化问题的分类"><a href="#最优化问题的分类" class="headerlink" title="最优化问题的分类"></a>最优化问题的分类</h1><p>在近似的意义下NPO可以被分为以下五类：</p><ul><li>NPO(I): NPO中所有存在FPTAS的最优化问题(e.g.背包问题)</li><li>NPO(II): NPO中所有存在PTAS的最优化问题(e.g. MS)</li><li>NPO(III): 包含所有$U\in NPO$满足：<ul><li>对某些$\delta&gt;1$存在多项式时间的$\delta-$近似算法</li><li>对某些$d&lt;\delta$不存在多项式时间的的$d-$近似算法</li><li>i.e.$U$没有PTAS</li></ul></li><li>NPO(IV): 包含所有$U\in NPO$满足：<ul><li>对某些$f:\mathbb{N}\to\mathbb{R}^+$,存在多项式时间的$f(n)-$近似算法,其中$f$以某个多项式函数为界</li><li>对任意$\delta\in\mathbb{R}^+$不存在任何多项式时间的$\delta-$近似算法</li><li>e.g.集合覆盖问题</li></ul></li><li>NPO(V): 包含所有$U\in NPO$，满足若存在多项式时间的$f(n)-$近似算法，则$f(n)$不以任何多项式函数为界(e.g. TSP, 最大团问题)</li></ul><p>以上分类都基于合理的假设P$\neq$NP<br>所有集合都是非空的</p><h1 id="近似算法的稳定性"><a href="#近似算法的稳定性" class="headerlink" title="近似算法的稳定性"></a>近似算法的稳定性</h1><p>即使是NPO(V)中的问题，也可能有很大一部分的输入是比较简单的</p><p>稳定性用来衡量问题实例的限定(参数，特性等)对近似率的影响<br>如果对模型的限制影响近似率的程度很低，则可以说我们的算法是稳定的</p><p><strong>定义4.2.3.1</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$, $\overline{U}={\Sigma_I, \Sigma_O, L, L, \mathcal{M}, cost, goal}$是两个最优化问题，$L_I\subseteq L$. $\overline{U}$依据$L_I$的距离函数(distance function for $\overline{U}$ according to $L_I$)是任何满足下列性质的函数$h_L:L\to\mathbb{R}^+\cup{0}$:</p><ul><li>对任意$x\in L_I, h_L(x)=0$</li><li>$h$可以在多项式时间内计算</li></ul><p>定义：对任意$r\in\mathbb{R}^+$,$$Ball_{r,h}(L_I)={w\in L\mid h(w)\le r}$$</p><p>$p$是正实数，若对任意实数$0\le r\le p$, 存在$\delta_{r,\varepsilon}\in\mathbb{R}^{&gt;1}$, $A$是$U_r={\Sigma_I, \Sigma_O, L, Ball_{r,h}, \mathcal{M}, cost, goal}$的$\delta_{r,\varepsilon}-$近似算法，则称$A$是<strong>p-stable</strong> according to $h$</p><p>若对任意$p\in\mathbb{R}^+$，$A$都是p-stable的，则称$A$是stable according to $h$<br>反之，若对任意$p\in\mathbb{R}^+$，$A$都不是p-stable的，则称$A$是unstable according to $h$</p><p>对任意正整数$r$和任意函数$f:\mathbb{N}\to\mathbb{R}^{&gt;1}$,若$A$是$U_r={\Sigma_I, \Sigma_O, L, Ball_{r,h}, \mathcal{M}, cost, goal}$的$f_r(n)-$近似算法，则称$A$是$(r,f_r(n))$-quasistable accroding to $h$</p><p>把PTAS$A$看作一系列多项式时间$(1+\varepsilon)-$近似算法的集合$A_\varepsilon$.若在某个距离度量$h$下对任意$\varepsilon&gt;0$,$A_\varepsilon$都是稳定的，则我们可以得到以下二者之一</p><ul><li>$U_r$的一个PTAS(for every $r\in\mathbb{R}^+$)</li><li>$U_r$的一个$\delta_{r,\varepsilon}$近似算法，但没有PTAS</li></ul><p><strong>定义4.2.3.6</strong>： $U,\overline{U}$定义同上。$h$是$\overline{U}$根据$L_I$的距离函数，$U_r$同上。设$A={A_\varepsilon}<em>{\varepsilon&gt;0}$是$U$的一个PTAS<br>若对任意$r&gt;0$和$\varepsilon&gt;0$,$A</em>\varepsilon$是$\delta_{r,\varepsilon}$-近似算法，则$A$是关于$h$stable的<br>若$\delta_{r,\varepsilon}\le f(\varepsilon)\cdot g(r)$，其中$f$和$g$是某些$\mathbb{R}^{\ge 0}\to\mathbb{R}^+$的函数且$\lim\limits_{\varepsilon\to 0}f(\varepsilon)=0$, 则称$A$关于$h$超稳定(superstable).</p><p>如果$A$对$U$超稳定，则$A$对$U_r$也超稳定</p><h1 id="对偶近似算法"><a href="#对偶近似算法" class="headerlink" title="对偶近似算法"></a>对偶近似算法</h1><p>修改限制条件$\mathcal(M)$来简化计算</p><p><strong>定义4.2.4.1</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$是一个最优化问题。$U$的<strong>限制距离函数(constraint distance function)</strong>是任何满足下列条件的函数$h:L_I\times\Sigma^*_O\to\mathbb{R}^{\ge 0}$:</p><ul><li>对任意$S\in\mathcal{M}(x), h(x,S)=0$</li><li>对任意$S\notin\mathcal{M}(x), h(x,S)&gt;0$</li><li>$h$是多项式时间内可计算的</li></ul><p>对任意$\varepsilon\in\mathbb{R}^+$,任意$x\in L_I$,$\mathcal{M}_\varepsilon^h(x)={S\in\Sigma_O^*\mid h(x,S)\le\varepsilon}$是$\varepsilon-$ball of $\mathcal{M}(x)$ according to $h$.</p><p><strong>定义4.2.4.2</strong>: $U$是最优化问题，$h$是$U$的限制距离函数. 若对任意$x\in L_1$,有$A(x)\in\mathcal{M}_\varepsilon^h(x)$且$cost(A(x))\ge Opt_U(x)$ if $goal=maximum$且$cost(A(x))\le Opt_U(x)$ if $goal=minimum$, 则称$A$是$U$的$h-$对偶$\varepsilon-$近似算法</p><p><strong>定义4.2.4.3</strong>: 条件同上。若</p><ul><li>对任意输入$(x,\varepsilon)\in L_I\times\mathbb{R}^+, A(x,\varepsilon)\in\mathcal{M}_\varepsilon^h(x)$</li><li>$cost(A(x))\ge Opt_U(x)$ if $goal=maximum$且$cost(A(x))\le Opt_U(x)$ if $goal=minimum$</li><li>$Time_A(x,\varepsilon^{-1})$以某个$|x|$的多项式函数为界</li></ul><p>则称$A$是$U$的$h-dual$PTAS<br>类似的可以定义$U$的$h-dual$FPTAS</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>降低问题难度的方法：</p><ul><li>对输出精度要求降低</li><li>对输入做限制</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;近似算法是能提供最优化问题的可行解的算法，所提供的解的质量不会与最优解相差太多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;形式化定义&lt;/strong&gt;：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自己看得惯的板子整理</title>
    <link href="https://mengzelev.github.io/2019/04/19/oj-templates/"/>
    <id>https://mengzelev.github.io/2019/04/19/oj-templates/</id>
    <published>2019-04-19T08:20:44.000Z</published>
    <updated>2019-04-20T10:55:16.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h2><h3 id="dfs版"><a href="#dfs版" class="headerlink" title="dfs版"></a>dfs版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> rnd, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (status == two[num] - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[i][status] &gt; <span class="number">0</span>) <span class="keyword">return</span> f[i][status];</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = num; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (j != i &amp;&amp; (!(status &amp; temp))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q &gt; dfs(j, rnd + <span class="number">1</span>, status | temp) + a[need[i]][need[j]]) &#123;</span><br><span class="line">                q = dfs(j, rnd + <span class="number">1</span>, status | temp) + a[need[i]][need[j]];</span><br><span class="line">                c[i][status] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[i][status] = q;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bfs版"><a href="#bfs版" class="headerlink" title="bfs版"></a>bfs版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(start);</span><br><span class="line">    vis[start] = <span class="literal">true</span>;</span><br><span class="line">    s[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = u + ok[i];</span><br><span class="line">            <span class="keyword">int</span> v2 = u - ok[i];</span><br><span class="line">            <span class="keyword">if</span> (v1 &lt;= n &amp;&amp; !vis[v1]) &#123;</span><br><span class="line">                Q.push(v1);</span><br><span class="line">                s[v1] = s[u] + <span class="number">1</span>;</span><br><span class="line">                vis[v1] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v2 &gt;= <span class="number">0</span> &amp;&amp; !vis[v2]) &#123;</span><br><span class="line">                Q.push(v2);</span><br><span class="line">                s[v2] = s[u] + <span class="number">1</span>;</span><br><span class="line">                vis[v2] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) e[i] = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">int</span> sn = <span class="number">1</span> &lt;&lt; cnt1; <span class="comment">//状态数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sn; ++i) f[i] = INF;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sn; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &amp; e[j]) ++j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p = j + <span class="number">1</span>; p &lt; cnt1; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(i &amp; e[p]) &amp;&amp; dist[p+<span class="number">1</span>][j+<span class="number">1</span>]) &#123;</span><br><span class="line">            f[i | e[j] | e[p]] = min(f[i | e[j] | e[p]], f[i] + dist[p+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> f[sn<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//别忘了初始化f[i]=i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = f[x];</span><br><span class="line">    <span class="keyword">while</span>(root != f[root]) root = f[root];</span><br><span class="line">    <span class="keyword">int</span> y = f[x];</span><br><span class="line">    <span class="keyword">while</span>(f[x] != root)&#123;</span><br><span class="line">        f[x] = f[y];</span><br><span class="line">        y = f[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(a, b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(a);</span><br><span class="line">    <span class="keyword">int</span> fb = find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa != fb) f[fa] = fb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> temp = f[x];</span><br><span class="line">    f[x] = find(temp);</span><br><span class="line">    rel[x] = (rel[x] + rel[temp]) % <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//rel[x]初始化为全0</span></span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">        f[fy] = fx;</span><br><span class="line">        rel[fy] = (<span class="number">3</span> + d + rel[x] - rel[y]) % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span>) <span class="keyword">return</span> (rel[x] == rel[y]);</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">1</span>) <span class="keyword">return</span> ((<span class="number">3</span> - rel[x] + rel[y]) % <span class="number">3</span> == d); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fu = find(e[i].u);</span><br><span class="line">        <span class="keyword">int</span> fv = find(e[i].v);</span><br><span class="line">        <span class="keyword">if</span> (fu != fv) &#123;</span><br><span class="line">            f[fv] = fu;</span><br><span class="line">            ans += e[i].weight;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">//序号，找边权用</span></span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;y) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &lt; y.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;vertex[MAXN] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue &lt;node&gt; q;</span><br><span class="line">    vertex[<span class="number">0</span>].d = <span class="number">0</span>;</span><br><span class="line">    q.push(vertex[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u.id].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> vid = son[u.id][i];</span><br><span class="line">            <span class="keyword">double</span> weight = w[u.id][i];</span><br><span class="line">            <span class="keyword">if</span>(vertex[vid].d &lt; u.d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vertex[vid].d &gt; u.d + weight)&#123;</span><br><span class="line">                vertex[vid].d = u.d + weight;</span><br><span class="line">                q.push(vertex[vid]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j] &gt; <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j])</span><br><span class="line">                    <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="各种tarjan"><a href="#各种tarjan" class="headerlink" title="各种tarjan"></a>各种tarjan</h1><h2 id="有向图强连通分量数"><a href="#有向图强连通分量数" class="headerlink" title="有向图强连通分量数"></a>有向图强连通分量数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfn[u] u的时间戳</span></span><br><span class="line"><span class="comment">//low[u] u或u的子树能够追溯到的最早栈中节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++cnt;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    stack1[++index] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v]) low[u] = min(low[u], dfn[v]); <span class="comment">//u-v is a back edge</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">        scnum ++; <span class="comment">//强连通分量数</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            belong[stack1[index]] = scnum;</span><br><span class="line">            num[scnum] ++;</span><br><span class="line">            vis[stack1[index]] = <span class="literal">false</span>;</span><br><span class="line">            index --;</span><br><span class="line">        &#125;<span class="keyword">while</span>(u != stack1[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">//     if(!dfn[i]) &#123;</span></span><br><span class="line"><span class="comment">//         cnt = 1;</span></span><br><span class="line"><span class="comment">//         tarjan(i);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="无向图割点与割边"><a href="#无向图割点与割边" class="headerlink" title="无向图割点与割边"></a>无向图割点与割边</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">    dfs_clock ++;</span><br><span class="line">    dfn[u] = low[u] = dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v,u);</span><br><span class="line">            child ++;</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>((u == <span class="number">1</span> &amp;&amp; child &gt; <span class="number">1</span>) || (u != <span class="number">1</span> &amp;&amp; dfn[u] &lt;= low[v])) &#123;</span><br><span class="line">                cut.push_back(u); <span class="comment">//割点判定</span></span><br><span class="line">                <span class="comment">//iscut[u] = true;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u]) </span><br><span class="line">                bridge.push_back(&#123;min(u,v), max(u,v)&#125;); <span class="comment">//割边判定</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v != pre)</span><br><span class="line">                low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tarjan(1,-1);</span></span><br></pre></td></tr></table></figure><h2 id="无向图双连通分量"><a href="#无向图双连通分量" class="headerlink" title="无向图双连通分量"></a>无向图双连通分量</h2><p>点（边）双连通分量：若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥），则称作点（边）双连通图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    dfs_clock ++;</span><br><span class="line">    dfn[u] = low[u] = dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v,u);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v != pre) low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计无向图的边双连通分量，在一个双连通分量中当且仅当low[u] == low[v]</span></span><br></pre></td></tr></table></figure><h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">directed_euler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> moreout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> morein = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ver[i].indeg &gt; ver[i].outdeg) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ver[i].indeg == ver[i].outdeg + <span class="number">1</span>) morein ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ver[i].deg &lt; ver[i].outdeg) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ver[i].outdeg == ver[i].indeg + <span class="number">1</span>) moreout++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("morein = %d, moreout = %d", morein, moreout);</span></span><br><span class="line">    <span class="keyword">if</span>(morein &lt;= <span class="number">1</span> &amp;&amp; moreout &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断连通有向图是否含欧拉迹</span></span><br><span class="line"><span class="comment">//至多一顶点出度=入度+1</span></span><br><span class="line"><span class="comment">//至多一顶点入度=出度+1</span></span><br><span class="line"><span class="comment">//其余顶点：入度=出度</span></span><br></pre></td></tr></table></figure><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">undirected_euler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(ver[i].deg % <span class="number">2</span> == <span class="number">1</span>) odd++;</span><br><span class="line">    <span class="keyword">if</span>(odd == <span class="number">0</span> || odd == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈密尔顿回路"><a href="#哈密尔顿回路" class="headerlink" title="哈密尔顿回路"></a>哈密尔顿回路</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hamilton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    path.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size() - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[path[j]][i] &amp;&amp; <span class="built_in">map</span>[i][path[j + <span class="number">1</span>]])&#123;</span><br><span class="line">                path.insert(path.begin() + j + <span class="number">1</span>, i);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[path.back()][i]) path.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> path.insert(path.begin(), i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h1><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">0</span> || find(match[i]))&#123;</span><br><span class="line">                match[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">if</span>(find(i)) ans ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KM：最小权匹配"><a href="#KM：最小权匹配" class="headerlink" title="KM：最小权匹配"></a>KM：最小权匹配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    S[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!T[j] &amp;&amp; ls[i] + lt[j] == <span class="built_in">map</span>[i][j]) &#123;</span><br><span class="line">            T[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!match[j] || find(match[j])) &#123;</span><br><span class="line">                match[j] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> relax_val = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(n,m); ++i)</span><br><span class="line">        <span class="keyword">if</span>(S[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j)</span><br><span class="line">                <span class="keyword">if</span>(!T[j] &amp;&amp; ls[i] + lt[j] &gt; <span class="built_in">map</span>[i][j]) relax_val = min(relax_val, ls[i] + lt[j] - <span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    assert(relax_val &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i]) ls[i] -= relax_val;</span><br><span class="line">        <span class="keyword">if</span> (T[i]) lt[i] += relax_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match, <span class="number">0</span>, <span class="keyword">sizeof</span>(match));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(m,n); ++i) &#123;</span><br><span class="line">        ls[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j) ls[i] = max(<span class="built_in">map</span>[i][j], ls[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) lt[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(n,m); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(S, <span class="number">0</span>, <span class="keyword">sizeof</span>(S));</span><br><span class="line">            <span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T));</span><br><span class="line">            <span class="keyword">if</span> (find(i)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> relax();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="Dinic-当前弧优化"><a href="#Dinic-当前弧优化" class="headerlink" title="Dinic+当前弧优化"></a>Dinic+当前弧优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0</span> , <span class="keyword">sizeof</span>(depth));</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    depth[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[u][v] &gt; <span class="number">0</span> &amp;&amp; !depth[v]) &#123;</span><br><span class="line">                depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth[t] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 寻找当前增广路径上的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> dist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i = cur[u]; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(depth[v] == depth[u] + <span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[u][v] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> minc = dfs(v, min(dist, <span class="built_in">map</span>[u][v]));</span><br><span class="line">            <span class="keyword">if</span>(minc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">map</span>[u][v] -= minc;</span><br><span class="line">                <span class="built_in">map</span>[v][u] += minc;</span><br><span class="line">                <span class="keyword">return</span> minc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span> , <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">int</span> minc = dfs(s, INF)) &#123;</span><br><span class="line">            ans += minc;</span><br><span class="line">            <span class="comment">//printf("minc=%d\n",minc);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2row</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) swap(a[x][i], a[y][i]);</span><br><span class="line">    <span class="comment">//printf("**swap row %d with row %d**\n",x,y);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot_one</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> temp = a[x][y];</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i &lt;= n + <span class="number">1</span>; ++i) a[x][i] /= temp;</span><br><span class="line">    <span class="comment">//printf("**pivot one at row %d**\n", x);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul_and_add</span><span class="params">(<span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">double</span> cof)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        a[dst][i] -= a[src][i] * cof;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("**mul row %d with %lf add to row %d**\n", src, cof, dst);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_matrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">printf</span>(<span class="string">"%lf "</span>, a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"| %lf\n"</span>, a[i][n + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">iszero</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(a[row][i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Guass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">1</span>, col = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(row &lt;= n &amp;&amp; col &lt;= n) &#123;</span><br><span class="line">        <span class="comment">//printf("Now row=%d, col=%d\n",row, col);</span></span><br><span class="line">        <span class="keyword">if</span>(a[row][col] == <span class="number">0.0</span>) &#123;</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = row + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                <span class="keyword">if</span>(a[i][col] != <span class="number">0</span>) &#123;</span><br><span class="line">                    swap2row(row, i);</span><br><span class="line">                    ok = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(ok == <span class="literal">false</span>) &#123;col++; <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="comment">//else print_matrix();</span></span><br><span class="line">        &#125;</span><br><span class="line">        pivot_one(row,col);</span><br><span class="line">        <span class="keyword">if</span>(col == n &amp;&amp; row == n &amp;&amp; a[row][col] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//print_matrix();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(i != row &amp;&amp; a[i][col] != <span class="number">0</span>) &#123;</span><br><span class="line">                assert(a[row][col] != <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">double</span> cof = a[i][col] / a[row][col];</span><br><span class="line">                <span class="keyword">if</span>(cof != <span class="number">0</span>) mul_and_add(row, i, cof);</span><br><span class="line">                assert(a[i][col] == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//print_matrix();</span></span><br><span class="line">        row ++; col ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性规划-–-simplex单纯形算法"><a href="#线性规划-–-simplex单纯形算法" class="headerlink" title="线性规划 – simplex单纯形算法"></a>线性规划 – simplex单纯形算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; -EPS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; EPS ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    swap(id[n + r], id[c]);</span><br><span class="line">    <span class="keyword">double</span> x = -a[r][c];</span><br><span class="line">    a[r][c] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) a[r][i] /= x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sgn(a[i][c]) &amp;&amp; i != r) &#123;</span><br><span class="line">            x = a[i][c];</span><br><span class="line">            a[i][c] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) a[i][j] += x * a[r][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* important: revert symbols of conditions */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            a[i][j] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = i;</span><br><span class="line">    <span class="comment">/* initial-simplex */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[i][<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123; x = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[x][i]) &gt; <span class="number">0</span>) &#123; y = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!y) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// infeasible</span></span><br><span class="line">        pivot(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* solve-simplex */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[<span class="number">0</span>][i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        printf("choose x%d, cof=%d\n", x, a[0][x]);</span></span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">break</span>; <span class="comment">// finished</span></span><br><span class="line">        <span class="keyword">double</span> w = <span class="number">0</span>, t = <span class="number">0</span>; <span class="comment">//t是最苛刻的非基本变量能取到的最大值</span></span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[i][x]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                t = ((<span class="keyword">double</span>)-a[i][<span class="number">0</span>]) / ((<span class="keyword">double</span>)a[i][x]);</span><br><span class="line"><span class="comment">//                if(x==3) printf("t: -%d / %d = %.lf\n", a[i][0], a[i][x], t);</span></span><br><span class="line">                <span class="keyword">if</span> (f || t &lt; w) &#123;</span><br><span class="line">                    w = t, y = i, f = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="comment">// unbounded</span></span><br><span class="line">        pivot(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) v[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; ++i) v[id[i]] = a[i - n][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">  kmp[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len2; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s2[i] != s2[j + <span class="number">1</span>]) j = kmp[j];</span><br><span class="line">    <span class="keyword">if</span>(s2[j + <span class="number">1</span>] == s2[i]) j ++;</span><br><span class="line">    kmp[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s1[i] != s2[j + <span class="number">1</span>]) j = kmp[j];</span><br><span class="line">    <span class="keyword">if</span>(s1[i] == s2[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    <span class="keyword">if</span>(j == len2 - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - len2 + <span class="number">2</span>);</span><br><span class="line">      j = kmp[j];</span><br><span class="line">      ok = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="comment">/*字典树*/</span></span><br><span class="line">    <span class="keyword">int</span> tot, root;</span><br><span class="line">    <span class="keyword">int</span> nxt[MAXN][<span class="number">26</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">      tot = <span class="number">1</span>;</span><br><span class="line">      root = newNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">memset</span>(nxt[tot], <span class="number">0</span> ,<span class="keyword">sizeof</span>(nxt[tot]));</span><br><span class="line">      <span class="keyword">return</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> cur = root;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(nxt[cur][id] == <span class="number">0</span>) nxt[cur][id] = newNode();</span><br><span class="line">        cur = nxt[cur][id];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">          <span class="keyword">if</span>(nxt[i][j] != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"S.nxt[%d][%c]=%d\n"</span>,i, j+<span class="string">'a'</span>, nxt[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;S;</span><br></pre></td></tr></table></figure><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n, ll mod)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*快速幂*/</span></span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  a %= mod;</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = (ans * a) % mod;</span><br><span class="line">    a = (a * a) % mod;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;状态压缩dp&quot;&gt;&lt;a href=&quot;#状态压缩dp&quot; class=&quot;headerlink&quot; title=&quot;状态压缩d
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>os期中复习</title>
    <link href="https://mengzelev.github.io/2019/04/15/os-midterm/"/>
    <id>https://mengzelev.github.io/2019/04/15/os-midterm/</id>
    <published>2019-04-15T14:17:55.000Z</published>
    <updated>2019-06-22T15:58:43.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用眼中的OS"><a href="#应用眼中的OS" class="headerlink" title="应用眼中的OS"></a>应用眼中的OS</h1><ul><li>操作系统一方面需要提供程序的<strong>执行的环境</strong>和<strong>相应的资源</strong>，还要提供<strong>和操作系统世界中其他对象交互的方法和约定</strong></li></ul><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="共享内存多线程"><a href="#共享内存多线程" class="headerlink" title="共享内存多线程"></a>共享内存多线程</h2><ul><li>并发定义：一个程序、算法或问题的不同部分乱序或偏序执行而不影响最终结果的能力</li><li><p>程序经历了什么？</p><ul><li>编译器优化$\to$顺序丧失</li><li>操作系统中断，多处理器、缓存(硬件)$\to$原子性(all or nothing)丧失</li><li>缓存，乱序（硬件）$\to$可见性丧失</li></ul></li><li><p>顺序丧失：允许源代码中内存访问指令不再按顺序甚至不再出现</p></li><li>原子性的丧失：指令序列可以在任意时刻被中断，然后操作系统切换到其他线程执行</li><li>可见性丧失：缓存&amp;乱序</li></ul><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>评估一把锁的基本准则</p><ul><li>能够完成基本任务：提供互斥性质</li><li>锁的分配是公平的：不会有现成想要上锁却永远得不到它</li><li>锁的高效的：无等待时性能？多线程同时等待时性能？多CPU每个核的线程都要上锁时性能？</li></ul><p>自旋锁的正确性证明：</p><ul><li>建模程序的状态</li><li>证明safety(只有一个线程进入临界区)和liveness(至少有一个线程能进入临界区)</li></ul><h3 id="几种上锁方法"><a href="#几种上锁方法" class="headerlink" title="几种上锁方法"></a>几种上锁方法</h3><ul><li>TestAndSet；相当于<code>atomic_xchg</code></li><li>CompareAndWait</li><li>LL&amp;SC</li><li>FetchAndAdd：彩票锁，保证公平性</li></ul><h2 id="同步-CV"><a href="#同步-CV" class="headerlink" title="同步(CV)"></a>同步(CV)</h2><ul><li><code>wait(&amp;cond)</code>：当前进程进入睡眠状态，等待cond被满足后唤醒</li><li><code>signal(&amp;cond)</code>：唤醒在等待cond条件的某个进程</li><li><code>broadcast(&amp;cond)</code>: 唤醒在等待cond条件的所有进程</li><li>需要配合互斥锁使用：读取状态到<code>wait()</code>之间不能被打断，改变状态到<code>signal</code>之间也不能被打断</li></ul><h3 id="使用条件变量"><a href="#使用条件变量" class="headerlink" title="使用条件变量"></a>使用条件变量</h3><p>记 得 上 锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line">    done[id] = <span class="number">1</span>;</span><br><span class="line">    signal(&amp;joins);</span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nworkers; ++i) create(worker,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nworkers; ++i) &#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(!done[i]) wait(&amp;joins, &amp;mutex);</span><br><span class="line">        mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>互斥锁(二元信号量)和同步都可以使用信号量来实现<br>信号量就相当于有一个管理员manage了一堆资源，进程需要资源时先向管理员请求(<code>semi_wait</code>)，暂时没有资源就等，使用完毕后归还(<code>semi_post</code>)给管理员</p><p>需要配合锁使用<br>注意死锁：lock之后P，其他线程是无法获得lock的</p><p>期中考题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'('</span>: lock(<span class="string">"("</span>); <span class="comment">// assume lock can nest</span></span><br><span class="line">     <span class="built_in">putchar</span>(); V(fill1);</span><br><span class="line"><span class="string">')'</span>: P(fill1); <span class="built_in">putchar</span>();</span><br><span class="line">     unlock(<span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">'['</span>: lock(<span class="string">"("</span>);</span><br><span class="line">     <span class="built_in">putchar</span>();</span><br><span class="line">     V(fill2);</span><br><span class="line">     unlock(<span class="string">"("</span>);</span><br><span class="line"><span class="string">']'</span>: P(fill2);</span><br><span class="line">     lock(<span class="string">"("</span>);</span><br><span class="line">     <span class="built_in">putchar</span>();</span><br><span class="line">     unlock(<span class="string">"("</span>);</span><br></pre></td></tr></table></figure><ul><li>不能上一把大锁（会死锁），所以拆了小锁来保证原子性</li><li>P不能在锁中间进行</li><li>自旋锁是为了保证圆括号和方括号不冲突（互斥），信号量是为了保证左右括号配对（同步）</li><li>之所以用锁而非信号量来处理圆括号和方括号的关系，是因为为了保证原子性本来就要上锁，这样一举两得。用信号量不是不可以，但一样也要上锁，造成了资源浪费。</li></ul><h3 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h3><ul><li><code>sem_wait</code>：信号量-1，表示在等待的线程增加了一个，消耗一个执行名额；如果信号量&lt;0, 表示等待的线程数多于可执行线程数，当前线程进入睡眠</li><li><code>sem_post</code>：信号量+1，表示执行的线程少了一个，可以让出一个执行名额</li></ul><h3 id="哲学家吃饭问题"><a href="#哲学家吃饭问题" class="headerlink" title="哲学家吃饭问题"></a>哲学家吃饭问题</h3><p>One general solution: 让一个人集中管理所有叉子(信号量)</p><h2 id="并发Bugs"><a href="#并发Bugs" class="headerlink" title="并发Bugs"></a>并发Bugs</h2><ul><li>原子性违反(AV) –&gt; 上锁</li><li>顺序违反(OV) –&gt; 同步</li></ul><h3 id="死锁出现的四个条件"><a href="#死锁出现的四个条件" class="headerlink" title="死锁出现的四个条件"></a>死锁出现的四个条件</h3><ul><li>互斥</li><li>请求与保持(同一个进程要同时上多把锁)</li><li>没有抢占(不能强制解锁)</li><li>循环等待</li></ul><h3 id="对付死锁"><a href="#对付死锁" class="headerlink" title="对付死锁"></a>对付死锁</h3><ul><li>避免：规定上锁顺序</li><li>检测：打log</li></ul><h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><p>每个进程都以为自己独占CPU和整个内存空间<br>进程：OS提供的对运行程序的抽象</p><h2 id="进程抽象"><a href="#进程抽象" class="headerlink" title="进程抽象"></a>进程抽象</h2><p>CPU执行指令时假设自己直接占有整个CPU<br>进程分时共享物理CPU</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>Running: 进程正在处理器上执行命令</li><li>Ready：进程准备执行，但由于某些原因OS决定现在不让它运行</li><li>Blocked：进程此前执行了某些操作(e.g. I/O)，让它在其他事件发生前停止执行</li></ul><h3 id="实现进程"><a href="#实现进程" class="headerlink" title="实现进程"></a>实现进程</h3><ul><li>进程=线程+地址空间</li><li>进程就是个结构体<ul><li>名字</li><li>pid</li><li>上下文</li><li>地址空间</li><li>堆栈</li><li>状态</li><li>其他信息（如父进程、文件描述符等）</li></ul></li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul><li>fork</li><li>execve</li><li>exit<ul><li><code>exit()</code>是库函数，<code>_exit()</code>是系统调用</li></ul></li></ul><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>一个指向os内对象的指针<br><code>fork-exec</code>不改变文件描述符<br><code>int dup2(int oldfd, int newfd);</code> - 关闭<code>newfd</code>，并复制<code>oldfd</code>到<code>newfd</code>(<code>dup+close</code>的并发版)</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">assert(pid != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(...);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    close(fd);</span><br><span class="line">    execve(...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pipe(fds) != <span class="number">0</span>) &#123;panic(<span class="string">"pipe error"</span>);&#125;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;<span class="comment">//child</span></span><br><span class="line">    dup2(fds[<span class="number">1</span>], STUOUT_FILENO); <span class="comment">//连接写口，往管道内写数据</span></span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; <span class="comment">//parent</span></span><br><span class="line">    dup2(fds[<span class="number">0</span>], STDIN_FILENO); <span class="comment">//连接读口，从管道内读数据</span></span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>进程组实现</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h3><ul><li>轮转时间(turnaround time): $\sum t_{complete}-t_{arrival}$</li><li>响应时间(response time): $\sum t_{firstrun}-t_{arrival}$</li></ul><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><ul><li>优点：简单易实现</li><li>缺点： 会产生护航效应（有一个<s>不要脸的</s>任务占坑很久）</li></ul><h3 id="SJF-Shortest-Job-First"><a href="#SJF-Shortest-Job-First" class="headerlink" title="SJF(Shortest Job First)"></a>SJF(Shortest Job First)</h3><ul><li>当假设所有任务同时到达时的最优算法</li><li>非抢占式(preemptive)算法</li></ul><h3 id="STCF-Shortest-Time-to-Completion-First"><a href="#STCF-Shortest-Time-to-Completion-First" class="headerlink" title="STCF(Shortest Time-to-Completion First)"></a>STCF(Shortest Time-to-Completion First)</h3><ul><li>抢占式策略，又名Preemptive Shortest Job First(PSJF)</li><li>轮转时间短但响应时间长</li></ul><h3 id="RR-Round-Robin"><a href="#RR-Round-Robin" class="headerlink" title="RR(Round Robin)"></a>RR(Round Robin)</h3><ul><li>每个进程运行一段时间片(time slice, sometimes called scheduling quantum)</li><li>时间片越短，响应时间越短，但是切换上下文的时间会变长(trade-off)</li><li>当考虑轮转时间时非常糟糕</li><li>保证了公平性但是损失了效率</li></ul><h3 id="MLFQ-Multi-level-Feedback-Queue"><a href="#MLFQ-Multi-level-Feedback-Queue" class="headerlink" title="MLFQ(Multi-level Feedback Queue)"></a>MLFQ(Multi-level Feedback Queue)</h3><p>MLFQ有很多种实现但都大同小异，书上只介绍一种</p><ul><li>有很多队列，每个队列具有不同的优先级，优先级高的先运行</li><li>通过观察进程过去的行为调整优先级<ul><li>如果一个进程频繁让出CPU，保持高优先级；反之一个进程如果长时间占用CPU则会被降低优先级</li></ul></li><li>并不知道一个任务是长是短，因此先假设是短的，然后根据进程的后续表现修改认知</li></ul><h4 id="优先级的修改"><a href="#优先级的修改" class="headerlink" title="优先级的修改"></a>优先级的修改</h4><p>workload: 交互式短时间任务(会频繁让出CPU)+不交互的长时间任务(响应时间不那么重要)</p><h4 id="Basic-Rules"><a href="#Basic-Rules" class="headerlink" title="Basic Rules"></a>Basic Rules</h4><ol><li>If Priority(A)&gt;Priority(B), A runs (B doesn’t)</li><li>If Priority(B)==Priority(B), A &amp; B runs in RR</li><li>一个任务最初进入系统时位于最高优先级<br>4(a). 如果一个任务耗尽了时间片，则优先级下降<br>4(b). 如果一个任务在时间片耗尽之前放弃了CPU,优先级不变<br>4(改进). 当一个任务在一定程度上用尽了被分配到的时间，优先级就下降<br>5(新增). 在一段时间$S$后，将所有任务移到最高优先级上(Priority-boost) </li></ol><p>缺陷： </p><ul><li>饥饿：如果交互式进程很多就会完全占用CPU使得长任务得不到调度(5解决)</li><li>有些心脏的应用可以玩弄这个规则，一直主动让出一小会儿CPU来使自己停留在高优先级上(4解决)</li><li>任务的行为可能会随着时间改变(5解决)</li></ul><h3 id="PS-Proportional-share"><a href="#PS-Proportional-share" class="headerlink" title="PS(Proportional-share)"></a>PS(Proportional-share)</h3><ul><li>老子才不管什么的轮转时间和响应时间，老子只要每个任务都能按比例分到一定时间</li></ul><h4 id="lottery-scheduling"><a href="#lottery-scheduling" class="headerlink" title="lottery scheduling"></a>lottery scheduling</h4><blockquote><p>随机的好处</p><ul><li>防止了边界情况</li><li>轻量级，需要记录的信息少</li><li>快(太快了可能会变成伪随机数)</li></ul></blockquote><p>怎么分配彩票也是个很棘手的问题</p><h4 id="stride-scheduling"><a href="#stride-scheduling" class="headerlink" title="stride scheduling"></a>stride scheduling</h4><ul><li>根据每个任务的彩票数决定每次调度执行的时间长短</li><li>每次调度都选取运行时间最短的任务</li></ul><h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><p>不想看了【瘫</p><h2 id="链接和加载"><a href="#链接和加载" class="headerlink" title="链接和加载"></a>链接和加载</h2><ul><li>静态链接下的加载：<code>_start(程序自己的)-&gt;__libc_start_main-&gt;generic_start_main-&gt;...-&gt;main</code></li><li>动态链接：<ul><li>PLT：程序链接表，放入进行链接的代码，方便lazy linking(名字叫表格其实就是一小段代码，用来判断是否已经完成链接)</li><li>GOT：全局偏移表，存放函数代码开始的地址</li></ul></li></ul><h3 id="第一条指令"><a href="#第一条指令" class="headerlink" title="第一条指令"></a>第一条指令</h3><ul><li>静态链接：<code>a.out</code>的entry</li><li>动态链接：<code>ld.so</code>的entry</li><li>动态链接libc：链接器使用一系列mmap把libc链接进进程地址空间</li></ul><h2 id="虚存抽象"><a href="#虚存抽象" class="headerlink" title="虚存抽象"></a>虚存抽象</h2><p>多级页表(PML): 复习ICS<br>反置页表(IPT): 硬件维护一个全局的hash table，计算$f(as,x)$<br>IPT实现Copy-on-Write有困难，且PML能高效地标记一段连续内存为某个权限</p><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>把操作系统里的对象映射到进程的地址空间</p><ul><li>e.g.加载可执行文件的时候把文件搬到某个地址处</li><li>不映射任何文件的时候就相当于malloc</li><li>只记录相关信息，余下的等发生缺页时再处理，所以非常快</li><li>可以用红黑树维护分配的内存</li><li>fork采用写时复制</li></ul><h3 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h3><p><code>pmap</code>-查看进程的地址空间</p><p>静态链接的程序的地址空间：代码、数据、bss、堆、栈、用户态系统调用<br>动态链接：多了动态链接库和链接器</p><h1 id="期中复习"><a href="#期中复习" class="headerlink" title="期中复习"></a>期中复习</h1><p>系统调用：操作系统为用户进程提供的一组API，通常在内核空间中实现，实现用户进程对操作系统对象/物理硬件访问的请求。<br>进程=操作系统中的数据<br>系统调用=这些数据上的操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;应用眼中的OS&quot;&gt;&lt;a href=&quot;#应用眼中的OS&quot; class=&quot;headerlink&quot; title=&quot;应用眼中的OS&quot;&gt;&lt;/a&gt;应用眼中的OS&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;操作系统一方面需要提供程序的&lt;strong&gt;执行的环境&lt;/strong&gt;和&lt;strong
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>问题求解学习笔记-密码算法</title>
    <link href="https://mengzelev.github.io/2019/04/13/ps-4-7-cryptographic-algorithm/"/>
    <id>https://mengzelev.github.io/2019/04/13/ps-4-7-cryptographic-algorithm/</id>
    <published>2019-04-13T04:04:44.000Z</published>
    <updated>2019-06-19T02:47:13.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RSA公钥加密系统"><a href="#RSA公钥加密系统" class="headerlink" title="RSA公钥加密系统"></a>RSA公钥加密系统</h1><p>每个参与者都有一把公钥($P$)和密钥($S$)</p><p>$\mathcal{D}$表示允许信息的集合，要求公钥与密钥指定一种从$\mathcal{D}$到自身的一一对应的函数。<br>Alice的公钥函数$P_A$和密钥函数$S_A$都是$\mathcal{D}$的排列</p><p>系统中任何参与者的公钥与密钥都是匹配对，指定函数互为反函数，对任何消息$M\in \mathcal{D}$，有<br>$$M=S_A(P_A(M))$$<br>$$M=P_A(S_A(M))$$</p><h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><ul><li>Bob取得Alice的公钥$P_A$</li><li>Bob计算出相应与$M$的密文$C=P_A(M)$，并把$C$发送给Alice</li><li>当Alice收到密文$C$后，运用自己的密钥$S_A$恢复原始信息$M$</li></ul><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul><li>Alice运用密钥$S_A$和等式$\sigma=S_A)M’$计算出信息$M’$的数字签名$\sigma$</li><li>Alice把消息/签名对$(M’,\sigma)$发给Bob</li><li>Bob收到$(M’,\sigma)$时，通过验证等式$M’=P_A(\sigma)$来证实消息的确是来自Alice</li></ul><p>任何人都可以把数字签名翻译出来，但只有密钥持有者可以生成数字签名</p><h2 id="RSA加密系统"><a href="#RSA加密系统" class="headerlink" title="RSA加密系统"></a>RSA加密系统</h2><p><img src="/2019/04/13/ps-4-7-cryptographic-algorithm/rsa.png"></p><p>加密<br>$$P(M)=M^e\bmod n$$<br>解密<br>$$S(C)=C^d\bmod n$$</p><p>上述加密解密操作可以使用快速幂实现。</p><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>假定：</p><ul><li>公钥$(e,n)$和密钥$(d,n)$满足$\lg~e=O(1), \lg~d\le\beta, \lg~n\le\beta$</li><li>应用公钥需要执行$O(1)$次模乘法运算和$O(\beta^2)$次位操作</li><li>应用密钥需要执行$O(\beta)$次模乘法运算和$O(\beta^2)$次位操作。</li></ul><h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p><strong>定理31.36(RSA的正确性)</strong>：RSA加密和解密等式定义了满足再上面两个等式的$\mathbb{Z}_n$的逆变换</p><p>RSA加密系统的安全性主要来源于对大整数进行因子分解的困难性</p><h3 id="效率提高"><a href="#效率提高" class="headerlink" title="效率提高"></a>效率提高</h3><ul><li>无公钥加密系统</li><li>抗冲突散列函数$h$</li><li>证书</li></ul><h1 id="整数的因子分解"><a href="#整数的因子分解" class="headerlink" title="整数的因子分解"></a>整数的因子分解</h1><h3 id="Pollard的rho启发式方法"><a href="#Pollard的rho启发式方法" class="headerlink" title="Pollard的rho启发式方法"></a>Pollard的rho启发式方法</h3><p><img src="/2019/04/13/ps-4-7-cryptographic-algorithm/pr.png"></p><ul><li>通过随机数寻找$n$的非平凡约数</li><li>可能会出现”$\rho$”字型回路，在出现回路之前预计要执行的步数为$\Theta(\sqrt{n})$</li><li>一种找出大整数的小素数因子的可供选择的办法</li></ul><h2 id="私钥密码学"><a href="#私钥密码学" class="headerlink" title="私钥密码学"></a>私钥密码学</h2><p>仿射密码系统(affine cryptosystem)：$f(p)=ap+b\bmod 26$, $f^{-1}(p)=a^{-1}p-a^{-1}b\bmod 26$</p><p>多字码密码系统(polyalphabetic cryptosystem): $f(\textbf{p})=A\textbf{p}+b$,其中$A$是矩阵，$b$是列向量，$f^{-1}(\textbf{p})=A^{-1}\textbf{p}-A^{-1}\textbf{p}$</p><h2 id="公钥密码学"><a href="#公钥密码学" class="headerlink" title="公钥密码学"></a>公钥密码学</h2><p>RSA加密系统（CLRS上已讲</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RSA公钥加密系统&quot;&gt;&lt;a href=&quot;#RSA公钥加密系统&quot; class=&quot;headerlink&quot; title=&quot;RSA公钥加密系统&quot;&gt;&lt;/a&gt;RSA公钥加密系统&lt;/h1&gt;&lt;p&gt;每个参与者都有一把公钥($P$)和密钥($S$)&lt;/p&gt;
&lt;p&gt;$\mathcal{
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-数论算法</title>
    <link href="https://mengzelev.github.io/2019/04/06/clrs-31Number-Theoretic-Algorithms/"/>
    <id>https://mengzelev.github.io/2019/04/06/clrs-31Number-Theoretic-Algorithms/</id>
    <published>2019-04-06T03:18:48.000Z</published>
    <updated>2019-06-18T09:43:32.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输入规模和算数计算的代价"><a href="#输入规模和算数计算的代价" class="headerlink" title="输入规模和算数计算的代价"></a>输入规模和算数计算的代价</h1><p>给定$k$个整数输入$a_1,a_2,\cdots ,a_k$，如果算法可以在关于$\lg~a_1,\lg~a_2,\cdots ,\lg~a_k$的多项式时间内完成，即算法在<strong>关于二进制编码后的输入长度</strong>的多项式时间内完成，则称该算法为<strong>多项式时间</strong>算法</p><p>当输入很大时，基本运算也会变得耗时。<br>两个$\beta$位整数相乘需要耗时$\Theta(\beta^2)$.<br>一个$\beta$为整数除以另一个较短整数的商或余数需要耗时$\Theta(\beta^2)$</p><h1 id="基础数论概念"><a href="#基础数论概念" class="headerlink" title="基础数论概念"></a>基础数论概念</h1><h2 id="整除性与约数"><a href="#整除性与约数" class="headerlink" title="整除性与约数"></a>整除性与约数</h2><p>你懂的</p><h2 id="素数与合数"><a href="#素数与合数" class="headerlink" title="素数与合数"></a>素数与合数</h2><p>你也懂的</p><h2 id="除法定理、余数和等模"><a href="#除法定理、余数和等模" class="headerlink" title="除法定理、余数和等模"></a>除法定理、余数和等模</h2><p><strong>定理31.1(除法定理)</strong>: 对于任何整数$a$和任何正整数$n$，存在唯一整数$q$和$r$，满足$0\le r&lt;n$且$a=qn+r$</p><p>根据整数模$n$的余数，可以将所有整数划分成$n$个等价类。<br>包含整数$a$的模$n$等价类为$\left[a\right]_n={a+kn:k\in\mathbb{Z}}$<br>所有这类等价类的集合是$\mathbb{Z}_n={[a]_n:0\le a\le n-1}$</p><h2 id="公约数与最大公约数"><a href="#公约数与最大公约数" class="headerlink" title="公约数与最大公约数"></a>公约数与最大公约数</h2><p>公约数的重要性质：</p><ul><li>$d\mid a$且$d\mid b$蕴含$d\mid (a+b)$且$d\mid (a-b)$</li><li>对任意整数$x$和$y$，都有$d\mid a$且$d\mid b$蕴含$d\mid(ax+by)$</li><li>$a\mid b$且$b\mid a$蕴含$a=\pm b$</li></ul><p><strong>定理31.2</strong>: 如果任意整数$a$和$b$不都为0，则gcd$(a,b)$是$a$与$b$线性组合集${ax+by:x,y\in\mathbb{Z}}$中的<strong>最小正元素</strong>。(最小正线性组合)</p><p><strong>推论31.3</strong>: 对任意整数$a$与$b$，如果$d\mid a$且$d\min b$，则$d\mid gcd(a,b)$</p><p><strong>推论31.4</strong>: 对所有整数$a$和$b$以及任意非负整数$n$，有$gcd(an,bn)=n~gcd(a,b)$</p><p><strong>推论31.5</strong>: 对于任意正整数$n,a$和$b$，如果$n\mid ab$且$gcd(a,n)=1$,则$n\mid b$.</p><h2 id="互质数"><a href="#互质数" class="headerlink" title="互质数"></a>互质数</h2><p><strong>定理31.6</strong>: 对任意整数$a,b$与$p$,如果$gcd(a,p)=1$且$gcd(b,p)=1$，则$gcd(ab,p)=1$.</p><h2 id="唯一因子分解定理"><a href="#唯一因子分解定理" class="headerlink" title="唯一因子分解定理"></a>唯一因子分解定理</h2><p><strong>定理31.7</strong>: 对所有素数$p$和所有整数$a,b$，如果$p\mid ab$,则$p\mid a$或$p\mid b$(或两者都成立)。</p><p><strong>定理31.8(唯一因子分解定理)</strong>: 合数$a$仅能以一种方式写成如下乘积形式<br>$$a=p_1^{e_1}p_2^{e_2}\cdots p_r^{e_r}$$<br>其中$p_i$为素数，$p_1&lt;p_2&lt;\cdots p_r$且$e_i$为正整数</p><h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><p><strong>定理31.9(GCD递归定理)</strong>: 对任意非负整数$a$和任意正整数$b$，$gcd(a,b)=gcd(b,a\bmod b)$</p><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p><strong>引理31.10</strong>: 如果$a&gt;b\ge 1$并且EUCLID($a,b$)执行了$k\ge 1$次递归调用，则$a\ge F_{k+2}， b\ge F_{k+1}$.($F_n$为斐波那契数列的第$n$项)</p><p><strong>定理31.11(Lame定理)</strong>: 对任意整数$k\ge 1$,如果$a&gt;b\ge 1$,且$b&lt;F_{k+1}$,则EUCLID($a,b$)的递归调用次数少于$k$次<br>该上界是最优的，因为$k\ge 2$时，EUCLID$(F_{k+1},F_k)$正好调用了$k$次</p><p>$F_k$约为$\phi^k/\sqrt{5}$, $\phi=(1+\sqrt{5})/2$<br>EUCLID执行中递归调用的次数为$O(\lg b)$<br>如果EUCLID作用于两个$\beta$位数，则将执行$O(\beta)$次算术运算和$O(\beta^3)$次位操作</p><h3 id="扩展形式"><a href="#扩展形式" class="headerlink" title="扩展形式"></a>扩展形式</h3><p>用于计算满足下列条件的整系数$x$和$y$(可能为0或负数):<br>$$d=gcd(a,b)=ax+by$$</p><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/exEUCLID.png"></p><p>运行时间与EUCLID相同</p><h1 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h1><p>群论复习</p><h2 id="模-n-加法群"><a href="#模-n-加法群" class="headerlink" title="模$n$加法群"></a>模$n$加法群</h2><p>你懂的</p><h2 id="模-n-乘法群"><a href="#模-n-乘法群" class="headerlink" title="模$n$乘法群"></a>模$n$乘法群</h2><p>$$(\mathbb{Z}_n^*, \cdot_n)$$</p><p>$$\mathbb{Z}_n^*={[a]_n\in\mathbb{Z}_n: gcd(a,n)=1}$$</p><p><strong>定理31.13</strong>: 模$n$乘法群是有限交换群</p><p>$\mathbb{Z}_n^*$中的除法由等式$a/b\equiv ab^{-1}\pmod n$定义</p><p>$\mathbb{Z}<em>n^*$的规模表示为欧拉phi函数($\phi(n)$)<br>$$\phi(n)=n\prod\limits</em>{p:\text{p is prime and }p\mid n}(1-\frac{1}{p})$$<br>直观理解(类似筛法求质数思想)：开始有一张$n$个余数组成的表，然后对于每个能整除$n$的素数$p$,在表中划掉所有$p$的倍数。</p><ul><li>若$p$是素数，则$\phi(p)=p-1$</li><li>若$n$是合数，$$\frac{n}{e^\gamma\ln\ln n+\frac{3}{\ln\ln n}}&lt;\phi(n)&lt;n-1$$($n\ge 3$, $\gamma=0.5772156649\cdots$是欧拉常数)<ul><li>$n&gt;5$时有个更松弛的下界$$\phi(n)&gt;\frac{n}{6\ln\ln n}$$</li></ul></li></ul><h2 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h2><p><strong>定理31.14</strong>: 一个有限群的非空封闭子集是一个子群</p><p><strong>定理31.15(拉格朗日定理)</strong>: 如果$(S,+)$是一个有限群，$(S’,+)$是$(S,+)$的一个子群，则$|S’|$是$|S|$的一个约数</p><p><strong>推论31.16</strong>: 如果$S’$是$S$的有限子群，则$|S’|\le |S|/2$</p><h2 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h2><p><strong>定理31.17</strong>: 对任意有限群$(S,+)$和任意$a\in S$, 一个元素的阶等于它所生成的循环子群的规模，即$ord(a)=|\langle a\rangle|$</p><p>$a^{(0)}=e, a^{(i)}=a^{(i\bmod t)}(t=\bmod a)$</p><p><strong>推论31.18</strong>: 序列$a^{(1)},a^{(2)},\cdots$是周期序列，其周期为$t=\bmod a$, 即$a^{(i)}=a^{(j)}$当且仅当$i\equiv j\pmod t$</p><p><strong>推论31.19</strong>: 如果$(S,+)$是具有单位元$e$的有限群，则对所有$a\in S$，$a^{(|S|)}=e$</p><h1 id="求解模线性方程"><a href="#求解模线性方程" class="headerlink" title="求解模线性方程"></a>求解模线性方程</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>$$ax\equiv b\pmod n$$<br>假设已知$a,b$和$n$，求出所有满足上述方程的对模$n$的$x$的值<br>该方程可能无解、仅有一解或有多解</p><h2 id="数学准备"><a href="#数学准备" class="headerlink" title="数学准备"></a>数学准备</h2><p><strong>定理31.20</strong>: 对任意正整数$a$和$n$，如果$d=gcd(a,n)$, 则在$\mathbb{Z}_n^*$中，$$\langle a\rangle=\langle d\rangle={0,d,2d,\cdots,((n/d)-1)d}$$<br>因此，$|\langle a\rangle|=n/d$.</p><p><strong>推论31.21</strong>: 当且仅当$d\mid b$时，方程$ax\equiv b\pmod n$对于未知量$x$有解。这里$d=gcd(a,n)$.<br>i.e. 当且仅当$[b]\in\langle a\rangle$时，方程有解</p><p><strong>推论31.22</strong>: 方程$ax\equiv b\pmod n$或者对模$n$有$d$个不同的解，或者无解。这里$d=gcd(a,d)$.</p><p><strong>定理31.23</strong>: 令$d=gcd(a,n)$, 假设对某些整数$x’$和$y’$,有$d=ax’+ny’$(例如EXTENDED-EUCLID所计算出的结果)。如果$d\mid b$,则方程$ax\equiv b\pmod n$有一个解的值为$x_0$,这里$x_0=x’(b/d)\pmod n$.</p><p><strong>定理31.24</strong>: 假设方程$ax\equiv b\pmod b$有解(即$d\mid b$),且$x_0$是该方程的任意一个解。因此，该方程对模$n$恰好有$d$个不同的解，分别为$x_i=x_0+i(n/d)$, 这里$i=0,1,\cdots,d-1$.</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/mod.png"></p><h2 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h2><p>执行$O(\lg n+gcd(a,n))$次算术运算</p><p><strong>推论31.25</strong>： 对任意$n&gt;1$, $a$和$n$互质时方程对模$n$有唯一解</p><p><strong>推论31.26</strong>： 对任意$n&gt;1$，若$a,n$互质，则方程$ax\equiv 1\pmod n$对模$n$有唯一解，否则方程无解。<br>因此，当$a$和$n$互质时，可以用记号$a^{-1}\bmod n$表示$a$对模$n$的乘法逆元</p><h1 id="中国余数定理"><a href="#中国余数定理" class="headerlink" title="中国余数定理"></a>中国余数定理</h1><p><strong>定理31.27(中国余数定理)</strong>: 令$n=n_1n_2\cdots n_k$,其中因子$n_i$两两互质。考虑以下对应关系:$$a\leftrightarrow(a_1,a_2,\cdots,a_k)$$这里$a\in\mathbb{Z}_n,a_i\in\mathbb{Z}_{n_i}$, 而且对$i=1,2,\cdots,k$, $$a_i=a\bmod n_i$$.</p><p>该映射是一个在$\mathbb{Z}<em>n$ 与笛卡尔积 $\mathbb{Z}</em>{n_1}\times\mathbb{Z}_{n_2}\times\cdots\times\mathbb{Z}_{n_k}$之间的一一对应，对$\mathbb{Z}_n$中元素所执行的运算可以等价地作用于对应的$k$元组</p><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/a+b.png"></p><p>从$(a_1,a_2,\cdots,a_k)$计算$a$：</p><ul><li>定义$m_i=n/n_i=n_1n_2\cdots n_{i-1}n_{i+1}\cdots n_l$</li><li>对$i=1,2, \cdots l$, 定义$c_i=m_i(m_i^{-1}\bmod n_i)$<ul><li>In fact, $c_i\leftrightarrow(0,0,\cdots ,0,1,0,\cdots 0)$ 除了在$i$个坐标上为1外其余坐标均为0</li></ul></li><li>$a\equiv (a_1c_1+a_2c_2+\cdots +a_kc_k)\pmod n$</li></ul><p>对任意$x$和$i=1,2,\cdots k,$有$x\bmod n_i=(x\bmod n)\mod n_i$.</p><p><strong>推论31.28</strong>: 如果$n_1,n_2,\cdots ,n_k$两两互质，$n=n_1n_2\cdots n_k$,则对任意整数$a_1,a_2,\cdots ,a_k$, 关于未知量$x$的联立方程组$$x\equiv a_i\pmod n_i,i=1,2,\cdots k$$对模$n$有唯一解</p><p><strong>推论31.29</strong>: 如果$n_1,n_2,\cdots ,n_k$两两互质，$n=n_1n_2\cdots n_k$, 则对所有整数$x$和$a$，$x\equiv a\pmod {n_i}$(其中$i=1,2,\cdots k$)当且仅当$x\equiv a\pmod n$.</p><p><strong>可以把模大数的线性方程转换为模小数的线性方程组</strong></p><h1 id="元素的幂"><a href="#元素的幂" class="headerlink" title="元素的幂"></a>元素的幂</h1><p><strong>定理31.30</strong>: 对于任意整数$n&gt;1$, $a^{\phi(n)}\equiv 1\pmod n$对所有$a\in\mathbb{Z}_n^*$都成立</p><p><strong>定理31.31</strong>: 若$p$是素数，则$a^{p-1}\equiv 1\pmod p$对所有$a\in\mathbb{Z}_p^*$都成立</p><p><strong>定理31.32</strong>: 对所有素数$p&gt;2$和所有正整数$e$，使得$\mathbb{Z}_n^*$是循环群的$n&gt;1$的值为2,4，$p^e$和$2p^e$。</p><p>若$g$是$\mathbb{Z}_n^<em>$的生成元，则对于任意$a\in\mathbb{Z}_n^</em>$存在一个$z$，使得$g^z\equiv a\pmod n$. 这个$z$称为对模$n$到基$g$上的$a$的一个<strong>离散对数</strong>或<strong>指数</strong>，记为$ind_{n,g}(a)$</p><p><strong>定理31.33(离散对数定理)</strong>: 如果$g$是$\mathbb{Z}_n^*$的一个生成元，则当且仅当等式$x\equiv y\pmod {\phi(n)}$ 成立时，有等式$g^x\equiv g^y\pmod n$成立。</p><p><strong>定理31.34</strong>: 如果$p$是一个奇素数且$e\ge 1$，则方程$$x^2\equiv 1\pmod {p^e}$$仅有两个解，即$x=\pm 1$。</p><p>如果$x$满足$x^2\equiv 1\pmod n$， 但$x$不等于以$n$为模的两个平凡平方根，则$x$是一个以$n$为模的<strong>非平凡平方根</strong></p><p><strong>推论31.35</strong>: 如果对模$n$存在1的非平凡平方根，则$n$是合数</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>又名：用反复平方法求数的幂</p><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/modex.png"></p><p>$c$只是用来辅助正确性证明的变量</p><p>循环不变式：</p><ul><li>$c$的值与$b$的二进制表示的前缀$\langle b_k,b_{k-1},\cdots b_{i+1}\rangle$相同</li><li>$d=a^c\pmod n$</li></ul><p>时间复杂度$O(\beta^3)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;输入规模和算数计算的代价&quot;&gt;&lt;a href=&quot;#输入规模和算数计算的代价&quot; class=&quot;headerlink&quot; title=&quot;输入规模和算数计算的代价&quot;&gt;&lt;/a&gt;输入规模和算数计算的代价&lt;/h1&gt;&lt;p&gt;给定$k$个整数输入$a_1,a_2,\cdots ,a_k
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
  </entry>
  
  <entry>
    <title>问题求解学习笔记-数论基础</title>
    <link href="https://mengzelev.github.io/2019/03/30/ps-4-6-basic-number-theory/"/>
    <id>https://mengzelev.github.io/2019/03/30/ps-4-6-basic-number-theory/</id>
    <published>2019-03-30T06:49:23.000Z</published>
    <updated>2019-06-18T09:18:23.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h1><p>你都懂的</p><h1 id="辗转相除法-Division-Algorithm"><a href="#辗转相除法-Division-Algorithm" class="headerlink" title="辗转相除法(Division Algorithm)"></a>辗转相除法(Division Algorithm)</h1><p><strong>定理2.9(辗转相除法)</strong>: $a,b$为整数，满足$b&gt;0$，则存在唯一的整数$q$和$r$使得$a=bq+r$，此处$0\le r&lt;b$</p><p>$a\mid b$: $a$能整除$b$,$b$能被$a$整除</p><p><strong>定理2.10</strong>: $a,b$为非零整数，则存在整数$r,s$使得gcd($a,b)=ar+bs$. $gcd(a,b)$是唯一的。但$r,s$不唯一</p><p><strong>推论2.11</strong>: $a,b$为互质的整数，则存在整数$r,s$使得$ar+bs=1$【事实上是当且仅当的关系】</p><h2 id="欧几里得算法-The-Euclidean-Algorithm"><a href="#欧几里得算法-The-Euclidean-Algorithm" class="headerlink" title="欧几里得算法(The Euclidean Algorithm)"></a>欧几里得算法(The Euclidean Algorithm)</h2><p>使用多次除法得到一个递减的序列来求出gcd$(a,b)$<br>$b=aq_1+r$<br>$a=r_1q_2+r_2$<br>$r_1=r_2q_3+r_3$<br>$\vdots$<br>$r_{n-2}=r_{n-1}a_n+r_n$<br>$r_{n-1}=r_nq_{n+1}$<br>将这一系列等式反过来书写可以得到$d$的表示(略)</p><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p><strong>引理2.13(Euclid)</strong>: $a,b$为整数，$p$为质数。如果$p\mid ab$,则$p\mid a$或$p\mid b$</p><p><strong>定理2.14(Euclid)</strong>: 质数的个数是无限的</p><p><strong>定理2.15(算术基本定理Fundamental Theorem of Arithmetic)</strong>: $n$为大于1的整数，则$n=p_1p_2\cdots p_k$，其中$p_1,…,p_k$为质数。这个分解是唯一的，即若$n=q_1q_2\cdots q_l$，则$k=l$且$q_i$只是$p_i$的排列</p><p>以下内容出自CZ</p><h2 id="mathbb-Z-n-上的乘法逆元"><a href="#mathbb-Z-n-上的乘法逆元" class="headerlink" title="$\mathbb{Z}_n$上的乘法逆元"></a>$\mathbb{Z}_n$上的乘法逆元</h2><p><strong>乘法逆元(multiplicative inverse)</strong>: $a’\cdot_{n}a=1$,则称$a’$是$a$在$\mathbb{Z}_n<br>$中的乘法逆元</p><p><strong>引理2.5</strong>: 设$a$在$\mathbb{Z}_n$中存在乘法逆元$a’$. 则对于任意$b\in\mathbb{Z}<em>n$,等式$a\cdot</em>{n}x=b$有唯一解$x=a’\cdot_{n}b$.</p><p><strong>推论2.6</strong>: 若存在$b\in\mathbb{Z}<em>n$使得$a\cdot</em>{n}x=b$的$a$无解，则$a$在$\mathbb{Z}_n$上不存在乘法逆元</p><p><strong>定理2.7</strong>: 若$\mathbb{Z}_n$中的元素有一个乘法逆元，则它的乘法逆元是唯一的。<br>因此可以用$a^{-1}$来表示乘法逆元。</p><p><strong>引理2.8</strong>: $a\cdot_{n}x=1$有解当且仅当存在整数$x,y$使得$ax+ny=1$</p><p><strong>定理2.9</strong>: $a$在$\mathbb{Z}_n$中有乘法逆元当且仅当存在整数$x,y$使得$ax+ny=1$</p><p><strong>推论2.10</strong>: 若$a\in\mathbb{Z}_n$且$x,y$是满足$ax+ny=1$的整数，则$a$在$\mathbb{Z}_n$中的乘法逆元是$x\bmod n$</p><p><strong>引理2.11</strong>: 若存在整数$x,y$使得$ax+ny=1$，则$a,n$互质</p><p><strong>定理2.12(欧几里得除法定理)</strong>: 同最TJ的定理2.9</p><p><strong>引理2.13</strong>: 若$j,k,q,r$是满足$k=jq+r$的正整数，则gcd($j,k$)=gcd($r,j$)</p><h2 id="欧几里得扩展算法"><a href="#欧几里得扩展算法" class="headerlink" title="欧几里得扩展算法"></a>欧几里得扩展算法</h2><p>其实就是计算$x$和$y$的算法</p><p><strong>定理2.15</strong>: 两个正整数$j$和$k$互质当且仅当存在整数$x,y$使得$jx+ky=1$</p><p><strong>推论2.16</strong>: 对于任意正整数$n$A，$\mathbb{Z}_n$的元素$a$有乘法逆元当且仅当$gcd(a,n)=1$</p><p><strong>推论2.17</strong>: 对任意质数$p$,$\mathbb{Z}_p$的任意非零元素存在乘法逆元。</p><h2 id="计算乘法逆元"><a href="#计算乘法逆元" class="headerlink" title="计算乘法逆元"></a>计算乘法逆元</h2><p>跑欧几里得算法求出满足$ax+ny=1$的$x$,就是$a$在$\mathbb{Z}_n$中的乘法逆元</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数学归纳法&quot;&gt;&lt;a href=&quot;#数学归纳法&quot; class=&quot;headerlink&quot; title=&quot;数学归纳法&quot;&gt;&lt;/a&gt;数学归纳法&lt;/h1&gt;&lt;p&gt;你都懂的&lt;/p&gt;
&lt;h1 id=&quot;辗转相除法-Division-Algorithm&quot;&gt;&lt;a href=&quot;#辗转相除法
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-字符串匹配</title>
    <link href="https://mengzelev.github.io/2019/03/23/clrs-32String-Mathcing/"/>
    <id>https://mengzelev.github.io/2019/03/23/clrs-32String-Mathcing/</id>
    <published>2019-03-23T06:42:50.000Z</published>
    <updated>2019-03-23T15:40:43.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="问题的形式化定义"><a href="#问题的形式化定义" class="headerlink" title="问题的形式化定义"></a>问题的形式化定义</h2><ul><li>文本是一个长度为$n$的数组$T[1,…n]$</li><li>模式是一个长度为$m$的数组$P<a href="m\le n">1,…m</a>$</li><li>$P$和$T$的元素都是来自一个有限字母集$\Sigma$的字符</li><li>若$0\le s\le n-m$,且$T[s+1,…s+m]=P[1,…m]$,则称模式$P$在文本$T$中<strong>出现</strong>，且<strong>偏移</strong>为$s$(模式$P$在文本$T$中出现的位置是$s+1$开始的)</li><li>如果$P$在$T$中以偏移$s$出现，那么称$s$是<strong>有效偏移</strong>，否则是无效偏移</li><li>字符串匹配问题：找到<strong>所有</strong>的有效偏移</li><li>算法总运行时间=预处理时间+匹配时间</li></ul><p><img src="/2019/03/23/clrs-32String-Mathcing/time.png"></p><h2 id="符号和术语"><a href="#符号和术语" class="headerlink" title="符号和术语"></a>符号和术语</h2><ul><li>$\Sigma^*$: 包含所有有限长度的字符串的集合</li><li>$\varepsilon$: 长度为0的空字符串，$\varepsilon\in\Sigma^*$</li><li>$|x|$: 字符串$x$的长度</li><li>$xy$: 两个字符串$x$和$y$的<strong>连结(concatenation)</strong></li><li>若对某个字符串$y\in \Sigma^*$有$x=wy$，则称字符串$w$是字符串$x$的<strong>前缀</strong>，记作$w\sqsubset x$</li><li>若对某个字符串$y$有$x=yw$，则称字符串$w$是字符串$x$的后缀，记作$w\sqsupset x$</li><li>空字符串$\varepsilon$同时是任何一个字符串的前缀和后缀</li><li>$x\sqsupset y$当且仅当$xa\sqsupset ya$</li><li>$\sqsubset$和$sqsupset$都是<strong>传递关系</strong></li></ul><p><strong>引理32.1(后缀重叠引理)</strong>: 假设$x,y$满足$x\sqsupset z$和$y\sqsupset z$的字符串。如果$|x|\le |y|$, 那么$x\sqsupset y$; 如果$|x|\ge |y|$, 那么$y\sqsupset x$; 如果$|x|=|y|$, 那么$x=y$</p><ul><li>把模式$P[1..m]$的由$k$个字符组成的前缀$P[1..k]$记作$P_k$，因此$P_0=\varepsilon$,$P_m=P=P[1..m]$</li><li>把文本$T$中由$k$个字符组成的前缀记为$T_k$</li><li>采用这种记号，字符串匹配问题能被表述为：找到所有偏移$s(0\le s\le n-m)$, 使得$P\sqsupset T_{s+m}$</li><li>假设：检测$x==y$需要时间$\Theta(t+1)$，其中$t$是满足$z\sqsubset x$和$z\sqsubset y$的最长字符串$z$的长度</li></ul><h1 id="朴素字符串匹配算法"><a href="#朴素字符串匹配算法" class="headerlink" title="朴素字符串匹配算法"></a>朴素字符串匹配算法</h1><p>通过循环找到所有有效偏移<br>对$n-m+1$个可能的$s$进行检测</p><p><img src="/2019/03/23/clrs-32String-Mathcing/naive.png"></p><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>最坏情况下：$O((n-m+1)m)$<br>无预处理时间</p><h1 id="Rabin-Karp算法"><a href="#Rabin-Karp算法" class="headerlink" title="Rabin-Karp算法"></a>Rabin-Karp算法</h1><p>为了便于说明，假设$\Sigma={0,1,2,…,9}$<br>在通常情况下可以假定每个字符都是以$d$为基数表示的数字<br>$p$: 模式$P$表示的十进制值<br>$t_s$: 文本$T[s+1..s+m]$对应的十进制值<br><strong>把字符串匹配转化为数值匹配</strong></p><p>计算$t_1,…t_s$时，可以根据$t_s$计算$t_{s+1}$<br>$$t_{s+1}=10(t_s-10^{m-1}T[s+1])+T[s+m+1]$$<br>(去掉高位数字，左移，加上低位数字)</p><p>如果$p$和$t_s$的值太大，可以选取一个合适的模$q$来计算$p$和$t_s$的模<br>在一般情况下，选取一个$q$，使得$dq$在一个计算机字长内，调整递归式<br>$$t_{s+1}=(d(t_s-T[s+1]h)+T[s+m+1])\mod~q$$<br>其中$h\equiv d^{m-1}(mod q)$是一个具有$m$数位的文本窗口的高位数位上的数字”1”的值</p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/RK.png"></p><ul><li>计算所有长度为$m$的文本窗口对$q$取模的值</li><li>找出$t_s\equiv q(\mod~q)$的$s$值(<strong>伪命中点</strong>)</li><li>进行字符串匹配检验</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/RKM.png"></p><ul><li>去除$t$的下标不会影响程序运行</li><li>循环不变量：$t_s=T[s+1…s+m]\mod~q$</li></ul><h2 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h2><p>预处理：$\Theta(m)$<br>最坏情况运行时间: $\Theta((n-m+1)m)$(e.g.$P=a^m$且$T=a^n$时需要对所有可能进行字符串匹配验证，相当于退化为朴素算法)</p><p>若有效便宜只有常数$c$个，算法的期望匹配时间为$O((n-m+1)+cm)=O(n+m)$</p><p>若假设$q$是从适当大的整数中随机得出的，则伪命中的次数为$O(n/q)$(因为任意$t_s$模A$q$与$p$同余的概率为$1/q$)。 第10行中的测试会在$O(n)$个位置上失败，每次命中的时间代价是$O(m)$。因此Rabin-Karp算法的期望运行时间是$$O(n)+O(m(v+n/q))$$其中$v$为有效偏移量</p><p>若选取的素数$q$大于模式的长度，则可以估计Rabin-Karp算法的匹配时间为$O(n+m)=O(n)$</p><h1 id="利用有限自动机进行字符串匹配"><a href="#利用有限自动机进行字符串匹配" class="headerlink" title="利用有限自动机进行字符串匹配"></a>利用有限自动机进行字符串匹配</h1><h2 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h2><p>一个有限自动机$M$是一个五元组$(Q,q_0,A,\Sigma,\delta)$,其中：</p><ul><li>$Q$是<strong>状态</strong>的有限集合</li><li>$q_0\in Q$是<strong>初始状态</strong></li><li>$A\subseteq Q$是一个特殊的<strong>接受状态</strong>集合</li><li>$\Sigma$是<strong>有限输入字母表</strong></li><li>$\delta$是一个从$Q\times\Sigma$到$Q$的函数，称为$M$的<strong>转移函数</strong> </li></ul><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><ul><li>开始状态为$q_0$，每次读入输入字符串的一个字符</li><li>如果在状态$q$时读入字符$a$，就从状态$q$变为状态$\delta(q,a)$(进行了一次转移)</li><li>当前状态$q\in A$时，就说$M$<strong>接受</strong>了迄今为止所读入的字符串，没有被接受的输入称为<strong>被拒绝</strong>的输入</li></ul><h3 id="终态函数"><a href="#终态函数" class="headerlink" title="终态函数"></a>终态函数</h3><p>终态函数$\phi:\Sigma^*\to Q$<br>$\phi(w)$: $M$在扫描字符串$w$后终止时的状态<br>当且仅当$\phi(w)\in A$时，$M$接受字符串$w$</p><p>用转移函数递归定义$\phi$:<br>$$\phi(\varepsilon)=q_0,$$<br>$$\phi(wa)=\delta(\phi(w),a), ~~w\in\Sigma^*,a\in\Sigma$$</p><h2 id="字符匹配自动机"><a href="#字符匹配自动机" class="headerlink" title="字符匹配自动机"></a>字符匹配自动机</h2><p>后缀函数$\sigma:\Sigma^*\to{0,1,…,m}$，满足$\sigma(x)$是同时是$x$的后缀和$P$的前缀的字符串的长度<br>$$\sigma(x)=\max{k:P_k\sqsupset x}$$</p><p>对于任意的状态$q$和字符串$a$，转移函数$\delta$定义如下：<br>$$\delta(q,a)=\sigma(P_qa)$$<br>记录已得到的与模式$P$匹配的文本字符串$T$的最长前缀</p><p><img src="/2019/03/23/clrs-32String-Mathcing/auto.png"></p><p>匹配时间为$\Theta(n)$</p><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p><strong>引理32.2(后缀函数不等式)</strong>: 对任意字符串$x$和字符$a$，$\sigma(xa)\le\sigma(x)+1$</p><p><strong>引理32.3(后缀函数递归引理)</strong>: 对任意$x$和字符$a$，若$q=\sigma(x)$,则$\sigma(xa)=\sigma(P_qa)$</p><p><strong>定理32.4</strong>: 如果$\phi$是字符串匹配自动机关于给定模式$P$的终态函数，$T[1..n]$是自动机的输入文本，则对$i=0,1,..,n,\phi(T_i)=\sigma(T_i)$(终态函数的值=后缀函数的值)</p><h2 id="计算转移函数"><a href="#计算转移函数" class="headerlink" title="计算转移函数"></a>计算转移函数</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/compute.png"></p><p>计算转移函数的运行时间为$O(m^3|\Sigma|)$，可以改进为$O(m\Sigma)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h1&gt;&lt;h2 id=&quot;问题的形式化定义&quot;&gt;&lt;a href=&quot;#问题的形式化定义&quot; class=&quot;headerlink&quot; title=&quot;问
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-群同构基本定理与正规子群</title>
    <link href="https://mengzelev.github.io/2019/03/14/ps-4-4-isomorphism/"/>
    <id>https://mengzelev.github.io/2019/03/14/ps-4-4-isomorphism/</id>
    <published>2019-03-14T08:20:40.000Z</published>
    <updated>2019-06-18T03:21:47.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同构-Isomorphisms"><a href="#同构-Isomorphisms" class="headerlink" title="同构(Isomorphisms)"></a>同构(Isomorphisms)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对两个群$(G,\cdot)$和$(H,\circ)$，若存在一个保群运算的双射$\phi:G\to H$，即对于任意$a,b\in G$<br>$$\phi(a\cdot b)=\phi(a)\circ\phi(b)$$<br>则称$G$和$H$<strong>同构(isomorphic)</strong>，记作$G\cong H$. $\phi$称为<strong>同构函数(isomorphism)</strong>。</p><h2 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h2><p><strong>定理9.6</strong>: Let $\phi: G\to H$ be an isomorphism of two groups. Then the following statements are true.</p><ol><li>$\phi^{-1}:H\to G$ is an isomorphism (废话)</li><li>$|G|=|H|$ (废话)</li><li>If $G$ is abelian, then $H$ is abelian.</li><li>If $G$ is cyclic, then $H$ is cyclic.</li><li>If $G$ has a subgroup of order $n$, then $H$ has a subgroup of order $n$.</li></ol><p><strong>定理9.7</strong>: All cyclic groups of infinite order are isomorphic to $\mathbb{Z}$. 无穷阶循环群与$\mathbb{Z}$同构。</p><p><strong>定理9.8</strong>: If $G$ is a cyclic group of order $n$, then $G$ is isomorphic to $\mathbb{Z}_n$.</p><p><strong>推论9.9</strong>: If $G$ is a group of order $p$, where $p$ is a prime number, then $G$ is isomorphic to $\mathbb{Z}_p$. (不需要是循环群)</p><p><strong>定理9.10</strong>: The isomorphism of groups determines an equivalence relation on the class of all groups. 群的同构关系将群划分成等价类。</p><h2 id="Cayley’s-Theorem"><a href="#Cayley’s-Theorem" class="headerlink" title="Cayley’s Theorem"></a>Cayley’s Theorem</h2><p><strong>定理9.12(Cayley定理)</strong>: Every group is isomorphic to a group of permutations. 任意群都与一个置换群同构。</p><p>The isomorphism $g\mapsto \lambda_g$ is known as the <strong>left regular representation</strong>of G.</p><h1 id="直积-Direct-Products"><a href="#直积-Direct-Products" class="headerlink" title="直积(Direct Products)"></a>直积(Direct Products)</h1><p>qlz管它叫直和</p><h2 id="外直积"><a href="#外直积" class="headerlink" title="外直积"></a>外直积</h2><p>定义运算$$G\times H: (g_1,h_1)(g_2,h_2)=(g1\cdot g_2, h_1\circ h_2)$$</p><p><strong>命题9.13</strong>: Let $G$ and $H$ be groups. The set $G\times H$ is a group under the operation $(g_1,h_1)(g_2,h_2)=(g1\cdot g_2, h_1\circ h_2)$ where $g_1, g_2\in G$ and $h_1, h_2\in H$.</p><p>群$G\times H$称为$G$和$H$的<strong>外直积(external direct product)</strong></p><p><strong>定理9.17</strong>: 设$(g,h)\in G\times H$. 若$g$和$h$分别为有限阶$r$和$s$,则$(g,h)$在$G\times H$中的阶数是$r$和$s$的<strong>最小公倍数(least common multiple)</strong></p><p><strong>推论9.18</strong>: 设$(g_1,…g_n)\in \prod G_i$. 若$g_i$在$G_i$中为有限阶$r_i$，则$(G-1,..g_n)$在$\prod G_i$中的阶数为$lcm(r_1,…r_n)$.</p><p><strong>定理9.21</strong>: 群$\mathbb{Z}_m\times\mathbb{Z}<em>n$与$Z</em>{mn}$同构当且仅当$m,n$互质($gcd(m,n)=1$). (From定理9.17)</p><p><strong>推论9.22</strong>: $n_1,…n_k$为正整数，则$\prod\limits_{i=1}^{k}\mathbb{Z}_{n_1…n_k}$当且仅当$gcd(i,j)=1$对任意$i\neq j$恒成立。</p><h2 id="内直积-Internal-Direct-Product"><a href="#内直积-Internal-Direct-Product" class="headerlink" title="内直积(Internal Direct Product)"></a>内直积(Internal Direct Product)</h2><p>外直积把小群组建成大群，内直积把大群打碎成小群</p><p>群$G$拥有子群$H,K$满足以下条件:</p><ul><li>$G=HK={hk:h\in H, k\in K}$</li><li>$H\cap K={e}$</li><li>$hk=kh$ for all $k\in K$ and $h\in H$</li></ul><p>称$G$是$H$和$K$的<strong>内直积</strong></p><p>不是所有的群都可以写成其真子群的内积的形式</p><p><strong>定理9.27</strong>: 设$G$是其子群$H$和$K$的内直积，则$G$与$H\times K$同构。(外直积群与内直积群同构)</p><p>推广到多维：</p><ul><li>$G=H_1H_2…H_n={h_1h_2…h_n:h_i\in H_i}$</li><li>$H_i\cap\left\langle \cup_{j\neq i}H_j\right\rangle={e}$</li><li>$H_ih_j=h_jh_i$ for all $h_i\in H_i$ and $h_j\in H_j$</li></ul><p><strong>定理9.29</strong>: 若$G$是其子集$H_i(i=1,2,…n)$的内直积，则$G$与$\prod_i H_i$同构</p><h1 id="正规子群-Normal-Subgroups"><a href="#正规子群-Normal-Subgroups" class="headerlink" title="正规子群(Normal Subgroups)"></a>正规子群(Normal Subgroups)</h1><p>若对任意$g\in G$有$gH=Hg$, 则称$H$是$G$的正规子群。(左陪集与右陪集相同)<br>交换群的所有子群都是正规的。</p><p><strong>定理10.3</strong>: 设$N$为$G$的子群，则如下命题等价：</p><ol><li>$N$是$G$的正规子群</li><li>$\forall g\in G, gNg^{-1}\subseteq N$.</li><li>$\forall g\in G, gNg^{-1}=N$.</li></ol><h1 id="商群-Factor-Group"><a href="#商群-Factor-Group" class="headerlink" title="商群(Factor Group)"></a>商群(Factor Group)</h1><p><strong>定理10.4</strong>: $N$为$G$的正规子群，$N$在$G$中的陪集构成了一个群$G/N$, 阶为$[G:N]$(复习: $[G:N]=|G|/|N|$). 该群的运算为$(aN)(bN)=abN$.<br>这个群被称为<strong>商群(fatcor or quotient group)</strong>.<br>$eN=N$是单位元，$g^{-1}N$是$gN$的逆元。<br>商群是<strong>集合</strong>组成的群。<br>简记为$N\triangleleft G$</p><p>对于正多边形旋转群$D_n$, 旋转群$R_n$是$D_n$的一个正规子群。</p><h1 id="交替群的简单性"><a href="#交替群的简单性" class="headerlink" title="交替群的简单性"></a>交替群的简单性</h1><p><strong>单群(simple group)</strong>: 没有非平凡正规真子群的群 e.g.$\mathbb{Z}_p$($p$为质数)</p><p><strong>引理10.8</strong>: 替换群$A_n(n\ge 3)$是由3-cycles生成的。</p><p><strong>引理10.9</strong>: $N$是$A_n(n\ge 3)$的正规子群.若$N$包含了一个3-cycle，则$N=A_n$.</p><p><strong>引理10.10</strong>: 对$n\ge 5$, $A_n$的每一个非平凡正规子群$N$都包含一个3-cycle.</p><p><strong>引理10.11</strong>: $n\ge 5$的替换群$A_n$是单群。</p><h1 id="同态-homomorphism"><a href="#同态-homomorphism" class="headerlink" title="同态(homomorphism)"></a>同态(homomorphism)</h1><p>两个群$(G,\cdot)$和$(H,\circ)$间的同态函数是一个映射$\phi:G\to H$，满足$\phi(g_1\cdot g_2)=\phi(g_1)\circ\phi(g_2)$,其中$g_1,g_2\in G$.<br>$\phi$在$H$中的值域被称为<strong>同态像(homomorphism image)</strong>.<br>若$\phi$是双射，则$G$和$H$同构。</p><p><strong>命题11.4</strong>: 设$\phi:G_1\to G_2$是群间的同态函数，则</p><ol><li>若$e$是$G_1$的单位元，则$e$是$G_2$的单位元</li><li>对于任意$g\in G_1$, $\phi(g^{-1})=[\phi(g)]^{-1}$</li><li>若$H_1$是$G_1$的子群，则$\phi(H_2)$是$G_2$的子群</li><li>若$H_2$是$G_2$的子群，则$\phi^{-1}(H_2)={g\in G_1: \phi(g)\in H_2}$是$G_1$的子群。此外，若$H_2$是$G_2$的正规子群，则$\phi^{-1}(H_2)$是$G_1$的正规子群</li></ol><p>由命题11.4知，$\phi^{-1}({e})$是$G$的子群，这个子群被称为$\phi$的<strong>核(kernel)</strong>,记为$ker\phi$. 该子群是正规的。</p><p><strong>定理11.5</strong>： 设$\phi:G\to H$是群的同态函数，则$\phi$的核是$G$的一个正规子群<br>潜台词：对于每一个同态函数都能找到一个正规子群$ker\phi$</p><p>核函数可以用来推测两个群间是否存在单射同态函数。(e.g. Example11.9 $\mathbb{Z}<em>7$与$\mathbb{Z}</em>{12}$不存在单射同态函数)</p><h1 id="同态定理"><a href="#同态定理" class="headerlink" title="同态定理"></a>同态定理</h1><p>设$H$是$G$的正规子群。定义<strong>自然同态函数</strong>或<strong>规范同态函数</strong>(<strong>natural</strong> or <strong>canonical homomorphism</strong>) $$\phi:G\to G/H$$为$$\phi(g)=gH$$<br>该同态函数的核为$H$</p><p><strong>定理11.10(第一同态定理)</strong>:  若$\varphi:G\to H$是核为$K$的同态函数， 则$K$是$G$的正规子群。设$\phi:G\to G/K$是规范同态函数。则存在唯一的同构函数$\eta:G/K\to\varphi(G)$使得$\varphi=\eta\phi$</p><p>规范同态函数产生的商群与原同态函数的像同构</p><p><strong>定理11.12(第二同态定理)</strong>: 设$H$是$G$的子群(不需要正规)，$N$是$G$的正规子群，则$HN$是$G$的子群，$H\cap N$是$H$的正规子群，且<br>$$H/H\cap N\cong HN/N$$</p><p><strong>定理11.13(一致性定理)</strong>: 设$N$是$G$的正规子群，则$H\mapsto H/N$是<strong>包含$N$的子群$H$</strong>的集合与<strong>$G/N$的子群</strong>的集合间的一对一关系。此外，包含$N$的$G$的正规子群与$G/N$的正规子群相对应。</p><p><img src="/2019/03/14/ps-4-4-isomorphism/corr.png" alt="wiki上的解释"></p><p><strong>定理11.14(第三同构定理)</strong>: 设$N$和$H$是$G$的正规子群满足$N\subseteq H$,则$$G/H\cong\frac{G/N}{H/N}$$. (可以当成分数来直观理解)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;同构-Isomorphisms&quot;&gt;&lt;a href=&quot;#同构-Isomorphisms&quot; class=&quot;headerlink&quot; title=&quot;同构(Isomorphisms)&quot;&gt;&lt;/a&gt;同构(Isomorphisms)&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-置换群与拉格朗日定理</title>
    <link href="https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/"/>
    <id>https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/</id>
    <published>2019-03-09T09:15:13.000Z</published>
    <updated>2019-06-17T14:18:27.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="置换群-Permutation-Group"><a href="#置换群-Permutation-Group" class="headerlink" title="置换群(Permutation Group)"></a>置换群(Permutation Group)</h1><p><strong>定理5.1</strong>:The symmetric group on $n$ letters, $S_n$, is a group with $n!$ elements, where<br>the binary operation is the composition of maps.</p><p>置换群(permutation group):所有排列的集合$S_n$的一个子集</p><h2 id="Cycle-Notation"><a href="#Cycle-Notation" class="headerlink" title="Cycle Notation"></a>Cycle Notation</h2><p>A permutation $\sigma\in S_X$ is a <strong>cycle of length</strong> $k$ if there exist elements $a_1,a_2,…a_k\in X$ such that<br>$$\sigma(a_1) = a_2$$<br>$$\sigma(a_2) = a_3$$<br>$$…$$<br>$$\sigma(a_k) = a_1$$<br>and $\sigma(x)=x$ for all other elements $x\in X$. </p><p>We write $(a_1,a_2,…a_k)$ to denote the cycle $\sigma$.</p><p>Cycles are the building blocks of all permutations.循环是所有排列的基石。</p><p>Two cycles in $S_X$, $\sigma=(a_1,a_2,…a_k)$, $\tau=(b_1,b_2,…b_l)$, are <strong>disjoint</strong> if $a_i\neq b_j$ for all $i$ and $j$</p><p><strong>命题5.8</strong>: Let $\sigma$ and $\tau$ be 2 disjoint cycles in $S_X$. Then $\sigma\tau=\tau\sigma$.</p><p><strong>定理5.9</strong>: $S_n$中的所有排列都可以被写成不相交循环的乘积的形式。</p><p><strong>Transpositions</strong>: a cycle of length 2 (任意两个数交换位置)</p><p><strong>命题5.12</strong>: 任意至少含有两个元素的有限集的排列都可以写成transposition乘积的形式<br>e.g. (253)=(23)(25)</p><p><strong>引理5.14</strong>: identity(恒等变换)只能写成<strong>偶数个</strong>transposition的乘积的形式</p><p><strong>定理5.15</strong>: 如果一个排列能被写成偶数个置换乘积的形式，那么另一个与之等价的排列也一定拥有偶数项置换乘积。奇数同理。<br>据此定理可以将排列分为奇偶两类</p><h3 id="交替组-The-Alternating-Groups"><a href="#交替组-The-Alternating-Groups" class="headerlink" title="交替组(The Alternating Groups)"></a>交替组(The Alternating Groups)</h3><p>交替组$A_n$是所有偶排列的集合</p><p><strong>定理5.16</strong>: 集合$A_n$是$S_n$的子群</p><p><strong>命题5.17</strong>: $S_n$中奇排列和欧排列的数目相等，都为$n!/2$</p><h1 id="反组-Dihedral-Groups"><a href="#反组-Dihedral-Groups" class="headerlink" title="反组(Dihedral Groups)"></a>反组(Dihedral Groups)</h1><p>the <strong>nth dihedral group</strong>($D_n$): the group of rigid motions of a regular n-gon(正多边形的刚性运动=转动+反射)</p><p><strong>定理5.20</strong>: $D_n$ is a subgroup of $S_n$ of order $2n$</p><p><strong>定理5.23</strong>: The group $D_n$, $n\ge 3$, consists of all products of the two elements $r$ and $s$, satisfying the relations<br>$$r^n=1$$<br>$$s^2=1$$<br>$$srs=r^{-1}$$<br>($r,s$分别为转动和反射)</p><p>$$D_n={1,r,r^2,..,r^{n-1},s,sr,sr^2,…,sr^{n-1}}$$</p><h2 id="立方体的运动"><a href="#立方体的运动" class="headerlink" title="立方体的运动"></a>立方体的运动</h2><p><strong>命题5.27</strong>: The group of rigid motions of a cube contains 24 elements.</p><p><strong>命题5.28</strong>: The group of rigid motions of a cube is $S_4$.(看体对角线)</p><h1 id="陪集-Coset"><a href="#陪集-Coset" class="headerlink" title="陪集(Coset)"></a>陪集(Coset)</h1><p>$G$为群，$H$为$G$的子群，定义<br><strong>左陪集(left coset)</strong>: $gH={gh:~h\in H}$<br><strong>右陪集(left coset)</strong>: $Hg={hg:~h\in H}$ <s>(这真的不是汞吗)</s><br>其中$g\in G$称为<strong>代表元(representative)</strong></p><p>在交换群中，左陪集与右陪集是相同的。</p><p><strong>引理6.3</strong>: $g_1,g_2\in G$，以下条件等价:<br>$1. g_1H=g_2H$;<br>$2. Hg_1^{-1}=Hg_2^{-1}$;<br>$3. g_1H\subset g_2H$;<br>$4. g_2\in g_1H$;<br>$5. g_1^{-1}g_2\in H$;</p><p><strong>定理6.4</strong>: $H$为$G$的子群。$H$的左陪集分割(partition)了$G$,即$G$是$H$的左陪集的disjoint union. (右陪集同理)</p><p><strong>index</strong> of $H$: the number of left cosets of $H$ in $G$. 表示为$[G:H]$</p><p><strong>定理6.8</strong>: $H$在$G$中的左陪集与右陪集的个数相等。</p><h1 id="拉格朗日定理"><a href="#拉格朗日定理" class="headerlink" title="拉格朗日定理"></a>拉格朗日定理</h1><p><strong>命题6.9</strong>: 定义映射$H\to gH$ by $\phi(h)=gh$. 该映射是双射，$H$中元素的个数等于$gH$中元素的个数。</p><p><strong>定理6.10(拉格朗日定理)</strong>: Let $G$ be a finite group and let $H$ be a subgroup of $G$. Then $|G|/|H|=[G:H]$ is the number of distinct left cosets of $H$ in $G$. In particular, the number of elements in $H$ must divide the number of elements in $G$.<br>$$|G|=[G:H]|H|$$</p><p><strong>推论6.11</strong>: Suppose that $G$ is a finite group and $g\in G$. Then the order of $g$ must divide the number of elements in $G$.</p><p><strong>推论6.12</strong>: Let $|G|=p$ with $p$ a prime number. Then $G$ is cyclic and any $g\in G$ such that $g\neq e$ is a generator. 含有质数个元素的群为循环群且任何非单位元的元素都是生成元。</p><p><strong>推论6.13</strong>: Let $H$ and $K$ be subgroups of a finite group $G$ such that $G\supset H\supset K$. Then $[G:K]=[G:H][H:K]$.</p><p><strong>拉格朗日定理的逆命题是不成立的</strong></p><p><strong>命题6.15</strong>: The group $A_4$ has no subgroup of order 6.</p><p><strong>定理6.16</strong>: Two cycles $\tau$ and $\mu$ in $S_n$ have the same length if and only if there exists a $\sigma\in S_n$ such that $\mu=\sigma\tau\sigma^{-1}$.</p><h1 id="费马与欧拉定理"><a href="#费马与欧拉定理" class="headerlink" title="费马与欧拉定理"></a>费马与欧拉定理</h1><p>欧拉函数$\phi(n)$表示$n$以内与$n$互质的数的个数<br>对任意质数$p$, $\phi(p)=p-1$</p><p><strong>定理6.17</strong>: Let $U(n)$ be the group of units in $\mathbb{Z}_n$. Then $|U(n)|=\phi(n)$</p><p><s>怎么又是欧拉</s><br><strong>定理6.18(欧拉定理)</strong>: Let $a$ and $n$ be integers such that $n&gt;0$ and $gcd(a,n)=1$. Then $a^{\phi(n)}\equiv 1\pmod n$</p><p><strong>定理6.19(费马小定理)</strong>: Let $p$ be any prime number and suppose that $p\nmid a$($p$ does not divide $a$). Then $a^{p-1}\equiv 1\pmod p$.<br>Furthermore, for any integer $b$, $b^p\equiv b\pmod p$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;置换群-Permutation-Group&quot;&gt;&lt;a href=&quot;#置换群-Permutation-Group&quot; class=&quot;headerlink&quot; title=&quot;置换群(Permutation Group)&quot;&gt;&lt;/a&gt;置换群(Permutation Group)
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
</feed>
