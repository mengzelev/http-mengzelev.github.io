<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengzelev&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mengzelev.github.io/"/>
  <updated>2018-12-08T02:14:21.948Z</updated>
  <id>https://mengzelev.github.io/</id>
  
  <author>
    <name>Mengzelev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法导论学习笔记-最大流</title>
    <link href="https://mengzelev.github.io/2018/12/05/clrs-26Maximum-Flow/"/>
    <id>https://mengzelev.github.io/2018/12/05/clrs-26Maximum-Flow/</id>
    <published>2018-12-05T07:03:20.000Z</published>
    <updated>2018-12-08T02:14:21.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流网络"><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h1><h2 id="流网络-1"><a href="#流网络-1" class="headerlink" title="流网络"></a>流网络</h2><ul><li>有向图$G=(V,E)$</li><li>图中中每条边$(u,v)\in E$有一个非负的<strong>容量值</strong>$c(u,v)\ge 0$</li><li>如果$(u,v)\notin E$，定义$c(u,v)=0$</li><li>如果边集合$E$包含一条边$(u,v)$，则图中不存在反方向的边$(v,u)$</li><li>有<strong>源结点$s$</strong>和<strong>汇点$t$</strong></li><li>流网络图是连通的</li><li>除源结点外的每个结点都至少有一条进入的边，$|E|\ge |V|-1$</li></ul><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>设$G=(V,E)$为一个流网络，其容量函数为$c$。设$s$为网络的源结点，$t$为汇点。$G$中的流是一个实值函数$f: V\times V \to \mathbb{R}$，满足下面两条性质：</p><ul><li><strong>容量限制</strong>：对于所有的结点$u,v\in V$，要求$0\le f(u,v)\le c(u,v)$</li><li><strong>流量守恒</strong>：对于所有的结点$u\in V-{s,t}$，要求$$\sum\limits f(v,u)=\sum\limits f(u,v)$$当$(u,v)\notin E$时，从结点$u$到结点$v$之间没有流，因此$f(u,v)=0$</li></ul><p>称非负数值$f(u,v)$为从结点$u$到结点$v$的流。（流入=流出）</p><p>一个流$f$的<strong>值</strong>$|f|=\sum\limits_{v\in V}f(s,v)-\sum\limits_{v\in V}f(v,s)$ （从源结点流出的总流量减去流入源结点的总流量）</p><p><strong>最大流问题</strong>：给定一个流网络$G$、一个源结点$s$、一个汇点$t$，找到值最大的一个流</p><h2 id="反平行边"><a href="#反平行边" class="headerlink" title="反平行边 "></a><strong>反平行边</strong> </h2><p>如果要使用反平行边来模拟一个流问题，就选择两条反平行边中的一条，加入一个新结点来将其分解为两段，并以新的结点到原来边的结点的两条路替换所选边，同时将两条新设立的边的容量设置为与原来的边的容量相同。</p><p><img src="/2018/12/05/clrs-26Maximum-Flow/antiparallel.png"></p><h2 id="具有多个源结点和多个汇点的网络"><a href="#具有多个源结点和多个汇点的网络" class="headerlink" title="具有多个源结点和多个汇点的网络"></a>具有多个源结点和多个汇点的网络</h2><p>加入一个<strong>超级源结点$s$</strong>和一个<strong>超级汇点$t$</strong></p><p><img src="/2018/12/05/clrs-26Maximum-Flow/multi.png"></p><h1 id="Ford-Fulkerson方法"><a href="#Ford-Fulkerson方法" class="headerlink" title="Ford-Fulkerson方法"></a>Ford-Fulkerson方法</h1><p><img src="/2018/12/05/clrs-26Maximum-Flow/ffm.png"></p><h2 id="残存网络"><a href="#残存网络" class="headerlink" title="残存网络"></a>残存网络</h2><p>给定流网络$G$和流量$f$，残存网络$G_f$由那些仍有空间对流量进行调整的边构成。</p><p>残存容量为$c_f(u,c)=c(u,v)-f(u,v)$</p><p>对正流量的<strong>缩减</strong>：将边$(v,u)$加入到图$G_f$中，并将其残存容量设置为$c_f(v,u)=f(u,v)$</p><p><strong>残存容量</strong>的形式化定义如下：<br><img src="/2018/12/05/clrs-26Maximum-Flow/residual_capacity.png"></p><p>给定一个流网络$G=(V,E)$和一个流$f$，则有$f$所诱导的图$G$的残存网络为$G_f=(V,E_f)$，其中$E_f={(u,v)\in V\times V: c_f(u,v)&gt;0}$，有$|E_f|\le 2|E|$</p><p><strong>递增</strong>：如果$f$是$G$的一个流，$f’$是对应的残存网络$G_f$的中的一个流，定义$$f’\uparrow f’:V\times V\to\mathbb{R}$$为流$f’$对流$f$的<strong>递增</strong></p><p><img src="/2018/12/05/clrs-26Maximum-Flow/augmentation.png"></p><p><strong>抵消操作</strong>：在残存网络中将流量推送回去</p><p><strong>引理26.1</strong>：$$|f\uparrow f’|=|f|+|f’|$$</p><h2 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h2><p><strong>增广路径</strong>$p$：残存网络$G_f$中一条从源结点$s$到汇点$t$的简单路径</p><p><strong>残存容量</strong>：在一条增广路径$p$上能够为每条边增加的流量的最大值$$c_f(p)=\min{c_f(u,v): (u,v)\in p}$$</p><p><img src="/2018/12/05/clrs-26Maximum-Flow/Lemma26-2.png"><br><img src="/2018/12/05/clrs-26Maximum-Flow/Lemma26-3.png"></p><h2 id="流网络的切割"><a href="#流网络的切割" class="headerlink" title="流网络的切割"></a>流网络的切割</h2><p><strong>流网络的切割</strong>：将结点集合$V$划分为$S$和$T=V-S$两个集合，使得$s\in S, t\in T$</p><p>横跨切割的$(S,T)$的<strong>净流量</strong>$f(S,T)$：$$f(S,T)=\sum\limits_{u\in S}\sum\limits_{v\in T}f(u,v)-\sum\limits_{u\in S}\sum\limits_{v\in T}f(v,u)$$</p><p>切割$(S,T)$的<strong>容量</strong>：$$c(S,T)=\sum\limits_{v\in S}\sum\limits_{v\in T}c(u,v)$$<br><strong>最小切割</strong>：整个网络中容量最小的切割</p><ul><li>对于容量，只计算从集合$S$发出进入集合$T$的边的容量，而忽略反方向边上的容量</li><li>对于流，考虑从$S$到$T$的流量减去从$T$到$S$的反方向的流量</li></ul><p><strong>引理26.4</strong>：整个流网络的流量与横跨某一个切割的流量相等$$f(S,T)=|f|$$</p><p><strong>推论26.5</strong>：$|f|\ge c(S,T)$</p><p><strong>定理26.6(最大流最小割定理)</strong><br><img src="/2018/12/05/clrs-26Maximum-Flow/Theorem26-6.png"></p><h2 id="基本的Ford-Fulkerson算法"><a href="#基本的Ford-Fulkerson算法" class="headerlink" title="基本的Ford-Fulkerson算法"></a>基本的Ford-Fulkerson算法</h2><p><img src="/2018/12/05/clrs-26Maximum-Flow/ff.png"></p><p>粗糙的时间复杂度上界：$O(E|f<em>|)$（$f</em>$为将有理数流网络转换成整数流网络后，网络中的一个最大流）</p><h2 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h2><p>在Ford-Fulkerson算法的第三行使用<strong>广度优先搜索</strong>来寻找增广路径。<br>每次在残存网络中选择的增广路径是一条从源结点$s$到汇点$t$的最短路径，其中每条边的权重为单位距离。</p><p>时间复杂度：$O(VE^2)$</p><p><strong>引理26.7</strong>：使用Edmonds-Karp算法，对于除源结点和汇点外的所有结点$v$，残存网络$G_f$中的最短路径距离$\delta_f(s,v)$随着每次流量的递增而单调递增。</p><p><strong>定理26.8</strong>：Edmonds-Karp算法所执行的流量递增操作的总次数为$O(VE)$</p><p><strong>关键边</strong>：在残存网络中，一条路径$p$的残存容量是该条路径上边$(u,v)$的残存容量，即$c_f(p)=c_f(u,v)$<br>对于$E$的每条边来说，其成为关键边的次数最多为$|V|/2$次。</p><h1 id="最大二分匹配"><a href="#最大二分匹配" class="headerlink" title="最大二分匹配"></a>最大二分匹配</h1><p>在一个二分图中，结点集合可以划分为$V=L\cup R$，其中$L$和$R$是不相交的，并且边集合$E$中所有的边都横跨$L$和$R$。</p><p>构造一个流网络$G=(V’,E’)$，其中$$V’=V\cup{s,t}$$$$E={(s,u):u\in L, u\in L}\cup {(u,v):(u,v)\in E}\cup {(v,t):v\in\mathbb{R}}$$<br>给$E’$中的每条边赋单位容量</p><p><img src="/2018/12/05/clrs-26Maximum-Flow/26-9.png"></p><p>流$f$是<strong>整数值</strong>的：对于所有的边$(u,v)\in V\times V$，$f(u,v)$都是整数值。</p><p><strong>定理26.10（完整性定理Integrality theorem）</strong>：如果容量函数$c$只能取整数值，则$Ford-Fulkerson$方法所生成的最大流$f$满足$|f|$是整数值的性质。而且，对于所有的结点$u$和$v$，$f(u,v)$都是整数。</p><p><strong>推论26.11</strong>：二分图$G$中的一个最大匹配$M$的基数等于其对应的流网络$G’$中某一最大流$f$的值。</p><p>时间复杂度：$O(VE)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;流网络&quot;&gt;&lt;a href=&quot;#流网络&quot; class=&quot;headerlink&quot; title=&quot;流网络&quot;&gt;&lt;/a&gt;流网络&lt;/h1&gt;&lt;h2 id=&quot;流网络-1&quot;&gt;&lt;a href=&quot;#流网络-1&quot; class=&quot;headerlink&quot; title=&quot;流网络&quot;&gt;&lt;/a&gt;流网
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
      <category term="Maximum Flow" scheme="https://mengzelev.github.io/tags/Maximum-Flow/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-图中的匹配与覆盖</title>
    <link href="https://mengzelev.github.io/2018/11/28/matchings/"/>
    <id>https://mengzelev.github.io/2018/11/28/matchings/</id>
    <published>2018-11-28T06:59:39.000Z</published>
    <updated>2018-12-01T02:14:22.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><h2 id="匹配的定义"><a href="#匹配的定义" class="headerlink" title="匹配的定义"></a>匹配的定义</h2><p><strong>独立</strong>：若图的边集中任意两条边不邻接，则称该集合是独立的</p><p><strong>匹配</strong>：图$G$中的边的一个独立集<br>$G$的<strong>匹配</strong>是一个边的集合$M={e_1,e_2,…,e_k}$，其中$e_i=u_iw_i(1\le i\le k)$，使得$u_1,u_2,…,u_k$是$U$中$k$个不同的顶点，$w_1,w_2,…,w_k$是$W$中$k$个不同的顶点。</p><h2 id="匹配存在的条件"><a href="#匹配存在的条件" class="headerlink" title="匹配存在的条件"></a>匹配存在的条件</h2><p><strong>邻域(neighbourhood)</strong>$N(X)$：设$G$为二部图，其部集为$U$和$W$，且$|U|\le |W|$，对于$U$的非空子集$X$，$X$中所有顶点的邻域的并。</p><p><strong>Hall’s condition/友好的(neighborly)</strong>：对于$U$的任意非空子集$X$，均有$|N(X)|\ge |X|$。</p><p><strong>定理8.3</strong>：设$G$为二部图，其部集为$U$和$W$，且$r=|U|\le |W|$。则$G$包含一个基数为$r$的匹配当且仅当$U$是<strong>友好的</strong>。 </p><p><strong>定理8.4</strong>：非空有限集族${S_1,S_2,…,S_n}$有一个互异代表元系(system of distinct representative) 当且仅当 对于任一整数$k(1\le k\le n)$，集族中任意$k$个集合的并至少包含$k$个元素。</p><p><strong>定理8.5(婚姻定理)</strong>:在一个由$r$个女人和$s$个男人构成的人群中，$1\le r\le s$，在熟识的男女之间可能出现$r$对婚姻当且仅当对每个整数$k(1\le k\le r)$，任意$k$个女人共认识至少$k$个男人。</p><p><strong>最大匹配(maximum matching)</strong>：具有最大基数的匹配</p><p><strong>完美匹配(perfect matching)</strong>：阶为$2k$的图$G$存在一个基数为$k$的匹配$M$，则称该匹配$M$为完美匹配</p><p><strong>定理8.6</strong>：任意$r$正则二部图$(r\ge 1)$均有一个完美匹配。</p><h2 id="边的独立性参数"><a href="#边的独立性参数" class="headerlink" title="边的独立性参数"></a>边的独立性参数</h2><p><strong>边独立数(edge independence number)</strong>$\alpha ‘(G)$：最大边独立集的基数</p><p><strong>覆盖</strong>：一个顶点和与其相连的一条边</p><p><strong>边覆盖数(edge covering number)</strong>$\beta ‘(G)$：$G$中所有边覆盖的最小基数</p><p><strong>最小边覆盖集(minimum edge cover)</strong>：具有最小基数的边覆盖集</p><p><strong>定理8.7</strong>：对于任意不包含孤立点的$n$阶图$G$，$$\alpha’(G)+\beta’(G)=n$$</p><h2 id="顶点的独立性参数"><a href="#顶点的独立性参数" class="headerlink" title="顶点的独立性参数"></a>顶点的独立性参数</h2><p>如果图中的一个顶点集合中任意两顶点都不邻接，则称该顶点的集合是<strong>独立</strong>的</p><p><strong>点独立数(vertex independence number)</strong>$\alpha(G)$:$G$中点独立集的最大基数，又称<strong>独立数</strong></p><p><strong>最大独立集(maximum independence set)</strong>：图$G$中基数为$\alpha(G)$的独立集</p><p><strong>点覆盖(vertex cover)</strong>：图$G$的某个顶点子集可以覆盖$G$的所有边</p><p><strong>点覆盖数(vertex covering number)</strong>$\beta(G)$：$G$的所有点覆盖的最小基数</p><p><strong>最小点覆盖(minimum vertex cover)</strong>：基数为$\beta(G)$的点覆盖</p><p><strong>定理8.8</strong>:对于任意不包含孤立点的$n$阶图，$$\alpha(G)+\beta(G)=n$$</p><p><strong>定理8.7</strong>与<strong>定理8.8</strong>合称为<strong>Gallai恒等式</strong></p><p>一般独立集比覆盖集好求</p><h1 id="因子分解"><a href="#因子分解" class="headerlink" title="因子分解"></a>因子分解</h1><h2 id="1因子"><a href="#1因子" class="headerlink" title="1因子"></a>1因子</h2><p><strong>1因子(1-factor)</strong>：图$G$的1正则生成子图。<br>$n$阶图$G$的完美匹配$M$的诱导的子图$F[M]$是$G$的1因子。<br>图$G$有1因子当且仅当$G$有完美匹配。</p><p>连通分支的<strong>奇偶性</strong>就是该连通分支的阶的<strong>奇偶性</strong>。<br>$k_O(G)$表示图$G$的<strong>奇连通分支</strong>的个数。</p><p><strong>定理8.10</strong>：图$G$包含1因子当且仅当对于$V(G)$的任意真子集$S$，$k_O(G-S)\le |S|$。</p><p><strong>定理8.11(Petersen定理)</strong>：所有无割边的3正则图包含1因子。</p><p><strong>定理8.12</strong>：任一至多含有两条割边的3正则图包含1因子。</p><h2 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h2><p><strong>可因子分解的(1-factorable)</strong>：若$G$有1因子$F_1,F_2,…,F_r$，使得${E(F_1),E(F_2),…,E(F_r)}$是$E(G)$的一个划分，此时我们称$G$被<strong>因子分解(factored)</strong>成1因子$F_1,F_2,…,F_r$；这些1因子构成了$G$的<strong>1因子分解(1-factorization)</strong></p><p>任一可1因子分解的图是正则的，反之不真，反例：Peterson图</p><p><strong>定理8.13</strong>：Petersen图是不可1因子分解的。</p><p><strong>定理8.14</strong>：对于任意正整数$k$，完全图$K_{2k}$是可1因子分解的。</p><p><strong>循环因子分解(cyclic factorization)</strong>：如图所示，所有因子分解可以由某一个因子分解旋转一定角度得到</p><p><img src="/2018/11/28/matchings/cyclic.png"></p><p><strong>定理8.15</strong>：任意$r$正则的二部图$(r\ge 1)$是可1因子分解的。</p><h2 id="2因子"><a href="#2因子" class="headerlink" title="2因子"></a>2因子</h2><p><strong>2因子(2-factor)</strong>：图$G$的二正则生成子图</p><p>2因子的任一连通分支是一个圈。</p><p><strong>可2因子分解的(2-factorable)</strong>：定义类似1因子</p><p><strong>定理8.16</strong>：图$G$是可2因子分解的当且仅当存在某个正偶数$r$，是的$G$是$r$正则的。</p><p><strong>*Hamilton因子分解(Hamilton factorization)</strong>：$G$的一个2因子分解，满足该分解中所有2因子均是Hamilton圈</p><p><strong>定理8.17</strong>：对于任一整数$k\ge 1$，完全图$K_{2k+1}$是可Hamilton分解的。<br>证明：构造法（如图）</p><p><img src="/2018/11/28/matchings/K9.png"></p><h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p><strong>因子(factor)</strong>：图$G$不含有孤立点的生成子图</p><p><strong>可因子分解(factorable)</strong>：因子$F_1,F_2,…,F_r$，满足${E(F_1),E(F_2),…,E(F_r)}$是$E(G)$的一个划分。</p><p><strong>可F-因子分解的(F-factorable)</strong>：若存在某个图$F$，是的每个因子$F_i\cong F$</p><h2 id="Kirkman三元系"><a href="#Kirkman三元系" class="headerlink" title="Kirkman三元系"></a>Kirkman三元系</h2><p><strong>n阶的Kirkman三元系(Kirkman triple system)</strong>：有一个基数为$n$的集合$S$，和$S$的三元子集（称为<strong>三元组(triple)</strong>）族$T$，以及$T$的一个划分$\mathcal{P}$构成，且满足如下性质：</p><ol><li>$S$中任意两个不同的元素属于$T$中唯一的三元组</li><li>$S$中任一元素属于划分$\mathcal{P}$的每一元素的唯一的三元组</li></ol><p>存在一个$6k+3$阶Kirkman三元系当且仅当存在一个$K_{6k+3}$的$(2k+1)K_3$因子分解</p><p><strong>定理8.19</strong>：$n(n\ge 3)$阶的Kirkman三元系存在当且仅当$n\equiv 3(mod 6)$，即$n=6k+3$</p><p><strong>定理8.20</strong>：对于每个整数$k\ge 1$，完全图$K_{2k}$可因子分解为$k-1$个Hamilton圈和一个1因子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;匹配&quot;&gt;&lt;a href=&quot;#匹配&quot; class=&quot;headerlink&quot; title=&quot;匹配&quot;&gt;&lt;/a&gt;匹配&lt;/h1&gt;&lt;h2 id=&quot;匹配的定义&quot;&gt;&lt;a href=&quot;#匹配的定义&quot; class=&quot;headerlink&quot; title=&quot;匹配的定义&quot;&gt;&lt;/a&gt;匹配的定
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
      <category term="Matchings" scheme="https://mengzelev.github.io/tags/Matchings/"/>
    
      <category term="Factorization" scheme="https://mengzelev.github.io/tags/Factorization/"/>
    
  </entry>
  
  <entry>
    <title>Lab3：链接与加载（2）实验报告</title>
    <link href="https://mengzelev.github.io/2018/11/24/lab3-report/"/>
    <id>https://mengzelev.github.io/2018/11/24/lab3-report/</id>
    <published>2018-11-24T09:17:47.000Z</published>
    <updated>2018-11-30T14:18:07.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现描述"><a href="#实现描述" class="headerlink" title="实现描述"></a>实现描述</h1><h2 id="寻找正确的入口地址"><a href="#寻找正确的入口地址" class="headerlink" title="寻找正确的入口地址"></a>寻找正确的入口地址</h2><p>在框架代码抽取出的<code>symtab</code>中主项寻找，如果该项的<code>Type</code>属性为<code>STT_FUNC</code>，就根据其<code>st_name</code>属性去字符串表<code>strtab</code>里寻找该函数的<code>Name</code>属性，并与<code>main</code>进行对比，就能找到<code>main</code>函数对应的表项，此时该表项的<code>st_value</code>属性即 我们需要的入口地址。</p><h2 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h2><p><code>loader()</code>函数的实现需要程序头表，模仿<code>load_elf_table()</code>函数的写法可将程序头表抽取到结构体<code>Elf32_phdr</code>中，找到<code>p_type</code>为<code>PT_LOAD</code>的表项，读取其<code>p_offset</code>，<code>p_vaddr</code>，<code>p_filesz</code>，<code>p_memsz</code>属性，按照讲义的描述，使用<code>fread</code>函数将可执行文件中相对文件偏移<code>p_offset</code>的内容读取<code>p_filedz</code>到内存地址为<code>[p_addr, p_addr + p_filesz</code>的地方，并用<code>memset</code>函数将<code>[p_vaddr + p_filesz, p_vaddr + p_memsiz)</code>对应的物理区间清零。</p><h2 id="打印栈帧链"><a href="#打印栈帧链" class="headerlink" title="打印栈帧链"></a>打印栈帧链</h2><p>第一次打印<code>eip</code>的值作为当前地址，之后每次都取内存中<code>ebp-4</code>的地址存放的返回地址作为函数调用的地址。函数的名字通过去<code>symtab</code>中寻找对应表项并从<code>strtab</code>中提取而得。仿照gdb的<code>bt</code>命令输出打印出来。对<code>ebp</code>的值解引用能得到上一个函数的<code>ebp</code>的值。如此循环直到<code>ebp</code>的信息为0为止。</p><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p>留着以后当笑话看的碎碎念</p><h2 id="寻找正确的入口地址-1"><a href="#寻找正确的入口地址-1" class="headerlink" title="寻找正确的入口地址"></a>寻找正确的入口地址</h2><p>我本来以为这个只要做好RTFSC就不会花太多时间的，<code>man 5 elf</code>之后理所当然地写了如下代码：</p><pre><code>if(symtab[i].st_info == STT_FUNC)</code></pre><p>发现怎么都找不到<code>main</code>，各种调试了一个多小时之后，问了同学才意识到，<code>st_info</code>不是直接的<code>type</code>值，<code>type</code>只占了低四位，高四位为绑定属性<code>bind</code>，把FM继续往下翻可以看到</p><pre><code>ELF32_ST_BIND(info), ELF64_ST_BIND(info)                                                                    Extract a binding from an st_info value. </code></pre><p><s>泪，可以流下来吗</s><br>论耐心RTFM的重要性</p><h2 id="加载程序-1"><a href="#加载程序-1" class="headerlink" title="加载程序"></a>加载程序</h2><p>这部分基本是照抄框架代码抽取<code>El32_Shdr</code>的方法抽取了<code>Elf32_Phdr</code>，让我自己写大概还是写不出来的吧[自卑.jpg]</p><h2 id="打印栈帧连"><a href="#打印栈帧连" class="headerlink" title="打印栈帧连"></a>打印栈帧连</h2><p>先用gdb调试了给的<code>segmentfault.c</code>，摸索了一下<code>bt</code>命令的打印格式，确认了打印的栈帧链中的地址为函数调用时压入栈中的返回地址。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="堆和栈在哪里？"><a href="#堆和栈在哪里？" class="headerlink" title="堆和栈在哪里？"></a>堆和栈在哪里？</h2><p>经过PA3.2的调教，可以知道堆是程序运行时调用<code>malloc</code>动态向高地址申请空间维护的。堆区的开始位置就是数据段的结束位置。当调用<code>malloc</code>函数时，会触发系统调用<code>sbrk</code>查询并调整堆区的结束位置，即program break，以调整堆区的大小。<br>栈区是从内核虚存区开始向低地址方向生长的，栈顶的地址保存在寄存器<code>esp</code>中。通过<code>push</code>和<code>pop</code>等指令来调整栈区大小。<br>堆和栈的内容不放入可执行文件，我猜想一方面因为这些部分是动态生成的，程序执行过程中它们的大小时刻变化着，因此不能放入静态的可执行文件中。另一方面，栈区会有一个随机化操作来防止恶意攻击，不便于放入可读的可执行文件中。</p><h2 id="如何识别不同格式的可执行文件？"><a href="#如何识别不同格式的可执行文件？" class="headerlink" title="如何识别不同格式的可执行文件？"></a>如何识别不同格式的可执行文件？</h2><p>ELF可执行目标文件有ELF头，根据ELF可执行文件的各种规范书写。Windows生成的可执行文件应该也有自己的文件头的格式，在GNU/Linux下执行时，系统按照ELF头的格式解析该文件的文件头出现了错误，例如没有读到“魔数”，就会报告“格式错误”。</p><h2 id="消失的符号"><a href="#消失的符号" class="headerlink" title="消失的符号"></a>消失的符号</h2><p>因为这些符号只在本模块内被使用，其被动态分配在栈中，链接器并不需要这些符号的信息，因此不会出现在符号表中。符号是指参与链接的变量名和函数名。</p><h2 id="寻找”Hello-World-”"><a href="#寻找”Hello-World-”" class="headerlink" title="寻找”Hello World!”"></a>寻找”Hello World!”</h2><p>用上述方法找到<code>hello</code>程序的字符串表，会发现“Hello World!”字符串…它…根本不在字符串表中，而是在<code>.rodata</code>节中。</p><p><img src="/2018/11/24/lab3-report/HelloWorld.png"></p><p>因为<code>printf</code>中的格式化字符串是一个只读的字符串，所以编译时会被放入只读数据节<code>.rodata</code>节中。</p><h2 id="冗余的符号表"><a href="#冗余的符号表" class="headerlink" title="冗余的符号表"></a>冗余的符号表</h2><p>编译单独的hello程序没有问题，但是尝试对hello.o进行链接时就会链接报错（忘了截图了）。因为符号表用于链接中的符号解析，单独运行程序时没有符号表，单有指令就也没有问题。</p><h2 id="冗余的属性？"><a href="#冗余的属性？" class="headerlink" title="冗余的属性？"></a>冗余的属性？</h2><p>起初我猜测是.bss节的数据没有在<code>Filesz</code>中被计算，而是计算在了<code>Memsz</code>中。但是我把.bss节的大小加上<code>Filesz</code>后还是比<code>Memsz</code>小一些，STFW发现stackoverflow上有人问了类似的问题，欣喜地点进去发现并没有人回答….我再思考一下说不定就有stackoverflow首答了…</p><h2 id="为什么要清零？"><a href="#为什么要清零？" class="headerlink" title="为什么要清零？"></a>为什么要清零？</h2><p>数电和问求还没写完，溜了…….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实现描述&quot;&gt;&lt;a href=&quot;#实现描述&quot; class=&quot;headerlink&quot; title=&quot;实现描述&quot;&gt;&lt;/a&gt;实现描述&lt;/h1&gt;&lt;h2 id=&quot;寻找正确的入口地址&quot;&gt;&lt;a href=&quot;#寻找正确的入口地址&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-旅行问题</title>
    <link href="https://mengzelev.github.io/2018/11/21/traversability/"/>
    <id>https://mengzelev.github.io/2018/11/21/traversability/</id>
    <published>2018-11-21T13:05:50.000Z</published>
    <updated>2018-11-30T14:19:40.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Euler图"><a href="#Euler图" class="headerlink" title="Euler图"></a>Euler图</h1><p><strong>Euler回路(Euler cycle)</strong>：图$G$的一条包含$G$的每一条边的回路$C$</p><p><strong>Euler图(Euler graph)</strong>:含有Euler回路的连通图</p><p><strong>Euler迹(Euler trial)</strong>含有连通图$G$的每条边的开迹</p><p>当讨论图的Euler性质时，</p><p><strong>定理6.1</strong>：一个非平凡连通图$G$是Euler的 当且仅当 $G$的每个顶点的度都为偶数</p><p><strong>推论6.2</strong>：一个连通图$G$含有一条Euler迹当且仅当$G$恰有两个度为奇数的顶点，而且$G$的每一条Euler迹始于一个度为奇数的顶点而终止于另一个度为奇数的顶点。</p><p><strong>例6.3结论</strong>：设$G$和$H$是两个非平凡的连通图，则$G\times H$是Euler的当且仅当$G$和$H$都是Euler的或者$G$和$H$的每个顶点度均为奇数。</p><h1 id="Hamilton图"><a href="#Hamilton图" class="headerlink" title="Hamilton图"></a>Hamilton图</h1><p><strong>Hamilton圈(Hamiltonian cycle)</strong>：一个含图$G$的每个顶点的圈</p><p><strong>Hamilton图(Hamiltonian graph)</strong>：一个含有Hamilton圈的图</p><p><strong>Hamilton路(Hamiltonian path)</strong>：一条含图$G$的每个顶点的路</p><p>有Hamilton圈, 一定有Hamilton路；<br>有Hamilton路，不一定有Hamilton圈</p><h2 id="Hamilton图的特征"><a href="#Hamilton图的特征" class="headerlink" title="Hamilton图的特征"></a>Hamilton图的特征</h2><ul><li>$n\ge 3$阶图的一个Hamilton圈$C$是$n$阶的连通2正则子图</li><li>$C$不含有阶小于$n$的圈作为子图</li><li>$G$也不含有有度大于等于3的子图</li><li>如果$G$含有度为2的顶点，则与$v$关联的两条边一定位于$C$上</li></ul><p><strong>定理6.4</strong>：Peterson图不是Hamilton的</p><h2 id="Hamilton图的性质"><a href="#Hamilton图的性质" class="headerlink" title="Hamilton图的性质"></a>Hamilton图的性质</h2><p>$k(G)$：图的连通分支数</p><p><strong>定理6.5</strong>：如果$G$是一个Hamilton图，则对$G$顶点的任一非空真子集$S$，都有$k(G-S)\ge |S|$（一个图是Hamilton图的<strong>必要条件</strong>）<br>逆否命题：设$G$为一个图。如果对$V(G)$的某个非空真子集$S$,有$k(G-S)&gt;|S|$，则$G$不是Hamilton的（一个图为非Hamilton的充分条件）<br>如果图$G$含有一个割点$v$，则$G$不是Hamilton的</p><h2 id="Hamilton图的充分条件"><a href="#Hamilton图的充分条件" class="headerlink" title="Hamilton图的充分条件"></a>Hamilton图的充分条件</h2><p><strong>定理6.6(Ore 定理)</strong>：设$G$为一个$n(n\ge 3)$阶的图，如果对于$G$的每对不邻接的顶点$u,v$，有$deg u +deg v\ge n$,则$G$是Hamilton的。<br>该定理给出的界是紧的</p><p><strong>推论6.7</strong>：设$G$为一个$n\ge 3$的图，如果对于$G$的每个顶点$v$，均有$deg v\ge n/2$，则$G$是Hamilton的。</p><p><strong>定理6.8</strong>：设$u$和$v$是一个$n$阶图$G$的两个不邻接的顶点，并且$deg u + deg v\ge n$，则$G+uv$是Hamilton的当且仅当$G$是Hamilton的。</p><p><strong>闭包(closure)</strong>：由$G$出发递归地连接度数之和至少为$n$的不邻接顶点对，记为$C(G)$</p><p><strong>定理6.9</strong>：一个图是Hamilton的当且仅当它的闭包是Hamilton的。</p><p><strong>推论6.10</strong>：如果$G$是一个阶至少为3的图，且它的闭包$C(G)$是一个完全图，则$G$是一个Hamilton图</p><p><strong>定理 6.11</strong>：设$G$是一个$n(n\ge 3)$阶的图。如果对于每个整数$j(1\le j&lt;\frac{n}{2})$，$G$中度至多为$j$的顶点数小于$j$，则$G$是Hamilton的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Euler图&quot;&gt;&lt;a href=&quot;#Euler图&quot; class=&quot;headerlink&quot; title=&quot;Euler图&quot;&gt;&lt;/a&gt;Euler图&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Euler回路(Euler cycle)&lt;/strong&gt;：图$G$的一条包含$G$的每一条
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
      <category term="Traversibility" scheme="https://mengzelev.github.io/tags/Traversibility/"/>
    
  </entry>
  
  <entry>
    <title>PA3实验报告</title>
    <link href="https://mengzelev.github.io/2018/11/18/PA3-report/"/>
    <id>https://mengzelev.github.io/2018/11/18/PA3-report/</id>
    <published>2018-11-18T08:00:32.000Z</published>
    <updated>2018-12-08T09:43:23.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PA3-实验报告"><a href="#PA3-实验报告" class="headerlink" title="PA3 实验报告"></a>PA3 实验报告</h1><p>姓名：刘恩萌<br>学号：171860013</p><h1 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h1><p>我已完成所有内容。<br>好，下面是惯例碎碎念。</p><p>2018/11/18<br>心态爆炸的一天！先是因为脑子短路完全没有想到<code>idt</code>的地址就在<code>lidt</code>译码过后的<code>id_dest</code>里。然后还因为惯性思维从<code>id_dest-&gt;val</code>里读地址，疯狂出错才发现应该在<code>id_dest-&gt;addr</code>里（因为是地址）。组织Context的时候思考了半天，最后问了大腿才知道怎么判断上下文的组织结构。感觉还是课本知识学得不够扎实的恶果。今日不宜PA，关机睡觉。</p><p>2018/11/19<br>PA3.1完成。感觉测试手段都不太给力，不知道有没有埋下隐藏bug</p><p>2018/11/24<br>PA3.2完成。感觉莫名顺利，可能是3.3要自闭的征兆</p><p>2018/12/1<br>开始自闭PA3.3，实现了文件读写操作，死活看不到PASS!!!，文件读写时对长度超过文件大小的情况的处理有一些麻烦，调了半天，最后发现是PA3.2时就好了的SYS_write没有加上刚刚写的<code>fs_write</code>，喷了。开始编写设备文件操作，看不懂vga那块到底是要干啥，机房关门了，回去睡觉。</p><p>2018/12/2<br>继续自闭PA3.3。为了看懂VGA那块的架构直接翻出了bmptest的源码，然后一路摸到NDL库的源码，花了大概一个下去终于显示出了ProjectN的Logo。实现<code>events_read()</code>时还把事件的格式搞错了debug了半天，终于可以开始跑仙剑了。小心翼翼地开始游戏，没有注释掉<code>Log</code>因此看到了瀑布般的<code>Log</code>信息，然后50min才播放完片头对话，所幸无事。然后注释掉了所有<code>Log</code>，又胆战心惊地开始尝试所有存档点，尝试了穿墙和穿人，全部失败，确认了没有肉眼可见的bug。长舒一口气，然后加急写完了批处理系统，机房关门，走人。难以置信我居然跑出了仙剑，亢奋。</p><h1 id="必答题"><a href="#必答题" class="headerlink" title="必答题"></a>必答题</h1><p><s>其实我写PA的时候都在系统调用过程梳理里做好笔记了</s></p><h2 id="游戏的存档"><a href="#游戏的存档" class="headerlink" title="游戏的存档"></a>游戏的存档</h2><ul><li>仙剑奇侠传中调用C标准I/O库函数<code>fread()</code></li><li>库函数<code>fread()</code>会调用libos中的系统调用的封装函数<code>_read()</code></li><li>libos中的<code>_read()</code>函数通过调用<code>_syscall_()</code>，直接使用内联汇编语句编译出<code>int 0x81</code>的系统调用内陷指令，并将相应的参数放入约定的寄存器中(<code>%eax</code>,<code>%ebx</code>，<code>%ecx</code>，<code>%edx</code>)</li><li>nemu执行指令时遇到了<code>int 0x81</code>指令，译码后执行<code>raise_intr()</code>，将EFLAGS，CS，EIP的值压入栈中，并到am中的中断门描述符表<code>idt</code>中查询0x81对应的跳转目标的偏移量offset，为<code>vectrap()</code></li><li><code>vectrap()</code>直接通过汇编指令将错误码<code>irq</code>压栈，然后跳转到<code>asm_jmp</code>函数执行（nexus-am/am/arch/x86-nemu/src/trap.S中定义）</li><li>在<code>asm_trap</code>中通过<code>pusha</code>指令让nemu将所有寄存器压栈，然后执行<code>irq_handle()</code>函数（在nexus-am/am/arch/x86-nemu/src/cte.c中）</li><li><code>irq_handle()</code>把执行流切换的原因打包成事件，然后调用在<code>_cte_init()</code> 中注册的事件处理回调函数, 将事件交给Nanos-lite来处理</li><li>Nanos-lite中的<code>do_event()</code>函数根据nemu打包传过来的时间决定系统调用类型，此处是<code>_EVENT_SYSCALL</code>类型的，就调用<code>do_syscall()</code>函数来处理这个系统调用</li><li><code>do_syscall()</code>根据上下文中寄存器<code>%eax</code>保存的参数确定系统调用的类型，此时为<code>SYS_read</code>类型，就调用文件系统中的<code>fs_read()</code>并将相应的参数传入</li><li><code>fs_read()</code>根据传入的文件名（存档信息文件的名称）读取需要的长度到指定的位置，恢复成存档前的状态，就可以从存档点继续游戏</li><li><code>fs_read()</code>执行完成后，一路返回到<code>asm_trap</code>中，恢复之前压入栈中保存的寄存器，然后执行<code>iret</code>指令</li><li>nemu执行<code>iret</code>指令，恢复EFLAGS，CS，EIP，跳转到EIP所指向的地方继续执行之后的指令</li></ul><p>至此，一次读取存档的系统调用全部完成</p><h2 id="更新屏幕"><a href="#更新屏幕" class="headerlink" title="更新屏幕"></a>更新屏幕</h2><ul><li>仙剑奇侠传中调用libndl中的库函数<code>NDL_DrawRect()</code></li><li><code>NDL_DrawRect()</code>会调用C标准I/O库函数<code>fwrite()</code>，将当前的像素信息写入<code>stdout</code>中，这里的<code>stdout</code>不是终端里的标准输出，而是应用程序的标准输出<code>_REENT-&gt;stdout</code></li><li>系统调用过程同上，此处不再赘述。进入Nanos-lite的文件系统后，由于是对显示设备抽象成的文件<code>/dev/fb</code>进行读取，<code>fs_write()</code>调用的是<code>fb_write()</code></li><li><code>fb_write()</code>调用了am的klib中提供的<code>screen_width()</code>和<code>draw_rect()</code></li><li>am中的<code>draw_rect()</code>调用了vga设备的写函数<code>video_write()</code>，把相应的像素信息写入到映射到<code>vga_memory</code>的物理内存中</li><li>当nemu访问到从0x4000开始的一段被映射到I/O空间的物理地址时，就会通过<code>mmio_write</code>来修改I/O空间的数据</li><li>I/O空间的数据被修改后调用了<code>update_screen()</code>，由nemu把更新后的屏幕显示信息显示了出来</li><li>进行系统调用的返回操作，同样不再赘述</li></ul><p>至此，一次更新屏幕的系统调用完成</p><h1 id="蓝框思考题"><a href="#蓝框思考题" class="headerlink" title="蓝框思考题"></a>蓝框思考题</h1><p>最近太忙了一题都没写…<br>想写的时候讲义又挂了…<br>二周目的时候再思考吧orz</p><h1 id="实验中的发现"><a href="#实验中的发现" class="headerlink" title="实验中的发现"></a>实验中的发现</h1><h2 id="关于nanos-lite和nemu是怎么通讯的"><a href="#关于nanos-lite和nemu是怎么通讯的" class="headerlink" title="关于nanos-lite和nemu是怎么通讯的"></a>关于nanos-lite和nemu是怎么通讯的</h2><p>在写PA3.1中的<code>lidt</code>指令的时候，我有个很大的疑惑，<code>idt</code>是在nanos-lite里被定义的，nemu要怎么获取它的地址呢？<code>_cte_init</code>中有一步调用了<code>set_idt</code>函数，将idt的地址和大小用内联汇编语句写入了指令集。因此当nanos编译成nemu可执行的指令后，idt的地址就可以通过相应的译码函数写入<code>id_dest</code>中。<br>问了一位nb的学长后，学长给出了如下理解</p><blockquote><p>不在system.c里的指令，一般靠编译c文件成机器码就可以给nemu做事，所以pa2很顺利；而system.c的东西依赖于系统（比如中断），只靠编译c文件做不到int、lidt这些东西，所以要内联汇编</p></blockquote><h2 id="关于如何判断-Context结构的组织顺序"><a href="#关于如何判断-Context结构的组织顺序" class="headerlink" title="关于如何判断_Context结构的组织顺序"></a>关于如何判断<code>_Context</code>结构的组织顺序</h2><p><code>_Context</code>是在函数<code>irq_handle</code>里作为参数的类型被传入的，然而<code>irq_handle</code>是通过汇编代码直接调用的，因此没有显式的参数传递语句，实际的参数是存放在栈中<code>%ebp-8</code>的位置开始的位置，观察<code>call irq_handle</code>之前所有的<code>push</code>相关语句就可以得知寄存器的顺序。而<code>eip</code>,<code>eflags</code>和<code>eip</code>是硬件保存的，因此需要观察<code>int</code>指令中的入栈顺序才能知道这三者的顺序。</p><h2 id="系统调用过程梳理"><a href="#系统调用过程梳理" class="headerlink" title="系统调用过程梳理"></a>系统调用过程梳理</h2><ol><li>用户层navy-apps在相应的系统调用函数（如<code>_exit()</code>）中调用系统调用接口函数<code>_syscall_()</code></li><li><code>_syscall_</code>用内联汇编语句将<code>int 0x80</code>和相应的系统调用参数传给nemu</li><li>nemu执行<code>int</code>指令，叫出nanos-lite</li><li><code>irq_handler</code>通过<code>int</code>指令传入的参数识别出这是一次系统调用的event，打包传给<code>do_event</code></li><li><code>irq.c</code>中的<code>do_event()</code>函数调用<code>do_syscall()</code>执行系统调用事件</li><li><code>syscall.c</code>中的<code>do_syscall()</code>函数根据传入的参数（在上下文的相应寄存器中）执行相应的系统调用操作，设置返回值并返回</li></ol><h1 id="我遇到的bug"><a href="#我遇到的bug" class="headerlink" title="我遇到的bug"></a>我遇到的bug</h1><ul><li>堆区管理的时候声明的用于记录program break的变量<code>pbrk</code>没有初始化【所以说初始化真的是个好文明</li><li>写了<code>fs_write</code>却忘了修改相应的系统调用<code>SYS_write</code>找了一个下午</li><li>所有关于文件读写的系统操作都需要控制<code>open_offset</code>，不能超过当前文件的size，但是<code>serial_write</code>和<code>dispinfo_read</code>等不同文件的读写又不能一概而论，写bug和debug的时候要特别注意</li><li><code>fs_lseek</code>最后要控制当前的<code>open_offset</code>，不然可能会导致<code>fs_read</code>和<code>fs_write</code>的功能无法正常使用</li><li><code>fs_read</code>和<code>fs_write</code>需要对<code>open_offset</code>做出修改</li><li>函数指针的调用就跟函数一样用就行了</li><li><code>fb_write</code>里的<code>offset</code>怎么用，怎么给<code>draw_rect</code>传参，可能要一直摸到<code>libnbl</code>才能搞清楚</li><li>字符串不能x**初始化，会由于某些我搞不懂的原因编译出<code>STOS</code>指令，导致看到亲切的i386 Logo</li><li><code>if((keytemp &amp; 0x8000) == 1)</code>和<code>if(keytemp &amp; 0x8000)</code>是不一样的！！！！！！[你是沙雕吗.jpg]</li></ul><h1 id="对讲义的一些建议（你们选择性反馈给yzh）"><a href="#对讲义的一些建议（你们选择性反馈给yzh）" class="headerlink" title="对讲义的一些建议（你们选择性反馈给yzh）"></a>对讲义的一些建议（你们选择性反馈给yzh）</h1><ul><li>建议把能看到<code>PASS!!!</code>信息的放在<code>serial_write()</code>之后，不少同学都在实现完<code>SYS_write</code>之后没看到PASS！！！感到困惑（当然仔细想一下还是能想通）</li><li>堆区管理那一块太考验阅读理解水平了，而且大部分人会忘掉PA2还接触过AM里一个叫<code>heap</code>的结构体，就稍微提醒一下下呗（</li><li>让dummy实现<code>_syscall_</code>时，最好能提醒一下如果按照之前加系统调用一下加入<code>do_event</code>中会触发死循环，或者干脆把下面的必做部分并到一起写，减少困惑</li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>RTFSC是很难的，不要一下子看不出来就自闭，<s>不然会出事情的</s></li><li>要成为一名优秀的程序猿，首先你要学好语文</li><li>出bug不可怕，如果能通过debug的过程对框架代码和计算机系统的原理有更深刻的理解，其实是一件很赚的事情。听了助教讲课之后我深刻感受到，一出bug就问大腿“怎么写才是对的”，实在太亏了，应该搞清楚哪里写错了，为什么写的fault这个出现这样的failure。</li></ul><h1 id="Appreciation"><a href="#Appreciation" class="headerlink" title="Appreciation"></a>Appreciation</h1><ul><li>感谢某人提供的探路和debug服务，我觉得有点保护过度了再这样下去我要不会自己写代码了【捂脸</li><li>感谢名字一直在换的学习群的群友们互帮互助的debug氛围</li></ul><p>本实验报告同样会将去掉必答题的版本同步上传至<a href="https://mengzelev.github.io/">个人blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PA3-实验报告&quot;&gt;&lt;a href=&quot;#PA3-实验报告&quot; class=&quot;headerlink&quot; title=&quot;PA3 实验报告&quot;&gt;&lt;/a&gt;PA3 实验报告&lt;/h1&gt;&lt;p&gt;姓名：刘恩萌&lt;br&gt;学号：171860013&lt;/p&gt;
&lt;h1 id=&quot;实验进度&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-图中的连通性与距离</title>
    <link href="https://mengzelev.github.io/2018/11/14/connectivity/"/>
    <id>https://mengzelev.github.io/2018/11/14/connectivity/</id>
    <published>2018-11-14T08:19:10.000Z</published>
    <updated>2018-11-30T14:19:28.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h1><p>割点的定义：去掉这个点后，原图不再连通</p><p><strong>定理5.1</strong>：设$v$是连通图$G$中与bridge相连的一个结点，则$v$是割点当且仅当$deg v\ge 2$<br>非简单树 = 端点 + 割点</p><p><strong>推论5.2</strong>：设$G$是一个至少有3个顶点的连通图，若$G$有bridge，则$G$一定有割点</p><p><strong>定理5.3</strong>：设$v$是连通图$G$的一个割点，$u$和$w$是$G-v$不同components中的两个顶点，则$v$位于$G$的任意一条$u-w$路径上。</p><p>回顾<strong>定理4.1</strong>：边$e$是bridge当且仅当$e$不存在于任何一个cycle上</p><p><strong>推论5.4</strong>：$v$是连通图$G$的一个割点 当且仅当 存在与$v$不同的两个顶点$u$和$w$，使得$v$位于$G$的任意一条$u-w$路上</p><p><strong>定理5.5</strong>：设$G$是非平凡连通图，$u\in V(G)$。若$v$是$G$中距离$u$最远的顶点，则$v$不是$G$的割点。</p><p><strong>推论5.6</strong>：任意非平凡的连通图至少包含两个非割点的顶点。</p><h1 id="块-Blocks"><a href="#块-Blocks" class="headerlink" title="块(Blocks)"></a>块(Blocks)</h1><p><strong>不可分图(nonseparable graph)：</strong>没有割点的非平凡连通图</p><p><strong>定理5.7</strong>：结点数不少于3的图是不可分的 当且仅当 任意两个顶点都位于某个圈上</p><p><strong>块(block)</strong>:图$G$的一个最大的不可分子图</p><p><strong>定理5.8</strong>：$R$是定义在非平凡连通图$G$的边集上的关系：对于$e,f\in E(G)$，若$e=f$或$e,f$位于$G$的同一个圈上，则$e,f$有关系$R$，即为$eRf$且$R$是等价关系。<br>该定理将图$G$的边画划分为了若干等价类。</p><p><strong>推论5.9</strong>：非平凡连通图$G$的任意两个不同的块$B_1$和$B_2$具有下面性质：</p><ul><li>$B_1$和$B_2$是不相交的</li><li>$B_1$和$B_2$至多有一个公共结点</li><li>若$B_1$和$B_2$有一个公共结点$v$，则$v$是$G$的割点</li></ul><h1 id="连通度"><a href="#连通度" class="headerlink" title="连通度"></a>连通度</h1><h2 id="顶点割"><a href="#顶点割" class="headerlink" title="顶点割"></a>顶点割</h2><p><strong>顶点割(vertex-cut)</strong>：顶点集$U$，$G-U$是不连通的</p><p><strong>最小顶点割</strong>：自行感受一下</p><p>只有非完全图才有顶点割，且所有非完全图都有顶点割</p><p><strong>(点)连通度(vertex-connectivity)</strong>:$\kappa(G)$=最小顶点割的基数<br>$$ 0\le \kappa(G)\le n-1 $$</p><p>图$G$是k-连通的(k-connected)，即$\kappa(G)\ge k$，随便去掉$k$个点之后依然是连通的</p><h2 id="边割-edge-cut"><a href="#边割-edge-cut" class="headerlink" title="边割(edge-cut)"></a>边割(edge-cut)</h2><p><strong>边割(edge-cut)</strong>：边集$X$，$G-X$是不连通的</p><p><strong>最小边割</strong>和<strong>极小边割</strong>是不同的概念</p><p><strong>边连通度(edge-connectivity)</strong>:$\lambda(G)$=最小边割的基数<br>$$ 0\le \lambda(G)\le n-1 $$</p><p>完全图的边连通度$\lambda(K_n)=n-1$</p><h2 id="点、边连通度间的关系"><a href="#点、边连通度间的关系" class="headerlink" title="点、边连通度间的关系"></a>点、边连通度间的关系</h2><p><strong>定理5.11</strong>：对于任意图$G$，$$\kappa(G)\le \lambda(G)\le \delta(G)$$<br>点连通度$\le$边连通度$\le$最小度数</p><p><strong>定理5.12</strong>：立方图$\kappa(G)=\lambda(G)$</p><p><strong>定理5.13</strong>：$G$顶点数为$n$，边数为$m$，则$\kappa(G)\le \lfloor\frac{2m}{n}\rfloor$</p><h2 id="Harary图"><a href="#Harary图" class="headerlink" title="Harary图"></a>Harary图</h2><p><strong>定理5.14</strong>：如果$G$是至少有3个结点的连通图，则$G^2$时候2-连通的。</p><p><strong>定理5.15</strong>：对于任意整数$r,n$满足$2\le r&lt;n$，有$$\kappa(H_{r,n})=r$</p><h1 id="Menger定理"><a href="#Menger定理" class="headerlink" title="Menger定理"></a>Menger定理</h1><p><strong>分离集(separating set)</strong>：$S$是图$G$的顶点集的一个子集，$u$和$v$是$G$的两个顶点。若$G-S$是不连通的且$u$和$v$属于$G-S$不同的连通分支，则称$S$<strong>分离</strong>$u$和$v$，$S$是一个<strong>$u-v$分离集</strong></p><p><strong>内点(internal vertex)</strong>:一条$u-v$路径上除去$u,v$的点<br><strong>内部不相交(internally disjoint)</strong>：两条路径除端点外没有公共点</p><p><strong>定理5.16(Menger定理)：</strong>设$u$和$v$是图$G$的不邻接的两个顶点，则$u-v$分离集中顶点的最小个数等于$G$中内部不相交$u-v$路的最大个数。<br>证明使用了数学归纳法，归纳步时分了3种情况讨论</p><p><strong>定理5.17</strong>：一个非平凡图$G$是$k$连通的($k\ge 2$) 当且仅当 对于$G$的任意两个顶点$u,v$，$G$至少有$k$条内部内部不相交的$u-v$路。</p><p><strong>推论5.18</strong>：设$G$为$k$连通图，$S$是由$G$中任意$k$个顶点构成的集合。若图$H$是由$G$通过添加一个新的顶点$w$以及连接$w$到$S$中所有的顶点所得，则$H$也是$k$连通的。</p><p><strong>推论5.19</strong>：若$G$为$k$连通图，$u,v_1,v_2,…,v_k$为$G$中$k+1$个不同的顶点，则$G$有内部不相交的$u-v_i$路($1\le i\le k$)</p><p><strong>定理5.20</strong>：若$G$为$k$连通图($k\ge 2$)，则$G$中任意$k$个顶点均位于某一个圈上。</p><p><strong>定理5.21</strong>：对于图$G$两个不同的顶点$u$和$v$，$G$中分离$u,v$的边的最小个额数等于$G$中边不相交$u-v$路的最大个数</p><p><strong>定理5.22</strong>：一个非平凡图$G$是$k$边连通的当且仅当对于$G$中任意两个不同的顶点$u,v$，$G$包含$k$条边不相交的$u-v$路</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;割点&quot;&gt;&lt;a href=&quot;#割点&quot; class=&quot;headerlink&quot; title=&quot;割点&quot;&gt;&lt;/a&gt;割点&lt;/h1&gt;&lt;p&gt;割点的定义：去掉这个点后，原图不再连通&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理5.1&lt;/strong&gt;：设$v$是连通图$G$中与bridge相
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
      <category term="Connectivity" scheme="https://mengzelev.github.io/tags/Connectivity/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-所有结点对的最短路径问题</title>
    <link href="https://mengzelev.github.io/2018/11/07/clrs-25All-Pairs-Shortest-Paths/"/>
    <id>https://mengzelev.github.io/2018/11/07/clrs-25All-Pairs-Shortest-Paths/</id>
    <published>2018-11-07T08:17:34.000Z</published>
    <updated>2018-11-19T00:56:44.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><p>$l_{ij}^(m)}$:从结点$i$到结点$j$的至多包含$m$条边的任意路径中的最小权重。<br>$$<br>l_{ij}^{(m)} = \min\limits_{1\lek\le n}{l_{ik}^{(m1)}+w_{kj}}<br>$$</p><h2 id="自底向上计算最短路径权重"><a href="#自底向上计算最短路径权重" class="headerlink" title="自底向上计算最短路径权重"></a>自底向上计算最短路径权重</h2><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/extend.png"></p><p>三重循环，时间复杂度为$\Theta(n^3)$</p><p>形式上与矩阵乘法的计算非常类似</p><p>计算$L^{(n-1)}=W^{n-1}$</p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/slowall.png"><br>这个算法本质上就是对$n$个点每个跑了一遍Bellman-Ford</p><h2 id="改进运行时间"><a href="#改进运行时间" class="headerlink" title="改进运行时间"></a>改进运行时间</h2><p>重复平方技术<br>二分计算矩阵的幂</p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/chongfu.png"></p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/faster.png"></p><p>优化后时间复杂度为$\Theta(n^3\lgn n)$</p><h1 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h1><p>枚举最短路径上的中间结点来进行递归的计算</p><ul><li>不允许有负权重环</li><li>但是可以做到在有负权重环的情况下报告（看对角元是否有负数）</li></ul><p>$d_{ij}^{(k)}$：从$i$到$j$经过的中间结点为${1,…k}$的子集的最短路径长度<br><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/d.png"></p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/floyd-alg.png"></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$\Theta(n^3)$</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>看似需要$\Theta(n^3)$，但是作业题中证明了只需要一个矩阵来存储，为$\Theta(n^2)$</p><h2 id="构建最短路径"><a href="#构建最短路径" class="headerlink" title="构建最短路径"></a>构建最短路径</h2><p>采用动态规划的思想，递推式如下</p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/pi0.png"></p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/pik.png"></p><h1 id="用于稀疏图的Johnson算法"><a href="#用于稀疏图的Johnson算法" class="headerlink" title="用于稀疏图的Johnson算法"></a>用于稀疏图的Johnson算法</h1><p>用一种神奇的方式对图中每条边的权重进行重新赋值，使新的图满足</p><ul><li>所有权重都为非负值</li><li>新图中的最短路径就是旧图中的最短路径</li></ul><h2 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/Johnson.png"></p><p>先增加一个新结点$s$，该点到原先各结点都有边相连，权重为0<br>对新图进行一次Bellman-Ford算法，寻找是否有负权重环路<br>没有负权重环，就用神奇的长得像顶点的势能函数一样的函数给每条边重新赋值<br>$$ \hat{w}(u,v)=w(u,v)+h(u)-h(v)$$<br>$$ h(u)=\delta(s,u)$$<br>然后对每个点进行Dijkstra<br>最后记得将最短路径的权重恢复，并存入矩阵$D$中返回</p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>二叉最小优先队列实现Dijkstra：$O(VE\lg V)$<br>斐波那契堆实现：$O(V^2\lgV+VE)$<br>在稀疏图的情况下，表现比Floyd-Warshall好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;矩阵乘法&quot;&gt;&lt;a href=&quot;#矩阵乘法&quot; class=&quot;headerlink&quot; title=&quot;矩阵乘法&quot;&gt;&lt;/a&gt;矩阵乘法&lt;/h1&gt;&lt;h2 id=&quot;最优子结构&quot;&gt;&lt;a href=&quot;#最优子结构&quot; class=&quot;headerlink&quot; title=&quot;最优子结构&quot;&gt;
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
      <category term="All-Pairs Shortest Path" scheme="https://mengzelev.github.io/tags/All-Pairs-Shortest-Path/"/>
    
  </entry>
  
  <entry>
    <title>Lab2:链接与加载 实验报告</title>
    <link href="https://mengzelev.github.io/2018/11/06/lab2-report/"/>
    <id>https://mengzelev.github.io/2018/11/06/lab2-report/</id>
    <published>2018-11-06T09:17:47.000Z</published>
    <updated>2018-11-30T14:17:54.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>按照实验讲义的提示，首先找到了libc库所在的位置，输出基本与讲义中给出的一致，不作赘述。</p><p>编写的测试文件a.c的代码为</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main (){    int a = rand();    printf(&quot;%d\n&quot;,a);    return 0;}</code></pre><p>只需要有对<code>rand</code>的调用且保证不会被编译器优化掉就可以了。</p><p>找到动态库文件之后，对该二进制文件进行反汇编</p><pre><code>$ objdump -d /lib/x86_64-linux-gnu/libc.so.6 &gt; libc64</code></pre><p>然后对反汇编后的文件进行查看，可以看到一堆库函数的反汇编代码。此时我看到了讲义中的这句话：</p><blockquote><p>然后你会发现这个文件对你并没有什么卵用，好吧，其实一会儿是会用到的。</p></blockquote><p>导致我真的以为现在用不到这个文件，于是，我<s>傻fufu地</s>按照讲义的指示去找<code>rand</code>函数的地址了。<br><code>gdb</code>，启动！看到了一堆跳转语句，感受到了自己对课本内容掌握不足；<br>课本，打开！复习了一下动态链接相关的知识点；<br><code>gdb</code>，开始！单步执行到<code>&lt;rand@plt&gt;</code>处时，发现了<code>rand</code>对应的GOT表项的地址，为<code>0x55555575020</code></p><p><img src="/2018/11/06/lab2-report/rand_id.png"></p><p>然后疯狂<code>si</code>，会看一堆<code>dl_</code>开头的，八成是和动态链接有关的函数。一不小心回车过头，最后在<code>main</code>里停下来，总之动态链接过程已经完成了，这时候可以查看内存地址为<code>0x55555575020</code>处的内容为<code>0x7ffff7a70820</code>（忘了截图了）</p><p>打印<code>0x7ffff7a70820</code>的内容，确认了确实为<code>rand</code>函数的地址</p><p><img src="/2018/11/06/lab2-report/rand.png"></p><p>做到这里，感觉像是完成了什么，开始思考下一步要做什么。等一下，我们的最终目标不是只要得到<code>system</code>到<code>rand</code>的偏移量吗，那我费尽千辛万苦搞到<code>rand</code>的地址干什么……算了，就当复习了一下动态链接的相关知识点和回忆了一下<code>gdb</code>的使用方法吧</p><p>不管了，总之先打开之前反汇编的动态库看一下，分别找到<code>rand</code>和<code>system</code>的地址</p><p><img src="/2018/11/06/lab2-report/rand64.png"></p><p><img src="/2018/11/06/lab2-report/system64.png"></p><p>偏移量为<code>0x3f480-0x36820=0x8c60</code></p><p>为了验证一下正确性，使用<code>gdb</code>打印了和<code>rand</code>具有相应偏移量（其实就是后3位不同）出的内存内容</p><p><img src="/2018/11/06/lab2-report/system.png"></p><p>这下准没错了，于是开始编写<code>oj_killer</code>函数</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>最初仅考虑64位情况的<code>oj_killer</code>函数代码如下</p><pre><code>#include &lt;stdlib.h&gt;void* oj_killer(){        void* randptr = (void *)rand;        //获得rand函数的地址        return (void*)(randptr + 0x8c60);        //加上libc中rand到system的偏移量，返回system函数的地址}</code></pre><p>编译运行后能够成功输出<code>Hello World</code></p><p><img src="/2018/11/06/lab2-report/hello64.png"></p><h2 id="兼容32位"><a href="#兼容32位" class="headerlink" title="兼容32位"></a>兼容32位</h2><p>接下来考虑32位的情况</p><p>如果将上述程序直接编译为32位，会得到<code>Illegal instruction</code>的错误</p><p><img src="/2018/11/06/lab2-report/illegal.png"></p><p>对<code>a.c</code>加上<code>-m32</code>选项进行编译后查看其调用的动态链接库，可以发现调用的是32位的库，和64位的库是不一样的（当然了</p><pre><code>$gcc a.c -m32 -o a32.out$file a32.outa32.out: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically link│ed, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=b3e591a0858f18│2549e63239c338f5fd30496ce2, not stripped $ldd a32.out                                              linux-gate.so.1 (0xf77ac000)                                                      libc.so.6 =&gt; /lib32/libc.so.6 (0xf75d1000)                                        /lib/ld-linux.so.2 (0xf77ae000)$file -L /lib32/libc.so.6                             /lib32/libc.so.6: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=84bb53910470c7ceb2a0963044117fdf8a2bb975, for GNU/Linux 2.6.32, stripped  </code></pre><p>使用同样的方法进行反汇编后</p><pre><code>$objdump -d /lib32/libc.so.6 &gt; libc32</code></pre><p>分别得到<code>rand</code>和<code>system</code>在<code>libc</code>内的地址</p><p><img src="/2018/11/06/lab2-report/rand32.png"></p><p><img src="/2018/11/06/lab2-report/system32.png"></p><p>于是可以按照同样的思路编写代码</p><h2 id="真·代码解释"><a href="#真·代码解释" class="headerlink" title="真·代码解释"></a>真·代码解释</h2><pre><code>void* oj_killer(){    int type = sizeof(void*);    void* randptr = (void *)rand;    //获得rand函数的地址    if(type == 8)     //判断当前环境是否为64-bit        return (void*)(randptr + 0x8c60);    //加上64位时libc中的偏移量    else return (void*)(randptr - 0x2f6f0 + 0x3a850);         //加上32位时libc的偏移量}</code></pre><p>为了保证代码的可移植性，特意将变量<code>randptr</code>声明为<code>void*</code>类型，而非<code>int</code>或<code>long long</code>。<br>判断当前环境为32/64位则依靠对<code>void*</code>长度的判断。 <s>暴露了不太会用<code>#if</code>预编译指令的事实</s></p><p>分别按32位和64位编译后，可以得到<code>Hello World</code>的输出：</p><p><img src="/2018/11/06/lab2-report/success.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验过程&quot;&gt;&lt;a href=&quot;#实验过程&quot; class=&quot;headerlink&quot; title=&quot;实验过程&quot;&gt;&lt;/a&gt;实验过程&lt;/h2&gt;&lt;p&gt;按照实验讲义的提示，首先找到了libc库所在的位置，输出基本与讲义中给出的一致，不作赘述。&lt;/p&gt;
&lt;p&gt;编写的测试文件a.
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
  <entry>
    <title>PA2实验报告</title>
    <link href="https://mengzelev.github.io/2018/11/06/PA2-report/"/>
    <id>https://mengzelev.github.io/2018/11/06/PA2-report/</id>
    <published>2018-11-06T01:33:26.000Z</published>
    <updated>2018-11-06T01:34:50.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验进度描述"><a href="#实验进度描述" class="headerlink" title="实验进度描述"></a>实验进度描述</h1><p><strong>2018/10/04</strong><br>RTF实验讲义，RTFSC，我是谁，我在哪儿，我要干什么</p><p><strong>2018/10/05</strong><br>经历了两天的RTFSC后终于看懂了框架代码是干嘛的，RTFM实现了<code>sub</code>,<code>push</code>,<code>ret</code>,<code>call</code>等指令，在nemu中运行了第一个程序<code>dummy</code></p><p><strong>2018/10/21</strong><br>听了同学们的建议，先实现了<code>diff-test</code>，结果发现PA2.1的指令实现有bug。修复了这些bug并温故框架代码的构成</p><p><strong>2018/10/22</strong><br>花了一整天对照着FM实现了exec目录下大部分指令，填写<code>opcode_table</code>巨表，然而有海量bug等待发现</p><p><strong>2018/10/27</strong><br>开<code>diff-test</code>跑完了cputest中所有的测试，修复了能发现的PA2.2中的bug。<code>bash runall</code>后看到了绿油油的full-combo，心情舒畅。<s>然而并不知道2.3的时候还有海量bug等着自己</s></p><p><strong>2018/10/28</strong><br>实现了<code>string.c</code>中所有的库函数和<code>sprintf</code>，先在nemu外单独手动测试，然后放入klib中，成功运行<code>string.c</code>和<code>hell-str.c</code>，PA2.2基本完成，<code>make submit</code></p><p><strong>2018/11/2</strong><br>实现了<code>in/out</code>指令，成功运行<code>hello</code>。与同学出去吃火锅，讨论发现自己的<code>diff-test</code>歪打正着可以正常运行。</p><p><strong>2018/11/3</strong><br>实现了<code>printf</code>，测试时钟时陷入莫名其妙的Segmentation Fault，在指令中加入大量Log测试，无果；找到大腿进行文件替换，无果；把指令实现和库函数又给了大腿二号进行替换，发现一切运行正常。心态爆炸，怀疑人生，git滚回到2.2完成的状态，从2开始的PA2.3。修仙实现了时钟、键盘和vga，并通过了相关测试，成功运行打字游戏（虽然慢的一笔）。跑分测试时还是出现了bug，遂开启<code>diff-test</code>后滚去睡觉</p><p><strong>2018/11/4</strong><br>起来看到结果发现是<code>neg</code>指令写错了，修复bug后成功运行了三个跑分测试。看到超级无敌慢动作马里奥，差点笑死，<s>录成视频发到qq空间被jyy点赞了</s>。复习链接相关知识，自学Makefile语法，编写硬核实验报告。</p><h1 id="必答题"><a href="#必答题" class="headerlink" title="必答题"></a>必答题</h1><blockquote><p>只有聪明的人才看得见</p></blockquote><h1 id="我遇到的那些bug"><a href="#我遇到的那些bug" class="headerlink" title="我遇到的那些bug"></a>我遇到的那些bug</h1><p>以后实验报告新增这一环节，希望可以帮到其他人</p><ul><li>有些指令不是RTL完了就完事的，还需要<code>operand_write</code>写入到相应位置</li><li>test指令手册表意不清，虽然写了<code>DEST := LeftSRC AND RightSRC</code>，但是两个操作数并不需要改变，不需要进行<code>operand_write</code></li><li>框架里已经为你准备了丰富多彩的译码函数，有些指令有自己特殊的译码函数，赶紧到<code>decode.h</code>里去康康吧！</li><li><code>ret</code>指令需要跳转到返回地址的，没有好好RTFM的后果</li><li><code>sar</code>是需要符号扩展的</li><li>译码函数的立即数读入也是需要符号扩展的</li><li>编译<code>timetest</code>的时候链接出错：<code>undefined reference to</code>，其实是因为<code>stdio.c</code>没有加上重要的头文件</li><li>运行跑分测试<code>coremark</code>时出现内存地址越界，发现是<code>opcode_table</code>中的<code>imul</code>指令的译码函数写错了</li><li><code>neg</code>指令只需要直接取反加一</li><li>不知道时钟怎么写，可以参考一下<code>_putc</code>的代码，里面有提示</li><li><code>native</code>的输入输出实现里有不少提示可供参考</li><li><strong>框架代码中没有rol指令，不知道是可爱PA作者的疏忽还是故意让我们练手的</strong></li></ul><h1 id="蓝框思考题"><a href="#蓝框思考题" class="headerlink" title="蓝框思考题"></a>蓝框思考题</h1><p>临近期中考试，时间不是很充裕，写得很少，但愿今后有机会二周目思考吧</p><ul><li><p>Q:AT&amp;T格式反汇编结果中的少量指令, 与i386手册中列出的指令名称不符, 如cltd. 除了STFW之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?<br>A:先STFW试图搞清楚这个指令是干什么的，然后翻手册的目录寻找描述差不多的指令。比如<code>cltd</code>是Convert longword to doubleword的意思，翻手册的目录能找到意思差不多的Convert word to double word。运气好的话可能在STFW的时候就能找到对应的i386的指令名称了。</p></li><li><p>Q：你或许会感到疑惑, 代码优化不是一件好事情吗? 为什么会有volatile这种奇葩的存在? 思考一下, 如果代码中p指向的地址最终被映射到一个设备寄存器, 去掉volatile可能会带来什么问题?<br>  A：因为编译器基本是根据输入输出状态进行的代码优化，而我们有些时候是care中间过程的，例如lab01中的性能测试。如果代码中<code>p</code>指向的地址最终被映射到一个设备寄存器，可能会发生设备状态的跳变，比如显示器某块地方应该是由蓝变绿再变红，会直接从蓝色变成红色。</p></li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>未测试的代码永远是错的，测试过的代码也不会是对的！隐藏bug无处不在。【PA2.2full-combo的大家几乎都在2.3里发现了cputests没能暴露的bug，以此类推PA3的时候可能还会发现PA2的bug</li><li>要及时坚定滚回去从头再来的决心，试过了力所能及的所有方法都找不出来的bug就不要找了，肯定是在一些玄学的地方犯了玄学的错误，干脆从头重新写一遍</li><li>am相关的概念还不是非常清楚，目前还不影响做实验，但还是想进一步了解</li><li>Copy-paste是坏文明</li><li>github private远程库保命是真的很重要，安心多了</li><li>跑分结果堪忧，但是本着先写对，再完美的宗旨，<s>不管了</s>还是值得开心一下的</li><li>bug死活找不出的时候容易心态血崩，但是这时候只要实现一个小的功能就能瞬间高兴回来</li><li>敲代码真**开心</li></ul><h1 id="Appreciation"><a href="#Appreciation" class="headerlink" title="Appreciation"></a>Appreciation</h1><ul><li>感谢“™写™PA真™开心”群的群友们，一起修仙，一起写bug，一起交流bug，帮忙debug，<s>还在心态快崩的时候一起出去约了顿火锅</s></li><li>感谢xy同学，提供了可供替换的大腿，做得太快了，还给我剧透了不少，让我少踩了不少坑</li><li>感谢ldw同学，用我的代码替换到了他的代码上证明我的指令集和库函数并没有大问题，给了我滚回去重做的决心（</li><li>感谢某位还是不愿意透露姓名的nb学长，通过千里眼，帮忙发现了不少bug</li></ul><p>本实验报告同样会将去掉必答题的版本同步上传至<a href="https://mengzelev.github.io/">个人blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验进度描述&quot;&gt;&lt;a href=&quot;#实验进度描述&quot; class=&quot;headerlink&quot; title=&quot;实验进度描述&quot;&gt;&lt;/a&gt;实验进度描述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;2018/10/04&lt;/strong&gt;&lt;br&gt;RTF实验讲义，RTFSC，我是谁，我在哪儿，
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-单源最短路径</title>
    <link href="https://mengzelev.github.io/2018/10/30/clrs-24Single-Source-Shortest-Path/"/>
    <id>https://mengzelev.github.io/2018/10/30/clrs-24Single-Source-Shortest-Path/</id>
    <published>2018-10-30T14:29:50.000Z</published>
    <updated>2018-11-07T08:18:49.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前备概念"><a href="#前备概念" class="headerlink" title="前备概念"></a>前备概念</h1><h2 id="环路"><a href="#环路" class="headerlink" title="环路"></a>环路</h2><p>如果有<strong>负权重环路</strong>，问题比较大，因为你在环路里往死里转路径要多短有多短，这时候定义最短路径长度为负无穷。$\delta(u,v)=-\infty$</p><p>如果有<strong>正权重环路</strong>，那最短路径肯定不会走这个环路，所以不影响</p><p>如果有<strong>0权重环路</strong>，那这个环路等于没有，也不影响</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>$v.d$：最短路径估计</p><p>使用下面运行时间为$\Theta(V)$的算法来对最短路径估计和前驱结点进行初始化：</p><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/initialize.png"></p><p>初始化操作的时间复杂度为$\Theta(V)$</p><h2 id="松弛操作"><a href="#松弛操作" class="headerlink" title="松弛操作"></a>松弛操作</h2><p>松弛过程：试图改善从$s$到$v$的最短路径。<br>可能降低最短路径的估计值$v.d$并更新$v$的前驱属性$v.\pi$</p><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/relax.png"></p><p>松弛是<strong>唯一</strong>导致最短路径估计和前驱结点发生变化的操作</p><p>本章讨论的所有算法之间的不同之处是对每条边进行松弛的次数和松弛边的次序有所不同</p><h2 id="最短路径和松弛操作的性质"><a href="#最短路径和松弛操作的性质" class="headerlink" title="最短路径和松弛操作的性质"></a>最短路径和松弛操作的性质</h2><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/properties.png"><br>这几条最好要背下来的，我觉得考试很容易考</p><p>为了方便记忆，po主尝试着<s>用人话</s>复述一遍：</p><ul><li><strong>三角不等式性质：</strong>图里任意两个点和源点$s$构成一个三角形（可以退化为直线），有两边之和大于等于第三边</li><li><strong>上界性质：</strong>$v.d$撑死就是$\delta(s,v)$，不能再小了</li><li><strong>非路径性质：</strong>原话已经很人话了</li><li><strong>收敛性质：</strong>松弛前边的起点已求得最短路径，松弛后边的终点也将获得最短路径buff</li><li><strong>路径松弛性质：</strong>只要一条最短路径上的点是按松弛的，那么估计值就等于最短路径</li><li><strong>前驱子图性质：</strong>最短路径算完了，前驱子图是一颗根结点为$s$的最短路径树</li></ul><h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h2><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><ul><li>先将结点进行初始化</li><li>对每条边进行$|V|-1$次松弛操作</li><li>当存在负权重环路时会返回FALSE</li><li>如果不存在负权重环路，则返回TRUE，每个结点的$v.d$即为源点$s$到该点的最短路径长度</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/BF-alg.png"></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(VE)$</p><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>用到了三角不等式 + 非路径性质 + 前驱子图性质 </p><h1 id="有向无环图（DAG）中的单源最短路径问题"><a href="#有向无环图（DAG）中的单源最短路径问题" class="headerlink" title="有向无环图（DAG）中的单源最短路径问题"></a>有向无环图（DAG）中的单源最短路径问题</h1><p>无环，因此没有负权重的环，对于任何结点，最短路径都是存在的</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>先对DAG进行拓扑排序，按照拓扑排序的顺序对每个结点进行松弛操作</p><h2 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/dag-alg.png"></p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>拓扑排序(1)： $\Theta(V+E)$</li><li>初始化(2)：$\Theta(V)$</li><li>3~5行的循环（聚合分析）：$\Theta(V)$<br>总时间复杂度：$\Theta(V+E)$</li></ul><h2 id="正确性证明-1"><a href="#正确性证明-1" class="headerlink" title="正确性证明"></a>正确性证明</h2><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/24-5.png"><br>精髓还是在于神奇的路径松弛性质，只要保证每条最短路径上边的松弛次序，就能得出算法终止时$v_i.d=\delta(s,v_i)$</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>PERT图</p><h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><ul><li>解决带权重的有向图上的单源最短路径问题</li><li>要求所有边的权重都为<strong>非负值</strong></li><li>维护一组结点结合$S$，从源点$s$到该集合中每个结点之间的最短路径已经被找到</li><li>使用贪心策略，每次都从结点集$V-S$中选择最短路径估计最小的结点$u$，然后更新与$u$相连的结点的最短路径估计值</li></ul><h2 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/dijkstra-alg.png"></p><h2 id="正确性证明-2"><a href="#正确性证明-2" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>循环不变式：在算法第4~8行的<code>while</code>语句的每次循环开始前，对于每个结点$v\in S$，有$v.d=\delta(s,v)$</p><p>证明使用了反证法+最小数原理<br>关键步用到了收敛性质和权重非负的假设</p><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>依赖于最小优先队列的实现</p><ul><li>数组遍历： $O(V^2)$</li><li>二叉堆：$O(E\lg V)$</li><li>斐波那契堆:$O(V\lg V+E)$</li></ul><h1 id="最短路径性质的证明"><a href="#最短路径性质的证明" class="headerlink" title="最短路径性质的证明"></a>最短路径性质的证明</h1><h2 id="三角不等式"><a href="#三角不等式" class="headerlink" title="三角不等式"></a>三角不等式</h2><p>根据最短路径的定义即可得证</p><h2 id="最短路径树性质"><a href="#最短路径树性质" class="headerlink" title="最短路径树性质"></a>最短路径树性质</h2><p>最短路径树的三条性质：</p><ul><li>$v’$是图$G$中从源结点$s$可以到达的所有结点的集合</li><li>$G’$形成一棵根结点为$s$的树</li><li>对于所有的结点$v\in V’$，图$G’$中从结点$s$到结点$v$的唯一简单路径是图$G$中从结点$s$到结点$v$的一条最短路径</li></ul><p><u>未完待不会续</u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前备概念&quot;&gt;&lt;a href=&quot;#前备概念&quot; class=&quot;headerlink&quot; title=&quot;前备概念&quot;&gt;&lt;/a&gt;前备概念&lt;/h1&gt;&lt;h2 id=&quot;环路&quot;&gt;&lt;a href=&quot;#环路&quot; class=&quot;headerlink&quot; title=&quot;环路&quot;&gt;&lt;/a&gt;环路&lt;/h
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Single Source Shortest Path" scheme="https://mengzelev.github.io/tags/Single-Source-Shortest-Path/"/>
    
      <category term="Bellman-Ford" scheme="https://mengzelev.github.io/tags/Bellman-Ford/"/>
    
      <category term="Dijkstra" scheme="https://mengzelev.github.io/tags/Dijkstra/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-基本图论算法</title>
    <link href="https://mengzelev.github.io/2018/10/24/clrs-22graphic-algs/"/>
    <id>https://mengzelev.github.io/2018/10/24/clrs-22graphic-algs/</id>
    <published>2018-10-24T06:20:35.000Z</published>
    <updated>2018-10-30T15:04:07.416Z</updated>
    
    <content type="html"><![CDATA[<p><u>辣鸡po主只挖坑不填坑</u><br>因为作业实在太多了！！！</p><p>试一下<code>Mathjax</code>有没有配置成功！</p><h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><h2 id="邻接链表-Adjacency-list"><a href="#邻接链表-Adjacency-list" class="headerlink" title="邻接链表(Adjacency-list)"></a>邻接链表(Adjacency-list)</h2><ul><li>由一个包含$|V|$条链表的数组<code>Adj</code>所构成，<code>Adj[u]</code>包含所有与结点u之间有右边相连的结点v</li><li>存储空间需求：$\Theta(V+E)$</li><li>鲁棒性高，稍加修改可以支持许多图的变种（如：有权图）</li><li>缺陷：无法快速判断一条边是否在图中</li></ul><h2 id="邻接矩阵-Adjacency-matrix"><a href="#邻接矩阵-Adjacency-matrix" class="headerlink" title="邻接矩阵(Adjacency-matrix)"></a>邻接矩阵(Adjacency-matrix)</h2><ul><li>用矩阵来存储连通信息</li><li>存储空间需求：<code>\Theta(V^2)</code> 与边数|E|无关</li><li>简单，图规模较小时优先使用</li></ul><h1 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>从一个源结点s开始，每次从已发现的结点向未发现的结点扩展</li><li>算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点</li><li>用三种颜色标记结点的访问状态：<ul><li>白色：未被发现</li><li>黑色：本身被发现且所有与之相连的结点都已经被发现</li><li>灰色：本身被发现且与之相连的结点中存在未被发现的</li></ul></li><li>结果可能以来</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><center><br><img src="/2018/10/24/clrs-22graphic-algs/bfs-alg.png"><br></center><ul><li>使用队列存储所有灰色结点</li><li><code>while</code>循环的循环不变式：队列Q中包含的是灰色结点的集合</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>结点信息初始化： O(V)</li><li>队列操作总时间： O(V) （每个结点都要进出各一次）</li><li>扫描邻接链表： O(E)</li></ul><p><strong>总时间复杂度：</strong> O(V+E)<br>是图G的邻接链表大小的一个线性函数</p><h2 id="最短路径正确性证明"><a href="#最短路径正确性证明" class="headerlink" title="最短路径正确性证明"></a>最短路径正确性证明</h2><p>一堆定理和证明</p><h2 id="广度优先树"><a href="#广度优先树" class="headerlink" title="广度优先树"></a>广度优先树</h2><h1 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h1><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>大胆地往前走，走到底再回头（雾</li><li>深度优先搜索的前驱子图可能有多棵树组成，即<strong>深度优先森林</strong>因为搜索可能从多个源结点重复进行</li><li>对结点进行黑白灰染色，可以保证每个结点仅在一棵深度优先树中出现，保证所有的深度优先树是不相交的</li><li>时间戳： 每个结点v有两个时间戳<ul><li>第一个时间戳<code>v.d</code>记录结点v第一次被发现的时间（染上灰色的时候）</li><li>第二个时间戳<code>v.f</code>记录搜索完成对v的邻接链表扫描的时间（图上黑色的时候）</li><li>时间戳都是处于1和2|V|之间的整数</li><li><code>u.d</code> &lt; <code>u.f</code></li></ul></li><li>非树边：<ul><li>前向边F：从祖先指向后代</li><li>后向边B：从后代指向祖先（包括有向图中的自循环）</li><li>横向边C：两端点无血缘关系</li></ul></li></ul><h2 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h2><center><br><img src="/2018/10/24/clrs-22graphic-algs/dfs-alg.png"><br></center><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>结点信息初始化： O(V)</li><li><code>DFS-VISIT</code>： O(E)</li></ul><p><strong>总运行时间： </strong>O(V+E)</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>能提供关于图结构的价值很高的信息</p><h2 id="括号化结构"><a href="#括号化结构" class="headerlink" title="括号化结构"></a>括号化结构</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;辣鸡po主只挖坑不填坑&lt;/u&gt;&lt;br&gt;因为作业实在太多了！！！&lt;/p&gt;
&lt;p&gt;试一下&lt;code&gt;Mathjax&lt;/code&gt;有没有配置成功！&lt;/p&gt;
&lt;h1 id=&quot;图的表示&quot;&gt;&lt;a href=&quot;#图的表示&quot; class=&quot;headerlink&quot; title=&quot;图的表
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Single Source Shortest Path" scheme="https://mengzelev.github.io/tags/Single-Source-Shortest-Path/"/>
    
      <category term="Bellman-Ford" scheme="https://mengzelev.github.io/tags/Bellman-Ford/"/>
    
      <category term="Dijkstra" scheme="https://mengzelev.github.io/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-树</title>
    <link href="https://mengzelev.github.io/2018/10/14/tree/"/>
    <id>https://mengzelev.github.io/2018/10/14/tree/</id>
    <published>2018-10-14T08:00:05.000Z</published>
    <updated>2018-10-15T01:17:40.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本章可用结论整理"><a href="#本章可用结论整理" class="headerlink" title="本章可用结论整理"></a>本章可用结论整理</h1><ul><li>定理4.1：e是图G的桥当且仅当e不在G的任何一个cycle上</li><li>定理4.2：图G是树当且仅当G的任意两个顶点只有唯一的path相连</li><li>定理4.3：每一棵非简单树都有至少两个端点(end-vertice)</li><li>定理4.4：每棵有n个顶点的树都有n-1条边</li><li>推论4.6：每棵有k个component的森林都有n-k条边</li><li>定理4.7：每一个有n个顶点的连通图至少有n-1条边</li><li>定理4.8：有n个顶点、m条边的图G，若满足以下3条性质中的2条：(1)连通 (2)无环 (3)m = n - 1，则G是树</li><li>定理4.9：设T是一棵有k个顶点的树。如果图G中最小的度数不小于k-1，那么T与G的某个子图同构</li><li>定理4.10：每个连通图都包含了一棵生成树</li><li>定理4.15(Tree Formula): 有n个不相同的顶点的树的个数为$n^{n-2}$</li><li>定理4.16(Matrix Tree Theorem):<br><img src="/2018/10/14/tree/theorem4-16.png"></li></ul><h1 id="桥-Bridges"><a href="#桥-Bridges" class="headerlink" title="桥(Bridges)"></a>桥(Bridges)</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>如果$e=uv$是连通图$G$的一条边，且$G-e$不连通，则$e$称为连通图$G$的<strong>桥</strong>.</p><p>如果$G$是非连通图，那么<strong>桥</strong>$e$是G一个部分(component)的桥。</p><p>考虑componnet的数目，边$e$是图$G$的桥当且仅当$k(G-e)=k(G)+1$</p><h2 id="定理4-1"><a href="#定理4-1" class="headerlink" title="定理4.1"></a>定理4.1</h2><p>$e$是图$G$的桥当且仅当$e$不在$G$的任何一个cycle上。</p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树即<strong>无环的连通图</strong>。<br>树<strong>所有</strong>的边都是桥。<br>树也是所有边都是桥的连通图。</p><p><strong>双星(double star)</strong>:包含了恰好两个非端点的树（这两个端点必然相邻）</p><p><strong>毛虫树(caterpillar)</strong>:定点数大于等于3、除去端点后得到的是path的树。<br>除去端点后得到的path叫作毛虫树的<strong>脊椎(spine)</strong>；<br>顶点数不小于3的path，star，double star都是毛虫树<br><s>端点其实就是毛毛虫的脚脚</s></p><p><strong>森林(Forests)</strong>:无环图。森林的每个component的都是树。(过于形象<br>森林不一定要是连通的，但是树必须是。</p><h2 id="定理4-2"><a href="#定理4-2" class="headerlink" title="定理4.2"></a>定理4.2</h2><p>图$G$是树当且仅当$G$的任意两个顶点只有唯一的path相连</p><p>这个证明嘛，只有唯一的path不是和无环是等价的吗(流汗.jpg</p><h2 id="定理4-3"><a href="#定理4-3" class="headerlink" title="定理4.3"></a>定理4.3</h2><p>每一棵非简单树都有至少两个端点(end-vertice)</p><p>证明取了最长路径的两个端点，利用了最长路径上的端点都不与非路径上点相邻的性质，证得最长路径的两个端点都是end-vertice</p><p>这条性质非常有用，可以成为对树结构使用<strong>数学归纳法</strong>的依据，划掉一个端点就会使order-1<br>使用数学归纳法证明图相关结论的关键在于<strong>找到一个end-vertice</strong></p><h2 id="定理4-4"><a href="#定理4-4" class="headerlink" title="定理4.4"></a>定理4.4</h2><p>每棵有n个顶点的树都有n-1条边</p><p>证明使用了基于定理4.3的数学归纳法，很直观</p><h2 id="推论4-6"><a href="#推论4-6" class="headerlink" title="推论4.6"></a>推论4.6</h2><p>每棵有k个component的森林都有n-k条边</p><p>简单的边数计算就能证明</p><h2 id="定理4-7"><a href="#定理4-7" class="headerlink" title="定理4.7"></a>定理4.7</h2><p>每一个有n个顶点的连通图至少有n-1条边。</p><p>证明用到了最小数原理，假设存在一个顶点最少的图少于n-1条边，然后证明此时至少会有一个端点(end vertex)，这时就可以把那一个端点去掉得到一个更小的满足条件的图，从而与假设矛盾。</p><h2 id="定理4-8"><a href="#定理4-8" class="headerlink" title="定理4.8"></a>定理4.8</h2><p>有n个顶点、m条边的图G，若满足以下3条性质中的2条：</p><ul><li>连通</li><li>无环</li><li>m = n - 1<br>则G是树</li></ul><p>证明非常直观，活用了上面的定理</p><h2 id="定理4-9"><a href="#定理4-9" class="headerlink" title="定理4.9"></a>定理4.9</h2><p>设T是一棵有k个顶点的树。如果图G中最小的度数不小于k-1，那么T与G的某个子图同构</p><h1 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h1><p>实际中存在村庄造路的问题，即造一些路使得所有村庄都连通，并保证造这些路的开销最小<br>这样的问题可以归结为最小生成树问题，求解一个有权图中权值最小的生成树</p><h2 id="Kruskal’s-Algorithm"><a href="#Kruskal’s-Algorithm" class="headerlink" title="Kruskal’s Algorithm"></a>Kruskal’s Algorithm</h2><p>算法描述：先取权最小的两条边，从第三次开始，每次都取不与取过的边构成cycle的、权最小的边，直到取满n-1条边为止。类似于贪心算法。</p><p>正确性证明也类似于证明贪心用到的<strong>替换法</strong>，取最优解中与算法解重叠最大的解，进行替换，导出矛盾。</p><h2 id="Prim’s-Algorithm"><a href="#Prim’s-Algorithm" class="headerlink" title="Prim’s Algorithm"></a>Prim’s Algorithm</h2><p>算法描述：先取权最小的一条边，之后每次都选择连接了未连接的点和已连接的点的边中权最小的一条，知道选择了n-1条边为止。类似于动态规划。</p><p>证明思路类似于<strong>剪切-粘贴法</strong>。难以概括……</p><h1 id="生成树的个数"><a href="#生成树的个数" class="headerlink" title="生成树的个数"></a>生成树的个数</h1><p>书上这部分完全就是在讲故事啊(╯°Д°)╯︵┻━┻</p><h1 id="图论证明特点"><a href="#图论证明特点" class="headerlink" title="图论证明特点"></a>图论证明特点</h1><p><s>自己xjb总结的，仅供参考</s></p><ul><li>多用反证法</li><li>…….我再想想</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本章可用结论整理&quot;&gt;&lt;a href=&quot;#本章可用结论整理&quot; class=&quot;headerlink&quot; title=&quot;本章可用结论整理&quot;&gt;&lt;/a&gt;本章可用结论整理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;定理4.1：e是图G的桥当且仅当e不在G的任何一个cycle上&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph" scheme="https://mengzelev.github.io/tags/Graph/"/>
    
      <category term="Tree" scheme="https://mengzelev.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Lab1-乘法 实验报告</title>
    <link href="https://mengzelev.github.io/2018/10/12/lab1-report/"/>
    <id>https://mengzelev.github.io/2018/10/12/lab1-report/</id>
    <published>2018-10-12T09:17:47.000Z</published>
    <updated>2018-10-15T01:25:08.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务1：实现multimod"><a href="#任务1：实现multimod" class="headerlink" title="任务1：实现multimod"></a>任务1：实现<code>multimod</code></h1><p>使用了高精度数乘法计算<code>a*b</code>，然后模拟手算除法的形式写了高精度除法（取模）。代码见文件<code>p1.c</code>.</p><h2 id="正确性-伪-证明"><a href="#正确性-伪-证明" class="headerlink" title="正确性(伪)证明"></a>正确性(伪)证明</h2><p>使用python随机生成生成了1000000组a、b、m，0~9223372036854775807(int64_t的最大值)并计算对应答案，与p1.c的计算结果进行对比。</p><p>python随机数生成代码如下：</p><pre><code>import randomMAX = 9223372036854775807for i in range(1,1000000)：    a = random.randint(0,MAX)    b = random.randint(0,MAX)    m = random.randint(1,MAX)    ans = (a * b) % m    print (a,b,m,ans)</code></pre><p>测试结果一百万组全对（从零开始计数的）<br><img src="/2018/10/12/lab1-report/1.png"></p><h1 id="任务2：性能优化"><a href="#任务2：性能优化" class="headerlink" title="任务2：性能优化"></a>任务2：性能优化</h1><p>由于是先听的课再做的lab，出于惰性直接按照jyy课上讲的方法做了<s>（我去面壁）</s>就不多解释了，代码见p2.c</p><h2 id="时间测试思路"><a href="#时间测试思路" class="headerlink" title="时间测试思路"></a>时间测试思路</h2><p>STFW找到了计算使用<code>time.h</code>库函数计算运行时间的方法，也有计算时钟周期的方法，但是后者使用了汇编代码，在对未知事物的恐惧(这样真的不好)的驱使下还是选择了比较好理解、比较好控制的前者。为了防止计算步骤被优化，又不能让多于的操作占用过多的时间，就使程序计算了正确的case的个数并输出。所以得到的时间应该比实际运行时间长一些。</p><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p><img src="/2018/10/12/lab1-report/time.png"><br>注：其中<code>p1.c</code>为任务一中的高精度实现，<code>p2.c</code>为任务二中的优化算法，<code>p3.c</code>为任务三中的神奇代码</p><h2 id="运行时间分析"><a href="#运行时间分析" class="headerlink" title="运行时间分析"></a>运行时间分析</h2><p>记<code>a,b,m</code>的位数为n<br>高精度除法需要做<code>O(n)</code>次减法和比较，每次减法和比较的时间复杂度也都为<code>O(n)</code>，因此总时间复杂度是<code>O(n^2)</code><br>任务二中优化过的时间需要循环次数是<code>O(n)</code>的，每次循环的操作都能在常数时间<code>O(1)</code>内完成，因此总时间复杂度为<code>O(n)</code><br>而神奇代码对任何输入消耗的时间都是相同的，时间复杂度为<code>O(1)</code><br>从运行时间上来看的确是<code>t(p1)&gt;t(p2)&gt;t(p3)</code>，符合预期<br>一个神奇的现象是，随着优化等级的升高，运行时间不一定缩短。尤其是p2.c的运行情况，O1和O2反而不如O0（虽然也只差了0.001ms），于是我反汇编对比了一下，发现<code>multimod</code>、<code>testcases</code>和<code>main</code>几个函数的汇编代码几乎一模一样，但对应行的行数不同，可能是调用了不同的系统库函数。对优化的原理不太了解，暂时无法想到合理的解释。可能是因为这个程序的优化空间不是太大？但是编译器肯定比我智能多了，我想不到优化方法不能看不起编译器啊。</p><h1 id="任务3：解析神秘代码"><a href="#任务3：解析神秘代码" class="headerlink" title="任务3：解析神秘代码"></a>任务3：解析神秘代码</h1><p><strong>结论</strong>：<code>ab</code>乘积不超过<code>2^53</code>次方，<code>m</code>在<code>int64_t</code>范围内任意取值，可以保证<code>multimod_fast</code>总是能返回正确的数值</p><p>过程非常曲折，以下都是流水账碎碎念，老师嫌长可以不看，自己写着好玩，回头上传个人Blog</p><p>刚拿到手先试了一大堆随机数据，发现一百万组测试样例总只能过1w+组，正确率非常低。后来和同学讨论了一下，听说<code>m</code>比较小的时候结果最容易出错，我就把<code>m</code>的随机范围改成了<code>1~3</code>，果然错误率高了很多。大概是因为神秘代码中<code>(int64_t)((double)a * b / m + 1e-8)</code>强制类型转换后要除以<code>m</code>，如果<code>m</code>偏小，那么<code>a*b</code>的误差就很容易保存下来，引起答案出错。</p><p>保持<code>m</code>1~3的范围，我又试了几组大数。发现是在<code>ab</code>乘积为<code>10^19</code>左右的时候（a和b在算法找中地位是等价的，所以只需要关注<code>ab</code>的乘积的范围）会出现计算错误，于是在这个范围附近取了一些数，绝了，这个使结果正确的区间并不是连续的！然后理智烧却瞎测了几组数据，不太能发现规律，决定先冷静下来，从理论上思考一下算法。<s>毕竟这次是关于数据表示形式的Lab嘛</s></p><p>这个神奇代码大概是把ab乘积转换为<code>double</code>类型。<code>double</code>类型能表示的范围是大于<code>int64_t</code>的，但是精度不够，尾数部分只有52位的精度（加上前面的1一共是53位），所以应该是只能保证这53位的精度，于是我打开<code>python</code>计算器计算了一下<code>2^26.5 =</code>，大概是94900000，于是我把任务一中随机数的生成范围改为了<code>(0,94900000)</code>，测试了5次，每次一百万组，都是全对的。</p><p><img src="/2018/10/12/lab1-report/double.png"></p><p>到这里我就很想吐槽了，这范围怎么还能算<code>int64_t</code>的，保证结果正确的<code>a</code>和<code>b</code>的范围<code>int</code>都达不到，如果能保证输入在这个范围之内，还不如直接用<code>int64_t</code>算呢，<code>ab</code>相乘肯定不会溢出的。但是如果<code>a</code>和<code>b</code>乘积位表示下末尾零比较多，还是有可能正确的。所以这根本就是一份拼人品的神奇代码吗…..</p><p>目前尚未想通的问题：</p><ul><li>为什么要<code>+1e-8</code>？</li><li>为什么返回时需要判断<code>t</code>的正负并做相应修正？</li></ul><p>最后，这个神奇代码毕竟是<code>O(1)</code>的，凭我的算法功底实在没办法优化到<code>O(n)</code>以下，所以神奇代码虽然正确率不高，但是效率还是很感人的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;任务1：实现multimod&quot;&gt;&lt;a href=&quot;#任务1：实现multimod&quot; class=&quot;headerlink&quot; title=&quot;任务1：实现multimod&quot;&gt;&lt;/a&gt;任务1：实现&lt;code&gt;multimod&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;使用了高精度数乘法
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-用于不相交集合的数据结构</title>
    <link href="https://mengzelev.github.io/2018/10/06/clrs-21DisjointSets/"/>
    <id>https://mengzelev.github.io/2018/10/06/clrs-21DisjointSets/</id>
    <published>2018-10-06T08:05:58.000Z</published>
    <updated>2018-10-07T07:33:25.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不相交集合的操作"><a href="#不相交集合的操作" class="headerlink" title="不相交集合的操作"></a>不相交集合的操作</h1><p>一个<strong>不相交集合数据结构</strong>维护了一个不相交动态集的集合<br>每个集合都有一个<strong>代表</strong>标识，它是该集合的某个成员</p><p>我们希望集合支持以下三个操作：</p><p><img src="/2018/10/06/clrs-21DisjointSets/operations.png"></p><h2 id="应用：确定无向图的连通分量"><a href="#应用：确定无向图的连通分量" class="headerlink" title="应用：确定无向图的连通分量"></a>应用：确定无向图的连通分量</h2><center><br><img src="/2018/10/06/clrs-21DisjointSets/g21-1.png"><br><img src="/2018/10/06/clrs-21DisjointSets/alg1.png"><br></center><p>算法就是将连通的顶点全部合并到同一个集合中。</p><h1 id="不相交集合的链表表示"><a href="#不相交集合的链表表示" class="headerlink" title="不相交集合的链表表示"></a>不相交集合的链表表示</h1><p>每个集合可以用一个自己的链表来表示<br>链表中对象可以以任意次序出现</p><p>每个链表组成为：</p><ul><li><code>head</code>– 指向表的第一个对象（代表元）</li><li><code>tail</code>– 指向表的最后一个对象</li></ul><p>链表中每个对象的组成为：</p><ul><li>关键字<code>key</code></li><li>指向<code>head</code>的指针<code>prev</code></li><li>指向后一个对象的指针<code>next</code></li></ul><p>时间复杂度：<br><code>MAKE-SET</code>  O(1)<br><code>FIND-SET</code>  O(1)<br><code>UNION</code>（简单实现） $\Theta(n^2)$  【摊还分析】</p><h2 id="简单加权合并启发式策略"><a href="#简单加权合并启发式策略" class="headerlink" title="简单加权合并启发式策略"></a>简单加权合并启发式策略</h2><p>策略是，每次合并时都将较小的链表挂到较大的链表上，需要多维护一个链表长度的属性。</p><p><img src="/2018/10/06/clrs-21DisjointSets/21.1.png"></p><p>证明的核心在于每个对象的指针在所有的<code>UNION</code>操作中最多被更新$\lceil\lg n\rceil$次，因此所有<code>UNION</code>操作中被更新的对象的指针总数为$O(n\lg n)$。加上<code>MAKE-SET</code>和<code>FIND-SEt</code>的O(m)。 </p><h1 id="不相交集合森林"><a href="#不相交集合森林" class="headerlink" title="不相交集合森林"></a>不相交集合森林</h1><p>使用有根树来表示集合。<br>每棵树表示一个集合，树的根结点是该集合的代表元。<br>执行<code>UNION</code>操作时将两棵树的树根合并。<br>实现时可以用到两种改进运行时间的启发式策略。</p><h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>类似链表的加权合并启发式策略<br>为了易于分析，对于每个结点，维护一个<strong>秩</strong>，表示该结点高度的一个上界。<br>秩<code>x.rank</code>代表x的高度的一个上界，高度即<u>从x到某一后代叶结点的最长简单路径上边的数目</u>。<br><code>UNION</code>操作中</p><ul><li>如果根的秩不同，则让较大秩的根成为较小秩的根的父结点，但秩本身保持不变</li><li>如果根的秩相同，则任意选择两个中的一个作为父结点，并使它的秩+1</li></ul><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>在<code>FIND-SET</code>操作中是查找路径中的每个结点直接指向根，不改变任何结点的秩。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><center><br><img src="/2018/10/06/clrs-21DisjointSets/makeset.png"><br><img src="/2018/10/06/clrs-21DisjointSets/union.png"><br><img src="/2018/10/06/clrs-21DisjointSets/findset.png"><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;不相交集合的操作&quot;&gt;&lt;a href=&quot;#不相交集合的操作&quot; class=&quot;headerlink&quot; title=&quot;不相交集合的操作&quot;&gt;&lt;/a&gt;不相交集合的操作&lt;/h1&gt;&lt;p&gt;一个&lt;strong&gt;不相交集合数据结构&lt;/strong&gt;维护了一个不相交动态集的集合&lt;br&gt;
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Disjoint Sets" scheme="https://mengzelev.github.io/tags/Disjoint-Sets/"/>
    
      <category term="Data Structure" scheme="https://mengzelev.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>做pa的时候可能会用到的操作</title>
    <link href="https://mengzelev.github.io/2018/10/04/pa-inspirations/"/>
    <id>https://mengzelev.github.io/2018/10/04/pa-inspirations/</id>
    <published>2018-10-04T09:18:29.000Z</published>
    <updated>2018-10-04T09:21:25.581Z</updated>
    
    <content type="html"><![CDATA[<p>当做笔记随便写写的，希望能帮到一些人吧。毕竟作为一名优秀的bug maker，别人遇到的问题我基本都能遇到的。</p><p>vim和tmux另外写了教程：</p><p><a href="https://mengzelev.github.io/2018/09/06/vim/">vim初探</a></p><p><a href="https://mengzelev.github.io/2018/09/12/tmux/">使用tmux变身炫酷程序猿(x</a></p><p><u>持续更新中</u><br>最后更新:</p><blockquote><p>2018/10/04 17:18:29 新增PA2时运行dummy出错的解决方式</p></blockquote><h1 id="语言规范"><a href="#语言规范" class="headerlink" title="语言规范"></a>语言规范</h1><hr><p>这名字很中二…但其实就是个人写文章的时候一点习惯用的表示，和别人的可能不一样，很可能非常不标准，注意区分就好</p><ul><li>[]方括号表示需要自定义的内容，括起来的只是你应该输入的东西的名字</li><li>$开头的表示在命令行中键入的代码，否则为文件中的代码</li></ul><h1 id="在整个目录下查找代码"><a href="#在整个目录下查找代码" class="headerlink" title="在整个目录下查找代码"></a>在整个目录下查找代码</h1><hr><p>在某个文件里看到某个函数或者宏或者变量的定义的时候经常会好奇在哪里、怎么使用过，除了用<code>/+(搜索内容)</code>靠vim的功能在文件内搜索外，还可以</p><pre><code>$ grep &quot;搜索内容&quot; -r &lt;目录&gt;</code></pre><p>e.g.</p><pre><code>$ grep &quot;CPU_state&quot; -r .</code></pre><p>其中-r表示递归搜索，可以搜索整个目录下所有的文件</p><h1 id="一键跳转定义处"><a href="#一键跳转定义处" class="headerlink" title="一键跳转定义处"></a>一键跳转定义处</h1><hr><p>创建接口的时候经常需要查看某些函数、宏、结构体的定义，于是被某位nb的学长安利了ctags神器，可以一键跳转至定义处并一键调回，先贴上自己查到的教程</p><p>首先需要<strong>安装</strong>ctags，一般来说直接apt就好了，但是莫名不行，可能是镜像源的问题</p><pre><code>$ sudo apt install ctags</code></pre><p>于是我选择了从<a href="http://ctags.sourceforge.net/" target="_blank" rel="noopener">ctags官网</a>手动下载<code>ctags-5.8.tar.gz</code></p><p>如果是在host里下载的，下载后通过自己的共享方式扔到虚拟机里面，进行<strong>解压缩</strong></p><pre><code>$ cd [压缩包所在目录]$ tar jxvf [文件名].tar.bz</code></pre><p>解压后<strong>手动安装</strong></p><pre><code>$ cd ctags-5.8$ ./configure$ make$ make install</code></pre><p>安装完成后<strong>测试</strong>一下是否安装成功</p><pre><code>$ whereis ctags</code></pre><p>你应该能看到让你觉得成功的提示信息。</p><p>安装成功后，为源码<strong>生成tags文件</strong>，在需要使用ctags的目录下(所有子目录都可以享受到)运行</p><pre><code>$ ctags -R</code></pre><p>为了使得字段补全有效，在生成tags时需要一些额外的参数，推荐的c语言（c处可以替换成其他语言）参数主要是：</p><pre><code>$ ctags -R --c-kinds=+px --fields=+iaS --extra=+q</code></pre><p>其中，fileds 用于指定每条标记的扩展字段域，extra 选项用于增加额外的条目，f表示每个文件增加一个条目，q为每个类增加一个条目</p><p>之后<strong>配置vim</strong>，就不用每次都手动设置</p><pre><code>$ vim ~/.vimrc</code></pre><p>在.vimrc 中加入如下内容</p><pre><code>set tags=[path]/tagsset tags=./tags,tags;$HOME</code></pre><p>第二行我暂时也不知道是干什么的，但是不加上去好像用不起来（小声</p><p>然后用vim编辑你需要的代码文件，当光标落到你想查询定义的函数上时使用<code>Ctrl + ]</code>跳转到定义处<s>（其实明明是两键跳转对不对）</s>，然后<code>Ctrl + o</code>或者<code>Ctrl + t</code>返回跳转前的位置。</p><p><a href="https://www.cnblogs.com/zl-graduate/p/5777711.html" target="_blank" rel="noopener">参考教程原地址</a></p><h1 id="编译dummy时出错"><a href="#编译dummy时出错" class="headerlink" title="编译dummy时出错"></a>编译dummy时出错</h1><p>进行到<strong>PA2</strong>开始时，试图编译dummy会产生如下的报错：</p><center><br><img src="/2018/10/04/pa-inspirations/cdefs.png"><br></center><p>这时候如果STFW得到的答案应该是安装<code>libc6-dev-i386</code></p><pre><code>$ sudo apt-get install libc6-dev-i386</code></pre><p>然而我装了之后还是报错，到stackoverflow上稍微刨了一下发现可能还需要安装<code>gcc-multilib</code></p><pre><code>$ sudo apt-get install gcc-multilib</code></pre><p>然后可以开始愉快的PA2了</p><center><br><img src="/2018/10/04/pa-inspirations/dummy.png"><br></center><p><a href="https://askubuntu.com/questions/470796/fatal-error-sys-cdefs-h-no-such-file-or-directory" target="_blank" rel="noopener">stackoverflow原回答地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当做笔记随便写写的，希望能帮到一些人吧。毕竟作为一名优秀的bug maker，别人遇到的问题我基本都能遇到的。&lt;/p&gt;
&lt;p&gt;vim和tmux另外写了教程：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mengzelev.github.io/2018/09/06/vim
      
    
    </summary>
    
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
      <category term="Linux" scheme="https://mengzelev.github.io/tags/Linux/"/>
    
      <category term="vim" scheme="https://mengzelev.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>PA1实验报告</title>
    <link href="https://mengzelev.github.io/2018/10/04/PA1-report/"/>
    <id>https://mengzelev.github.io/2018/10/04/PA1-report/</id>
    <published>2018-10-04T09:17:47.000Z</published>
    <updated>2018-10-04T09:18:35.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h1><p><strong>2018/9/15：</strong><br>完成阶段一，实现了单步执行、打印寄存器和扫描内存（简易版）<br>开始做之前忘了<code>git checkout pa1</code>导致工作都在pa0分支里完成了，后来在pa1分支下返工了一遍，<strong>两边的git log里都可以查到记录所以求求老师不要扣我的分qwq</strong>我下次确定一定肯定确认分支后再开始工作</p><p><strong>2018/9/23:</strong><br>完成阶段二，实现了包含<code>(</code>、<code>)</code>、<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>和十进制数字的表达式计算。为了处理负数将类型都实现为了<code>long long</code>而不是<code>uint32_t</code>，需要按<code>uint32_t</code>类型使用时进行强制类型转换。实现了表达式生成器并测试。</p><p><strong>2018/9/29:</strong><br>完成阶段三，扩展了表达式计算中的<code>==</code>、<code>!=</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&lt;</code>、解除引用和寄存器计算。实现了监视点添加、删除和打印信息功能。用自带的用户镜像初步测试无问题。</p><p><strong>2018/9/30:</strong><br>早上起来和同学聊天发现了自己监视点实现的隐藏bug，一开始看了半天没理解到底怎么回事，然后动手加了一堆<code>printf</code>语句缩小范围终于找到了出错的区间，虽然具体的原理还没理解透彻，但是靠着一知半解成功修复了隐藏bug。</p><p><img src="/2018/10/04/PA1-report/bug.png" height="200"></p><h1 id="必答题"><a href="#必答题" class="headerlink" title="必答题"></a>必答题</h1><p>不敢po上来的！</p><h1 id="部分蓝框思考题"><a href="#部分蓝框思考题" class="headerlink" title="部分蓝框思考题"></a>部分蓝框思考题</h1><p><strong>Q：</strong>假设你在Windows中使用Docker安装了一个GNU/Linux container, 然后在container中完成PA, 通过NEMU运行Hello World程序. 在这样的情况下, 尝试画出相应的层次图.<br><strong>A：</strong>参考了docker官网上的架构图</p><table><thead><tr><th style="text-align:center">架构</th></tr></thead><tbody><tr><td style="text-align:center">“Hello World” program</td></tr><tr><td style="text-align:center">simulated x86 hardware</td></tr><tr><td style="text-align:center">NEMU</td></tr><tr><td style="text-align:center">bins/libs</td></tr><tr><td style="text-align:center">Docker</td></tr><tr><td style="text-align:center">host os  (windows)</td></tr><tr><td style="text-align:center">Hardware</td></tr></tbody></table><p><strong>Q：</strong>如果没有寄存器, 计算机还可以工作吗? 如果可以, 这会对硬件提供的编程模型有什么影响呢?<br><strong>A：</strong>我认为没有寄存器计算机是可以工作的，但是效率会非常低，因为数据的读写只能从内存中进行，而内存的读写速度是慢于寄存器的。而且现在我们学的IA-32架构是不允许在两个内存单元之间进行数据操作的，必须用寄存器作为中间媒介。编程模型一周目的我查了一下没有看懂，但愿二周目的我能看懂吧。</p><p><strong>Q：</strong>我们知道, 时序逻辑电路里面有”状态”的概念. 那么, 对于TRM来说, 是不是也有这样的概念呢? 具体地, 什么东西表征了TRM的状态? 在状态模型中, 执行指令和执行程序, 其本质分别是什么?<br><strong>A：</strong>TRM中存在一个叫做状态寄存器的组成部分，会存储图灵机当前的状态。（状态模型又是什么）执行指令和执行程序的本质区别是程序是一大堆指令的集合。（个人理解）</p><p><strong>Q：</strong>嗯… 如果你觉得提示还不够, 那就来一个劲爆的: 回忆程序设计课的内容, 一个程序从哪里开始执行呢?如果你不屑于回答这个问题, 不妨先冷静下来. 其实这是一个值得探究的问题, 你会在将来重新审视它.<br><strong>A：</strong>我正在尝试冷静下来….</p><p><strong>Q：</strong>阅读reg_test()的代码, 思考代码中的assert()条件是根据什么写出来的<br><strong>A：</strong>我不太理解“根据什么写出来”是什么意思……反正没有对错我就说一下个人理解吧。reg_test里的assert们应该是check了一下所有寄存器的存储状态，包括整个32位、低16位和两个低8位，从而来检查CPU_state的结构是否正确。根据…根据CPU_state应有的结构写出来的？</p><p><strong>Q：</strong>在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1, 你知道这是什么意思吗?<br><strong>A：</strong>这样就不会做<code>cpu_exec()</code>中的for循环而直接执行<code>if(nemu_state == NEMU_RUNNING) nemu_state = NEMU_STOP</code>语句实现单步执行。</p><p><strong>Q：</strong>opcode_table到底是个什么类型的数组?<br><strong>A：</strong>是一个opcode_entry结构体类型的数组，通过RTFSC推测应该是模拟指令码的结构体。</p><p><strong>Q：</strong>你可能会抑制不住编码的冲动: 与其RTFM, 还不如自己写. 如果真是这样, 你可以考虑一下, 你会如何测试自己编写的字符串处理函数?<br><strong>A：</strong><s>其实我更愿意RTFM，有现成的为什么要造轮子</s><br>写个随机生成字符串的程序产生输入，然后将输入和输出全部都输出肉眼比对一下，大概测试个20组没问题就当过了吧。（做oj的后遗症）</p><p><strong>Q：</strong>框架代码中定义<code>wp_pool</code>等变量的时候使用了关键字<code>static</code>, <code>static</code>在此处的含义是什么? 为什么要在此处使用它?<br><strong>A：</strong>static是Internal Linkage的意思，是指编译过程中进行链接时由<code>static</code>修饰的变量不参与与外部文件的链接。这样就使外部的函数一旦使用了这几个变量，编译器就会报错，保证了与WP相关的操作都只能定义在这个文件中。（如果真是这样就有点OOP的感觉？对外只提供接口，实现都在内部，保证了数据和操作的安全性）</p><p>剩下一些思考题要么是能力不够STFW找不到满意的答案，要么是找到了看上去满意的答案然而看不懂….</p><h1 id="遇到的问题以及对问题的思考"><a href="#遇到的问题以及对问题的思考" class="headerlink" title="遇到的问题以及对问题的思考"></a>遇到的问题以及对问题的思考</h1><ul><li>git merge的时候发生了conflict<br>STFW之后发现需要先git reset –merge然后cat冲突文件查看是哪里冲突，修改相应地方之后再git merge</li><li>全部写完之后才发现写错分支了<br>本来以为git merge之后再给分支重命名就可以了，但是各种冲突实在太多了，所以重新写了一遍，血的教训告诉我们以后一定要在写之前反复检查git branch。因为难以找到一段完整的时间一次性写完，所以每次开始工作之前都需要git branch。</li><li>vim忽然“死机”<br>写完一段之后下意识Ctrl+S，之后发现其实是把vim锁定了，Ctrl+Q解锁</li><li>vim非正常退出后再次打开与.swp文件发生冲突<br>按R检查是否是自己需要的状态，然后rm .[filename].c.swp将交换文件删除（删之前一定要谨慎不然就是作死）</li><li><strong>量子态更新<a href="https://mengzelev.github.io/">个人blog</a>中，<s>欢迎老师视奸后加分</s></strong></li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>PA虽然是个时间黑洞但是真的很好玩！</li><li>开始动手之前一定要认真RTFSC</li><li>看不懂代码的时候手动加点测试可以帮助理解</li><li>人真是越学越挑剔，曾经我可以看着全默认的ui手动缩进代码，现在编辑器要是没有（配置）喜欢的字体、自动缩进、括号匹配、甚至一键函数跳转，我可能都会当场疯掉<s>某种意义上越挑剔也就越有学习的欲望</s>很多大佬的故事都告诉我们，工具的改进源于对现有工具的极大不爽</li><li>PA1完全是写给自己用的程序而不是OJ那样的了，一定要扪心自问：你写的代码对得起你自己吗？</li></ul><h1 id="Acknowledegments"><a href="#Acknowledegments" class="headerlink" title="Acknowledegments"></a>Acknowledegments</h1><ul><li>感谢 Massimo同学 在我vim出现异常的时候告诉我是<code>Ctrl+s</code>把屏幕给锁死了并成功教我“急救”方法</li><li>感谢 某不愿透露姓名的nb学长 帮忙看了一下表达式生成器的bug，还解决了我的一堆疑问，并且提供深夜debug陪聊服务，并给我负罪感使我以后牢记优先STFW</li><li>感谢 xy同学 提供轻度剧透，使我避免了一些bug，还告诉了我一个隐藏bug的存在</li><li>感谢 不学习的正经水群 交流pa心得一起快乐编程</li></ul><p><u>实验报告虽然写了很多还是意犹未尽啊，为了赶ddl并尽快愉快地开始PA2先交了，等ddl过了之后会上传删掉了必做题的版本到个人blog，不定时更新</u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验进度&quot;&gt;&lt;a href=&quot;#实验进度&quot; class=&quot;headerlink&quot; title=&quot;实验进度&quot;&gt;&lt;/a&gt;实验进度&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;2018/9/15：&lt;/strong&gt;&lt;br&gt;完成阶段一，实现了单步执行、打印寄存器和扫描内存（简易版）&lt;b
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
  </entry>
  
  <entry>
    <title>关于“过程调用”的讨论</title>
    <link href="https://mengzelev.github.io/2018/09/27/ics-process-calling/"/>
    <id>https://mengzelev.github.io/2018/09/27/ics-process-calling/</id>
    <published>2018-09-27T01:59:13.000Z</published>
    <updated>2018-10-04T09:15:16.428Z</updated>
    
    <content type="html"><![CDATA[<p>这是计算机系统基础课上的开放课题，在不同环境下测试一些UB的结果，照理说此处应该有分析但是萌捷列夫懒了，等ddl处理掉了再来写。</p><h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#include &lt;stdio.h&gt; int main(int argc, char* argv[]){    int a = 10;    double *p = (double*)&amp;a;    printf(&quot;%f\n&quot;, *p);    printf(&quot;%f\n&quot;, ((double)(a)));return 0;}</code></pre><h2 id="windows10"><a href="#windows10" class="headerlink" title="windows10"></a>windows10</h2><p>环境：dev-cpp/TDM-GCC 4.9.2 64bit Release</p><p><img src="/2018/09/27/ics-process-calling/ics1-win.png"></p><p><img src="/2018/09/27/ics-process-calling/ics1-win-asm.png"></p><h2 id="Debian-64bit"><a href="#Debian-64bit" class="headerlink" title="Debian-64bit"></a>Debian-64bit</h2><p><img src="/2018/09/27/ics-process-calling/ics1-debian.png"></p><p><img src="/2018/09/27/ics-process-calling/ics1-debian-asm.png"></p><h2 id="Ubuntu-32bit"><a href="#Ubuntu-32bit" class="headerlink" title="Ubuntu-32bit"></a>Ubuntu-32bit</h2><p><img src="/2018/09/27/ics-process-calling/ics1-ubuntu.png"></p><p><img src="/2018/09/27/ics-process-calling/ics1-ubuntu-asm.png"></p><h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code>#include&lt;stdio.h&gt;int main(){    double a = 10;    printf(&quot;a = %d\n&quot;, a);    return 0;}</code></pre><h2 id="windows10-1"><a href="#windows10-1" class="headerlink" title="windows10"></a>windows10</h2><p><img src="/2018/09/27/ics-process-calling/ics2-win.png"></p><p><img src="/2018/09/27/ics-process-calling/ics2-win-asm.png"></p><h2 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h2><p><img src="/2018/09/27/ics-process-calling/ics2-debian.png"></p><p><img src="/2018/09/27/ics-process-calling/ics2-debian-asm.png"></p><h2 id="Ubuntu-32bit-1"><a href="#Ubuntu-32bit-1" class="headerlink" title="Ubuntu-32bit"></a>Ubuntu-32bit</h2><p><img src="/2018/09/27/ics-process-calling/ics2-ubuntu.png"></p><p><img src="/2018/09/27/ics-process-calling/ics2-ubuntu-asm.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是计算机系统基础课上的开放课题，在不同环境下测试一些UB的结果，照理说此处应该有分析但是萌捷列夫懒了，等ddl处理掉了再来写。&lt;/p&gt;
&lt;h1 id=&quot;实验一&quot;&gt;&lt;a href=&quot;#实验一&quot; class=&quot;headerlink&quot; title=&quot;实验一&quot;&gt;&lt;/a&gt;实验一&lt;/
      
    
    </summary>
    
    
      <category term="ics" scheme="https://mengzelev.github.io/tags/ics/"/>
    
      <category term="process calling" scheme="https://mengzelev.github.io/tags/process-calling/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习笔记</title>
    <link href="https://mengzelev.github.io/2018/09/21/regex/"/>
    <id>https://mengzelev.github.io/2018/09/21/regex/</id>
    <published>2018-09-21T14:04:40.000Z</published>
    <updated>2018-09-21T14:38:21.936Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，贴4张截图就跑路（。</p><p>有空还是会回来写的，容我先把ddl肝完（瘫）。</p><p><a href="http://docs.huihoo.com/c/linux-c-programming/ch32.html" target="_blank" rel="noopener">PA讲义中的Linux-C教程</a></p><p><img src="/2018/09/21/regex/table1.png"><br><img src="/2018/09/21/regex/table2.png"><br><img src="/2018/09/21/regex/table3.png"><br><img src="/2018/09/21/regex/table4.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话不多说，贴4张截图就跑路（。&lt;/p&gt;
&lt;p&gt;有空还是会回来写的，容我先把ddl肝完（瘫）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.huihoo.com/c/linux-c-programming/ch32.html&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
      <category term="regular expressions" scheme="https://mengzelev.github.io/tags/regular-expressions/"/>
    
      <category term="linux" scheme="https://mengzelev.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-摊还分析</title>
    <link href="https://mengzelev.github.io/2018/09/17/clrs-17amortized/"/>
    <id>https://mengzelev.github.io/2018/09/17/clrs-17amortized/</id>
    <published>2018-09-17T15:47:29.000Z</published>
    <updated>2018-09-20T15:58:45.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h1><p>聚合分析指，证明对所有n，一个n个操作的序列的最坏情况下花费的总时间为T(n)。因此在最坏情况下，每个操作的平均代价，或<strong>摊还代价</strong>为T(n)/n。</p><p>摊还操作可以看作是不带概率计算的平均情况分析。因为概率不好计算。<s>概率什么时候好计算过了</s></p><p>此摊还代价适用于<strong>每个</strong>操作，即使序列中有多种类型的操作也是如此。</p><p>算法导论上给出的示例为<strong>增加了MULTIPOP的栈操作</strong>和<strong>二进制计数器递增</strong>问题，简单概括一下二者的共同点：</p><ul><li>需要分析复杂度的操作由连续的n个操作构成</li><li>每个单步操作的时间复杂度难以确定为与n有关的表达式，与当前状态密切相关</li><li>对每个单步操作取最坏情况得出的上界过于宽松，浪费时间</li><li>n个连续操作的总时间复杂度比较容易求得</li></ul><p>大致感觉就是，使用摊还分析可以给这些操作一个<strong>清白</strong>，它们事实上没有那么慢。</p><h1 id="核算法"><a href="#核算法" class="headerlink" title="核算法"></a>核算法</h1><p>核算法就是对不同的操作赋予不同的信用，这个信用值可能会多于或少于实际消耗的代价。实际操作时采用多退少补的原则，保证总信用（支付的代价-实际的代价）始终非负即可。</p><p>一般用于解决不同操作间具有依赖关系的问题，例如聚合分析中提到的<strong>栈操作问题</strong>（出栈操作次数上界即为进栈操作次数）和<strong>二进制计数器递增问题</strong>（复位操作次数依赖于置位操作次数）。</p><h1 id="势能分析"><a href="#势能分析" class="headerlink" title="势能分析"></a>势能分析</h1><p>势能分析看上去更加数(wu)学(li)一点，与核算法有点类似，不同之处势能分析为每一个状态都设置了一个对应的势能，即势能函数。虽然在操作过程中势能可能有升有降，但只要最终势能是增加的，就可以证明代价的上界。</p><p>选择势能函数应该是比较困难的。产生的摊还代价依赖于选择的势能函数。具体根据需要证明的上界来选择适度的势能函数，毕竟最优势能函数不是那么好找的。</p><h1 id="动态表"><a href="#动态表" class="headerlink" title="动态表"></a>动态表</h1><p>这个有丶玄学，是势能分析的综合应用，建议看书。</p><p><u>睡觉了，先更到这里，明天继续更</u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;聚合分析&quot;&gt;&lt;a href=&quot;#聚合分析&quot; class=&quot;headerlink&quot; title=&quot;聚合分析&quot;&gt;&lt;/a&gt;聚合分析&lt;/h1&gt;&lt;p&gt;聚合分析指，证明对所有n，一个n个操作的序列的最坏情况下花费的总时间为T(n)。因此在最坏情况下，每个操作的平均代价，或&lt;s
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="amortized analysis" scheme="https://mengzelev.github.io/tags/amortized-analysis/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-贪心算法</title>
    <link href="https://mengzelev.github.io/2018/09/17/clrs-16greedy/"/>
    <id>https://mengzelev.github.io/2018/09/17/clrs-16greedy/</id>
    <published>2018-09-17T02:53:05.000Z</published>
    <updated>2018-09-18T03:10:20.626Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇dp写得又乱又烂简直不想看。但愿自己能坚持下去吧。<s>可是这依然改变不了搬运和截图多于实际内容的事实</s></p><h1 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h1><p>贪心算法可以看做是动态规划的弱化版，处理某一类特殊的具有最优子结构的问题。</p><blockquote><p>在每个贪心算法之下，几乎总有一个更繁琐的动态规划算法。</p></blockquote><h2 id="算法设计步骤"><a href="#算法设计步骤" class="headerlink" title="算法设计步骤"></a>算法设计步骤</h2><ol><li>将最优化问题转化为这样的形式：对其作出一次选择后，只剩下<strong>一个</strong>子问题需要求解【子问题削减】</li><li>证明作出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的【安全性证明：<strong>替换法</strong>】</li><li>证明作出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构【确认最优子结构】</li></ol><h2 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h2><p>贪心选择性质是指，当进行选择时，我们直接作出在当前问题中看来最优的选择，而不必考虑子问题的解【鼠目寸光】</p><p>贪心起来不太方便的时候，可以改进贪心选择，例如做一些预处理（活动选择问题中按照结束时间对活动进行排序）</p><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><p>证明：子问题最优解 + 贪心选择 = 原问题最优解<br>隐含地使用了数学归纳法</p><h2 id="两种背包问题"><a href="#两种背包问题" class="headerlink" title="两种背包问题"></a>两种背包问题</h2><ul><li><strong>0-1背包问题</strong></li><li><strong>分数背包问题</strong></li></ul><p>共同的条件是有一堆不同价值、重量的东西，用一个有一定承重量的背包去装，求装得的最大价值。<br>不同在于，<strong>0-1背包问题</strong>中每个东西要么拿要么不拿，而<strong>分数背包问题</strong>中可以拿分数个东西。</p><p>前者无法用贪心算法求解，但后者可以，主要区别在于考虑<strong>0-1背包问题</strong>中是否将一个商品装入背包时，必须比较包含此商品的子问题的解和不包含此商品的子问题的解。简单来说就是，空闲空间的存在非常讨厌。只能使用动态规划来求解</p><h1 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><center><br><img src="/2018/09/17/clrs-16greedy/activity1.png" height="200"><br></center><h2 id="最优子结构-1"><a href="#最优子结构-1" class="headerlink" title="最优子结构"></a>最优子结构</h2><p>通俗地说，对于某一个活动$a_k$，在它开始之前结束的所有活动，和在它结束之后开始的所有活动，这两个集合都应该取到最优解，可以使用剪切-粘贴发得到证明。因为如果子问题存在更优解，只需替换即可得到原问题的最优解，与原问题已经是最优解矛盾。</p><p>严谨化表述可以描述为：</p><center><br><img src="/2018/09/17/clrs-16greedy/activity2.png" height="100"><br></center><br>其中，$S{ij}$表示在$ai$结束后开始、在$aj$开始前结束的活动的集合；<br>c[i,j]表示集合$S{ij}$的最优解。<br><br>贪心选择<br>———————————<br>抛开各种分析直接来看这个问题，或者说和一个不知道动态规划的人谈起这个问题，很容易（大概）有这样一种想法：<br>对于每一次选择，都取不冲突的、最早结束的活动，感觉应该能够得到最优解。<br><br>事实上这个想法是对的，可以使用<a href="#replace">替换法</a>进行证明。<br><center><br><img src="/2018/09/17/clrs-16greedy/activity3.png" height="200"><br></center><p>这样每次做选择的时候就只剩下了一个子问题。</p><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p>贪心算法可以自顶向下实现。</p><center><br><img src="/2018/09/17/clrs-16greedy/activity4.png" height="200"><br></center><h2 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h2><center><br><img src="/2018/09/17/clrs-16greedy/activity5.png" height="250"><br></center><p>其中Q是一个单调队列。如果用最小堆实现，则该算法的时间复杂度为O(nlgn)。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>如果直接使用dp，状态转移是O(n)的，子问题总数为O(n^2)，因此总时间复杂度为O(n^3)。</p><p>而如果使用贪心策略，压缩了解空间，限制了解的范围，从伪代码可以看出每个$a_{i}$都被检查且只被检查了一次，因此时间复杂度是O(n)的。</p><p>如果输入数据是无序的那么还需要一个O(nlgn)的排序时间，总体的时间复杂度为O(nlgn)。</p><h1 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>解释起来有点麻烦，提供STFW快捷入口</p><p><a href="https://baike.baidu.com/item/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/1719730?fr=aladdin" target="_blank" rel="noopener">百度百科-哈夫曼编码</a></p><p><a href="https://en.wikipedia.org/wiki/Huffman_coding" target="_blank" rel="noopener">wikipedia-Huffman coding</a></p><p>简单概括一下：</p><ul><li>用变长编码压缩编码长度</li><li>Huffman树的叶结点与码字的编码一一对应</li><li>字符的二进制码字用从根结点到该字符对应的叶结点的简单路径表示</li><li>代价的定义：<center><br><img src="/2018/09/17/clrs-16greedy/huffman2.png" height="150"><br></center></li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><center><br><img src="/2018/09/17/clrs-16greedy/huffman1.png" height="200"><br></center><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>这一块设计很多数学推导，难度比较大，此处指概括大致思路，<u>配合算法导论原书食用风味更佳</u></p><p>主要是需要证明两个引理。</p><p><center><br><img src="/2018/09/17/clrs-16greedy/huffman3.png" height="100"><br></center><br>引理2旨在说明在单步选择下，贪心能得到是最优解。用的是<strong>替换法</strong>。从假想出一个<strong>抽象的最优解T</strong>，经过某些变换得到<strong>根据贪心选择构造出的解T’’</strong>，运用数学手段证明这两个解具有相等的代价。<br>此处采用的是相减得到大于等于关系，与最优解天然具有的小于等于构造解相结合，证明等价。</p><p><center><br><img src="/2018/09/17/clrs-16greedy/huffman4.png" height="120"><br></center><br>引理3旨在证明该问题的最优子结构。采用了<s>喜闻乐见的</s>的剪切-粘贴法，也使用了一定的数学手段导出了矛盾。</p><p>引理2+引理3能证明上文的贪心算法可以生成一个最优前缀码。</p><p><s>课程要求暂时只需要看前三章</s></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一篇dp写得又乱又烂简直不想看。但愿自己能坚持下去吧。&lt;s&gt;可是这依然改变不了搬运和截图多于实际内容的事实&lt;/s&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础理论&quot;&gt;&lt;a href=&quot;#基础理论&quot; class=&quot;headerlink&quot; title=&quot;基础理论&quot;&gt;&lt;/a&gt;基础理论&lt;/h1
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="greedy algorithm" scheme="https://mengzelev.github.io/tags/greedy-algorithm/"/>
    
  </entry>
  
</feed>
