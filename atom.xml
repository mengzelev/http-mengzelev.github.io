<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengzelev&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mengzelev.github.io/"/>
  <updated>2019-06-22T07:12:36.239Z</updated>
  <id>https://mengzelev.github.io/</id>
  
  <author>
    <name>Mengzelev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统期末复习笔记</title>
    <link href="https://mengzelev.github.io/2019/06/21/os-review/"/>
    <id>https://mengzelev.github.io/2019/06/21/os-review/</id>
    <published>2019-06-21T12:58:41.000Z</published>
    <updated>2019-06-22T07:12:36.239Z</updated>
    
    <content type="html"><![CDATA[<p><s>这其实是jyy课程讲义摘抄</s></p><h1 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h1><p>维度：价格、容量、速度、可靠性</p><p>持久化存储介质统称Non-Volatile Memory</p><h1 id="IO设备与驱动"><a href="#IO设备与驱动" class="headerlink" title="IO设备与驱动"></a>IO设备与驱动</h1><p>设备：三种操作（发送命令、读取状态、传输数据）的集合</p><h2 id="管理IO设备"><a href="#管理IO设备" class="headerlink" title="管理IO设备"></a>管理IO设备</h2><p>查看系统IO设备：<code>lspci,lsblk</code><br>(实现： <code>open(/sys/bus/pci)</code>)</p><p>Loop Back Device(回路设备)：把一个文件模拟成一个块设备<br>a pseudo-device that makes a file accessible as a block device in Unix-like operating systems</p><p>IO设备类型众多、访问模式差距很大<br>解决：抽象层——设备驱动<br>设备驱动：操作系统对设备进行的额外抽象，使得更上层的部分（通常是文件系统）能够以统一的接口访问这些设备，i.e.把文件API翻译成设备命令</p><ul><li>设备驱动层帮助我们屏蔽了底层设备的具体实现细节</li><li>使得创建“虚拟”设备非常容易(<code>/dev/random</code>,<code>/dev/null</code>)</li></ul><p>I/O设备最主要的功能：input/output(read/write)<br>还有一些设备相关设置</p><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>解决中断没能解决的问题<br>一个完成CPU和设备之间传输的I/O设备<br>这样CPU可以在传送数据时做别的事</p><h1 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h1><p>存储设备虚拟化<br>虚拟磁盘：一个可以读写的动态字节序列<br>传统理解：文件系统是保存在持久存储上的数据结构(存储格式规范+允许的操作)</p><p>文件系统【以下是我能找到的所有描述】</p><ul><li>存储设备的虚拟化机制</li><li>文件名到虚拟磁盘的映射</li><li>管理操作系统内部对象的中间层</li><li>连接应用程序与设备驱动的桥梁</li><li>管理操作系统中能够抽象成“虚拟磁盘”接口访问的任何数据</li></ul><p>文件系统实现 = 数据结构的查询/修改操作<br>文件：可读写的数据对象，相当于一个虚拟磁盘<br>文件操作</p><ul><li>打开（返回文件描述符），关闭</li><li>文件描述符操作：read,write,lseek,ioctl,mmap…</li></ul><p>目录：文件和目录的集合<br>目录操作</p><ul><li>改变进程工作目录</li><li>目录解析</li><li>读取目录</li><li>目录操作：link,unlink,rename</li></ul><h2 id="文件系统设计"><a href="#文件系统设计" class="headerlink" title="文件系统设计"></a>文件系统设计</h2><p>文件（扩展）：操作系统中的一个可读/写/控制的对象<br>文件描述符：指向操作系统对象的handle<br>管理操作系统对象的本质：传递数据的需求</p><blockquote><p>为什么<code>/proc</code>不是进程树？-方便根据pid查找进程</p></blockquote><p>虚拟文件系统：把read/write翻译成对操作系统对象(进程线程、文件目录、设备等)的读写</p><h1 id="文件系统API"><a href="#文件系统API" class="headerlink" title="文件系统API"></a>文件系统API</h1><h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><p>挂载：<code>mount -t type device dir</code><br>把一个设备和一个文件系统实现联系起来，在设备上创建一个文件系统实例，并且把创建的文件系统“放置”到文件系统中的一个路径里</p><h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>切换根目录<br>只影响路径解析<br>如果持有外部文件描述符很容易越狱</p><h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p>本质也是文件，只是操作系统在路径解析、目录遍历时对它的数据有特殊的解读</p><h3 id="硬♂链接"><a href="#硬♂链接" class="headerlink" title="硬♂链接"></a>硬♂链接</h3><ul><li>目标只能是文件(不能是目录)</li><li>不能跨越文件系统</li></ul><h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><ul><li>目标可以是任何相对/绝对路径</li><li>只是一个路径解析提示</li></ul><h2 id="文件管理：打开文件"><a href="#文件管理：打开文件" class="headerlink" title="文件管理：打开文件"></a>文件管理：打开文件</h2><p>打开目录：得到一个指向文件系统某个位置的指针</p><h2 id="文件操作：文件描述符"><a href="#文件操作：文件描述符" class="headerlink" title="文件操作：文件描述符"></a>文件操作：文件描述符</h2><ul><li>避免每次操作都要重新打开文件</li><li>帮助我们自动管理文件访问的偏移量</li></ul><h2 id="文件系统的同步"><a href="#文件系统的同步" class="headerlink" title="文件系统的同步"></a>文件系统的同步</h2><p>操作系统做了很多激进地缓存，所以多用<code>sync</code></p><h1 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h1><p>实现文件系统需要考虑一下因素</p><ul><li>虚拟磁盘的数据结构（链表，树…）</li><li>目录文件的数据结构</li><li>inode的表示和存储</li><li>balloc/bfree的实现</li></ul><h2 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h2><p>固定大小的block的数组<br>在<code>/sys/block</code>里可以找到<br>块设备API：进程/线程向存储设备提交I/O request, request首先进入设备队列，经过调度器调度后执行设备上的I/O<br>操作系统不管Block I/O调度，管进程尽可能公平地获得I/O操作和请求优化</p><h2 id="虚拟磁盘"><a href="#虚拟磁盘" class="headerlink" title="虚拟磁盘"></a>虚拟磁盘</h2><p>数据结构：链表/树，提供<code>balloc/bfree</code><br>链表在文件小时表现较好，索引的lseek性能更好<br>block bitmap(联系L3)</p><p>文件应该有</p><ul><li>一个唯一的编号</li><li>元数据信息（类型，大小，权限，访问时间、链接数量、索引）</li></ul><h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><p>目录=文件名$\to$文件id的映射</p><h3 id="Inode的存储"><a href="#Inode的存储" class="headerlink" title="Inode的存储"></a>Inode的存储</h3><table><thead><tr><th style="text-align:left">存储方式</th><th style="text-align:center">好处</th><th style="text-align:center">坏处</th></tr></thead><tbody><tr><td style="text-align:left">在磁盘用单独区域统一存储和管理</td><td style="text-align:center">容易被破坏（备份）；浪费空间</td><td style="text-align:center">查找快速（可以快速计算出inode在磁盘中的位置）</td></tr><tr><td style="text-align:left">存储在目录文件中（如FAT）</td><td style="text-align:center">节约空间</td><td style="text-align:center">不支持硬链接</td></tr><tr><td style="text-align:left">存储在文件头部</td><td style="text-align:center"></td><td style="text-align:center">容错性</td></tr></tbody></table><h3 id="评价文件系统"><a href="#评价文件系统" class="headerlink" title="评价文件系统"></a>评价文件系统</h3><ul><li>性能<ul><li>存在超大文件、超大目录时各个操作的性能表现</li><li>在各种类型workload的读写（顺序/随机，读/写分布）、目录操作比例下的性能表现</li><li>多进程并发时的文件系统表现</li></ul></li><li>可靠性<ul><li>在系统可能意外崩溃时文件系统实现的正确性</li><li>在磁盘可能损坏的前提下文件系统的可靠性</li></ul></li></ul><h1 id="FAT和ext2"><a href="#FAT和ext2" class="headerlink" title="FAT和ext2"></a>FAT和ext2</h1><h2 id="File-Allocationg-Table"><a href="#File-Allocationg-Table" class="headerlink" title="File Allocationg Table"></a>File Allocationg Table</h2><p>链表实现文件，为每个block维护一个next block<br>文件分配表：几种存储next</p><p>PBR(Partition Boot Record)：存储在分区头部</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>读写序列不够连续</li><li>FAT容易被枪毙（一般都有两个备份）</li><li>文件系统可能碎片化（巨大的文件可能散落在磁盘的各个角落）</li><li><s>不支持链接只是因为手册里没写</s></li></ul><p>磁盘碎片整理：使文件尽可能在磁盘中占有连续的块</p><h2 id="ext2"><a href="#ext2" class="headerlink" title="ext2"></a>ext2</h2><p>索引实现文件：混合多种存储方式<br>inodes单独管理：支持硬链接<br>inodes连续存储：提高文件访问的局部性<br>相比于FAT空间浪费比较多</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li>分配分成了两级(组级、块级)<ul><li>不用管理全局的bitmap</li></ul></li><li>一定程度的性能优化<ul><li>尽量把相近的文件分配在同一个组里</li><li>尽量把同一个文件的数据块分配在同一个组里</li></ul></li><li>使磁盘大小容易动态调整</li></ul><h1 id="持久数据的可靠性"><a href="#持久数据的可靠性" class="headerlink" title="持久数据的可靠性"></a>持久数据的可靠性</h1><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>如何把虚拟磁盘映射到物理磁盘块</p><h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID-0"></a>RAID-0</h3><p>没有冗余</p><ul><li>方案1</li></ul><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>3</td></tr><tr><td>#1</td><td>1</td><td>4</td></tr><tr><td>#2</td><td>2</td><td>5</td></tr></tbody></table><ul><li>方案2</li></ul><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>1</td></tr><tr><td>#1</td><td>2</td><td>3</td></tr><tr><td>#2</td><td>4</td><td>5</td></tr></tbody></table><table><thead><tr><th></th><th>方案一</th><th>方案二</th></tr></thead><tbody><tr><td>顺序读写速度</td><td>1X</td><td>2X</td></tr><tr><td>随机读写速度</td><td>1X</td><td>2X</td></tr></tbody></table><p>实际使用中对目录访问较多（顺序读写），方案2中磁盘2等于没有</p><p>毫无容错</p><h3 id="RAID-1-镜像"><a href="#RAID-1-镜像" class="headerlink" title="RAID-1 镜像"></a>RAID-1 镜像</h3><p>维护两块数据完全一样的磁盘实现容错</p><ul><li>RAID-10</li></ul><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>0</td></tr><tr><td>#1</td><td>1</td><td>1</td></tr><tr><td>#2</td><td>2</td><td>2</td></tr><tr><td>#3</td><td>3</td><td>3</td></tr></tbody></table><h3 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID-4"></a>RAID-4</h3><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th><th>磁盘3</th><th>磁盘4</th><th>磁盘P</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>$0\oplus1\oplus2\oplus3$</td></tr><tr><td>#1</td><td>4</td><td>5</td><td>6</td><td>7</td><td>$4\oplus5\oplus6\oplus7$</td></tr><tr><td>#2</td><td>8</td><td>9</td><td>10</td><td>11</td><td>$8\oplus9\oplus10\oplus11$</td></tr><tr><td>#3</td><td>12</td><td>13</td><td>14</td><td>15</td><td>$12\oplus13\oplus14\oplus15$</td></tr></tbody></table><ul><li>顺序读：4X</li><li>顺序写：4X</li><li>随机读：4X</li><li>随机写：X/2(校验盘是性能瓶颈)</li></ul><h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID-5"></a>RAID-5</h3><p>RAID-4升级版</p><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th><th>磁盘3</th><th>磁盘4</th><th>磁盘P</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>P</td></tr><tr><td>#1</td><td>4</td><td>5</td><td>6</td><td>P</td><td>7</td></tr><tr><td>#2</td><td>8</td><td>9</td><td>P</td><td>10</td><td>11</td></tr><tr><td>#3</td><td>12</td><td>P</td><td>13</td><td>14</td><td>15</td></tr></tbody></table><ul><li>随机写可以并发</li></ul><h3 id="带宽分析"><a href="#带宽分析" class="headerlink" title="带宽分析"></a>带宽分析</h3><p>见OSTEP</p><h3 id="RAID硬件"><a href="#RAID硬件" class="headerlink" title="RAID硬件"></a>RAID硬件</h3><ul><li>缓冲&amp;日志</li><li>奇偶校验电池</li><li>保证数据写回</li></ul><h1 id="崩溃恢复与日志"><a href="#崩溃恢复与日志" class="headerlink" title="崩溃恢复与日志"></a>崩溃恢复与日志</h1><h2 id="磁盘上的数据结构"><a href="#磁盘上的数据结构" class="headerlink" title="磁盘上的数据结构"></a>磁盘上的数据结构</h2><p>读磁盘的请求：</p><ul><li>读一个已经写过的块，可以不从磁盘读取</li><li>读一个未被访问过的块，必须从磁盘读取（等待）</li></ul><p>写磁盘的请求：</p><ul><li>原则上可以无限排队，让磁盘的读请求先行</li><li>但同时最终应当被写入磁盘</li></ul><h2 id="原子性的丧失"><a href="#原子性的丧失" class="headerlink" title="原子性的丧失"></a>原子性的丧失</h2><p>崩溃=缓存数据丢失</p><h3 id="简单的workload-追加写"><a href="#简单的workload-追加写" class="headerlink" title="简单的workload: 追加写"></a>简单的workload: 追加写</h3><ol><li>$FAT[b’]\leftarrow EOF$</li><li>$data[b’]\leftarrow$ 数据</li><li>$FAT[f_{end}]\leftarrow b’$</li></ol><p>一下考虑所有可能的崩溃情况</p><ul><li>$FAT[b’]\to$❌ (dead block/leak)</li><li>$data[b’]\to$❌ (random writes, 写到了没办法再读到的地方)</li><li>$FAT[f{end}]\to$❌ (corrupted FAT, inconsistency)</li><li>$data[b’]\to FAT[f_{end}]\to$❌ (random writes + corrupted FAT)</li><li>$FAT[b’]\to data[b’]\to$❌ (dead block * 2)</li><li>$FAT[b’]\to FAT[f_{end}]\to$❌ (corrupted file, incorrect data)</li><li>$FAT[f_end’]\to FAT[b’]\to data[b’]$ ✅</li></ul><p>dead block不是个很大的问题所以$FAT[b’]\to FAT[f_{end}]\to data[b’]$是个相对可以接受的方案，但这只是追加写，一般情形就很困难了</p><h2 id="文件系统一致性"><a href="#文件系统一致性" class="headerlink" title="文件系统一致性"></a>文件系统一致性</h2><p>当磁盘上的数据结构不合法或不满足文件操作的语义，文件系统就处于不一致的状态，e.g.</p><ul><li>链接成环</li><li>FAT指向未被分配数据块</li><li>两个文件的索引个共享数据块</li></ul><h2 id="FSCK"><a href="#FSCK" class="headerlink" title="FSCK"></a>FSCK</h2><p>File System Checking<br>在崩溃后扫描磁盘进行补救</p><p>缺陷：</p><ul><li>为了一点小事扫描整个磁盘，太花时间了</li><li>没人能证明这么做一定能回到一个一致的状态</li><li>fsck的时候也会崩溃</li></ul><h2 id="实现崩溃一致性"><a href="#实现崩溃一致性" class="headerlink" title="实现崩溃一致性"></a>实现崩溃一致性</h2><p>Key idea: 使磁盘上的状态能推导出某个过去时刻的文件系统状态<br>借助<code>sync()</code>保证数据写入磁盘后才返回</p><h3 id="日志-Journaling"><a href="#日志-Journaling" class="headerlink" title="日志(Journaling)"></a>日志(Journaling)</h3><p>把操作以append only的方式记下来：写入TXbegin和数据→sync→写入TXEND→sync<br>用一个额外的指针维护journal完成的时刻</p><p>崩溃恢复：从指针开始向后重做journal中记录的操作<br>优化：合并log，只对metadata做journaling(但可能导致应用程序丢失数据)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;s&gt;这其实是jyy课程讲义摘抄&lt;/s&gt;&lt;/p&gt;
&lt;h1 id=&quot;存储介质&quot;&gt;&lt;a href=&quot;#存储介质&quot; class=&quot;headerlink&quot; title=&quot;存储介质&quot;&gt;&lt;/a&gt;存储介质&lt;/h1&gt;&lt;p&gt;维度：价格、容量、速度、可靠性&lt;/p&gt;
&lt;p&gt;持久化存储介质统称No
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OSTEP阅读笔记-持久化部分</title>
    <link href="https://mengzelev.github.io/2019/06/21/OSTEP-persistence/"/>
    <id>https://mengzelev.github.io/2019/06/21/OSTEP-persistence/</id>
    <published>2019-06-21T02:23:27.000Z</published>
    <updated>2019-06-21T09:48:08.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch36-IO设备"><a href="#Ch36-IO设备" class="headerlink" title="Ch36 IO设备"></a>Ch36 IO设备</h1><h2 id="典型设备协议"><a href="#典型设备协议" class="headerlink" title="典型设备协议"></a>典型设备协议</h2><p>设备的两个重要组成部分：硬件接口+内部结构</p><p><img src="/2019/06/21/OSTEP-persistence/os-review/device.png"></p><p>OS通过读写状态、命令和数据寄存器来控制设备行为</p><p>协议模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(STATUS == BUSY);</span><br><span class="line">//wait until device is not busy(polling)</span><br><span class="line">write data to DATA reg;</span><br><span class="line">write cmd to cmd reg;</span><br><span class="line">  (Doing so starts the device and executes the cmd)</span><br><span class="line">while(STATUS == BUSY);</span><br><span class="line">//wait until device is done with your request</span><br></pre></td></tr></table></figure><p>缺陷：轮询浪费时间——用中断减少CPU浪费(概括一下：等待设备的时候去做别的事情)</p><p>使用中断还是轮询取决于设备的速度</p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>要传送数据的时候，OS告诉DMA数据在哪里、送多少、要送给谁，然后OS就可以去干别的事了，数据拷贝全部由DMA来完成</p><h2 id="OS与设备的交互"><a href="#OS与设备的交互" class="headerlink" title="OS与设备的交互"></a>OS与设备的交互</h2><h3 id="明确的I-O指令"><a href="#明确的I-O指令" class="headerlink" title="明确的I/O指令"></a>明确的I/O指令</h3><p>古代方法<br>e.g. <code>x86</code>的<code>in</code>,<code>out</code>指令<br>PA你都写过了<br>都是特权指令，只有OS可以使用</p><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>现代方法<br>但古代方法没有被抛弃</p><h2 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h2><p>by传统艺能：抽象<br>设备驱动：OS中的某一块(piece)知道设备的工作细节的软件，封装了所有与设备的交互行为(原话：a piece of software in the OS must know in detail how a device works)<br>但这样会使设备损失特殊功能(e.g SCSI有比ATA和IDE更丰富的error handling机制)<br>OS里70%的代码都是设备驱动程序，而且因为设备驱动主要都是野鸡程序猿(相对于内核代码)写的，所以是贡献内核bug的中坚力量</p><h1 id="Ch37-硬盘驱动"><a href="#Ch37-硬盘驱动" class="headerlink" title="Ch37 硬盘驱动"></a>Ch37 硬盘驱动</h1><p>虽然现代os会一次性往硬盘写很多数据，但是硬盘只保证一个sector(512字节)的写是原子的(要么写了要么没写)</p><h2 id="物理构造"><a href="#物理构造" class="headerlink" title="物理构造"></a>物理构造</h2><p>盘片(platter)的两个面称为盘面(surface)，盘片装在转轴(spindle)上。数据按磁道(track)排列在盘片上，由磁头(disk head)读写。每个盘面都有一个磁头(disk head)。磁头长在磁臂(disk arm)上<br>RPM(rotation per minute)</p><p>缓存(track buffer)</p><p>写判定</p><ul><li>写回(write back): 把数据放入磁盘缓冲就算写完</li><li>直写(write through): 把数据写入磁盘后才算写完</li></ul><p>下面都是磁盘读写调度我不看了啦</p><h1 id="Ch38-RAIDs"><a href="#Ch38-RAIDs" class="headerlink" title="Ch38 RAIDs"></a>Ch38 RAIDs</h1><p>Redundant Arrays of Inexpensive Disks廉价磁盘冗余阵列<br>RAID其实是一个firmware(编程硬件)，有自己的处理器、存储和磁盘</p><p>###评价标准<br>performance, capacity, reliability.<br>其中performance有两个判定尺度：single-request latency(单操作延迟), steady-state throughput(稳态吞吐量, the total bandwidth of many concurrent requests)</p><h2 id="故障模型-Fault-Model"><a href="#故障模型-Fault-Model" class="headerlink" title="故障模型(Fault Model)"></a>故障模型(Fault Model)</h2><h3 id="fail-stop"><a href="#fail-stop" class="headerlink" title="fail-stop"></a>fail-stop</h3><p>磁盘只有两个状态：wording &amp; failed(永远没有了)，不考虑坏了半块这样的情况</p><h2 id="RAID-Level-0-Striping-串列"><a href="#RAID-Level-0-Striping-串列" class="headerlink" title="RAID Level 0: Striping(串列)"></a>RAID Level 0: Striping(串列)</h2><p>毫无冗余，虚假的RAID</p><p>capacity: perfect<br>reliability: any disk failure will lead to data loss<br>performance:  excellent</p><p>【此处省略懒得截图的截图】<br>stripe: 排在同一行的blocks<br>chunk size(组块大小): 连续分布在同一块磁盘上的数据大小<br>chunk size对RAID的performance影响最大<br>小的chunk size能提高连续读的并发性，但是延长了把block分配到不同磁盘的时间<br>大的chunk size只有在读大文件时才能有较好的并发性，但缩短了分配时间<br>chunk size的选择依赖于workload</p><p>workload有两种：sequential和random</p><h2 id="RAID-Level-1-Mirroring"><a href="#RAID-Level-1-Mirroring" class="headerlink" title="RAID Level 1: Mirroring"></a>RAID Level 1: Mirroring</h2><p><img src="/2019/06/21/OSTEP-persistence/os-review/raid10.png"></p><p>图上那个又叫RAID-10</p><p>读：随机选一个<br>写：两份都要写（并发）</p><ul><li>capacity: N块磁盘，容量N/2</li><li>reliability: 可以忍受单块磁盘爆炸(只要不是同一块磁盘的两个备份同时爆炸)</li><li>performance: <ul><li>读延迟：速度同读单块磁盘</li><li>写延迟：同时写两份（并发），与同时写单块相同。但写时间由两块中时间长的决定，因此比写单块会慢一丢丢</li><li>连续读：同随机写</li><li>连续写：最大带宽$(\frac{N}{2}\cdot S)$，峰值带宽的一半</li><li>随机读：满带宽$N\cdot R$ MB/s</li><li>随机写：一半</li></ul></li></ul><h3 id="多块磁盘的一致性维护"><a href="#多块磁盘的一致性维护" class="headerlink" title="多块磁盘的一致性维护"></a>多块磁盘的一致性维护</h3><p>刚决定写一块磁盘，另一块磁盘写不写还没确定，就断电了，这时另一块磁盘完全没被写，导致两块磁盘数据不一致。也就是说希望镜像的两块盘的写操作是原子的。<br>解决：write-ahead log<br>大多数磁盘都带有电池供电的小型非易失性RAM</p><h2 id="RAID-Level-4-Saving-Space-With-Parity"><a href="#RAID-Level-4-Saving-Space-With-Parity" class="headerlink" title="RAID Level 4: Saving Space With Parity"></a>RAID Level 4: Saving Space With Parity</h2><p>用时间(performance)换空间(capacity)</p><p><img src="/2019/06/21/OSTEP-persistence/os-review/raid4.png"></p><p>给每个stripe加了一个parity check block(XOR)<br>当一块盘坏掉时，我们需要读同一个stripe中其他所有盘的数据才能恢复出这块盘的数据</p><ul><li>capacity： $N-1$</li><li>reliability: 能容忍每个stripe中有一块磁盘爆炸</li><li>performance<ul><li>连续读：只有校验盘没有被占用，$(N-1)\cdot S$ MB/s</li><li>连续写：full-stripe write很高效，因为写完一个stripe正好能写校验盘，$(N-1)\cdot S$ MB/s</li><li>随机读：除了校验盘，$(N-1)\cdot S$ MB/s</li><li>随机写：当修改了一块盘中的数据时，需要同时修改校验盘，这里有两种方法。一是additive parity，把同一个stripe中的块的数据全部读出来再算一遍校验位，然后并发地写入校验盘和数据盘，这种做法在RAID块比较多的时候会很慢；另一种是subtractive parity，从检验位中把原来的数据减去再加上新的数据，这种方法的瓶颈在于校验盘不能并发读写，带宽只有$R/2$ MB/s，即使加磁盘也不会加快。</li><li>读延迟：同读单块磁盘</li><li>写延迟：写单块时需要进行两次读和写(subtractive parity)，但读写都可以并发，因此写延迟为写单块磁盘的两倍（速度是一半）</li></ul></li></ul><h2 id="RAID-Level-5：-Rotating-Parity"><a href="#RAID-Level-5：-Rotating-Parity" class="headerlink" title="RAID Level 5： Rotating Parity"></a>RAID Level 5： Rotating Parity</h2><p><img src="/2019/06/21/OSTEP-persistence/os-review/raid5.png"></p><p>为了消除RAID-4校验盘的性能瓶颈</p><p>三围基本和RAID-4相同<br>随机读的performance会好一些，因为所有的磁盘都被占用了<br>随机写性能大大提升，因为写操作之间可以并发了。当有较大的随机写操作序列时，可以保证每块磁盘都能并发工作，带宽是$\frac{N}{4}\cdot R$ MB/s.<br>在市场上已经基本取代了RAID-4</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>一张表格概括本章精髓</p><p><img src="/2019/06/21/OSTEP-persistence/os-review/sum.png"></p><p>方案选择取决于实际使用，对reliability、顺序或随机读写的不同需求</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ch36-IO设备&quot;&gt;&lt;a href=&quot;#Ch36-IO设备&quot; class=&quot;headerlink&quot; title=&quot;Ch36 IO设备&quot;&gt;&lt;/a&gt;Ch36 IO设备&lt;/h1&gt;&lt;h2 id=&quot;典型设备协议&quot;&gt;&lt;a href=&quot;#典型设备协议&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>难问题求解学习笔记-随机算法</title>
    <link href="https://mengzelev.github.io/2019/05/25/ps-4-13-Randomized-Algorithms/"/>
    <id>https://mengzelev.github.io/2019/05/25/ps-4-13-Randomized-Algorithms/</id>
    <published>2019-05-25T03:20:40.000Z</published>
    <updated>2019-06-19T12:33:02.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>输出为随机变量的算法称为蒙特卡洛算法(Monte Carlo)<br>输出总是正确的但时间复杂度为随机变量的算法称为拉斯维加斯算法(Las Vegas)</p><p>概率论理论引入了随机算法$A$与确定输入$x$构成的随机试验。试验可以被描述为概率空间$(S_{A,x},Prob)$，其中$S_{A,x}={C\mid C \text{is a computation (radom run) of } A \text{ on } x}$，$Prob$是$S_{A,x}$上的概率分布。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="一种新的复杂度度量"><a href="#一种新的复杂度度量" class="headerlink" title="一种新的复杂度度量"></a>一种新的复杂度度量</h2><p>$Random_A(x)$: 对于所有$A$在$x$上的随机计算中使用的random bits的最大数量<br>$Random_A(n)=\max{Random_A(x)\mid x \text{is a input of size }n}$</p><p>这么衡量的两点原因</p><ul><li>产生真随机数非常困难，且真随机序列越长越困难</li><li>如果一个算法的$Random_A(x)$是对数级的，那就可能可以在多项式时间内追踪它的所有运行的可能情况，做到去随机化(derandomization)</li></ul><p>$Prob_{A,x}(C)$: 某一次$A$对输入$x$的计算$C$, 由相应的随机序列的概率决定<br>$Prob(A(x)=y)$: $A$ outputs $y$ for an input $x$的概率<br>$Time(C)$: the time complexity of the run $C$ of $A$ on $x$</p><p>期望时间复杂度of $A$ on $x$(expected time complexity)<br>$$Exp-Time_A(x)=E[Time]=\sum\limits_{C}Prob_{A,x}(C)\cdot Time(C)$$</p><p>$A$的期望时间复杂度(worst case approach)<br>$$Exp-TIme_A(n)=\max{Exp-Time_A(x)\mid x \text{is an input of size } n}$$</p><p>$$Time_A(x)=\max{Time(C)\mid C \text{ is a run of} A \text{on} x }$$<br>$$Time_A(n)=\max{Time_A(x)\mid x \text{ is an input of size }n}$$</p><p>随机算法不一定会终止，可能会进行无限次计算，在实际情况下可以在某一时间后叫停，算法输出”?”，即无法在给定时间内解决该问题，然后重新开始</p><h1 id="随机算法的分类"><a href="#随机算法的分类" class="headerlink" title="随机算法的分类"></a>随机算法的分类</h1><h2 id="拉斯维加斯算法"><a href="#拉斯维加斯算法" class="headerlink" title="拉斯维加斯算法"></a>拉斯维加斯算法</h2><p>拉斯维加斯算法与其时间复杂度有两种定义方式，适用于不同的场景</p><h3 id="第一种定义"><a href="#第一种定义" class="headerlink" title="第一种定义"></a>第一种定义</h3><p>若对问题$F$的任意输入实例$x$，$Prob(A(x)=F(x))=1$,其中$F(x)$是问题$F$对于输入$x$的解，则称$A$是计算问题$F$的拉斯维加斯算法。这种定义下时间复杂度是$Exp-Time_A(n)$</p><h3 id="第二种定义"><a href="#第二种定义" class="headerlink" title="第二种定义"></a>第二种定义</h3><p>允许”?”输出<br>若对问题$F$的任意输入实例$x$，$Prob(A(x)=F(x))\ge\frac{1}{2}$且$Prob(A(x)=”?”)=1-Prob(A(x)=F(x))\le\frac{1}{2}$.<br>这种定义下时间复杂度采用$Time_A(n)$</p><p>第一种定义一般用于计算函数，第二种一般用于计算decision problem</p><h2 id="单边误差蒙特卡洛算法"><a href="#单边误差蒙特卡洛算法" class="headerlink" title="单边误差蒙特卡洛算法"></a>单边误差蒙特卡洛算法</h2><p>ONE-SIDED-ERROR MONTE CARLO ALGORITHMS</p><p>$L$的单边蒙特卡洛算法满足</p><ul><li>对任意$x\in L, Prob(A(x)=1)\ge 1/2$</li><li>对任意$x\notin L, Prob(A(x)=0)=1$</li></ul><p>重复次数越多，得到正确答案的可能性就越大</p><p>质数定理：集合${1,2,\cdots,m}$中质数的个数大约是$m/\ln m$，且当$m\ge 100$时至少是$m/\ln m$</p><h2 id="双边误差蒙特卡洛算法"><a href="#双边误差蒙特卡洛算法" class="headerlink" title="双边误差蒙特卡洛算法"></a>双边误差蒙特卡洛算法</h2><p>TWO-SIDED-ERROR MONTE CARLO ALGORITHMS</p><p>若存在实数$\varepsilon, 0\le\varepsilon &lt;1/2$，满足对于$F$的任意输入$x, Prob(A(x)=F(x))\ge\frac{1}{2}+\varepsilon$,则称该算法为$F$的双边蒙特卡洛算法</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/at.png"> </p><h2 id="无限制误差蒙特卡洛算法"><a href="#无限制误差蒙特卡洛算法" class="headerlink" title="无限制误差蒙特卡洛算法"></a>无限制误差蒙特卡洛算法</h2><p>UNBOUNDED-ERROR MONTE CARLO ALGORITHMS</p><p>若对于$F$的任意输入$x, Prob(A(x)=F(x))&gt;\frac{1}{2}$，则称这样的算法$A$是无限制蒙特卡洛算法</p><h2 id="随机最优化问题"><a href="#随机最优化问题" class="headerlink" title="随机最优化问题"></a>随机最优化问题</h2><p>判定问题的随机算法是选择出现最多的答案，而最优化问题是选择最接近(根据cost function)的答案</p><h3 id="随机近似算法"><a href="#随机近似算法" class="headerlink" title="随机近似算法"></a>随机近似算法</h3><p>随机算法可以看成是以高概率得到与最优解差别不大的解的近似算法</p><p><strong>定义5.2.2.10</strong>：设$U=$(略)是一个最优化问题。对任意正实数$\delta&gt;1$，随机算法$A$是$U$的<strong>随机$\delta-$近似算法</strong>，若$A$满足以下要求</p><ul><li>$Prob(A(x)=\mathcal{M}(x))=1$且</li><li>$Prob(R_A(x)\le\delta)\ge 1/2$</li></ul><p>对任意$x\in L_I$</p><p>类似可定义<strong>随机$f(n)-$近似算法</strong></p><p>随机多项式近似方案(RPTAS)</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/rptas1.png"></p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/rptas2.png"></p><p>还有随机 完全多项式近似方案(RFPTAS)</p><p>$\delta-$期望近似算法</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/52211.png"></p><p>以上两种定义互不包含</p><h1 id="随机算法设计"><a href="#随机算法设计" class="headerlink" title="随机算法设计"></a>随机算法设计</h1><h2 id="挫败对手"><a href="#挫败对手" class="headerlink" title="挫败对手"></a>挫败对手</h2><p>随机选择一系列算法中的一个，这样就无法特意构造一组最坏输入</p><h2 id="充分取证"><a href="#充分取证" class="headerlink" title="充分取证"></a>充分取证</h2><p>常用于判定问题</p><p>如Example5.2.2.6的取模运算</p><h2 id="指纹"><a href="#指纹" class="headerlink" title="指纹"></a>指纹</h2><p>用于判定等价问题</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/fp.png"></p><h2 id="随机采样"><a href="#随机采样" class="headerlink" title="随机采样"></a>随机采样</h2><h2 id="松弛与随机舍入"><a href="#松弛与随机舍入" class="headerlink" title="松弛与随机舍入"></a>松弛与随机舍入</h2><p>比如把线性规划的值舍入成整数规划</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;输出为随机变量的算法称为蒙特卡洛算法(Monte Carlo)&lt;br&gt;输出总是正确的但时间复杂度为随机变量的算法称为拉斯维加斯算法(Las 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>难问题求解学习笔记-近似算法</title>
    <link href="https://mengzelev.github.io/2019/05/18/ps-4-12-Approximation-Algorithms/"/>
    <id>https://mengzelev.github.io/2019/05/18/ps-4-12-Approximation-Algorithms/</id>
    <published>2019-05-18T03:03:30.000Z</published>
    <updated>2019-06-19T08:16:41.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>近似算法是能提供最优化问题的可行解的算法，所提供的解的质量不会与最优解相差太多</p><p><strong>形式化定义</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$是一个最优化问题，$A$是$U$的consistent algorithm. 对任意$x\in L_I$, $A$在$x$上的相对误差(relative error)$\varepsilon_A(x)$定义为<br>$$\varepsilon_A(x)=\frac{|cost(A(x))-Opt_U(x)|}{Opt_U(x)}$$<br>对任意$x\in\mathbb{N}$,定义$A$的相对误差$$\varepsilon_A(n)=\max{\varepsilon_A(x)|x\in L_I\cap (\Sigma_I)^n}$$<br>对每个$x\in L_I$,$A$在$x$上的的近似率(approximation ration)$R_A(x)$定义为$$R_A(x)=\max{\frac{cost(A(x))}{Opt_U(x)}, \frac{Opt_U(x)}{cost(A(x))}}$$<br>对任意$n\in\mathbb{N}$,定义$A$的近似率为$$R_A(n)=\max{R_A(x)|x\in L_I\cap (\Sigma_I)^n}$$<br>$R_A$又名最坏情况性能(worst case performance)，近似因子(approximation factor), 性能约束(performance bound)，性能率(performance ratio)，误差率(error ratio)</p><p>若$A$是最小化问题且$R_A(x)=\frac{Opt_U(x)}{cost(A(x))}$,则$R_A(x)=1+\varepsilon_A(x)$</p><p>对于任意正实数$\delta&gt;1$，若$R_A(x)\le\delta$对任意$x\in L_I$恒成立，则称$A$是$U$的$\delta-$近似算法<br>对任意函数$f:\mathbb{N}\to\mathbb{R}^+$,若$R_A(x)\le f(n)$对任意$n\in\mathbb{N}$恒成立，则称$A$是$U$的$f(n)-$近似算法</p><h1 id="近似方案-approximation-scheme"><a href="#近似方案-approximation-scheme" class="headerlink" title="近似方案(approximation scheme)"></a>近似方案(approximation scheme)</h1><p>用户可以指定一个小的相对误差值$\varepsilon$，程序可以提供出一个误差至多为$\varepsilon$的可行解</p><p><strong>定义4.2.1.6</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$是一个最优化问题。若对任意输入对$(x,\varepsilon)\in L_I\times\mathbb{R}^+$, $A$计算出一个相对误差至多为$\epsilon$的可行解$A(x)$, 且$Time_A(x,\varepsilon^{-1})$以某个$|x|$的多项式函数为界，则称$A$是$U$的<strong>多项式时间近似方案(polynomial-time approximation scheme, PTAS)</strong>. 若$Time_A(x,\varepsilon^{-1})$以某个同时是$|x|$和$\varepsilon^{-1}$的多项式的函数为界，则称$A$是$U$的<strong>完全多项式近似方案(fully polynomial-time approximation scheme, FPTAS)</strong></p><p>一般来说$Time_A(x,\varepsilon^{-1})$关于$|x|$和$\varepsilon^{-1}$都单调递增</p><p>好处：用户有权决定要快还是要精度</p><h1 id="最优化问题的分类"><a href="#最优化问题的分类" class="headerlink" title="最优化问题的分类"></a>最优化问题的分类</h1><p>在近似的意义下NPO可以被分为以下五类：</p><ul><li>NPO(I): NPO中所有存在FPTAS的最优化问题(e.g.背包问题)</li><li>NPO(II): NPO中所有存在PTAS的最优化问题(e.g. MS)</li><li>NPO(III): 包含所有$U\in NPO$满足：<ul><li>对某些$\delta&gt;1$存在多项式时间的$\delta-$近似算法</li><li>对某些$d&lt;\delta$不存在多项式时间的的$d-$近似算法</li><li>i.e.$U$没有PTAS</li></ul></li><li>NPO(IV): 包含所有$U\in NPO$满足：<ul><li>对某些$f:\mathbb{N}\to\mathbb{R}^+$,存在多项式时间的$f(n)-$近似算法,其中$f$以某个多项式函数为界</li><li>对任意$\delta\in\mathbb{R}^+$不存在任何多项式时间的$\delta-$近似算法</li><li>e.g.集合覆盖问题</li></ul></li><li>NPO(V): 包含所有$U\in NPO$，满足若存在多项式时间的$f(n)-$近似算法，则$f(n)$不以任何多项式函数为界(e.g. TSP, 最大团问题)</li></ul><p>以上分类都基于合理的假设P$\neq$NP<br>所有集合都是非空的</p><h1 id="近似算法的稳定性"><a href="#近似算法的稳定性" class="headerlink" title="近似算法的稳定性"></a>近似算法的稳定性</h1><p>即使是NPO(V)中的问题，也可能有很大一部分的输入是比较简单的</p><p>稳定性用来衡量问题实例的限定(参数，特性等)对近似率的影响<br>如果对模型的限制影响近似率的程度很低，则可以说我们的算法是稳定的</p><p><strong>定义4.2.3.1</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$, $\overline{U}={\Sigma_I, \Sigma_O, L, L, \mathcal{M}, cost, goal}$是两个最优化问题，$L_I\subseteq L$. $\overline{U}$依据$L_I$的距离函数(distance function for $\overline{U}$ according to $L_I$)是任何满足下列性质的函数$h_L:L\to\mathbb{R}^+\cup{0}$:</p><ul><li>对任意$x\in L_I, h_L(x)=0$</li><li>$h$可以在多项式时间内计算</li></ul><p>定义：对任意$r\in\mathbb{R}^+$,$$Ball_{r,h}(L_I)={w\in L\mid h(w)\le r}$$</p><p>$p$是正实数，若对任意实数$0\le r\le p$, 存在$\delta_{r,\varepsilon}\in\mathbb{R}^{&gt;1}$, $A$是$U_r={\Sigma_I, \Sigma_O, L, Ball_{r,h}, \mathcal{M}, cost, goal}$的$\delta_{r,\varepsilon}-$近似算法，则称$A$是<strong>p-stable</strong> according to $h$</p><p>若对任意$p\in\mathbb{R}^+$，$A$都是p-stable的，则称$A$是stable according to $h$<br>反之，若对任意$p\in\mathbb{R}^+$，$A$都不是p-stable的，则称$A$是unstable according to $h$</p><p>对任意正整数$r$和任意函数$f:\mathbb{N}\to\mathbb{R}^{&gt;1}$,若$A$是$U_r={\Sigma_I, \Sigma_O, L, Ball_{r,h}, \mathcal{M}, cost, goal}$的$f_r(n)-$近似算法，则称$A$是$(r,f_r(n))$-quasistable accroding to $h$</p><p>把PTAS$A$看作一系列多项式时间$(1+\varepsilon)-$近似算法的集合$A_\varepsilon$.若在某个距离度量$h$下对任意$\varepsilon&gt;0$,$A_\varepsilon$都是稳定的，则我们可以得到以下二者之一</p><ul><li>$U_r$的一个PTAS(for every $r\in\mathbb{R}^+$)</li><li>$U_r$的一个$\delta_{r,\varepsilon}$近似算法，但没有PTAS</li></ul><p><strong>定义4.2.3.6</strong>： $U,\overline{U}$定义同上。$h$是$\overline{U}$根据$L_I$的距离函数，$U_r$同上。设$A={A_\varepsilon}<em>{\varepsilon&gt;0}$是$U$的一个PTAS<br>若对任意$r&gt;0$和$\varepsilon&gt;0$,$A</em>\varepsilon$是$\delta_{r,\varepsilon}$-近似算法，则$A$是关于$h$stable的<br>若$\delta_{r,\varepsilon}\le f(\varepsilon)\cdot g(r)$，其中$f$和$g$是某些$\mathbb{R}^{\ge 0}\to\mathbb{R}^+$的函数且$\lim\limits_{\varepsilon\to 0}f(\varepsilon)=0$, 则称$A$关于$h$超稳定(superstable).</p><p>如果$A$对$U$超稳定，则$A$对$U_r$也超稳定</p><h1 id="对偶近似算法"><a href="#对偶近似算法" class="headerlink" title="对偶近似算法"></a>对偶近似算法</h1><p>修改限制条件$\mathcal(M)$来简化计算</p><p><strong>定义4.2.4.1</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$是一个最优化问题。$U$的<strong>限制距离函数(constraint distance function)</strong>是任何满足下列条件的函数$h:L_I\times\Sigma^*_O\to\mathbb{R}^{\ge 0}$:</p><ul><li>对任意$S\in\mathcal{M}(x), h(x,S)=0$</li><li>对任意$S\notin\mathcal{M}(x), h(x,S)&gt;0$</li><li>$h$是多项式时间内可计算的</li></ul><p>对任意$\varepsilon\in\mathbb{R}^+$,任意$x\in L_I$,$\mathcal{M}_\varepsilon^h(x)={S\in\Sigma_O^*\mid h(x,S)\le\varepsilon}$是$\varepsilon-$ball of $\mathcal{M}(x)$ according to $h$.</p><p><strong>定义4.2.4.2</strong>: $U$是最优化问题，$h$是$U$的限制距离函数. 若对任意$x\in L_1$,有$A(x)\in\mathcal{M}_\varepsilon^h(x)$且$cost(A(x))\ge Opt_U(x)$ if $goal=maximum$且$cost(A(x))\le Opt_U(x)$ if $goal=minimum$, 则称$A$是$U$的$h-$对偶$\varepsilon-$近似算法</p><p><strong>定义4.2.4.3</strong>: 条件同上。若</p><ul><li>对任意输入$(x,\varepsilon)\in L_I\times\mathbb{R}^+, A(x,\varepsilon)\in\mathcal{M}_\varepsilon^h(x)$</li><li>$cost(A(x))\ge Opt_U(x)$ if $goal=maximum$且$cost(A(x))\le Opt_U(x)$ if $goal=minimum$</li><li>$Time_A(x,\varepsilon^{-1})$以某个$|x|$的多项式函数为界</li></ul><p>则称$A$是$U$的$h-dual$PTAS<br>类似的可以定义$U$的$h-dual$FPTAS</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>降低问题难度的方法：</p><ul><li>对输出精度要求降低</li><li>对输入做限制</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;近似算法是能提供最优化问题的可行解的算法，所提供的解的质量不会与最优解相差太多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;形式化定义&lt;/strong&gt;：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自己看得惯的板子整理</title>
    <link href="https://mengzelev.github.io/2019/04/19/oj-templates/"/>
    <id>https://mengzelev.github.io/2019/04/19/oj-templates/</id>
    <published>2019-04-19T08:20:44.000Z</published>
    <updated>2019-04-20T10:55:16.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h2><h3 id="dfs版"><a href="#dfs版" class="headerlink" title="dfs版"></a>dfs版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> rnd, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (status == two[num] - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[i][status] &gt; <span class="number">0</span>) <span class="keyword">return</span> f[i][status];</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = num; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (j != i &amp;&amp; (!(status &amp; temp))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q &gt; dfs(j, rnd + <span class="number">1</span>, status | temp) + a[need[i]][need[j]]) &#123;</span><br><span class="line">                q = dfs(j, rnd + <span class="number">1</span>, status | temp) + a[need[i]][need[j]];</span><br><span class="line">                c[i][status] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[i][status] = q;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bfs版"><a href="#bfs版" class="headerlink" title="bfs版"></a>bfs版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(start);</span><br><span class="line">    vis[start] = <span class="literal">true</span>;</span><br><span class="line">    s[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = u + ok[i];</span><br><span class="line">            <span class="keyword">int</span> v2 = u - ok[i];</span><br><span class="line">            <span class="keyword">if</span> (v1 &lt;= n &amp;&amp; !vis[v1]) &#123;</span><br><span class="line">                Q.push(v1);</span><br><span class="line">                s[v1] = s[u] + <span class="number">1</span>;</span><br><span class="line">                vis[v1] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v2 &gt;= <span class="number">0</span> &amp;&amp; !vis[v2]) &#123;</span><br><span class="line">                Q.push(v2);</span><br><span class="line">                s[v2] = s[u] + <span class="number">1</span>;</span><br><span class="line">                vis[v2] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) e[i] = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">int</span> sn = <span class="number">1</span> &lt;&lt; cnt1; <span class="comment">//状态数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sn; ++i) f[i] = INF;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sn; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &amp; e[j]) ++j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p = j + <span class="number">1</span>; p &lt; cnt1; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(i &amp; e[p]) &amp;&amp; dist[p+<span class="number">1</span>][j+<span class="number">1</span>]) &#123;</span><br><span class="line">            f[i | e[j] | e[p]] = min(f[i | e[j] | e[p]], f[i] + dist[p+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> f[sn<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//别忘了初始化f[i]=i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = f[x];</span><br><span class="line">    <span class="keyword">while</span>(root != f[root]) root = f[root];</span><br><span class="line">    <span class="keyword">int</span> y = f[x];</span><br><span class="line">    <span class="keyword">while</span>(f[x] != root)&#123;</span><br><span class="line">        f[x] = f[y];</span><br><span class="line">        y = f[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(a, b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(a);</span><br><span class="line">    <span class="keyword">int</span> fb = find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa != fb) f[fa] = fb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> temp = f[x];</span><br><span class="line">    f[x] = find(temp);</span><br><span class="line">    rel[x] = (rel[x] + rel[temp]) % <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//rel[x]初始化为全0</span></span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">        f[fy] = fx;</span><br><span class="line">        rel[fy] = (<span class="number">3</span> + d + rel[x] - rel[y]) % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span>) <span class="keyword">return</span> (rel[x] == rel[y]);</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">1</span>) <span class="keyword">return</span> ((<span class="number">3</span> - rel[x] + rel[y]) % <span class="number">3</span> == d); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fu = find(e[i].u);</span><br><span class="line">        <span class="keyword">int</span> fv = find(e[i].v);</span><br><span class="line">        <span class="keyword">if</span> (fu != fv) &#123;</span><br><span class="line">            f[fv] = fu;</span><br><span class="line">            ans += e[i].weight;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">//序号，找边权用</span></span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;y) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &lt; y.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;vertex[MAXN] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue &lt;node&gt; q;</span><br><span class="line">    vertex[<span class="number">0</span>].d = <span class="number">0</span>;</span><br><span class="line">    q.push(vertex[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u.id].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> vid = son[u.id][i];</span><br><span class="line">            <span class="keyword">double</span> weight = w[u.id][i];</span><br><span class="line">            <span class="keyword">if</span>(vertex[vid].d &lt; u.d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vertex[vid].d &gt; u.d + weight)&#123;</span><br><span class="line">                vertex[vid].d = u.d + weight;</span><br><span class="line">                q.push(vertex[vid]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j] &gt; <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j])</span><br><span class="line">                    <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="各种tarjan"><a href="#各种tarjan" class="headerlink" title="各种tarjan"></a>各种tarjan</h1><h2 id="有向图强连通分量数"><a href="#有向图强连通分量数" class="headerlink" title="有向图强连通分量数"></a>有向图强连通分量数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfn[u] u的时间戳</span></span><br><span class="line"><span class="comment">//low[u] u或u的子树能够追溯到的最早栈中节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++cnt;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    stack1[++index] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v]) low[u] = min(low[u], dfn[v]); <span class="comment">//u-v is a back edge</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">        scnum ++; <span class="comment">//强连通分量数</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            belong[stack1[index]] = scnum;</span><br><span class="line">            num[scnum] ++;</span><br><span class="line">            vis[stack1[index]] = <span class="literal">false</span>;</span><br><span class="line">            index --;</span><br><span class="line">        &#125;<span class="keyword">while</span>(u != stack1[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">//     if(!dfn[i]) &#123;</span></span><br><span class="line"><span class="comment">//         cnt = 1;</span></span><br><span class="line"><span class="comment">//         tarjan(i);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="无向图割点与割边"><a href="#无向图割点与割边" class="headerlink" title="无向图割点与割边"></a>无向图割点与割边</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">    dfs_clock ++;</span><br><span class="line">    dfn[u] = low[u] = dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v,u);</span><br><span class="line">            child ++;</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>((u == <span class="number">1</span> &amp;&amp; child &gt; <span class="number">1</span>) || (u != <span class="number">1</span> &amp;&amp; dfn[u] &lt;= low[v])) &#123;</span><br><span class="line">                cut.push_back(u); <span class="comment">//割点判定</span></span><br><span class="line">                <span class="comment">//iscut[u] = true;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u]) </span><br><span class="line">                bridge.push_back(&#123;min(u,v), max(u,v)&#125;); <span class="comment">//割边判定</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v != pre)</span><br><span class="line">                low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tarjan(1,-1);</span></span><br></pre></td></tr></table></figure><h2 id="无向图双连通分量"><a href="#无向图双连通分量" class="headerlink" title="无向图双连通分量"></a>无向图双连通分量</h2><p>点（边）双连通分量：若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥），则称作点（边）双连通图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    dfs_clock ++;</span><br><span class="line">    dfn[u] = low[u] = dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v,u);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v != pre) low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计无向图的边双连通分量，在一个双连通分量中当且仅当low[u] == low[v]</span></span><br></pre></td></tr></table></figure><h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">directed_euler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> moreout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> morein = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ver[i].indeg &gt; ver[i].outdeg) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ver[i].indeg == ver[i].outdeg + <span class="number">1</span>) morein ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ver[i].deg &lt; ver[i].outdeg) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ver[i].outdeg == ver[i].indeg + <span class="number">1</span>) moreout++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("morein = %d, moreout = %d", morein, moreout);</span></span><br><span class="line">    <span class="keyword">if</span>(morein &lt;= <span class="number">1</span> &amp;&amp; moreout &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断连通有向图是否含欧拉迹</span></span><br><span class="line"><span class="comment">//至多一顶点出度=入度+1</span></span><br><span class="line"><span class="comment">//至多一顶点入度=出度+1</span></span><br><span class="line"><span class="comment">//其余顶点：入度=出度</span></span><br></pre></td></tr></table></figure><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">undirected_euler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(ver[i].deg % <span class="number">2</span> == <span class="number">1</span>) odd++;</span><br><span class="line">    <span class="keyword">if</span>(odd == <span class="number">0</span> || odd == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈密尔顿回路"><a href="#哈密尔顿回路" class="headerlink" title="哈密尔顿回路"></a>哈密尔顿回路</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hamilton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    path.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size() - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[path[j]][i] &amp;&amp; <span class="built_in">map</span>[i][path[j + <span class="number">1</span>]])&#123;</span><br><span class="line">                path.insert(path.begin() + j + <span class="number">1</span>, i);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[path.back()][i]) path.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> path.insert(path.begin(), i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h1><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">0</span> || find(match[i]))&#123;</span><br><span class="line">                match[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">if</span>(find(i)) ans ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KM：最小权匹配"><a href="#KM：最小权匹配" class="headerlink" title="KM：最小权匹配"></a>KM：最小权匹配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    S[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!T[j] &amp;&amp; ls[i] + lt[j] == <span class="built_in">map</span>[i][j]) &#123;</span><br><span class="line">            T[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!match[j] || find(match[j])) &#123;</span><br><span class="line">                match[j] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> relax_val = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(n,m); ++i)</span><br><span class="line">        <span class="keyword">if</span>(S[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j)</span><br><span class="line">                <span class="keyword">if</span>(!T[j] &amp;&amp; ls[i] + lt[j] &gt; <span class="built_in">map</span>[i][j]) relax_val = min(relax_val, ls[i] + lt[j] - <span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    assert(relax_val &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i]) ls[i] -= relax_val;</span><br><span class="line">        <span class="keyword">if</span> (T[i]) lt[i] += relax_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match, <span class="number">0</span>, <span class="keyword">sizeof</span>(match));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(m,n); ++i) &#123;</span><br><span class="line">        ls[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j) ls[i] = max(<span class="built_in">map</span>[i][j], ls[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) lt[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(n,m); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(S, <span class="number">0</span>, <span class="keyword">sizeof</span>(S));</span><br><span class="line">            <span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T));</span><br><span class="line">            <span class="keyword">if</span> (find(i)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> relax();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="Dinic-当前弧优化"><a href="#Dinic-当前弧优化" class="headerlink" title="Dinic+当前弧优化"></a>Dinic+当前弧优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0</span> , <span class="keyword">sizeof</span>(depth));</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    depth[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[u][v] &gt; <span class="number">0</span> &amp;&amp; !depth[v]) &#123;</span><br><span class="line">                depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth[t] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 寻找当前增广路径上的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> dist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i = cur[u]; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(depth[v] == depth[u] + <span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[u][v] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> minc = dfs(v, min(dist, <span class="built_in">map</span>[u][v]));</span><br><span class="line">            <span class="keyword">if</span>(minc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">map</span>[u][v] -= minc;</span><br><span class="line">                <span class="built_in">map</span>[v][u] += minc;</span><br><span class="line">                <span class="keyword">return</span> minc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span> , <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">int</span> minc = dfs(s, INF)) &#123;</span><br><span class="line">            ans += minc;</span><br><span class="line">            <span class="comment">//printf("minc=%d\n",minc);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2row</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) swap(a[x][i], a[y][i]);</span><br><span class="line">    <span class="comment">//printf("**swap row %d with row %d**\n",x,y);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot_one</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> temp = a[x][y];</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i &lt;= n + <span class="number">1</span>; ++i) a[x][i] /= temp;</span><br><span class="line">    <span class="comment">//printf("**pivot one at row %d**\n", x);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul_and_add</span><span class="params">(<span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">double</span> cof)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        a[dst][i] -= a[src][i] * cof;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("**mul row %d with %lf add to row %d**\n", src, cof, dst);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_matrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">printf</span>(<span class="string">"%lf "</span>, a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"| %lf\n"</span>, a[i][n + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">iszero</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(a[row][i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Guass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">1</span>, col = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(row &lt;= n &amp;&amp; col &lt;= n) &#123;</span><br><span class="line">        <span class="comment">//printf("Now row=%d, col=%d\n",row, col);</span></span><br><span class="line">        <span class="keyword">if</span>(a[row][col] == <span class="number">0.0</span>) &#123;</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = row + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                <span class="keyword">if</span>(a[i][col] != <span class="number">0</span>) &#123;</span><br><span class="line">                    swap2row(row, i);</span><br><span class="line">                    ok = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(ok == <span class="literal">false</span>) &#123;col++; <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="comment">//else print_matrix();</span></span><br><span class="line">        &#125;</span><br><span class="line">        pivot_one(row,col);</span><br><span class="line">        <span class="keyword">if</span>(col == n &amp;&amp; row == n &amp;&amp; a[row][col] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//print_matrix();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(i != row &amp;&amp; a[i][col] != <span class="number">0</span>) &#123;</span><br><span class="line">                assert(a[row][col] != <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">double</span> cof = a[i][col] / a[row][col];</span><br><span class="line">                <span class="keyword">if</span>(cof != <span class="number">0</span>) mul_and_add(row, i, cof);</span><br><span class="line">                assert(a[i][col] == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//print_matrix();</span></span><br><span class="line">        row ++; col ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性规划-–-simplex单纯形算法"><a href="#线性规划-–-simplex单纯形算法" class="headerlink" title="线性规划 – simplex单纯形算法"></a>线性规划 – simplex单纯形算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; -EPS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; EPS ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    swap(id[n + r], id[c]);</span><br><span class="line">    <span class="keyword">double</span> x = -a[r][c];</span><br><span class="line">    a[r][c] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) a[r][i] /= x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sgn(a[i][c]) &amp;&amp; i != r) &#123;</span><br><span class="line">            x = a[i][c];</span><br><span class="line">            a[i][c] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) a[i][j] += x * a[r][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* important: revert symbols of conditions */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            a[i][j] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = i;</span><br><span class="line">    <span class="comment">/* initial-simplex */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[i][<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123; x = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[x][i]) &gt; <span class="number">0</span>) &#123; y = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!y) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// infeasible</span></span><br><span class="line">        pivot(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* solve-simplex */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[<span class="number">0</span>][i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        printf("choose x%d, cof=%d\n", x, a[0][x]);</span></span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">break</span>; <span class="comment">// finished</span></span><br><span class="line">        <span class="keyword">double</span> w = <span class="number">0</span>, t = <span class="number">0</span>; <span class="comment">//t是最苛刻的非基本变量能取到的最大值</span></span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[i][x]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                t = ((<span class="keyword">double</span>)-a[i][<span class="number">0</span>]) / ((<span class="keyword">double</span>)a[i][x]);</span><br><span class="line"><span class="comment">//                if(x==3) printf("t: -%d / %d = %.lf\n", a[i][0], a[i][x], t);</span></span><br><span class="line">                <span class="keyword">if</span> (f || t &lt; w) &#123;</span><br><span class="line">                    w = t, y = i, f = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="comment">// unbounded</span></span><br><span class="line">        pivot(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) v[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; ++i) v[id[i]] = a[i - n][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">  kmp[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len2; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s2[i] != s2[j + <span class="number">1</span>]) j = kmp[j];</span><br><span class="line">    <span class="keyword">if</span>(s2[j + <span class="number">1</span>] == s2[i]) j ++;</span><br><span class="line">    kmp[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s1[i] != s2[j + <span class="number">1</span>]) j = kmp[j];</span><br><span class="line">    <span class="keyword">if</span>(s1[i] == s2[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    <span class="keyword">if</span>(j == len2 - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - len2 + <span class="number">2</span>);</span><br><span class="line">      j = kmp[j];</span><br><span class="line">      ok = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="comment">/*字典树*/</span></span><br><span class="line">    <span class="keyword">int</span> tot, root;</span><br><span class="line">    <span class="keyword">int</span> nxt[MAXN][<span class="number">26</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">      tot = <span class="number">1</span>;</span><br><span class="line">      root = newNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">memset</span>(nxt[tot], <span class="number">0</span> ,<span class="keyword">sizeof</span>(nxt[tot]));</span><br><span class="line">      <span class="keyword">return</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> cur = root;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(nxt[cur][id] == <span class="number">0</span>) nxt[cur][id] = newNode();</span><br><span class="line">        cur = nxt[cur][id];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">          <span class="keyword">if</span>(nxt[i][j] != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"S.nxt[%d][%c]=%d\n"</span>,i, j+<span class="string">'a'</span>, nxt[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;S;</span><br></pre></td></tr></table></figure><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n, ll mod)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*快速幂*/</span></span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  a %= mod;</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = (ans * a) % mod;</span><br><span class="line">    a = (a * a) % mod;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;状态压缩dp&quot;&gt;&lt;a href=&quot;#状态压缩dp&quot; class=&quot;headerlink&quot; title=&quot;状态压缩d
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>os期中复习</title>
    <link href="https://mengzelev.github.io/2019/04/15/os-midterm/"/>
    <id>https://mengzelev.github.io/2019/04/15/os-midterm/</id>
    <published>2019-04-15T14:17:55.000Z</published>
    <updated>2019-06-22T08:27:58.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用眼中的OS"><a href="#应用眼中的OS" class="headerlink" title="应用眼中的OS"></a>应用眼中的OS</h1><ul><li>操作系统一方面需要提供程序的<strong>执行的环境</strong>和<strong>相应的资源</strong>，还要提供<strong>和操作系统世界中其他对象交互的方法和约定</strong></li></ul><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="共享内存多线程"><a href="#共享内存多线程" class="headerlink" title="共享内存多线程"></a>共享内存多线程</h2><ul><li>并发定义：一个程序、算法或问题的不同部分乱序或偏序执行而不影响最终结果的能力</li><li><p>程序经历了什么？</p><ul><li>编译器优化$\to$顺序丧失</li><li>操作系统中断，多处理器、缓存(硬件)$\to$原子性(all or nothing)丧失</li><li>缓存，乱序（硬件）$\to$可见性丧失</li></ul></li><li><p>顺序丧失：允许源代码中内存访问指令不再按顺序甚至不再出现</p></li><li>原子性的丧失：指令序列可以在任意时刻被中断，然后操作系统切换到其他线程执行</li><li>可见性丧失：缓存&amp;乱序</li></ul><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>评估一把锁的基本准则</p><ul><li>能够完成基本任务：提供互斥性质</li><li>锁的分配是公平的：不会有现成想要上锁却永远得不到它</li><li>锁的高效的：无等待时性能？多线程同时等待时性能？多CPU每个核的线程都要上锁时性能？</li></ul><p>自旋锁的正确性证明：</p><ul><li>建模程序的状态</li><li>证明safety(只有一个线程进入临界区)和liveness(至少有一个线程能进入临界区)</li></ul><h3 id="几种上锁方法"><a href="#几种上锁方法" class="headerlink" title="几种上锁方法"></a>几种上锁方法</h3><ul><li>TestAndSet；相当于<code>atomic_xchg</code></li><li>CompareAndWait</li><li>LL&amp;SC</li><li>FetchAndAdd：彩票锁，保证公平性</li></ul><h2 id="同步-CV"><a href="#同步-CV" class="headerlink" title="同步(CV)"></a>同步(CV)</h2><ul><li><code>wait(&amp;cond)</code>：当前进程进入睡眠状态，等待cond被满足后唤醒</li><li><code>signal(&amp;cond)</code>：唤醒在等待cond条件的某个进程</li><li><code>broadcast(&amp;cond)</code>: 唤醒在等待cond条件的所有进程</li><li>需要配合互斥锁使用：读取状态到<code>wait()</code>之间不能被打断，改变状态到<code>signal</code>之间也不能被打断</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>互斥锁(二元信号量)和同步都可以使用信号量来实现<br>信号量就相当于有一个管理员manage了一堆资源，进程需要资源时先向管理员请求(<code>semi_wait</code>)，暂时没有资源就等，使用完毕后归还(<code>semi_post</code>)给管理员</p><h3 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h3><ul><li><code>sem_wait</code>：信号量-1，表示在等待的线程增加了一个，消耗一个执行名额；如果信号量&lt;0, 表示等待的线程数多于可执行线程数，当前线程进入睡眠</li><li><code>sem_post</code>：信号量+1，表示执行的线程少了一个，可以让出一个执行名额</li></ul><h2 id="并发Bugs"><a href="#并发Bugs" class="headerlink" title="并发Bugs"></a>并发Bugs</h2><ul><li>原子性违反(AV) —&gt; 上锁</li><li>顺序违反(OV) -&gt; 同步</li></ul><h3 id="死锁出现的四个条件"><a href="#死锁出现的四个条件" class="headerlink" title="死锁出现的四个条件"></a>死锁出现的四个条件</h3><ul><li>互斥</li><li>请求与保持(同一个进程要同时上多把锁)</li><li>没有抢占(不能强制解锁)</li><li>循环等待</li></ul><h3 id="对付死锁"><a href="#对付死锁" class="headerlink" title="对付死锁"></a>对付死锁</h3><ul><li>避免：规定上锁顺序</li><li>检测：打log</li></ul><h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><p>每个进程都以为自己独占CPU和整个内存空间<br>进程：OS提供的对运行程序的抽象</p><h2 id="进程抽象"><a href="#进程抽象" class="headerlink" title="进程抽象"></a>进程抽象</h2><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>Running: 进程正在处理器上执行命令</li><li>Ready：进程准备执行，但由于某些原因OS决定现在不让它运行</li><li>Blocked：进程此前执行了某些操作(e.g. I/O)，让它在其他事件发生前停止执行</li></ul><h3 id="实现进程"><a href="#实现进程" class="headerlink" title="实现进程"></a>实现进程</h3><ul><li>进程=线程+地址空间</li><li>进程就是个结构体<ul><li>名字</li><li>pid</li><li>上下文</li><li>地址空间</li><li>堆栈</li><li>状态</li><li>其他信息（如父进程、文件描述符等）</li></ul></li></ul><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>一个指向os内对象的指针<br><code>fork-exec</code>不改变文件描述符</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"a.txt"</span>);</span><br><span class="line">dup2(STDOUT_FILENO, fd); <span class="comment">//???</span></span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pipe(fds) != <span class="number">0</span>) &#123;panic(<span class="string">"pipe error"</span>);&#125;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;<span class="comment">//child</span></span><br><span class="line">    dup2(fds[<span class="number">1</span>], STUOUT_FILENO); <span class="comment">//连接写口，往管道内写数据</span></span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; <span class="comment">//parent</span></span><br><span class="line">    dup2(fds[<span class="number">0</span>], STDIN_FILENO); <span class="comment">//连接读口，从管道内读数据</span></span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>进程组实现</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h3><ul><li>轮转时间(turnaround time): $\sum t_{complete}-t_{arrival}$</li><li>响应时间(response time): $\sum t_{firstrun}-t_{arrival}$</li></ul><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><ul><li>优点：简单易实现</li><li>缺点： 会产生护航效应</li></ul><h3 id="SJF-Shortest-Job-First"><a href="#SJF-Shortest-Job-First" class="headerlink" title="SJF(Shortest Job First)"></a>SJF(Shortest Job First)</h3><ul><li>当假设所有任务同时到达时的最优算法</li><li>非抢占式(preemptive)算法</li></ul><h3 id="STCF-Shortest-Time-to-Completion-First"><a href="#STCF-Shortest-Time-to-Completion-First" class="headerlink" title="STCF(Shortest Time-to-Completion First)"></a>STCF(Shortest Time-to-Completion First)</h3><ul><li>抢占式策略，又名Preemptive Shortest Job First(PSJF)</li><li>轮转时间短但响应时间长</li></ul><h3 id="RR-Round-Robin"><a href="#RR-Round-Robin" class="headerlink" title="RR(Round Robin)"></a>RR(Round Robin)</h3><ul><li>每个进程运行一段时间片(time slice, sometimes called scheduling quantum)</li><li>时间片越短，响应时间越短，但是切换上下文的时间会变长(trade-off)</li><li>当考虑轮转时间时非常糟糕</li><li>保证了公平性但是损失了效率</li></ul><h3 id="MLFQ-Multi-level-Feedback-Queue"><a href="#MLFQ-Multi-level-Feedback-Queue" class="headerlink" title="MLFQ(Multi-level Feedback Queue)"></a>MLFQ(Multi-level Feedback Queue)</h3><p>MLFQ有很多种实现但都大同小异，书上只介绍一种</p><ul><li>有很多队列，每个队列具有不同的优先级，优先级高的先运行</li><li>通过观察进程过去的行为调整优先级<ul><li>如果一个进程频繁让出CPU，保持高优先级；反之一个进程如果长时间占用CPU则会被降低优先级</li></ul></li><li>并不知道一个任务是长是短，因此先假设是短的，然后根据进程的后续表现修改认知</li></ul><h4 id="优先级的修改"><a href="#优先级的修改" class="headerlink" title="优先级的修改"></a>优先级的修改</h4><p>workload: 交互式短时间任务(会频繁让出CPU)+不交互的长时间任务(响应时间不那么重要)</p><h4 id="Basic-Rules"><a href="#Basic-Rules" class="headerlink" title="Basic Rules"></a>Basic Rules</h4><ol><li>If Priority(A)&gt;Priority(B), A runs (B doesn’t)</li><li>If Priority(B)==Priority(B), A &amp; B runs in RR</li><li>一个任务最初进入系统时位于最高优先级<br>4(a). 如果一个任务耗尽了时间片，则优先级下降<br>4(b). 如果一个任务在时间片耗尽之前放弃了CPU,优先级不变<br>4(改进). 当一个任务在一定程度上用尽了被分配到的时间，优先级就下降<br>5(新增). 在一段时间$S$后，将所有任务移到最高优先级上(Priority-boost) </li></ol><p>缺陷： </p><ul><li>饥饿：如果交互式进程很多就会完全占用CPU使得长任务得不到调度(5解决)</li><li>有些心脏的应用可以玩弄这个规则，一直主动让出一小会儿CPU来使自己停留在高优先级上(4解决)</li><li>任务的行为可能会随着时间改变(5解决)</li></ul><h3 id="PS-Proportional-share"><a href="#PS-Proportional-share" class="headerlink" title="PS(Proportional-share)"></a>PS(Proportional-share)</h3><ul><li>老子才不管什么的轮转时间和响应时间，老子只要每个任务都能按比例分到一定时间</li></ul><h4 id="lottery-scheduling"><a href="#lottery-scheduling" class="headerlink" title="lottery scheduling"></a>lottery scheduling</h4><blockquote><p>随机的好处</p><ul><li>防止了边界情况</li><li>轻量级，需要记录的信息少</li><li>快(太快了可能会变成伪随机数)</li></ul></blockquote><p>怎么分配彩票也是个很棘手的问题</p><h4 id="stride-scheduling"><a href="#stride-scheduling" class="headerlink" title="stride scheduling"></a>stride scheduling</h4><ul><li>根据每个任务的彩票数决定每次调度执行的时间长短</li><li>每次调度都选取运行时间最短的任务</li></ul><h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><p>不想看了【瘫</p><h2 id="链接和加载"><a href="#链接和加载" class="headerlink" title="链接和加载"></a>链接和加载</h2><ul><li>静态链接下的加载：<code>_start-&gt;__libc_start_main-&gt;generic_start_main-&gt;...-&gt;main</code></li><li>动态链接：<ul><li>PLT：程序链接表，放入进行链接的代码，方便lazy linking</li><li>GOT：全局偏移表，存放函数代码开始的地址</li></ul></li></ul><h2 id="虚存抽象"><a href="#虚存抽象" class="headerlink" title="虚存抽象"></a>虚存抽象</h2><ul><li>mmap：把操作系统里的对象映射到进程的地址空间<ul><li>e.g.加载可执行文件的时候把文件搬到某个地址处</li><li>不映射任何文件的时候就相当于malloc</li><li>只记录相关信息，余下的等发生缺页时再处理，所以非常快</li><li>可以用红黑树维护分配的内存</li><li>fork采用写时复制</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;应用眼中的OS&quot;&gt;&lt;a href=&quot;#应用眼中的OS&quot; class=&quot;headerlink&quot; title=&quot;应用眼中的OS&quot;&gt;&lt;/a&gt;应用眼中的OS&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;操作系统一方面需要提供程序的&lt;strong&gt;执行的环境&lt;/strong&gt;和&lt;strong
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>问题求解学习笔记-密码算法</title>
    <link href="https://mengzelev.github.io/2019/04/13/ps-4-7-cryptographic-algorithm/"/>
    <id>https://mengzelev.github.io/2019/04/13/ps-4-7-cryptographic-algorithm/</id>
    <published>2019-04-13T04:04:44.000Z</published>
    <updated>2019-06-19T02:47:13.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RSA公钥加密系统"><a href="#RSA公钥加密系统" class="headerlink" title="RSA公钥加密系统"></a>RSA公钥加密系统</h1><p>每个参与者都有一把公钥($P$)和密钥($S$)</p><p>$\mathcal{D}$表示允许信息的集合，要求公钥与密钥指定一种从$\mathcal{D}$到自身的一一对应的函数。<br>Alice的公钥函数$P_A$和密钥函数$S_A$都是$\mathcal{D}$的排列</p><p>系统中任何参与者的公钥与密钥都是匹配对，指定函数互为反函数，对任何消息$M\in \mathcal{D}$，有<br>$$M=S_A(P_A(M))$$<br>$$M=P_A(S_A(M))$$</p><h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><ul><li>Bob取得Alice的公钥$P_A$</li><li>Bob计算出相应与$M$的密文$C=P_A(M)$，并把$C$发送给Alice</li><li>当Alice收到密文$C$后，运用自己的密钥$S_A$恢复原始信息$M$</li></ul><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul><li>Alice运用密钥$S_A$和等式$\sigma=S_A)M’$计算出信息$M’$的数字签名$\sigma$</li><li>Alice把消息/签名对$(M’,\sigma)$发给Bob</li><li>Bob收到$(M’,\sigma)$时，通过验证等式$M’=P_A(\sigma)$来证实消息的确是来自Alice</li></ul><p>任何人都可以把数字签名翻译出来，但只有密钥持有者可以生成数字签名</p><h2 id="RSA加密系统"><a href="#RSA加密系统" class="headerlink" title="RSA加密系统"></a>RSA加密系统</h2><p><img src="/2019/04/13/ps-4-7-cryptographic-algorithm/rsa.png"></p><p>加密<br>$$P(M)=M^e\bmod n$$<br>解密<br>$$S(C)=C^d\bmod n$$</p><p>上述加密解密操作可以使用快速幂实现。</p><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>假定：</p><ul><li>公钥$(e,n)$和密钥$(d,n)$满足$\lg~e=O(1), \lg~d\le\beta, \lg~n\le\beta$</li><li>应用公钥需要执行$O(1)$次模乘法运算和$O(\beta^2)$次位操作</li><li>应用密钥需要执行$O(\beta)$次模乘法运算和$O(\beta^2)$次位操作。</li></ul><h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p><strong>定理31.36(RSA的正确性)</strong>：RSA加密和解密等式定义了满足再上面两个等式的$\mathbb{Z}_n$的逆变换</p><p>RSA加密系统的安全性主要来源于对大整数进行因子分解的困难性</p><h3 id="效率提高"><a href="#效率提高" class="headerlink" title="效率提高"></a>效率提高</h3><ul><li>无公钥加密系统</li><li>抗冲突散列函数$h$</li><li>证书</li></ul><h1 id="整数的因子分解"><a href="#整数的因子分解" class="headerlink" title="整数的因子分解"></a>整数的因子分解</h1><h3 id="Pollard的rho启发式方法"><a href="#Pollard的rho启发式方法" class="headerlink" title="Pollard的rho启发式方法"></a>Pollard的rho启发式方法</h3><p><img src="/2019/04/13/ps-4-7-cryptographic-algorithm/pr.png"></p><ul><li>通过随机数寻找$n$的非平凡约数</li><li>可能会出现”$\rho$”字型回路，在出现回路之前预计要执行的步数为$\Theta(\sqrt{n})$</li><li>一种找出大整数的小素数因子的可供选择的办法</li></ul><h2 id="私钥密码学"><a href="#私钥密码学" class="headerlink" title="私钥密码学"></a>私钥密码学</h2><p>仿射密码系统(affine cryptosystem)：$f(p)=ap+b\bmod 26$, $f^{-1}(p)=a^{-1}p-a^{-1}b\bmod 26$</p><p>多字码密码系统(polyalphabetic cryptosystem): $f(\textbf{p})=A\textbf{p}+b$,其中$A$是矩阵，$b$是列向量，$f^{-1}(\textbf{p})=A^{-1}\textbf{p}-A^{-1}\textbf{p}$</p><h2 id="公钥密码学"><a href="#公钥密码学" class="headerlink" title="公钥密码学"></a>公钥密码学</h2><p>RSA加密系统（CLRS上已讲</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RSA公钥加密系统&quot;&gt;&lt;a href=&quot;#RSA公钥加密系统&quot; class=&quot;headerlink&quot; title=&quot;RSA公钥加密系统&quot;&gt;&lt;/a&gt;RSA公钥加密系统&lt;/h1&gt;&lt;p&gt;每个参与者都有一把公钥($P$)和密钥($S$)&lt;/p&gt;
&lt;p&gt;$\mathcal{
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-数论算法</title>
    <link href="https://mengzelev.github.io/2019/04/06/clrs-31Number-Theoretic-Algorithms/"/>
    <id>https://mengzelev.github.io/2019/04/06/clrs-31Number-Theoretic-Algorithms/</id>
    <published>2019-04-06T03:18:48.000Z</published>
    <updated>2019-06-18T09:43:32.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输入规模和算数计算的代价"><a href="#输入规模和算数计算的代价" class="headerlink" title="输入规模和算数计算的代价"></a>输入规模和算数计算的代价</h1><p>给定$k$个整数输入$a_1,a_2,\cdots ,a_k$，如果算法可以在关于$\lg~a_1,\lg~a_2,\cdots ,\lg~a_k$的多项式时间内完成，即算法在<strong>关于二进制编码后的输入长度</strong>的多项式时间内完成，则称该算法为<strong>多项式时间</strong>算法</p><p>当输入很大时，基本运算也会变得耗时。<br>两个$\beta$位整数相乘需要耗时$\Theta(\beta^2)$.<br>一个$\beta$为整数除以另一个较短整数的商或余数需要耗时$\Theta(\beta^2)$</p><h1 id="基础数论概念"><a href="#基础数论概念" class="headerlink" title="基础数论概念"></a>基础数论概念</h1><h2 id="整除性与约数"><a href="#整除性与约数" class="headerlink" title="整除性与约数"></a>整除性与约数</h2><p>你懂的</p><h2 id="素数与合数"><a href="#素数与合数" class="headerlink" title="素数与合数"></a>素数与合数</h2><p>你也懂的</p><h2 id="除法定理、余数和等模"><a href="#除法定理、余数和等模" class="headerlink" title="除法定理、余数和等模"></a>除法定理、余数和等模</h2><p><strong>定理31.1(除法定理)</strong>: 对于任何整数$a$和任何正整数$n$，存在唯一整数$q$和$r$，满足$0\le r&lt;n$且$a=qn+r$</p><p>根据整数模$n$的余数，可以将所有整数划分成$n$个等价类。<br>包含整数$a$的模$n$等价类为$\left[a\right]_n={a+kn:k\in\mathbb{Z}}$<br>所有这类等价类的集合是$\mathbb{Z}_n={[a]_n:0\le a\le n-1}$</p><h2 id="公约数与最大公约数"><a href="#公约数与最大公约数" class="headerlink" title="公约数与最大公约数"></a>公约数与最大公约数</h2><p>公约数的重要性质：</p><ul><li>$d\mid a$且$d\mid b$蕴含$d\mid (a+b)$且$d\mid (a-b)$</li><li>对任意整数$x$和$y$，都有$d\mid a$且$d\mid b$蕴含$d\mid(ax+by)$</li><li>$a\mid b$且$b\mid a$蕴含$a=\pm b$</li></ul><p><strong>定理31.2</strong>: 如果任意整数$a$和$b$不都为0，则gcd$(a,b)$是$a$与$b$线性组合集${ax+by:x,y\in\mathbb{Z}}$中的<strong>最小正元素</strong>。(最小正线性组合)</p><p><strong>推论31.3</strong>: 对任意整数$a$与$b$，如果$d\mid a$且$d\min b$，则$d\mid gcd(a,b)$</p><p><strong>推论31.4</strong>: 对所有整数$a$和$b$以及任意非负整数$n$，有$gcd(an,bn)=n~gcd(a,b)$</p><p><strong>推论31.5</strong>: 对于任意正整数$n,a$和$b$，如果$n\mid ab$且$gcd(a,n)=1$,则$n\mid b$.</p><h2 id="互质数"><a href="#互质数" class="headerlink" title="互质数"></a>互质数</h2><p><strong>定理31.6</strong>: 对任意整数$a,b$与$p$,如果$gcd(a,p)=1$且$gcd(b,p)=1$，则$gcd(ab,p)=1$.</p><h2 id="唯一因子分解定理"><a href="#唯一因子分解定理" class="headerlink" title="唯一因子分解定理"></a>唯一因子分解定理</h2><p><strong>定理31.7</strong>: 对所有素数$p$和所有整数$a,b$，如果$p\mid ab$,则$p\mid a$或$p\mid b$(或两者都成立)。</p><p><strong>定理31.8(唯一因子分解定理)</strong>: 合数$a$仅能以一种方式写成如下乘积形式<br>$$a=p_1^{e_1}p_2^{e_2}\cdots p_r^{e_r}$$<br>其中$p_i$为素数，$p_1&lt;p_2&lt;\cdots p_r$且$e_i$为正整数</p><h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><p><strong>定理31.9(GCD递归定理)</strong>: 对任意非负整数$a$和任意正整数$b$，$gcd(a,b)=gcd(b,a\bmod b)$</p><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p><strong>引理31.10</strong>: 如果$a&gt;b\ge 1$并且EUCLID($a,b$)执行了$k\ge 1$次递归调用，则$a\ge F_{k+2}， b\ge F_{k+1}$.($F_n$为斐波那契数列的第$n$项)</p><p><strong>定理31.11(Lame定理)</strong>: 对任意整数$k\ge 1$,如果$a&gt;b\ge 1$,且$b&lt;F_{k+1}$,则EUCLID($a,b$)的递归调用次数少于$k$次<br>该上界是最优的，因为$k\ge 2$时，EUCLID$(F_{k+1},F_k)$正好调用了$k$次</p><p>$F_k$约为$\phi^k/\sqrt{5}$, $\phi=(1+\sqrt{5})/2$<br>EUCLID执行中递归调用的次数为$O(\lg b)$<br>如果EUCLID作用于两个$\beta$位数，则将执行$O(\beta)$次算术运算和$O(\beta^3)$次位操作</p><h3 id="扩展形式"><a href="#扩展形式" class="headerlink" title="扩展形式"></a>扩展形式</h3><p>用于计算满足下列条件的整系数$x$和$y$(可能为0或负数):<br>$$d=gcd(a,b)=ax+by$$</p><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/exEUCLID.png"></p><p>运行时间与EUCLID相同</p><h1 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h1><p>群论复习</p><h2 id="模-n-加法群"><a href="#模-n-加法群" class="headerlink" title="模$n$加法群"></a>模$n$加法群</h2><p>你懂的</p><h2 id="模-n-乘法群"><a href="#模-n-乘法群" class="headerlink" title="模$n$乘法群"></a>模$n$乘法群</h2><p>$$(\mathbb{Z}_n^*, \cdot_n)$$</p><p>$$\mathbb{Z}_n^*={[a]_n\in\mathbb{Z}_n: gcd(a,n)=1}$$</p><p><strong>定理31.13</strong>: 模$n$乘法群是有限交换群</p><p>$\mathbb{Z}_n^*$中的除法由等式$a/b\equiv ab^{-1}\pmod n$定义</p><p>$\mathbb{Z}<em>n^*$的规模表示为欧拉phi函数($\phi(n)$)<br>$$\phi(n)=n\prod\limits</em>{p:\text{p is prime and }p\mid n}(1-\frac{1}{p})$$<br>直观理解(类似筛法求质数思想)：开始有一张$n$个余数组成的表，然后对于每个能整除$n$的素数$p$,在表中划掉所有$p$的倍数。</p><ul><li>若$p$是素数，则$\phi(p)=p-1$</li><li>若$n$是合数，$$\frac{n}{e^\gamma\ln\ln n+\frac{3}{\ln\ln n}}&lt;\phi(n)&lt;n-1$$($n\ge 3$, $\gamma=0.5772156649\cdots$是欧拉常数)<ul><li>$n&gt;5$时有个更松弛的下界$$\phi(n)&gt;\frac{n}{6\ln\ln n}$$</li></ul></li></ul><h2 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h2><p><strong>定理31.14</strong>: 一个有限群的非空封闭子集是一个子群</p><p><strong>定理31.15(拉格朗日定理)</strong>: 如果$(S,+)$是一个有限群，$(S’,+)$是$(S,+)$的一个子群，则$|S’|$是$|S|$的一个约数</p><p><strong>推论31.16</strong>: 如果$S’$是$S$的有限子群，则$|S’|\le |S|/2$</p><h2 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h2><p><strong>定理31.17</strong>: 对任意有限群$(S,+)$和任意$a\in S$, 一个元素的阶等于它所生成的循环子群的规模，即$ord(a)=|\langle a\rangle|$</p><p>$a^{(0)}=e, a^{(i)}=a^{(i\bmod t)}(t=\bmod a)$</p><p><strong>推论31.18</strong>: 序列$a^{(1)},a^{(2)},\cdots$是周期序列，其周期为$t=\bmod a$, 即$a^{(i)}=a^{(j)}$当且仅当$i\equiv j\pmod t$</p><p><strong>推论31.19</strong>: 如果$(S,+)$是具有单位元$e$的有限群，则对所有$a\in S$，$a^{(|S|)}=e$</p><h1 id="求解模线性方程"><a href="#求解模线性方程" class="headerlink" title="求解模线性方程"></a>求解模线性方程</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>$$ax\equiv b\pmod n$$<br>假设已知$a,b$和$n$，求出所有满足上述方程的对模$n$的$x$的值<br>该方程可能无解、仅有一解或有多解</p><h2 id="数学准备"><a href="#数学准备" class="headerlink" title="数学准备"></a>数学准备</h2><p><strong>定理31.20</strong>: 对任意正整数$a$和$n$，如果$d=gcd(a,n)$, 则在$\mathbb{Z}_n^*$中，$$\langle a\rangle=\langle d\rangle={0,d,2d,\cdots,((n/d)-1)d}$$<br>因此，$|\langle a\rangle|=n/d$.</p><p><strong>推论31.21</strong>: 当且仅当$d\mid b$时，方程$ax\equiv b\pmod n$对于未知量$x$有解。这里$d=gcd(a,n)$.<br>i.e. 当且仅当$[b]\in\langle a\rangle$时，方程有解</p><p><strong>推论31.22</strong>: 方程$ax\equiv b\pmod n$或者对模$n$有$d$个不同的解，或者无解。这里$d=gcd(a,d)$.</p><p><strong>定理31.23</strong>: 令$d=gcd(a,n)$, 假设对某些整数$x’$和$y’$,有$d=ax’+ny’$(例如EXTENDED-EUCLID所计算出的结果)。如果$d\mid b$,则方程$ax\equiv b\pmod n$有一个解的值为$x_0$,这里$x_0=x’(b/d)\pmod n$.</p><p><strong>定理31.24</strong>: 假设方程$ax\equiv b\pmod b$有解(即$d\mid b$),且$x_0$是该方程的任意一个解。因此，该方程对模$n$恰好有$d$个不同的解，分别为$x_i=x_0+i(n/d)$, 这里$i=0,1,\cdots,d-1$.</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/mod.png"></p><h2 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h2><p>执行$O(\lg n+gcd(a,n))$次算术运算</p><p><strong>推论31.25</strong>： 对任意$n&gt;1$, $a$和$n$互质时方程对模$n$有唯一解</p><p><strong>推论31.26</strong>： 对任意$n&gt;1$，若$a,n$互质，则方程$ax\equiv 1\pmod n$对模$n$有唯一解，否则方程无解。<br>因此，当$a$和$n$互质时，可以用记号$a^{-1}\bmod n$表示$a$对模$n$的乘法逆元</p><h1 id="中国余数定理"><a href="#中国余数定理" class="headerlink" title="中国余数定理"></a>中国余数定理</h1><p><strong>定理31.27(中国余数定理)</strong>: 令$n=n_1n_2\cdots n_k$,其中因子$n_i$两两互质。考虑以下对应关系:$$a\leftrightarrow(a_1,a_2,\cdots,a_k)$$这里$a\in\mathbb{Z}_n,a_i\in\mathbb{Z}_{n_i}$, 而且对$i=1,2,\cdots,k$, $$a_i=a\bmod n_i$$.</p><p>该映射是一个在$\mathbb{Z}<em>n$ 与笛卡尔积 $\mathbb{Z}</em>{n_1}\times\mathbb{Z}_{n_2}\times\cdots\times\mathbb{Z}_{n_k}$之间的一一对应，对$\mathbb{Z}_n$中元素所执行的运算可以等价地作用于对应的$k$元组</p><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/a+b.png"></p><p>从$(a_1,a_2,\cdots,a_k)$计算$a$：</p><ul><li>定义$m_i=n/n_i=n_1n_2\cdots n_{i-1}n_{i+1}\cdots n_l$</li><li>对$i=1,2, \cdots l$, 定义$c_i=m_i(m_i^{-1}\bmod n_i)$<ul><li>In fact, $c_i\leftrightarrow(0,0,\cdots ,0,1,0,\cdots 0)$ 除了在$i$个坐标上为1外其余坐标均为0</li></ul></li><li>$a\equiv (a_1c_1+a_2c_2+\cdots +a_kc_k)\pmod n$</li></ul><p>对任意$x$和$i=1,2,\cdots k,$有$x\bmod n_i=(x\bmod n)\mod n_i$.</p><p><strong>推论31.28</strong>: 如果$n_1,n_2,\cdots ,n_k$两两互质，$n=n_1n_2\cdots n_k$,则对任意整数$a_1,a_2,\cdots ,a_k$, 关于未知量$x$的联立方程组$$x\equiv a_i\pmod n_i,i=1,2,\cdots k$$对模$n$有唯一解</p><p><strong>推论31.29</strong>: 如果$n_1,n_2,\cdots ,n_k$两两互质，$n=n_1n_2\cdots n_k$, 则对所有整数$x$和$a$，$x\equiv a\pmod {n_i}$(其中$i=1,2,\cdots k$)当且仅当$x\equiv a\pmod n$.</p><p><strong>可以把模大数的线性方程转换为模小数的线性方程组</strong></p><h1 id="元素的幂"><a href="#元素的幂" class="headerlink" title="元素的幂"></a>元素的幂</h1><p><strong>定理31.30</strong>: 对于任意整数$n&gt;1$, $a^{\phi(n)}\equiv 1\pmod n$对所有$a\in\mathbb{Z}_n^*$都成立</p><p><strong>定理31.31</strong>: 若$p$是素数，则$a^{p-1}\equiv 1\pmod p$对所有$a\in\mathbb{Z}_p^*$都成立</p><p><strong>定理31.32</strong>: 对所有素数$p&gt;2$和所有正整数$e$，使得$\mathbb{Z}_n^*$是循环群的$n&gt;1$的值为2,4，$p^e$和$2p^e$。</p><p>若$g$是$\mathbb{Z}_n^<em>$的生成元，则对于任意$a\in\mathbb{Z}_n^</em>$存在一个$z$，使得$g^z\equiv a\pmod n$. 这个$z$称为对模$n$到基$g$上的$a$的一个<strong>离散对数</strong>或<strong>指数</strong>，记为$ind_{n,g}(a)$</p><p><strong>定理31.33(离散对数定理)</strong>: 如果$g$是$\mathbb{Z}_n^*$的一个生成元，则当且仅当等式$x\equiv y\pmod {\phi(n)}$ 成立时，有等式$g^x\equiv g^y\pmod n$成立。</p><p><strong>定理31.34</strong>: 如果$p$是一个奇素数且$e\ge 1$，则方程$$x^2\equiv 1\pmod {p^e}$$仅有两个解，即$x=\pm 1$。</p><p>如果$x$满足$x^2\equiv 1\pmod n$， 但$x$不等于以$n$为模的两个平凡平方根，则$x$是一个以$n$为模的<strong>非平凡平方根</strong></p><p><strong>推论31.35</strong>: 如果对模$n$存在1的非平凡平方根，则$n$是合数</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>又名：用反复平方法求数的幂</p><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/modex.png"></p><p>$c$只是用来辅助正确性证明的变量</p><p>循环不变式：</p><ul><li>$c$的值与$b$的二进制表示的前缀$\langle b_k,b_{k-1},\cdots b_{i+1}\rangle$相同</li><li>$d=a^c\pmod n$</li></ul><p>时间复杂度$O(\beta^3)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;输入规模和算数计算的代价&quot;&gt;&lt;a href=&quot;#输入规模和算数计算的代价&quot; class=&quot;headerlink&quot; title=&quot;输入规模和算数计算的代价&quot;&gt;&lt;/a&gt;输入规模和算数计算的代价&lt;/h1&gt;&lt;p&gt;给定$k$个整数输入$a_1,a_2,\cdots ,a_k
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
  </entry>
  
  <entry>
    <title>问题求解学习笔记-数论基础</title>
    <link href="https://mengzelev.github.io/2019/03/30/ps-4-6-basic-number-theory/"/>
    <id>https://mengzelev.github.io/2019/03/30/ps-4-6-basic-number-theory/</id>
    <published>2019-03-30T06:49:23.000Z</published>
    <updated>2019-06-18T09:18:23.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h1><p>你都懂的</p><h1 id="辗转相除法-Division-Algorithm"><a href="#辗转相除法-Division-Algorithm" class="headerlink" title="辗转相除法(Division Algorithm)"></a>辗转相除法(Division Algorithm)</h1><p><strong>定理2.9(辗转相除法)</strong>: $a,b$为整数，满足$b&gt;0$，则存在唯一的整数$q$和$r$使得$a=bq+r$，此处$0\le r&lt;b$</p><p>$a\mid b$: $a$能整除$b$,$b$能被$a$整除</p><p><strong>定理2.10</strong>: $a,b$为非零整数，则存在整数$r,s$使得gcd($a,b)=ar+bs$. $gcd(a,b)$是唯一的。但$r,s$不唯一</p><p><strong>推论2.11</strong>: $a,b$为互质的整数，则存在整数$r,s$使得$ar+bs=1$【事实上是当且仅当的关系】</p><h2 id="欧几里得算法-The-Euclidean-Algorithm"><a href="#欧几里得算法-The-Euclidean-Algorithm" class="headerlink" title="欧几里得算法(The Euclidean Algorithm)"></a>欧几里得算法(The Euclidean Algorithm)</h2><p>使用多次除法得到一个递减的序列来求出gcd$(a,b)$<br>$b=aq_1+r$<br>$a=r_1q_2+r_2$<br>$r_1=r_2q_3+r_3$<br>$\vdots$<br>$r_{n-2}=r_{n-1}a_n+r_n$<br>$r_{n-1}=r_nq_{n+1}$<br>将这一系列等式反过来书写可以得到$d$的表示(略)</p><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p><strong>引理2.13(Euclid)</strong>: $a,b$为整数，$p$为质数。如果$p\mid ab$,则$p\mid a$或$p\mid b$</p><p><strong>定理2.14(Euclid)</strong>: 质数的个数是无限的</p><p><strong>定理2.15(算术基本定理Fundamental Theorem of Arithmetic)</strong>: $n$为大于1的整数，则$n=p_1p_2\cdots p_k$，其中$p_1,…,p_k$为质数。这个分解是唯一的，即若$n=q_1q_2\cdots q_l$，则$k=l$且$q_i$只是$p_i$的排列</p><p>以下内容出自CZ</p><h2 id="mathbb-Z-n-上的乘法逆元"><a href="#mathbb-Z-n-上的乘法逆元" class="headerlink" title="$\mathbb{Z}_n$上的乘法逆元"></a>$\mathbb{Z}_n$上的乘法逆元</h2><p><strong>乘法逆元(multiplicative inverse)</strong>: $a’\cdot_{n}a=1$,则称$a’$是$a$在$\mathbb{Z}_n<br>$中的乘法逆元</p><p><strong>引理2.5</strong>: 设$a$在$\mathbb{Z}_n$中存在乘法逆元$a’$. 则对于任意$b\in\mathbb{Z}<em>n$,等式$a\cdot</em>{n}x=b$有唯一解$x=a’\cdot_{n}b$.</p><p><strong>推论2.6</strong>: 若存在$b\in\mathbb{Z}<em>n$使得$a\cdot</em>{n}x=b$的$a$无解，则$a$在$\mathbb{Z}_n$上不存在乘法逆元</p><p><strong>定理2.7</strong>: 若$\mathbb{Z}_n$中的元素有一个乘法逆元，则它的乘法逆元是唯一的。<br>因此可以用$a^{-1}$来表示乘法逆元。</p><p><strong>引理2.8</strong>: $a\cdot_{n}x=1$有解当且仅当存在整数$x,y$使得$ax+ny=1$</p><p><strong>定理2.9</strong>: $a$在$\mathbb{Z}_n$中有乘法逆元当且仅当存在整数$x,y$使得$ax+ny=1$</p><p><strong>推论2.10</strong>: 若$a\in\mathbb{Z}_n$且$x,y$是满足$ax+ny=1$的整数，则$a$在$\mathbb{Z}_n$中的乘法逆元是$x\bmod n$</p><p><strong>引理2.11</strong>: 若存在整数$x,y$使得$ax+ny=1$，则$a,n$互质</p><p><strong>定理2.12(欧几里得除法定理)</strong>: 同最TJ的定理2.9</p><p><strong>引理2.13</strong>: 若$j,k,q,r$是满足$k=jq+r$的正整数，则gcd($j,k$)=gcd($r,j$)</p><h2 id="欧几里得扩展算法"><a href="#欧几里得扩展算法" class="headerlink" title="欧几里得扩展算法"></a>欧几里得扩展算法</h2><p>其实就是计算$x$和$y$的算法</p><p><strong>定理2.15</strong>: 两个正整数$j$和$k$互质当且仅当存在整数$x,y$使得$jx+ky=1$</p><p><strong>推论2.16</strong>: 对于任意正整数$n$A，$\mathbb{Z}_n$的元素$a$有乘法逆元当且仅当$gcd(a,n)=1$</p><p><strong>推论2.17</strong>: 对任意质数$p$,$\mathbb{Z}_p$的任意非零元素存在乘法逆元。</p><h2 id="计算乘法逆元"><a href="#计算乘法逆元" class="headerlink" title="计算乘法逆元"></a>计算乘法逆元</h2><p>跑欧几里得算法求出满足$ax+ny=1$的$x$,就是$a$在$\mathbb{Z}_n$中的乘法逆元</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数学归纳法&quot;&gt;&lt;a href=&quot;#数学归纳法&quot; class=&quot;headerlink&quot; title=&quot;数学归纳法&quot;&gt;&lt;/a&gt;数学归纳法&lt;/h1&gt;&lt;p&gt;你都懂的&lt;/p&gt;
&lt;h1 id=&quot;辗转相除法-Division-Algorithm&quot;&gt;&lt;a href=&quot;#辗转相除法
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-字符串匹配</title>
    <link href="https://mengzelev.github.io/2019/03/23/clrs-32String-Mathcing/"/>
    <id>https://mengzelev.github.io/2019/03/23/clrs-32String-Mathcing/</id>
    <published>2019-03-23T06:42:50.000Z</published>
    <updated>2019-03-23T15:40:43.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="问题的形式化定义"><a href="#问题的形式化定义" class="headerlink" title="问题的形式化定义"></a>问题的形式化定义</h2><ul><li>文本是一个长度为$n$的数组$T[1,…n]$</li><li>模式是一个长度为$m$的数组$P<a href="m\le n">1,…m</a>$</li><li>$P$和$T$的元素都是来自一个有限字母集$\Sigma$的字符</li><li>若$0\le s\le n-m$,且$T[s+1,…s+m]=P[1,…m]$,则称模式$P$在文本$T$中<strong>出现</strong>，且<strong>偏移</strong>为$s$(模式$P$在文本$T$中出现的位置是$s+1$开始的)</li><li>如果$P$在$T$中以偏移$s$出现，那么称$s$是<strong>有效偏移</strong>，否则是无效偏移</li><li>字符串匹配问题：找到<strong>所有</strong>的有效偏移</li><li>算法总运行时间=预处理时间+匹配时间</li></ul><p><img src="/2019/03/23/clrs-32String-Mathcing/time.png"></p><h2 id="符号和术语"><a href="#符号和术语" class="headerlink" title="符号和术语"></a>符号和术语</h2><ul><li>$\Sigma^*$: 包含所有有限长度的字符串的集合</li><li>$\varepsilon$: 长度为0的空字符串，$\varepsilon\in\Sigma^*$</li><li>$|x|$: 字符串$x$的长度</li><li>$xy$: 两个字符串$x$和$y$的<strong>连结(concatenation)</strong></li><li>若对某个字符串$y\in \Sigma^*$有$x=wy$，则称字符串$w$是字符串$x$的<strong>前缀</strong>，记作$w\sqsubset x$</li><li>若对某个字符串$y$有$x=yw$，则称字符串$w$是字符串$x$的后缀，记作$w\sqsupset x$</li><li>空字符串$\varepsilon$同时是任何一个字符串的前缀和后缀</li><li>$x\sqsupset y$当且仅当$xa\sqsupset ya$</li><li>$\sqsubset$和$sqsupset$都是<strong>传递关系</strong></li></ul><p><strong>引理32.1(后缀重叠引理)</strong>: 假设$x,y$满足$x\sqsupset z$和$y\sqsupset z$的字符串。如果$|x|\le |y|$, 那么$x\sqsupset y$; 如果$|x|\ge |y|$, 那么$y\sqsupset x$; 如果$|x|=|y|$, 那么$x=y$</p><ul><li>把模式$P[1..m]$的由$k$个字符组成的前缀$P[1..k]$记作$P_k$，因此$P_0=\varepsilon$,$P_m=P=P[1..m]$</li><li>把文本$T$中由$k$个字符组成的前缀记为$T_k$</li><li>采用这种记号，字符串匹配问题能被表述为：找到所有偏移$s(0\le s\le n-m)$, 使得$P\sqsupset T_{s+m}$</li><li>假设：检测$x==y$需要时间$\Theta(t+1)$，其中$t$是满足$z\sqsubset x$和$z\sqsubset y$的最长字符串$z$的长度</li></ul><h1 id="朴素字符串匹配算法"><a href="#朴素字符串匹配算法" class="headerlink" title="朴素字符串匹配算法"></a>朴素字符串匹配算法</h1><p>通过循环找到所有有效偏移<br>对$n-m+1$个可能的$s$进行检测</p><p><img src="/2019/03/23/clrs-32String-Mathcing/naive.png"></p><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>最坏情况下：$O((n-m+1)m)$<br>无预处理时间</p><h1 id="Rabin-Karp算法"><a href="#Rabin-Karp算法" class="headerlink" title="Rabin-Karp算法"></a>Rabin-Karp算法</h1><p>为了便于说明，假设$\Sigma={0,1,2,…,9}$<br>在通常情况下可以假定每个字符都是以$d$为基数表示的数字<br>$p$: 模式$P$表示的十进制值<br>$t_s$: 文本$T[s+1..s+m]$对应的十进制值<br><strong>把字符串匹配转化为数值匹配</strong></p><p>计算$t_1,…t_s$时，可以根据$t_s$计算$t_{s+1}$<br>$$t_{s+1}=10(t_s-10^{m-1}T[s+1])+T[s+m+1]$$<br>(去掉高位数字，左移，加上低位数字)</p><p>如果$p$和$t_s$的值太大，可以选取一个合适的模$q$来计算$p$和$t_s$的模<br>在一般情况下，选取一个$q$，使得$dq$在一个计算机字长内，调整递归式<br>$$t_{s+1}=(d(t_s-T[s+1]h)+T[s+m+1])\mod~q$$<br>其中$h\equiv d^{m-1}(mod q)$是一个具有$m$数位的文本窗口的高位数位上的数字”1”的值</p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/RK.png"></p><ul><li>计算所有长度为$m$的文本窗口对$q$取模的值</li><li>找出$t_s\equiv q(\mod~q)$的$s$值(<strong>伪命中点</strong>)</li><li>进行字符串匹配检验</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/RKM.png"></p><ul><li>去除$t$的下标不会影响程序运行</li><li>循环不变量：$t_s=T[s+1…s+m]\mod~q$</li></ul><h2 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h2><p>预处理：$\Theta(m)$<br>最坏情况运行时间: $\Theta((n-m+1)m)$(e.g.$P=a^m$且$T=a^n$时需要对所有可能进行字符串匹配验证，相当于退化为朴素算法)</p><p>若有效便宜只有常数$c$个，算法的期望匹配时间为$O((n-m+1)+cm)=O(n+m)$</p><p>若假设$q$是从适当大的整数中随机得出的，则伪命中的次数为$O(n/q)$(因为任意$t_s$模A$q$与$p$同余的概率为$1/q$)。 第10行中的测试会在$O(n)$个位置上失败，每次命中的时间代价是$O(m)$。因此Rabin-Karp算法的期望运行时间是$$O(n)+O(m(v+n/q))$$其中$v$为有效偏移量</p><p>若选取的素数$q$大于模式的长度，则可以估计Rabin-Karp算法的匹配时间为$O(n+m)=O(n)$</p><h1 id="利用有限自动机进行字符串匹配"><a href="#利用有限自动机进行字符串匹配" class="headerlink" title="利用有限自动机进行字符串匹配"></a>利用有限自动机进行字符串匹配</h1><h2 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h2><p>一个有限自动机$M$是一个五元组$(Q,q_0,A,\Sigma,\delta)$,其中：</p><ul><li>$Q$是<strong>状态</strong>的有限集合</li><li>$q_0\in Q$是<strong>初始状态</strong></li><li>$A\subseteq Q$是一个特殊的<strong>接受状态</strong>集合</li><li>$\Sigma$是<strong>有限输入字母表</strong></li><li>$\delta$是一个从$Q\times\Sigma$到$Q$的函数，称为$M$的<strong>转移函数</strong> </li></ul><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><ul><li>开始状态为$q_0$，每次读入输入字符串的一个字符</li><li>如果在状态$q$时读入字符$a$，就从状态$q$变为状态$\delta(q,a)$(进行了一次转移)</li><li>当前状态$q\in A$时，就说$M$<strong>接受</strong>了迄今为止所读入的字符串，没有被接受的输入称为<strong>被拒绝</strong>的输入</li></ul><h3 id="终态函数"><a href="#终态函数" class="headerlink" title="终态函数"></a>终态函数</h3><p>终态函数$\phi:\Sigma^*\to Q$<br>$\phi(w)$: $M$在扫描字符串$w$后终止时的状态<br>当且仅当$\phi(w)\in A$时，$M$接受字符串$w$</p><p>用转移函数递归定义$\phi$:<br>$$\phi(\varepsilon)=q_0,$$<br>$$\phi(wa)=\delta(\phi(w),a), ~~w\in\Sigma^*,a\in\Sigma$$</p><h2 id="字符匹配自动机"><a href="#字符匹配自动机" class="headerlink" title="字符匹配自动机"></a>字符匹配自动机</h2><p>后缀函数$\sigma:\Sigma^*\to{0,1,…,m}$，满足$\sigma(x)$是同时是$x$的后缀和$P$的前缀的字符串的长度<br>$$\sigma(x)=\max{k:P_k\sqsupset x}$$</p><p>对于任意的状态$q$和字符串$a$，转移函数$\delta$定义如下：<br>$$\delta(q,a)=\sigma(P_qa)$$<br>记录已得到的与模式$P$匹配的文本字符串$T$的最长前缀</p><p><img src="/2019/03/23/clrs-32String-Mathcing/auto.png"></p><p>匹配时间为$\Theta(n)$</p><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p><strong>引理32.2(后缀函数不等式)</strong>: 对任意字符串$x$和字符$a$，$\sigma(xa)\le\sigma(x)+1$</p><p><strong>引理32.3(后缀函数递归引理)</strong>: 对任意$x$和字符$a$，若$q=\sigma(x)$,则$\sigma(xa)=\sigma(P_qa)$</p><p><strong>定理32.4</strong>: 如果$\phi$是字符串匹配自动机关于给定模式$P$的终态函数，$T[1..n]$是自动机的输入文本，则对$i=0,1,..,n,\phi(T_i)=\sigma(T_i)$(终态函数的值=后缀函数的值)</p><h2 id="计算转移函数"><a href="#计算转移函数" class="headerlink" title="计算转移函数"></a>计算转移函数</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/compute.png"></p><p>计算转移函数的运行时间为$O(m^3|\Sigma|)$，可以改进为$O(m\Sigma)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h1&gt;&lt;h2 id=&quot;问题的形式化定义&quot;&gt;&lt;a href=&quot;#问题的形式化定义&quot; class=&quot;headerlink&quot; title=&quot;问
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-群同构基本定理与正规子群</title>
    <link href="https://mengzelev.github.io/2019/03/14/ps-4-4-isomorphism/"/>
    <id>https://mengzelev.github.io/2019/03/14/ps-4-4-isomorphism/</id>
    <published>2019-03-14T08:20:40.000Z</published>
    <updated>2019-06-18T03:21:47.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同构-Isomorphisms"><a href="#同构-Isomorphisms" class="headerlink" title="同构(Isomorphisms)"></a>同构(Isomorphisms)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对两个群$(G,\cdot)$和$(H,\circ)$，若存在一个保群运算的双射$\phi:G\to H$，即对于任意$a,b\in G$<br>$$\phi(a\cdot b)=\phi(a)\circ\phi(b)$$<br>则称$G$和$H$<strong>同构(isomorphic)</strong>，记作$G\cong H$. $\phi$称为<strong>同构函数(isomorphism)</strong>。</p><h2 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h2><p><strong>定理9.6</strong>: Let $\phi: G\to H$ be an isomorphism of two groups. Then the following statements are true.</p><ol><li>$\phi^{-1}:H\to G$ is an isomorphism (废话)</li><li>$|G|=|H|$ (废话)</li><li>If $G$ is abelian, then $H$ is abelian.</li><li>If $G$ is cyclic, then $H$ is cyclic.</li><li>If $G$ has a subgroup of order $n$, then $H$ has a subgroup of order $n$.</li></ol><p><strong>定理9.7</strong>: All cyclic groups of infinite order are isomorphic to $\mathbb{Z}$. 无穷阶循环群与$\mathbb{Z}$同构。</p><p><strong>定理9.8</strong>: If $G$ is a cyclic group of order $n$, then $G$ is isomorphic to $\mathbb{Z}_n$.</p><p><strong>推论9.9</strong>: If $G$ is a group of order $p$, where $p$ is a prime number, then $G$ is isomorphic to $\mathbb{Z}_p$. (不需要是循环群)</p><p><strong>定理9.10</strong>: The isomorphism of groups determines an equivalence relation on the class of all groups. 群的同构关系将群划分成等价类。</p><h2 id="Cayley’s-Theorem"><a href="#Cayley’s-Theorem" class="headerlink" title="Cayley’s Theorem"></a>Cayley’s Theorem</h2><p><strong>定理9.12(Cayley定理)</strong>: Every group is isomorphic to a group of permutations. 任意群都与一个置换群同构。</p><p>The isomorphism $g\mapsto \lambda_g$ is known as the <strong>left regular representation</strong>of G.</p><h1 id="直积-Direct-Products"><a href="#直积-Direct-Products" class="headerlink" title="直积(Direct Products)"></a>直积(Direct Products)</h1><p>qlz管它叫直和</p><h2 id="外直积"><a href="#外直积" class="headerlink" title="外直积"></a>外直积</h2><p>定义运算$$G\times H: (g_1,h_1)(g_2,h_2)=(g1\cdot g_2, h_1\circ h_2)$$</p><p><strong>命题9.13</strong>: Let $G$ and $H$ be groups. The set $G\times H$ is a group under the operation $(g_1,h_1)(g_2,h_2)=(g1\cdot g_2, h_1\circ h_2)$ where $g_1, g_2\in G$ and $h_1, h_2\in H$.</p><p>群$G\times H$称为$G$和$H$的<strong>外直积(external direct product)</strong></p><p><strong>定理9.17</strong>: 设$(g,h)\in G\times H$. 若$g$和$h$分别为有限阶$r$和$s$,则$(g,h)$在$G\times H$中的阶数是$r$和$s$的<strong>最小公倍数(least common multiple)</strong></p><p><strong>推论9.18</strong>: 设$(g_1,…g_n)\in \prod G_i$. 若$g_i$在$G_i$中为有限阶$r_i$，则$(G-1,..g_n)$在$\prod G_i$中的阶数为$lcm(r_1,…r_n)$.</p><p><strong>定理9.21</strong>: 群$\mathbb{Z}_m\times\mathbb{Z}<em>n$与$Z</em>{mn}$同构当且仅当$m,n$互质($gcd(m,n)=1$). (From定理9.17)</p><p><strong>推论9.22</strong>: $n_1,…n_k$为正整数，则$\prod\limits_{i=1}^{k}\mathbb{Z}_{n_1…n_k}$当且仅当$gcd(i,j)=1$对任意$i\neq j$恒成立。</p><h2 id="内直积-Internal-Direct-Product"><a href="#内直积-Internal-Direct-Product" class="headerlink" title="内直积(Internal Direct Product)"></a>内直积(Internal Direct Product)</h2><p>外直积把小群组建成大群，内直积把大群打碎成小群</p><p>群$G$拥有子群$H,K$满足以下条件:</p><ul><li>$G=HK={hk:h\in H, k\in K}$</li><li>$H\cap K={e}$</li><li>$hk=kh$ for all $k\in K$ and $h\in H$</li></ul><p>称$G$是$H$和$K$的<strong>内直积</strong></p><p>不是所有的群都可以写成其真子群的内积的形式</p><p><strong>定理9.27</strong>: 设$G$是其子群$H$和$K$的内直积，则$G$与$H\times K$同构。(外直积群与内直积群同构)</p><p>推广到多维：</p><ul><li>$G=H_1H_2…H_n={h_1h_2…h_n:h_i\in H_i}$</li><li>$H_i\cap\left\langle \cup_{j\neq i}H_j\right\rangle={e}$</li><li>$H_ih_j=h_jh_i$ for all $h_i\in H_i$ and $h_j\in H_j$</li></ul><p><strong>定理9.29</strong>: 若$G$是其子集$H_i(i=1,2,…n)$的内直积，则$G$与$\prod_i H_i$同构</p><h1 id="正规子群-Normal-Subgroups"><a href="#正规子群-Normal-Subgroups" class="headerlink" title="正规子群(Normal Subgroups)"></a>正规子群(Normal Subgroups)</h1><p>若对任意$g\in G$有$gH=Hg$, 则称$H$是$G$的正规子群。(左陪集与右陪集相同)<br>交换群的所有子群都是正规的。</p><p><strong>定理10.3</strong>: 设$N$为$G$的子群，则如下命题等价：</p><ol><li>$N$是$G$的正规子群</li><li>$\forall g\in G, gNg^{-1}\subseteq N$.</li><li>$\forall g\in G, gNg^{-1}=N$.</li></ol><h1 id="商群-Factor-Group"><a href="#商群-Factor-Group" class="headerlink" title="商群(Factor Group)"></a>商群(Factor Group)</h1><p><strong>定理10.4</strong>: $N$为$G$的正规子群，$N$在$G$中的陪集构成了一个群$G/N$, 阶为$[G:N]$(复习: $[G:N]=|G|/|N|$). 该群的运算为$(aN)(bN)=abN$.<br>这个群被称为<strong>商群(fatcor or quotient group)</strong>.<br>$eN=N$是单位元，$g^{-1}N$是$gN$的逆元。<br>商群是<strong>集合</strong>组成的群。<br>简记为$N\triangleleft G$</p><p>对于正多边形旋转群$D_n$, 旋转群$R_n$是$D_n$的一个正规子群。</p><h1 id="交替群的简单性"><a href="#交替群的简单性" class="headerlink" title="交替群的简单性"></a>交替群的简单性</h1><p><strong>单群(simple group)</strong>: 没有非平凡正规真子群的群 e.g.$\mathbb{Z}_p$($p$为质数)</p><p><strong>引理10.8</strong>: 替换群$A_n(n\ge 3)$是由3-cycles生成的。</p><p><strong>引理10.9</strong>: $N$是$A_n(n\ge 3)$的正规子群.若$N$包含了一个3-cycle，则$N=A_n$.</p><p><strong>引理10.10</strong>: 对$n\ge 5$, $A_n$的每一个非平凡正规子群$N$都包含一个3-cycle.</p><p><strong>引理10.11</strong>: $n\ge 5$的替换群$A_n$是单群。</p><h1 id="同态-homomorphism"><a href="#同态-homomorphism" class="headerlink" title="同态(homomorphism)"></a>同态(homomorphism)</h1><p>两个群$(G,\cdot)$和$(H,\circ)$间的同态函数是一个映射$\phi:G\to H$，满足$\phi(g_1\cdot g_2)=\phi(g_1)\circ\phi(g_2)$,其中$g_1,g_2\in G$.<br>$\phi$在$H$中的值域被称为<strong>同态像(homomorphism image)</strong>.<br>若$\phi$是双射，则$G$和$H$同构。</p><p><strong>命题11.4</strong>: 设$\phi:G_1\to G_2$是群间的同态函数，则</p><ol><li>若$e$是$G_1$的单位元，则$e$是$G_2$的单位元</li><li>对于任意$g\in G_1$, $\phi(g^{-1})=[\phi(g)]^{-1}$</li><li>若$H_1$是$G_1$的子群，则$\phi(H_2)$是$G_2$的子群</li><li>若$H_2$是$G_2$的子群，则$\phi^{-1}(H_2)={g\in G_1: \phi(g)\in H_2}$是$G_1$的子群。此外，若$H_2$是$G_2$的正规子群，则$\phi^{-1}(H_2)$是$G_1$的正规子群</li></ol><p>由命题11.4知，$\phi^{-1}({e})$是$G$的子群，这个子群被称为$\phi$的<strong>核(kernel)</strong>,记为$ker\phi$. 该子群是正规的。</p><p><strong>定理11.5</strong>： 设$\phi:G\to H$是群的同态函数，则$\phi$的核是$G$的一个正规子群<br>潜台词：对于每一个同态函数都能找到一个正规子群$ker\phi$</p><p>核函数可以用来推测两个群间是否存在单射同态函数。(e.g. Example11.9 $\mathbb{Z}<em>7$与$\mathbb{Z}</em>{12}$不存在单射同态函数)</p><h1 id="同态定理"><a href="#同态定理" class="headerlink" title="同态定理"></a>同态定理</h1><p>设$H$是$G$的正规子群。定义<strong>自然同态函数</strong>或<strong>规范同态函数</strong>(<strong>natural</strong> or <strong>canonical homomorphism</strong>) $$\phi:G\to G/H$$为$$\phi(g)=gH$$<br>该同态函数的核为$H$</p><p><strong>定理11.10(第一同态定理)</strong>:  若$\varphi:G\to H$是核为$K$的同态函数， 则$K$是$G$的正规子群。设$\phi:G\to G/K$是规范同态函数。则存在唯一的同构函数$\eta:G/K\to\varphi(G)$使得$\varphi=\eta\phi$</p><p>规范同态函数产生的商群与原同态函数的像同构</p><p><strong>定理11.12(第二同态定理)</strong>: 设$H$是$G$的子群(不需要正规)，$N$是$G$的正规子群，则$HN$是$G$的子群，$H\cap N$是$H$的正规子群，且<br>$$H/H\cap N\cong HN/N$$</p><p><strong>定理11.13(一致性定理)</strong>: 设$N$是$G$的正规子群，则$H\mapsto H/N$是<strong>包含$N$的子群$H$</strong>的集合与<strong>$G/N$的子群</strong>的集合间的一对一关系。此外，包含$N$的$G$的正规子群与$G/N$的正规子群相对应。</p><p><img src="/2019/03/14/ps-4-4-isomorphism/corr.png" alt="wiki上的解释"></p><p><strong>定理11.14(第三同构定理)</strong>: 设$N$和$H$是$G$的正规子群满足$N\subseteq H$,则$$G/H\cong\frac{G/N}{H/N}$$. (可以当成分数来直观理解)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;同构-Isomorphisms&quot;&gt;&lt;a href=&quot;#同构-Isomorphisms&quot; class=&quot;headerlink&quot; title=&quot;同构(Isomorphisms)&quot;&gt;&lt;/a&gt;同构(Isomorphisms)&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-置换群与拉格朗日定理</title>
    <link href="https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/"/>
    <id>https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/</id>
    <published>2019-03-09T09:15:13.000Z</published>
    <updated>2019-06-17T14:18:27.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="置换群-Permutation-Group"><a href="#置换群-Permutation-Group" class="headerlink" title="置换群(Permutation Group)"></a>置换群(Permutation Group)</h1><p><strong>定理5.1</strong>:The symmetric group on $n$ letters, $S_n$, is a group with $n!$ elements, where<br>the binary operation is the composition of maps.</p><p>置换群(permutation group):所有排列的集合$S_n$的一个子集</p><h2 id="Cycle-Notation"><a href="#Cycle-Notation" class="headerlink" title="Cycle Notation"></a>Cycle Notation</h2><p>A permutation $\sigma\in S_X$ is a <strong>cycle of length</strong> $k$ if there exist elements $a_1,a_2,…a_k\in X$ such that<br>$$\sigma(a_1) = a_2$$<br>$$\sigma(a_2) = a_3$$<br>$$…$$<br>$$\sigma(a_k) = a_1$$<br>and $\sigma(x)=x$ for all other elements $x\in X$. </p><p>We write $(a_1,a_2,…a_k)$ to denote the cycle $\sigma$.</p><p>Cycles are the building blocks of all permutations.循环是所有排列的基石。</p><p>Two cycles in $S_X$, $\sigma=(a_1,a_2,…a_k)$, $\tau=(b_1,b_2,…b_l)$, are <strong>disjoint</strong> if $a_i\neq b_j$ for all $i$ and $j$</p><p><strong>命题5.8</strong>: Let $\sigma$ and $\tau$ be 2 disjoint cycles in $S_X$. Then $\sigma\tau=\tau\sigma$.</p><p><strong>定理5.9</strong>: $S_n$中的所有排列都可以被写成不相交循环的乘积的形式。</p><p><strong>Transpositions</strong>: a cycle of length 2 (任意两个数交换位置)</p><p><strong>命题5.12</strong>: 任意至少含有两个元素的有限集的排列都可以写成transposition乘积的形式<br>e.g. (253)=(23)(25)</p><p><strong>引理5.14</strong>: identity(恒等变换)只能写成<strong>偶数个</strong>transposition的乘积的形式</p><p><strong>定理5.15</strong>: 如果一个排列能被写成偶数个置换乘积的形式，那么另一个与之等价的排列也一定拥有偶数项置换乘积。奇数同理。<br>据此定理可以将排列分为奇偶两类</p><h3 id="交替组-The-Alternating-Groups"><a href="#交替组-The-Alternating-Groups" class="headerlink" title="交替组(The Alternating Groups)"></a>交替组(The Alternating Groups)</h3><p>交替组$A_n$是所有偶排列的集合</p><p><strong>定理5.16</strong>: 集合$A_n$是$S_n$的子群</p><p><strong>命题5.17</strong>: $S_n$中奇排列和欧排列的数目相等，都为$n!/2$</p><h1 id="反组-Dihedral-Groups"><a href="#反组-Dihedral-Groups" class="headerlink" title="反组(Dihedral Groups)"></a>反组(Dihedral Groups)</h1><p>the <strong>nth dihedral group</strong>($D_n$): the group of rigid motions of a regular n-gon(正多边形的刚性运动=转动+反射)</p><p><strong>定理5.20</strong>: $D_n$ is a subgroup of $S_n$ of order $2n$</p><p><strong>定理5.23</strong>: The group $D_n$, $n\ge 3$, consists of all products of the two elements $r$ and $s$, satisfying the relations<br>$$r^n=1$$<br>$$s^2=1$$<br>$$srs=r^{-1}$$<br>($r,s$分别为转动和反射)</p><p>$$D_n={1,r,r^2,..,r^{n-1},s,sr,sr^2,…,sr^{n-1}}$$</p><h2 id="立方体的运动"><a href="#立方体的运动" class="headerlink" title="立方体的运动"></a>立方体的运动</h2><p><strong>命题5.27</strong>: The group of rigid motions of a cube contains 24 elements.</p><p><strong>命题5.28</strong>: The group of rigid motions of a cube is $S_4$.(看体对角线)</p><h1 id="陪集-Coset"><a href="#陪集-Coset" class="headerlink" title="陪集(Coset)"></a>陪集(Coset)</h1><p>$G$为群，$H$为$G$的子群，定义<br><strong>左陪集(left coset)</strong>: $gH={gh:~h\in H}$<br><strong>右陪集(left coset)</strong>: $Hg={hg:~h\in H}$ <s>(这真的不是汞吗)</s><br>其中$g\in G$称为<strong>代表元(representative)</strong></p><p>在交换群中，左陪集与右陪集是相同的。</p><p><strong>引理6.3</strong>: $g_1,g_2\in G$，以下条件等价:<br>$1. g_1H=g_2H$;<br>$2. Hg_1^{-1}=Hg_2^{-1}$;<br>$3. g_1H\subset g_2H$;<br>$4. g_2\in g_1H$;<br>$5. g_1^{-1}g_2\in H$;</p><p><strong>定理6.4</strong>: $H$为$G$的子群。$H$的左陪集分割(partition)了$G$,即$G$是$H$的左陪集的disjoint union. (右陪集同理)</p><p><strong>index</strong> of $H$: the number of left cosets of $H$ in $G$. 表示为$[G:H]$</p><p><strong>定理6.8</strong>: $H$在$G$中的左陪集与右陪集的个数相等。</p><h1 id="拉格朗日定理"><a href="#拉格朗日定理" class="headerlink" title="拉格朗日定理"></a>拉格朗日定理</h1><p><strong>命题6.9</strong>: 定义映射$H\to gH$ by $\phi(h)=gh$. 该映射是双射，$H$中元素的个数等于$gH$中元素的个数。</p><p><strong>定理6.10(拉格朗日定理)</strong>: Let $G$ be a finite group and let $H$ be a subgroup of $G$. Then $|G|/|H|=[G:H]$ is the number of distinct left cosets of $H$ in $G$. In particular, the number of elements in $H$ must divide the number of elements in $G$.<br>$$|G|=[G:H]|H|$$</p><p><strong>推论6.11</strong>: Suppose that $G$ is a finite group and $g\in G$. Then the order of $g$ must divide the number of elements in $G$.</p><p><strong>推论6.12</strong>: Let $|G|=p$ with $p$ a prime number. Then $G$ is cyclic and any $g\in G$ such that $g\neq e$ is a generator. 含有质数个元素的群为循环群且任何非单位元的元素都是生成元。</p><p><strong>推论6.13</strong>: Let $H$ and $K$ be subgroups of a finite group $G$ such that $G\supset H\supset K$. Then $[G:K]=[G:H][H:K]$.</p><p><strong>拉格朗日定理的逆命题是不成立的</strong></p><p><strong>命题6.15</strong>: The group $A_4$ has no subgroup of order 6.</p><p><strong>定理6.16</strong>: Two cycles $\tau$ and $\mu$ in $S_n$ have the same length if and only if there exists a $\sigma\in S_n$ such that $\mu=\sigma\tau\sigma^{-1}$.</p><h1 id="费马与欧拉定理"><a href="#费马与欧拉定理" class="headerlink" title="费马与欧拉定理"></a>费马与欧拉定理</h1><p>欧拉函数$\phi(n)$表示$n$以内与$n$互质的数的个数<br>对任意质数$p$, $\phi(p)=p-1$</p><p><strong>定理6.17</strong>: Let $U(n)$ be the group of units in $\mathbb{Z}_n$. Then $|U(n)|=\phi(n)$</p><p><s>怎么又是欧拉</s><br><strong>定理6.18(欧拉定理)</strong>: Let $a$ and $n$ be integers such that $n&gt;0$ and $gcd(a,n)=1$. Then $a^{\phi(n)}\equiv 1\pmod n$</p><p><strong>定理6.19(费马小定理)</strong>: Let $p$ be any prime number and suppose that $p\nmid a$($p$ does not divide $a$). Then $a^{p-1}\equiv 1\pmod p$.<br>Furthermore, for any integer $b$, $b^p\equiv b\pmod p$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;置换群-Permutation-Group&quot;&gt;&lt;a href=&quot;#置换群-Permutation-Group&quot; class=&quot;headerlink&quot; title=&quot;置换群(Permutation Group)&quot;&gt;&lt;/a&gt;置换群(Permutation Group)
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-群论初步</title>
    <link href="https://mengzelev.github.io/2019/03/02/ps-4-2-group/"/>
    <id>https://mengzelev.github.io/2019/03/02/ps-4-2-group/</id>
    <published>2019-03-02T06:03:29.000Z</published>
    <updated>2019-06-17T09:30:57.511Z</updated>
    
    <content type="html"><![CDATA[<p>由于接下来的书没有中文版了，因此笔记中英文都<u>看心情</u></p><h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><h2 id="整数等价类"><a href="#整数等价类" class="headerlink" title="整数等价类"></a>整数等价类</h2><p><strong>命题3.4</strong>：模运算下的整数等价类具有以下性质：</p><ol><li>加法和乘法交换律</li><li>加法和乘法结合律</li><li>加法(0)与乘法(1)恒等式</li><li>乘法分配律</li><li>任意元素都存在加法逆元</li><li>$a$为非零整数，$gcd(a,n)=1$当且仅当$a$存在乘法逆元，即存在非零整数$b$，使得$ab\equiv 1(mod n)$</li></ol><p>(虽然我觉得这玩意儿记了应该没什么卵用)<br>【复习时的我回来打脸了</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>二元运算(binary operation)或合成律(law of composition):a function $G\times G\to G$ that assigns to each pair $(a,b)\in G\times G$ a unique element $a\circ b$, or $ab$ in $G$, called the composition of $a$ and $b$</li><li>群(group): a set $G$ together with a law of composition $(a,b)\mapsto a\circ b$ that satisfies the following axioms:<ol><li>合成律满足<strong>结合律</strong>(asscociative)</li><li>存在<strong>单位元(identity element)</strong>$e\in G$，满足$e\circ a = a\circ e = a$</li><li>对于每个$a\in G$，都存在<em>逆元</em>$a^{-1}$，使得$a\circ a^{-1}=a^{-1}\circ a=e$</li></ol></li><li>群 = 运算封闭+结合律+单位元+逆元</li><li>阿贝尔群(Abelian)或交换群(commutative):满足$a\circ b=b\circ a$的群，反之为nonabelian或noncommutative</li><li>凯莱表(Cayley table):用加法或乘法描述群的表格</li><li>可逆元素群(group of units): 拥有逆元的元素组成的群</li><li>一般线性群(general linear group)</li><li>四元群(quaternion group)</li><li>群是<strong>有限的(finite)</strong>，或者说有<strong>有限序数(has finite order)</strong>，当它具有有限个元素，否则是无限的(infinite)或有无限序数(infinite order)</li></ul><h2 id="群的基本性质"><a href="#群的基本性质" class="headerlink" title="群的基本性质"></a>群的基本性质</h2><p><strong>命题3.17</strong>: 群中的单位元是唯一的<br><strong>命题3.18</strong>: 逆元是唯一的<br><strong>命题3.19</strong>: $G$是群，$a,b\in G$，则$(ab)^{-1}=b^{-1}a^{-1}$<br><strong>命题3.20</strong>: $(a^{-1})^{-1}=a$<br><strong>命题3.21</strong>: $ax=b$和$xa=b$在$G$中有唯一解<br><strong>命题3.22</strong>(左右消去律right and left cancellation law): $ba=ca$ implies $b=c$ and $ab=ac$ implies $b=c$</p><p>对群中的元素，可以定义乘方</p><p><strong>定理3.23</strong>: 在群中，一般指数的运算律成立</p><h2 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h2><ul><li>子群(subgroup):仿照子空间的定义<ul><li>平凡子群(trivial subgroup):$H={e}$</li><li>真子群(proper subgroup)</li></ul></li><li>子群必须继承群的二元运算</li></ul><h3 id="子群相关的定理"><a href="#子群相关的定理" class="headerlink" title="子群相关的定理"></a>子群相关的定理</h3><p><strong>命题3.30</strong>: $G$的子集$H$是子群当且仅当</p><ol><li>$G$的单位元$e\in H$</li><li>$H$对$G$的运算封闭：If $h_1,h_2\in H$, then $h_1h_2\in H$</li><li>If $h\in H$, then $h^{-1}\in H$</li></ol><p><strong>命题3.31</strong>: $H$是$G$的子群当且仅当$H\neq\emptyset$ and whenever $g,h\in H$ then $gh^{-1}$ is in $H$</p><h1 id="循环子群-Cyclic-Subgroups"><a href="#循环子群-Cyclic-Subgroups" class="headerlink" title="循环子群(Cyclic Subgroups)"></a>循环子群(Cyclic Subgroups)</h1><p><strong>定理4.3</strong>: Let $G$ be a group and $a$ be any element in $G$. Then the set $\left⟨a\right⟩={a^k:k\in\mathbb{Z}}$is a subgroup of $G$. Furthermore, $⟨a⟩$ is the <strong>smallest</strong> subgroup of $G$ that contains $a$.</p><p><strong>循环子群(Cyclic Subgroup)</strong>:$⟨a⟩$<br><strong>循环群(Cyclic group)</strong>: 包含了某个元素$a$，使得$G=⟨a⟩$.此时$⟨a⟩$是$G$的<strong>生成器(generator)</strong>.<br>The <strong>order</strong> of $a$: 最小的整数$n$满足$a^n=e$，表示为$|a|=n$。如果不存在满足要求的$n$，则称$a$是<strong>无穷的(infinite)</strong>，表示为$|a|=\infty$<br>e.g. $\mathbb{Z}$和$\mathbb{Z}_n$都是循环群，1和-1是$\mathbb{Z}$的生成器，1是$\mathbb{Z}_n$的生成器但不一定是唯一的。</p><p><strong>定理4.9</strong>: 所有循环群都是可交换的。(Every cyclic group is abelian).</p><p><strong>定理4.10</strong>: 循环群的子群都是循环子群。(Every subgroup of a cyclic group is cyclic.)</p><p><strong>引理4.11</strong>: The subgroups of $\mathbb{Z}$ are exactly $n\mathbb{Z}$ for $n=0,1,2…$</p><p><strong>命题4.12</strong>: Let $G$ be a cyclic group of order $n$ and suppose that $a$ is a generator<br>for $G$. Then $a^k = e$ if and only if $n$ divides $k$.($n$能整除$k$,$k$能被$n$整除)</p><p><strong>定理4.13</strong>: Let $G$ be a cyclic group of order $n$ and suppose that $a\in G$ is a generator<br>of the group. If $b = a^k$, then the order of $b$ is $n/d$, where $d = gcd(k, n)$.</p><p><strong>引理4.14</strong>: The generators of $\mathbb{Z}_n$ are the integers $r$ such that $1\le r&lt; n$ and<br>$gcd(r,n) = 1$. $\mathbb{Z}_n$的生成器与$n$互质。</p><h2 id="复数乘法群-Multiplicative-Group-of-Complex-Numbers"><a href="#复数乘法群-Multiplicative-Group-of-Complex-Numbers" class="headerlink" title="复数乘法群(Multiplicative Group of Complex Numbers)"></a>复数乘法群(Multiplicative Group of Complex Numbers)</h2><p>一堆复数的基础知识…….</p><p>$r(\cos\theta+i\sin\theta)$ 会被简写为 $r~cis\theta$</p><p><strong>命题4.20</strong>: $z=r~cis\theta$ and $w=s~cis\phi$. Then $zw=rs~cis(\theta+\phi)$</p><h3 id="圆群-The-circle-group"><a href="#圆群-The-circle-group" class="headerlink" title="圆群(The circle group)"></a>圆群(The circle group)</h3><p>定义: $$\mathbb{T}={z\in\mathbb{C}: |z|=1}$$</p><p><strong>命题4.24</strong>: 圆群是$\mathbb{C}^*$的子群</p><p><strong>定理4.25</strong>: If $z^n=1$, then the nth roots of unity are $$z=cis(\frac{2k\pi}{n})$$<br>where $k-0,1,…n-1$. Furthermore, the nth roors of unity form a cyclic subgroup of $\mathbb{T}$ of order $n$.</p><p>A generator for the group of the nth roots of unity is called a <strong>primitive nth root of<br>unity</strong>.</p><h2 id="重复平方法-The-Method-of-Repeated-Squares"><a href="#重复平方法-The-Method-of-Repeated-Squares" class="headerlink" title="重复平方法(The Method of Repeated Squares)"></a>重复平方法(The Method of Repeated Squares)</h2><p>其实就是快速幂</p><p>理论基础: If $b\equiv a^x (\mod n)$ and $c\equiv a^y (\mod n)$, then $bc\equiv a^{x+y}(\mod n)$<br>$(a^{2n})^2\equiv a^{2\cdot 2n}\equiv a^{2^{n+1}}(\mod n)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于接下来的书没有中文版了，因此笔记中英文都&lt;u&gt;看心情&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&quot;群&quot;&gt;&lt;a href=&quot;#群&quot; class=&quot;headerlink&quot; title=&quot;群&quot;&gt;&lt;/a&gt;群&lt;/h1&gt;&lt;h2 id=&quot;整数等价类&quot;&gt;&lt;a href=&quot;#整数等价类&quot; class
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
  <entry>
    <title>2019年寒假计划(flags)</title>
    <link href="https://mengzelev.github.io/2019/02/18/2019-winter-flags/"/>
    <id>https://mengzelev.github.io/2019/02/18/2019-winter-flags/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-01-31T10:11:55.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美赛准备"><a href="#美赛准备" class="headerlink" title="美赛准备"></a>美赛准备</h1><ul><li>MATLAB入门《MATLAB数学工具软件实例简明教程》</li><li>《MATLAB在数学建模中的应用》</li><li>研读优秀论文，总结模板</li></ul><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul><li>学习Python</li><li>分析minilab的git log中的CE数据</li></ul><h1 id="HK学术竞赛"><a href="#HK学术竞赛" class="headerlink" title="HK学术竞赛"></a>HK学术竞赛</h1><ul><li>等打完美赛再来研究</li></ul><h1 id="番剧"><a href="#番剧" class="headerlink" title="番剧"></a>番剧</h1><h2 id="追番"><a href="#追番" class="headerlink" title="追番"></a>追番</h2><ul><li>多罗罗</li><li>灵能百分百第二季</li><li>关于我转生成为史莱姆的这档事</li><li>强风吹拂</li><li>不吉波普不笑</li><li>约定的梦幻岛 </li></ul><h2 id="补番"><a href="#补番" class="headerlink" title="补番"></a>补番</h2><ul><li>战栗杀机</li><li>小林家的龙女仆</li></ul><h1 id="吉他"><a href="#吉他" class="headerlink" title="吉他"></a>吉他</h1><ul><li>看B站教学视频</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;美赛准备&quot;&gt;&lt;a href=&quot;#美赛准备&quot; class=&quot;headerlink&quot; title=&quot;美赛准备&quot;&gt;&lt;/a&gt;美赛准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MATLAB入门《MATLAB数学工具软件实例简明教程》&lt;/li&gt;
&lt;li&gt;《MATLAB在数学建模中的应用》&lt;
      
    
    </summary>
    
      <category term="Flags" scheme="https://mengzelev.github.io/categories/Flags/"/>
    
    
      <category term="Flags" scheme="https://mengzelev.github.io/tags/Flags/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-线性规划</title>
    <link href="https://mengzelev.github.io/2019/02/13/clrs-29Linear-Programming/"/>
    <id>https://mengzelev.github.io/2019/02/13/clrs-29Linear-Programming/</id>
    <published>2019-02-13T12:28:03.000Z</published>
    <updated>2019-06-16T06:39:36.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识背景"><a href="#知识背景" class="headerlink" title="知识背景"></a>知识背景</h1><ul><li>一个<strong>线性规划问题</strong>是一个线性函数最小化或最大化的问题，该线性函数服从一组有限个线性约束，分为最小化线性规划和最大化线性规划</li><li><strong>可行解</strong>：所有满足约束条件的自变量的取值</li><li><strong>可行区域</strong>：所有可行解在二维空间中构成的凸区域</li><li><strong>目标函数</strong>：希望最大化的函数</li><li><strong>目标值</strong>：目标函数在一个特定点上的值</li><li><strong>最优解</strong>：所有目标值中最大的一个，其目标值为<strong>最优目标值</strong></li><li><strong>不可行的</strong>：一个线性规划没有可行解</li><li><strong>无界的</strong>：一个线性规划有可行解但没有有限的最优目标值</li></ul><h1 id="标准型和松弛型"><a href="#标准型和松弛型" class="headerlink" title="标准型和松弛型"></a>标准型和松弛型</h1><h2 id="标准型"><a href="#标准型" class="headerlink" title="标准型"></a>标准型</h2><ul><li>所有的约束都是不等式</li><li>标准型=目标函数+约束+非负约束</li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/std.png"></p><ul><li>重写为向量与矩阵的形式，可以用一个元组$(A,b,c)$来表示一个标准型的线性规划</li></ul><p>最大化$$c^Tx$$<br>满足约束$$Ax\le b$$<br>$$x\ge 0$$</p><ul><li><strong>线性规划的等价</strong>：对两个最大化线性规划$L$和$L’$，如果对$L$的每个目标值为$z$的可行解$\overline{x}$，都存在一个对应的$L’$的目标值为$z$的可行解的$\overline{x}’$；(反过来同理)，则称$L$和$L’$是等价的。<ul><li>最小化线性规划和目标函数取负后得到的最大化线性规划是等价的</li></ul></li></ul><h3 id="非标准型的标准化"><a href="#非标准型的标准化" class="headerlink" title="非标准型的标准化"></a>非标准型的标准化</h3><ul><li>目标函数是最小化：取负</li><li>某些变量不具有非负约束：假设$x_j$无非负约束，则将所有出现的$x_j$替换为$x_{j}’-x_{j}’’$，并令$x_{j}’\ge 0, x_{j}’’\ge 0$</li><li>存在等式约束：$\ge + \le$</li><li>存在大于等于约束：取负</li></ul><h2 id="松弛型"><a href="#松弛型" class="headerlink" title="松弛型"></a>松弛型</h2><ul><li>松弛变量$s=b_i-\sum\limits_{j=1}^{n}a_{ij}x_i,s\ge 0$</li><li>只有非负约束是不等式，其余都是等式</li><li><p>当从标准型转换到松弛型时，我们将使用$x_{n+i}$表示与第$i$个不等式相关的松弛变量$$x_{n+i}=b_i-\sum\limits_{j=1}^{n}a_{ij}x_i,x_{n+i}\ge 0$$</p><p><img src="/2019/02/13/clrs-29Linear-Programming/slack.png"></p></li><li><p><strong>基本变量</strong>：等式左边的变量</p></li><li><strong>非基本变量</strong>：等式右边的变量</li><li>有时描述时会省略词语“最大化”和“满足约束”以及明显的非负约束要求</li><li>简洁记号<ul><li>$N$:非基本变量下标的集合</li><li>$B$:基本变量下标的集合</li><li>$N\cup B={1,2,…,n+m}$</li><li>用一个元组$(N,B,A,b,c,v)$来表示松弛型</li><li>这里的$a_{ij}$是“出现”在松弛型中的 负数</li><li>$A,b,c$的小标不必是连续整数的集合，依赖于索引集合$B$和$N$</li></ul></li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/slack2.png"></p><h1 id="将问题表达为线性规划"><a href="#将问题表达为线性规划" class="headerlink" title="将问题表达为线性规划"></a>将问题表达为线性规划</h1><h2 id="单对最短路径"><a href="#单对最短路径" class="headerlink" title="单对最短路径"></a>单对最短路径</h2><p>如下的线性规划可以计算从$s$到$t$的最短路径权值<br><img src="/2019/02/13/clrs-29Linear-Programming/sssp.png"></p><p>之所以是<strong>最大化目标函数</strong>，是因为最短路径问题的一个最优解把每一个$\overline{d}_v$设置成所有$\overline{d}_u+w(u,v)$的最小值，使得$\overline{d}_v$是小于等于集合${\overline{d}_u+w(u,v)}$所有值的最大值；而最小化目标函数会使所有$\overline{d}_v=0$，这个解显然没有意义</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>最大流问题表示为一个线性规划<br><img src="/2019/02/13/clrs-29Linear-Programming/maxflow.png"></p><p>这个线性规划可以重写为有$O(V+E)$个约束的表示，这样计算起来会更高效</p><h2 id="最小费用流"><a href="#最小费用流" class="headerlink" title="最小费用流"></a>最小费用流</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>最大流的推广</li><li>每条边除了容量还有费用值$a(u,v)$。如果通过边$(u,v)$传送了$f_{uv}$个单位的流，那么产生了一个费用$a(u,v)f_{uv}$。</li><li>求从$s$到$t$发送$d$个单位的流(流目标)，使得流上发生的总费用$\sum\limits_{(u,v)\in E}a(u,v)f_{uv}$最小</li></ul><p>最小费用流有专门设计的多项式时间算法，但算导上没有涉及到</p><h3 id="线性规划建模"><a href="#线性规划建模" class="headerlink" title="线性规划建模"></a>线性规划建模</h3><p><img src="/2019/02/13/clrs-29Linear-Programming/mincost.png"></p><p><s>这不是很直观吗</s></p><h2 id="多商品流"><a href="#多商品流" class="headerlink" title="多商品流"></a>多商品流</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>在最小费用流问题的基础上，有$k$种不同的商品$K_1,K_2,…,K_k$，其中用三元组$K_i=(s_i,t_i,d_i)$来详细说明商品的源点、汇点和需求</li><li>定义商品$i$的流$f_i$，汇聚流为各种商品流的总和$f_{uv}=\sum\limits_{i=1}^{k}f_{iuv}$</li><li>不用最小化任何目标函数，只需要确定是否存在这样的一个流</li></ul><h3 id="线性规划建模-1"><a href="#线性规划建模-1" class="headerlink" title="线性规划建模"></a>线性规划建模</h3><p><img src="/2019/02/13/clrs-29Linear-Programming/multi.png"></p><h1 id="单纯形算法"><a href="#单纯形算法" class="headerlink" title="单纯形算法"></a>单纯形算法</h1><ul><li>求解线性规划的经典方法</li><li>在最坏情况下执行时间非多项式</li><li>在实际中次算法通常相当快速</li><li>可以看成不等式上的<strong>高斯消元法</strong></li></ul><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><ul><li>每轮迭代都关联一个“基本解”<ul><li>从松弛型中得到“基本解”</li><li>将每个非基本变量设为0，并从等式约束中计算基本变量的值</li></ul></li><li>每轮迭代把一个松弛型转换成一个等价的松弛型 </li><li>如果一个<strong>非基本变量</strong>从0开始增加时目标值也增加(目标函数中系数为正)，则增加该非基本变量直到某<strong>基本变量</strong>为0</li><li>重写松弛型，<strong>交换</strong>此基本变量和选定的非基本变量，这个操作称为<strong>转动</strong><ul><li>一个转动选取一个非基本变量$x_e$(替入变量)和一个基本变量$x_l$(替出变量)</li></ul></li></ul><p>单纯型算法执行了两个操作</p><ol><li>重写等式使得变量在等式的左边与右边之间移动</li><li>替换一个等式为另一个等式</li></ol><p>这两个操作都建立了等价的问题</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在目标函数中选一个<strong>最大正系数非基本变量</strong>$x_1$，尝试增大$x_1$，使得$z$增大(增大时必须满足约束条件)</li><li>找到最紧的约束，解出$x_1$</li><li>将$x_1$代入系统中其他约束和目标函数【转动】</li><li>找到新系统的基本解</li></ol><h2 id="转动"><a href="#转动" class="headerlink" title="转动"></a>转动</h2><ul><li>输入：元组$(N,B,A,b,c,v)$，替出变量$x_l$的下标$l$(从左边调到右边),以及替入变量$x_e$的下标$e$(从右边调到左边)<strong>出入是相对非基本变量集合$N$而言的</strong></li><li>输出：新松弛的元组$(\hat{N},\hat{B},\hat{A},\hat{b},\hat{c},\hat{v})$</li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/pivot.png"></p><h2 id="正式的单纯形算法"><a href="#正式的单纯形算法" class="headerlink" title="正式的单纯形算法"></a>正式的单纯形算法</h2><p>SIMPLEX</p><ul><li>输入：一个标准型的线性规划</li><li>输出：一个$n$维向量，表示该线性规划的一个最优解</li><li>假设INITIALIZE-SIMPLEX过程返回一个初始基本解可行的松弛型或不可解信息</li><li>3~12行：算法主体<ul><li>如果都是目标函数所有系数为负，则while循环终止，否则第4行选择替入变量$x_e$</li><li>5~9行检查每个约束，然后挑出一个最严格限制$x_e$增加幅度的约束相关联的基本变量$x_l$，如果没有约束能够限制替入变量增加的幅度，则在第11行返回<strong>无界</strong></li><li>调用PIVOT交换替入变量和替出变量</li><li>13~16行吧所有非基本变量设为0，把基本变量$\overline{x_i}$设为$b_i$</li><li>17行返回这些值</li></ul></li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/simplex.png"></p><h3 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h3><p>while循环每次迭代开始：</p><ul><li>此松弛型等价于调用INITIALIZE-SIMPLEX返回的松弛型</li><li>对每个$i\in B$，有$b_i\ge 0$(保证新系统的基本解可行)</li><li>此松弛型相关的基本解是可行的</li></ul><p>需要保证while循环终止，可以通过第4行和第9行总是选择具有最小下标的变量来打破目标值不变的局面</p><p>假设INITIALIZE-SIMPLEX返回一个基本解可行的松弛型，那么SIMPLEX要么报告一个线性规划是无界的，要么以一个可行解结束，且至多$(^{m+n}_{m})$次循环内终止</p><h1 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h1><p>对偶性：给定一个最大化问题，我们定义一个相关的最小化问题，使得这两个问题具有同样的最优目标值(e.g.最大流最小割)</p><p>给定一个标准型的原式线性规划，我们定义其对偶线性规划为(将最大化改为最小化，交换右边系数与目标函数的系数)<br><img src="/2019/02/13/clrs-29Linear-Programming/duality.png"></p><p>弱对偶性：原式线性规划的任意可行解的值不大于此对偶线性规划的任意可行解的对应值</p><p><strong>引理 29.8</strong>：线性规划对偶性</p><p><img src="/2019/02/13/clrs-29Linear-Programming/29-10.png"></p><p>证明涉及大量数学推导</p><p>对偶问题都可以像最大流最小割一样，用来转移火力，找到一个等价的问题来求解原来的问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;知识背景&quot;&gt;&lt;a href=&quot;#知识背景&quot; class=&quot;headerlink&quot; title=&quot;知识背景&quot;&gt;&lt;/a&gt;知识背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个&lt;strong&gt;线性规划问题&lt;/strong&gt;是一个线性函数最小化或最大化的问题，该线性函数服从一组有限个线
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>SVM的临时抱佛脚for HK</title>
    <link href="https://mengzelev.github.io/2019/02/12/SVM-getstart/"/>
    <id>https://mengzelev.github.io/2019/02/12/SVM-getstart/</id>
    <published>2019-02-12T06:28:39.000Z</published>
    <updated>2019-03-02T02:32:09.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/av9912938/?p=76" target="_blank" rel="noopener">B站 机器学习（Machine Learning）- 吴恩达（Andrew Ng）</a></p><h1 id="关于调参"><a href="#关于调参" class="headerlink" title="关于调参"></a>关于调参</h1><p>使用SVM需要指定的参数</p><ul><li>参数$C$<ul><li>$C$较大：小偏差，大方差</li><li>$C$较小：大偏差，小方差</li></ul></li><li>核函数(kernel)的选择<ul><li>线性核函数(Linear Kernel/No Kernel)</li><li>高斯核函数(Gaussian Kernel)</li><li>以上是两个最常用的核函数</li><li>多项式核函数</li><li>字符串核函数</li><li>卡方核函数</li><li>….</li></ul></li></ul><p>$n=$number of features, $m=$number of training examples</p><ul><li>If $n$ is large(relative to $m$),e.g.$n\ge m$, use logistic regression or SVM without a kernel</li><li>If $n$ is small, $m$ is intermediate, use SVM with Gaussian kernel</li><li>If $n$ is is small, $m$ is large, create/add more features, then use logistic regression or SVM without a kernel</li></ul><h2 id="线性核函数"><a href="#线性核函数" class="headerlink" title="线性核函数"></a>线性核函数</h2><p>特征数较多，样本数较少时选择</p><h2 id="高斯核函数"><a href="#高斯核函数" class="headerlink" title="高斯核函数"></a>高斯核函数</h2><p>$$f_i=exp(-\frac{\Vert{x-l^{(i)}}^2}{2\sigma^2}),\text{where} l^{(i)}=x^{(i)}$$</p><p>选择高斯核的情况：特征数较少，样本较多</p><p>$\sigma$的选取：</p><ul><li>大$\sigma$: high bias, low variance</li><li>小$\sigma$: low bias, high variance</li></ul><p>Note:在使用高斯核之前记得<strong>特征归一化</strong>(feature scaling)</p><h2 id="多项式核函数"><a href="#多项式核函数" class="headerlink" title="多项式核函数"></a>多项式核函数</h2><p>$$(x^Tl + C)^d$$</p><ul><li>当$x$和$l$都是严格的非负数时才会使用</li><li>用得不多</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av9912938/?p=76&quot; targe
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Machine Learning" scheme="https://mengzelev.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>HKUST项目讨论内容</title>
    <link href="https://mengzelev.github.io/2019/02/11/HKUST-discussion/"/>
    <id>https://mengzelev.github.io/2019/02/11/HKUST-discussion/</id>
    <published>2019-02-11T07:12:48.000Z</published>
    <updated>2019-02-19T07:05:47.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题理解"><a href="#问题理解" class="headerlink" title="问题理解"></a>问题理解</h1><h2 id="原文【来自有道机翻】"><a href="#原文【来自有道机翻】" class="headerlink" title="原文【来自有道机翻】"></a>原文【来自有道机翻】</h2><h3 id="预测Sklearn程序的运行时间"><a href="#预测Sklearn程序的运行时间" class="headerlink" title="预测Sklearn程序的运行时间"></a>预测Sklearn程序的运行时间</h3><p>在共享基础设施上高效运行分布式应用程序具有挑战性。过去的研究表明，选择合适的硬件配置可以显著提高性能和降低成本。为了选择最佳配置，需要准确地预测不同应用程序的性能。</p><p>我们考虑这个挑战的一个简化版本:<strong>预测单个服务器上机器学习程序的性能</strong>。Scikit-learn (sklearn)是一个用于python的机器学习库。提供的数据集描述了在sklearn中运行SGDClassifier的几个示例。数据集的特征描述了SGDClassifier以及用于生成综合训练数据的特征。待分析数据为SGDClassifier的训练时间。</p><p>在这个文件夹中，您可以找到一个样例训练数据集(“sample_train.csv”)。“Time”是模型的训练时间。具体来说，“n_samples”、“n_features”描述了如何使用<code>sklearn.dataset.make_classification</code>生成训练合成数据集。在生成数据集之后，即使用SGDClassifier进行分类。‘l1_ratio’，‘alpha’，‘max_iter’描述了<code>sklearn.linear.model.SGDClassifier</code>的设置。所有特性名称都遵循sklearn文档中的定义。</p><p>本项目的目标是<strong>最小化预测运行时间的误差</strong>，即您应该预测接近真实运行时间的测试集的运行时间。使用的评价指标是<strong>均方误差</strong>。您可以找到“sample_test.csv”和“sample_submission”，用于测试集和解决方案提交格式。</p><p>项目分为两个阶段:</p><ul><li>阶段1：在访问HKUST前，你可浏览样本数据集及草拟解决方案。建议您提前处理数据集并准备模型。</li><li>阶段2:在您访问期间，我们将为您提供一个更大的数据集，包含更多的示例和特性。然后，您可以使用扩展的数据集处理您的解决方案。请注意，我们在阶段1中提供的数据只是一个示例，在示例数据集上建立一个准确的模型并不一定意味着在这个阶段在真实数据集上具有良好的性能。</li></ul><p>项目的其他信息和要求:</p><ul><li>所有的训练和测试数据集都在同一个服务器上生成。</li><li>不受编程语言或机器学习技术的限制。但是，您不允许运行sklearn程序来扩展训练集或预测测试集。</li><li>你需要在你自己的笔记本电脑上编程和训练你的模型。</li></ul><p>任何查询欢迎发送邮件至jxiaab @ust.hk与Jiacheng Xia联络</p><h2 id="相关名词说明"><a href="#相关名词说明" class="headerlink" title="相关名词说明"></a>相关名词说明</h2><ul><li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_classification.html" target="_blank" rel="noopener">make_classification</a></li><li><a href="https://scikit-learn.org/stable/modules/sgd.html" target="_blank" rel="noopener">sklearn.linear_model.SGDclassifier</a></li></ul><h2 id="任务概括"><a href="#任务概括" class="headerlink" title="任务概括"></a>任务概括</h2><ul><li>得到一个时间关于<code>l1_ratio</code>, <code>alpha</code>, <code>max_iter</code>, <code>n_samples</code>, <code>n_features</code>这5个参数的回归方程</li><li>将以上5个参数重新命名一下，即求$T(x_1,x_2,x_3,x_4,x_5)$</li></ul><h2 id="任务理解"><a href="#任务理解" class="headerlink" title="任务理解"></a>任务理解</h2><p>看到这个问题，有以下两种思路</p><ol><li>把SGDclassifier当成黑盒处理，不管SGD分类器算法的内部运作，用现有的算法作回归分析，拟合回归方程</li><li>根据SGD分类器具体运行的原理，自己确定一个时间函数</li></ol><p>后者需要的数学知识过多，几乎是不可能做到的，而且到时候还会有一个更大、feature更多的数据集，所以采用前者</p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><h3 id="SGD分类器模型相关"><a href="#SGD分类器模型相关" class="headerlink" title="SGD分类器模型相关"></a>SGD分类器模型相关</h3><ul><li><code>penalty</code>:惩罚函数的选择</li><li><code>l1_ratio</code>:混合惩罚函数中l1和l2方法的比例</li><li><code>alpha</code>:乘以正则项的常数</li><li><code>max_iter</code>:最大迭代次数</li><li><code>random_state</code>:随机数种子</li><li><code>n_jobs</code>:运算使用的CPU个数，’-1’表示使用了所有的CPU</li></ul><h3 id="数据生成相关"><a href="#数据生成相关" class="headerlink" title="数据生成相关"></a>数据生成相关</h3><ul><li><code>n_samples</code>:样本个数</li><li><code>n_features</code>:feature个数</li><li><code>n_classes</code>:类别的个数</li><li><code>n_clusters</code>: 每一个分类中的团簇个数</li><li><code>n_informative</code>:看不懂orz</li><li><code>flip_y</code>:随机交换所属类别，越大噪声越多</li><li><code>scale</code>:对每个值乘以一个数</li></ul><h1 id="演讲思路"><a href="#演讲思路" class="headerlink" title="演讲思路"></a>演讲思路</h1><ul><li>问题分析(如果已经有人讲过可以简单带过<ul><li>简述问题【提取关键字</li><li>简要介绍一下SGDclassifier</li><li>拉出我们参考的一篇论文，仿照论文决定训练模型计算</li></ul></li><li>我们尝试了诸多算法，决策树表现得比较好【数据可视化列举各种算法的表现情况</li><li>介绍决策树</li><li>对决策树进行改进【决策树，随机森林</li><li>总结结果</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题理解&quot;&gt;&lt;a href=&quot;#问题理解&quot; class=&quot;headerlink&quot; title=&quot;问题理解&quot;&gt;&lt;/a&gt;问题理解&lt;/h1&gt;&lt;h2 id=&quot;原文【来自有道机翻】&quot;&gt;&lt;a href=&quot;#原文【来自有道机翻】&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019美赛经历</title>
    <link href="https://mengzelev.github.io/2019/01/30/ICM-feelings/"/>
    <id>https://mengzelev.github.io/2019/01/30/ICM-feelings/</id>
    <published>2019-01-30T09:45:38.000Z</published>
    <updated>2019-01-31T10:09:50.651Z</updated>
    
    <content type="html"><![CDATA[<p>在经过了一夜的通宵之后终于把论文交上去惹，然后睡了一天，摸了一天，终于想起来要写这篇blog了。</p><h1 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h1><ul><li>学习MATLAB基本语法，笔记见<a href="https://mengzelev.github.io/2019/01/16/matlab-getstart/">MATLAB临时抱佛脚</a></li><li>学习数模基本算法，资料见<a href="https://github.com/NJUBroccoli/Material-of-MCM-ICM" target="_blank" rel="noopener">NJUBroccoli的github仓库</a></li><li>抄写常用算法模板，如：规划问题、AHP、灰色系统、灰色预测、主成分分析、方差分析等</li><li>阅读往年赛题和O奖论文，摸清套路</li><li><s>和朋友出去看电影</s></li><li>和队友做迫真模拟</li><li><s>补番</s></li></ul><h1 id="团队配置"><a href="#团队配置" class="headerlink" title="团队配置"></a>团队配置</h1><ul><li>po主：cs大二狗，会C/C++，LaTeX，以及Java和Verilog的皮毛，MATLAB是比赛前速成的。建模、计算、写论文、校对多面打杂，兼职美工和排版工人。</li><li>队友A：数学系大二小姐姐。建模扛把子。</li><li>队友B：大气科学大二小哥哥。负责给建模提供灵感，负责抱大气老师教授大腿，负责询问环科同学、商科同学…<s>这么写会不会被打死</s></li></ul><h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><ul><li>模型是一起讨论建的</li><li>数据是一起找的(虽然后来没怎么用上)</li><li>编程队友B不会所以我和队友A小姐姐一起负责</li><li>论文是每个人挑几个部分一起写的</li><li>翻译是交给有道姬完成的，由我和队友A校对<s>因为队友B校对的质量堪忧</s></li><li>排版由原po一人完成</li></ul><h1 id="比赛过程"><a href="#比赛过程" class="headerlink" title="比赛过程"></a>比赛过程</h1><h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><p>之前和队友商量好了选E或F题，因为MCM比较有难度，<s>D题需要排队论和马氏链不想看</s>。比赛当天题目公布的时候，看到F题需要不少硬核经济学知识果断放弃了，然后果断就上了E题这条贼船。MCM碰都没碰所以错过了养龙的机会，<s>我想养康娜酱啊呜呜呜</s></p><p>今年赛题内容大致为</p><ul><li>A题：养龙</li><li>B题：救救难民</li><li>C题：美国总统五大洲四日游</li><li>D题：逃离卢浮宫</li><li>E题：生态服务成本估价</li><li>F题：电子货币</li></ul><p>(只有E题是认真看过的，如有偏差欢迎指出)</p><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>E题按照惯例是环境问题，今年是要求对生态系统服务(ecological services)进行估价。生态系统服务是指生态系统提供的诸如净化空气、水体自净、保持水土等功能。要求大概有以下几点</p><ul><li>建立生态系统估价模型(ecological services valuation model)</li><li>对不同规模的土地开发利用项目进行成本效益分析(CBA)，评估这些项目的真实经济成本</li><li>决策者和管理者提出建议(implication)</li><li>随着时间推移模型如何修改</li></ul><p>本来是抱着AHP+GRA+PCA的觉悟来选的E题，结果一看这tm难道不是$\sum$单价$\times$数量的小学生模型吗，只要我找到每吨废水处理的价格，每吨垃圾回收的价格etc.<br>然后标准结局出现了：找不到！！！<br>比如污水处理费，中国大陆，HK和法国是按吨收的，美国英国是每年交固定的类似于下水道保护费一样的费用。<br>而且题干里都说了“现在的土地利用项目一般不考虑环境成本”，所以根本就找不到工程前后环境相关的数据。几篇类似的论文都是有自己的监测站的啊！！！！我们上哪找去啊！！！<br>环境经济学的书查了一堆啊！！！直接说环境估价是一个尚未解决的难题啊！！！！【废话要是解决了还会出成赛题吗<br>如此绝望了一天半之后，我们决定，死马当活马医：gtnd，上AHP！<br>然后就开始了玄学AHP玄学建模玄学论文解释<br>由于只是个心路历程记录，所以就不详细解释了</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>我们的玄学模型只有CBA那一块有一丢丢计算量，直接上MATLAB<br>甚至把图调得更好看花的时间还多一些【丢人</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p>是大家一起写的中文稿，然后扔给有道姬翻成英文，再手动修改</p><h2 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h2><p>DAY1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选题</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    讨论模;</span><br><span class="line">    找论文;</span><br><span class="line">    找数据;</span><br><span class="line">    推翻模型;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAY2：</p><ul><li>找数据</li><li>推翻模型</li><li>玄学建模开始</li><li>玄学AHP</li><li>玄学CBA</li><li>玄学编程</li><li>队友B开始玄学扯淡写论文</li></ul><p>DAY3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    论文扯淡;</span><br><span class="line">    发现模型有问题;</span><br><span class="line">    打补丁;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAY4(通宵)：</p><ul><li>写论文</li><li>继续给模型打补丁</li><li>翻译并校对</li><li>排版</li><li>提交</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><ul><li>美赛是<strong>真的很累</strong>！！！【不过也有些队伍早早就做完提交了根本没有通宵</li><li>前面不知道做些什么，所以每天都睡足了8小时，事情都积到最后一天做了，所以不得不通宵，所幸还是赶上了的</li><li>没有养龙好遗憾啊，反正哪题都不会做，不如养龙爽一把，非要吊死在E题上</li><li>美赛过于昂贵。3人平分100美元的报名费不说，因为作死没有留在学校里打，导致只能去市图书馆讨论，花费大量金钱在吃饭上，最后一天为了通宵还开了个房</li><li>这次的E题感觉还是挺坑的，涉及到不少环境经济学的知识，外行人慎选。<s>其实哪道题都是坑</s></li><li>我们的模型后来算出来西气东输是个失败的工程，感觉小命不保了</li><li>33.33美元，体验通宵的感觉，参赛一次，受益一生【棒读】</li></ul><blockquote><p>MCM/ICM真是一个骗钱又坑爹的比赛啊</p></blockquote><p><img src="/2019/01/30/ICM-feelings/trump.jpeg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在经过了一夜的通宵之后终于把论文交上去惹，然后睡了一天，摸了一天，终于想起来要写这篇blog了。&lt;/p&gt;
&lt;h1 id=&quot;赛前准备&quot;&gt;&lt;a href=&quot;#赛前准备&quot; class=&quot;headerlink&quot; title=&quot;赛前准备&quot;&gt;&lt;/a&gt;赛前准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Diary" scheme="https://mengzelev.github.io/categories/Diary/"/>
    
    
      <category term="Math Modeling" scheme="https://mengzelev.github.io/tags/Math-Modeling/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记</title>
    <link href="https://mengzelev.github.io/2019/01/23/python-getstart/"/>
    <id>https://mengzelev.github.io/2019/01/23/python-getstart/</id>
    <published>2019-01-23T07:37:50.000Z</published>
    <updated>2019-03-13T03:42:01.600Z</updated>
    
    <content type="html"><![CDATA[<p><u>持续更新中</u><br>参考：</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰的Python3教程</a></li><li>《Python编程：从入门到实践》</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Python是动态语言，即变量本身类型不固定，不需要提前声明变量类型的<br>Python有三大数据类型：整数、浮点数、字符串</p><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>整数可以是任意大小的</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数可以是任意精度的【但是运算也会出现误差】</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>字符串用单引号或双引号括起来</li><li>会涉及到转义符的问题</li><li>在字符串前加<code>r</code>表示让所有的转义符都不转</li><li>字符串拼接：<code>+</code>号</li></ul><h3 id="几个骚方法"><a href="#几个骚方法" class="headerlink" title="几个骚方法"></a>几个骚方法</h3><ul><li><code>title()</code>首字母大写</li><li><code>upper()</code>全部大写</li><li><code>lower()</code>全部小写</li><li><p><code>rstrip()</code>暂时删除字符串右端的空白</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'python '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rstrip()</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'python '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = rstrip() <span class="comment">#永久删除右端空格</span></span><br></pre></td></tr></table></figure></li><li><p><code>lstrip()</code>暂时删除字符串左端的空白</p></li><li><code>strip()</code>同时暂时删除字符串两端空白</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>Python中使用<code>#</code>注释掉一整行</li><li>PyCharm中可以使用<code>Ctrl+/</code></li></ul><h2 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h2><ul><li><code>int(x)</code>把<code>x</code>转化为整数</li><li><code>float(x)</code>把<code>x</code>转化为浮点数</li><li><code>str(x)</code>把<code>x</code>转化为字符串</li></ul><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><blockquote><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p></blockquote><ul><li>Python 3的字符串是以Unicode编码的</li><li><code>ord()</code>获取字符的整数表示，<code>chr()</code>把编码转换为对应的字符</li><li>字符串类型是<code>str</code>，加前缀<code>b&#39;</code>可以转换为<code>bytes</code>类型</li><li><p>Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为<code>bytes</code>类型，反过来<code>bytes</code>类型可以通过<code>decode()</code>方法解码为<code>str</code>类型</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">b'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'中文'</span></span><br></pre></td></tr></table></figure></li><li><p>len()函数返回字符串长度或<code>bytes</code>字节数</p></li><li>始终坚持使用UTF-8对<code>str</code>和<code>bytes</code>进行转换</li><li><p>开头通常需要加上</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure></li><li><p>格式化字符串<code>%</code>，用法同C的<code>printf</code></p></li></ul><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><ul><li>值为<code>True</code>或<code>False</code></li><li>运算<code>and</code>、<code>or</code>、<code>not</code></li></ul><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><ul><li><code>None</code>，是一个特殊变量</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul><li>习惯用全部大写的变量名表示常量</li><li>然而并不能保证该变量不会改变，不像C有<code>const</code></li></ul><h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h2><ul><li>[]表示list</li><li>[]为下标索引，从0开始，同C</li><li>[-1]表示最后一个元素,负号索引-n就表示倒数第n个<s>这也太nb了吧</s></li><li>list里的数据类型可以不同</li><li>list可以嵌套</li></ul><h3 id="list方法"><a href="#list方法" class="headerlink" title="list方法"></a>list方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">len(mylist) <span class="comment">#获得list元素的个数 </span></span><br><span class="line">mylist.append(<span class="string">'a'</span>) <span class="comment"># 往list中追加元素到末尾</span></span><br><span class="line">mylist.insert(<span class="number">1</span>, <span class="string">'a'</span>) <span class="comment"># 把元素插入到指定位置</span></span><br><span class="line">mylist.pop() <span class="comment"># 删除list末尾的元素</span></span><br><span class="line">mylist.pop(<span class="number">1</span>) <span class="comment"># 删除指定位置的元素</span></span><br><span class="line"><span class="comment">#pop返回值为被删除的元素</span></span><br><span class="line"><span class="keyword">del</span> mylist[<span class="number">1</span>] <span class="comment">#使用del可以删除任何位置的列表元素，条件是知道索引</span></span><br><span class="line">mylist.remove() <span class="comment">#按值删除元素，只删除第一个指定的值</span></span><br><span class="line"><span class="comment"># `pop和`del`的选择：删除后是否还要使用该元素</span></span><br><span class="line">mylist.sort() <span class="comment">#永久排序</span></span><br><span class="line">mylist.sort(reverse = <span class="keyword">True</span>) <span class="comment">#倒序排序</span></span><br><span class="line">sorted(mylist) <span class="comment">#暂时排序，也可以加入倒序参数</span></span><br><span class="line">mylist.reverse() <span class="comment">#永久倒置</span></span><br><span class="line">mylist[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#list切片，同MATLAB，首尾可缺省</span></span><br><span class="line">copy_list = mylist[:] <span class="comment">#通过切片赋值list</span></span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L[head : tail :step]</span><br><span class="line">L[:<span class="number">3</span>] <span class="comment">#取出从第0个到第3个元素</span></span><br><span class="line">L[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#取出从第1个到第3个元素</span></span><br><span class="line">L[:<span class="number">10</span>:<span class="number">2</span>] <span class="comment">#前10个数，每2个取一个</span></span><br><span class="line">L[::<span class="number">5</span>] <span class="comment">#所有数，每5个取一个</span></span><br><span class="line">L[:] <span class="comment">#原样复制一个list</span></span><br><span class="line"><span class="string">'ABCDEFG'</span>[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#字符串也可以看成List</span></span><br></pre></td></tr></table></figure><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squares = [value ** <span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">squares = [value ** <span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> value % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>] <span class="comment">#两两组合双重循环</span></span><br><span class="line">[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L] <span class="comment">#将一个list中所有字符串变成小写</span></span><br></pre></td></tr></table></figure><p>上述代码等价于对<code>squares</code>这个list执行了一个<code>for</code>循环，每个元素都平方(<code>**</code>是乘方的意思)<br><s>自然语言编程指日可待</s></p><h3 id="生成器generator"><a href="#生成器generator" class="headerlink" title="生成器generator"></a>生成器generator</h3><ul><li>lits保存的是数据，generator保存的是算法</li><li>使用<code>next()</code>函数可以获得generator的下一返回值</li><li>generator也是可迭代对象</li><li>定义generator<ul><li>把list的[]变成()</li><li>使用<code>yield</code>关键字把函数变成generator</li></ul></li><li>变成generator的函数，每次调用<code>next()</code>时执行，遇到<code>yield</code>语句返回，再次执行时</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)) <span class="comment">#把list的[]变成()就可以得到生成器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(n &lt; max):</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        <span class="comment">#相当于(a,b) = (b, a+b)</span></span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> fib:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#杨辉三角生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangles</span><span class="params">()</span>:</span></span><br><span class="line">    L = [<span class="number">1</span>,]</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> L</span><br><span class="line">        L = [<span class="number">1</span>,] + [L[i<span class="number">-1</span>] + L[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(L))] + [<span class="number">1</span>,]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> triangles():</span><br><span class="line">    print(t)</span><br><span class="line">    results.append(t)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h2><ul><li>与list类似，但是一旦初始化就<strong>不能修改</strong>，类似于C的<code>enum</code></li><li>不可变的tuple使代码更安全</li><li>注：定义一个元素的tuple时需要加一个逗号<code>,</code></li><li><code>tuple</code>的不变是<strong>指向不变</strong>，即给元组变量赋值是合法的</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = () <span class="comment">#定义空tuple</span></span><br><span class="line">t = (<span class="number">1</span>,) <span class="comment">#定义单元素tuple</span></span><br><span class="line">dim = (<span class="number">200</span>, <span class="number">5</span>)</span><br><span class="line">dim = (<span class="number">400</span>, <span class="number">10</span>) <span class="comment">#合法，相当于重新定义了整个元组</span></span><br></pre></td></tr></table></figure><h1 id="分支语句if"><a href="#分支语句if" class="headerlink" title="分支语句if"></a>分支语句if</h1><ul><li>除了不要括号、冒号换行、缩进代替大括号外，其他都和C语言一样</li><li><code>else if</code>可以缩写为<code>elif</code></li><li><code>if mylist</code> 可以检验列表是否非空</li><li><code>if a in mylist</code>你以为我是自然语言编程其实我只是检查某个元素在不在列表里哒</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">s = input(<span class="string">'birth:'</span>)</span><br><span class="line">birth = int(s) //将字符串输入转化为数字类型</span><br><span class="line"><span class="keyword">if</span> birth &gt;= <span class="number">2000</span>:</span><br><span class="line">    print(<span class="string">'00后'</span>)</span><br><span class="line"><span class="keyword">elif</span> birth &lt; <span class="number">1960</span>:</span><br><span class="line">    print(<span class="string">'60前'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'00前'</span>)</span><br></pre></td></tr></table></figure><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>python有2种循环</p><ul><li><code>for x in ...</code>循环，依次把list或者tuple中的每个元素迭代出来</li><li><code>range(m,n,step)</code>函数生成从m开始到n的整数序列，步长为step，<code>m</code>缺省为0，<code>step</code>缺省为1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>): <span class="comment">#行尾要有冒号</span></span><br><span class="line">    print(value) <span class="comment">#别忘了缩进对齐</span></span><br><span class="line">numbers = list(range(<span class="number">1</span>,<span class="number">11</span>,<span class="number">2</span>)) <span class="comment">#list()函数将参数转换为列表</span></span><br></pre></td></tr></table></figure><h3 id="类似C语言的循环"><a href="#类似C语言的循环" class="headerlink" title="类似C语言的循环"></a>类似C语言的循环</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]):</span><br><span class="line">    print(i, value)</span><br><span class="line"><span class="comment"># enumerate可以将list变成索引-元素对，相当于数组</span></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">9</span>)]:</span><br><span class="line">    print(x,y)</span><br><span class="line"><span class="comment">#同时对两个变量进行迭代</span></span><br></pre></td></tr></table></figure><h3 id="迭代对象"><a href="#迭代对象" class="headerlink" title="迭代对象"></a>迭代对象</h3><p><code>for</code>可以作用于所有可迭代对象</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以通过isinstance()函数判断一个对象是否为Iterable(可迭代对象)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">100</span>, Iterable)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li>可以被next()调用并不断返回下一个值的对象成为<strong>迭代器</strong><code>Iterator</code></li><li><code>Iterator</code>对象表示的是一个数据流</li><li>生成器都是<code>Iterator</code>对象</li><li><code>Iterable</code>可迭代对象不一定是<code>Iterator</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">n = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    ans += n</span><br><span class="line">    n -= <span class="number">2</span> <span class="comment"># 没有n--这种语法糖了</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><p><code>break</code>和<code>continue</code>都可以像以前一样用</p><h1 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h1><ul><li><code>dict</code>就相当于C++里的<code>map</code>，功能类似于Hash Table</li><li>是关键字-值对(key-value),key和value只是名字，并不规定类型</li><li>dict相比于list，是在用<strong>空间换时间</strong></li><li>dict的key必须是<strong>不可变对象</strong></li></ul><h2 id="创建dict"><a href="#创建dict" class="headerlink" title="创建dict"></a>创建dict</h2><p>注意dict的初始化使用的<code>{}</code>花括号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'Michael'</span>:<span class="number">95</span>, <span class="string">'Bob'</span>:<span class="number">75</span>, <span class="string">'Tracy'</span>:<span class="number">85</span>&#125; <span class="comment">#将名字和成绩对应起来，项比较多的时候可以加上换行</span></span><br><span class="line">d[<span class="string">'Adam'</span>] = <span class="number">67</span> <span class="comment">#直接通过关键字索引放入数据</span></span><br></pre></td></tr></table></figure><ul><li>多次对一个关键字放入数据，后面的值会把前面的冲掉</li><li>访问了不存在的关键字时会报错</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Thomas'</span> <span class="keyword">in</span> d <span class="comment">#返回布尔值，判断某关键字是否在该字典中</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">'Bob'</span>] <span class="comment">#删除指定关键字</span></span><br></pre></td></tr></table></figure><h2 id="dict方法"><a href="#dict方法" class="headerlink" title="dict方法"></a>dict方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.get(<span class="string">'Thomas'</span>,<span class="number">-1</span>) <span class="comment">#寻找某个关键字的值，-1是规定的不存在时的返回值，缺省时返回None，Python交互环境不显示结果</span></span><br><span class="line">d.pop(<span class="string">'Bob'</span>) <span class="comment">#删除一个关键字</span></span><br></pre></td></tr></table></figure><h2 id="遍历dict"><a href="#遍历dict" class="headerlink" title="遍历dict"></a>遍历dict</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> d.items(): <span class="comment"># 使用items()方法可以访问所有条目</span></span><br><span class="line">    print(key + <span class="string">":"</span> + value)</span><br><span class="line"><span class="comment"># 需要声明两个变量，命名任意</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d.keys(): <span class="comment"># 使用keys()方法可以访问所有的关键字</span></span><br><span class="line">    print(key.title())</span><br><span class="line"><span class="comment">#遍历字典时默认遍历所有key</span></span><br><span class="line"><span class="comment">#同理有values()方法</span></span><br></pre></td></tr></table></figure><h1 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h1><ul><li>无序、无重复元素的集合</li><li>不能放入可变对象</li></ul><h2 id="创建set"><a href="#创建set" class="headerlink" title="创建set"></a>创建set</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#需要提供一个list作为输入，重复元素自动过滤</span></span><br></pre></td></tr></table></figure><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">4</span>) <span class="comment">#添加元素</span></span><br><span class="line">s.remove(<span class="number">4</span>) <span class="comment">#删除元素</span></span><br></pre></td></tr></table></figure><h2 id="set操作"><a href="#set操作" class="headerlink" title="set操作"></a>set操作</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 &amp; s2 <span class="comment">#交集</span></span><br><span class="line">s1 | s2 <span class="comment">#并集</span></span><br></pre></td></tr></table></figure><h2 id="可变对象与不可变对象"><a href="#可变对象与不可变对象" class="headerlink" title="可变对象与不可变对象"></a>可变对象与不可变对象</h2><p>不可变对象：调用对象自身的方法不会改变该对象自身的内容，而是会创建新的对象并返回，如str<br>可变对象：恰恰相反，如list</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>函数名可以像变量一样赋值【太骚了</li></ul><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span> <span class="comment">#行尾加个冒号</span></span><br><span class="line">    <span class="keyword">if</span> x = <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure><h3 id="空操作"><a href="#空操作" class="headerlink" title="空操作"></a>空操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># pass可以用作占位符，没想好写什么但函数可以先运行起来</span></span><br></pre></td></tr></table></figure><h3 id="参数类型检查"><a href="#参数类型检查" class="headerlink" title="参数类型检查"></a>参数类型检查</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x,(int, float)): <span class="comment">#数据类型检查</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>) <span class="comment">#异常处理(后续会提到)</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure><h3 id="返回多值"><a href="#返回多值" class="headerlink" title="返回多值"></a>返回多值</h3><p>这也太骚了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle=<span class="number">0</span>)</span>:</span></span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br></pre></td></tr></table></figure><p>事实上返回的是一个tuple</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>位置参数：普通意义上的参数</li><li>默认参数：有缺省值的参数，如<code>def power(x,n=2)</code><ul><li>必选参数在前，默认参数在后</li><li>多个默认参数时，可以按顺序调用，也可以将需要修改的参数值的名称写好，不写的使用默认值，如<code>enroll(&#39;Adam&#39;, &#39;M&#39;,city=&#39;Tianjin&#39;)</code></li><li>默认参数必须指向<strong>不变对象</strong>，例如默认参数为list时用<code>None</code>代替<code>[]</code></li></ul></li><li><p>可变参数：参数个数不确定时，可以使用list或tuple传参，带<code>*</code>表示可变参数</p><ul><li>参数在函数调用时自动组装为tuple<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(*numbers)</span>:</span> <span class="comment">#加*表示可变参数</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        ans += n * n</span><br><span class="line">    <span class="keyword">return</span> ans   </span><br><span class="line"><span class="comment">#传参</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cal(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#传递变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cal(*number) <span class="comment">#传递list和tuple</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>关键字参数：允许传入0个或任意个含参数名的参数</p><ul><li>参数在内部自动组装为dict<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span> <span class="comment">#表示接受关键字参数`kw`</span></span><br><span class="line">        print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br><span class="line">    <span class="comment">#调用</span></span><br><span class="line">    &gt;&gt;&gt; person(<span class="string">'Michael'</span>, <span class="number">30</span>) <span class="comment">#可以只传入必选参数</span></span><br><span class="line">    &gt;&gt;&gt; person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">    &gt;&gt;&gt; person(<span class="string">'Adam'</span>, <span class="number">45</span>, **extra) <span class="comment">#将现成的dict作为参数</span></span><br><span class="line">+ 命名关键字参数：在函数内部检查传入了哪些参数</span><br><span class="line">  + 为了限制调用者可以传入的参数名，同时可以提供默认值。</span><br><span class="line">  + 必须传入参数名，否则调用将报错</span><br><span class="line">  + 命名关键字参数可以有缺省值</span><br><span class="line">  + 使用时，如果没有可变参数，必须加一个`*`作为分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数</span><br><span class="line">    ```py</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'city'</span> <span class="keyword">in</span> kw: <span class="comment">#有city参数</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'job'</span> <span class="keyword">in</span> kw: <span class="comment">#有job参数</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span> </span><br><span class="line">    <span class="comment">#限制关键字参数的名字，分隔符*后的参数被视为命名关键字参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *args, city, job)</span>:</span></span><br><span class="line">    <span class="comment">#有可变参数时后面的命名关键字参数不再需要分隔符*</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>参数定义顺序：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</p></li><li>对于任何函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用</li></ul><p>P.S.</p><ul><li>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code></li><li>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code></li><li><code>*args</code>和<code>**kw</code>是习惯写法</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><ul><li>函数名也是变量</li><li>有点C里面函数指针的感觉</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = abs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul><li>接收函数作为参数的函数叫做<strong>高阶函数</strong></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li><code>map(f,L)</code>，<code>f</code>为函数，<code>L</code>为一个list，表示将<code>f</code>作用于<code>L</code>的每一个元素上</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><ul><li><code>reduce(f,L)</code>，把结果继续和序列的下一个元素做累计计算</li><li><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></li><li>使用时需要加上<code>from functools import reduce</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="comment">#求和运算可以直接用sum()函数</span></span><br></pre></td></tr></table></figure><p><code>map()</code>与<code>reduce()</code>结合使用可以用很少的代码写出<code>str2int</code>函数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num = &#123;<span class="string">'0'</span>:<span class="number">0</span>, <span class="string">'1'</span>:<span class="number">1</span>, <span class="string">'2'</span>:<span class="number">2</span>, <span class="string">'3'</span>:<span class="number">3</span>, <span class="string">'4'</span>:<span class="number">4</span>, <span class="string">'5'</span>:<span class="number">5</span>, <span class="string">'6'</span>:<span class="number">6</span>, <span class="string">'7'</span>:<span class="number">7</span>, <span class="string">'8'</span>:<span class="number">8</span>, <span class="string">'9'</span>:<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2num</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> num[s]</span><br><span class="line">    <span class="keyword">return</span> reduce(fn, map(char2num, s))</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul><li>用于过滤list</li><li>把传入的函数依次作用于某个元素，根据返回值是True还是False决定保留还是丢弃该元素</li><li>返回的是一个惰性序列，需要用<code>list()</code>函数将所有结果组织为list</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#筛选回文数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(n)</span>:</span></span><br><span class="line">    s = str(n)</span><br><span class="line">    rev = s[::<span class="number">-1</span>] <span class="comment">#使用切片倒转字符串</span></span><br><span class="line">    <span class="keyword">return</span> s == rev</span><br><span class="line"></span><br><span class="line">output = filter(is_palindrome, range(<span class="number">1</span>, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><ul><li>可以直接对全是数据的list排序，<code>sort(L)</code>返回升序排序的<code>L</code></li><li>可以接受一个<code>key</code>函数来实现自定义的排序，<code>sort(L,key)</code><ul><li><code>key</code>指定的函数将作用于list的每一个元素上，并根据<code>key</code>函数返回的结果进行排序</li><li>然后<code>sorted()</code>函数按照keys进行排序，并按对应关系返回<strong>原list</strong>的相应元素</li><li>要进行反向排序可以传入第三个参数<code>reverse=True</code></li></ul></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">by_name</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> t[<span class="number">0</span>] <span class="comment">#按姓名字母顺序排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">by_score</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> -t[<span class="number">1</span>] <span class="comment">#按分数降序排序</span></span><br><span class="line"></span><br><span class="line">L = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</span><br><span class="line">L1 = sorted(L, key=by_name)</span><br><span class="line">L2 = sorted(L, key=by_score)</span><br><span class="line">print(L1)</span><br><span class="line">print(L2)</span><br></pre></td></tr></table></figure><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><ul><li>函数作为返回值的函数</li><li>“闭包”程序结构：相关参数和变量都包含在返回的函数中</li><li>返回的函数不会被立刻执行，而是直到调用了才执行</li><li><strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong></li><li>有啥卵用：保存当前的运行环境。被引用的自由变量与函数同在，即使离开了创造它的环境也不例外</li><li>将外部函数的变量与内部函数绑定</li></ul><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul><li><p>关键字<code>lambda</code>表示匿名函数，冒号前的<code>x</code>表示函数参数</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x : x * x</span><br><span class="line"><span class="comment">#相当于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure></li><li><p>只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果</p></li><li>好处：没有名字，不用担心和其他函数名冲突</li><li>匿名函数也是函数对象，可以把匿名函数赋值给一个变量，再利用变量来调用该函数【有毒吗，不能直接def吗</li><li>匿名函数也可以作为返回值返回</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = list(filter((<span class="keyword">lambda</span> x : x%<span class="number">2</span>==<span class="number">1</span>), range(<span class="number">1</span>,<span class="number">20</span>)))</span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>函数对象有个<code>__name__</code>属性，可以获得函数的名字</li><li>在代码运行期间动态增加函数的功能的方式成为<strong>装饰器(decorator)</strong></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func) # 把原始函数的属性复制到wrapper()函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__) <span class="comment"># 先打印日志</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw) <span class="comment"># 再调用原函数</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log # @语法，相当于执行now=log(now)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"2019-2-6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2019</span><span class="number">-2</span><span class="number">-6</span></span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><ul><li>把一个函数的某些参数固定住(设置一个参数的默认值)，返回一个新的函数，可以直接调用这个新的函数</li><li><code>functools.partial(f,*args,**kw)</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int2 = functools.partial(int, base=<span class="number">2</span>) </span><br><span class="line"><span class="comment">#固定转化为二进制的函数</span></span><br></pre></td></tr></table></figure><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><ul><li>一个.py文件就是一个模块</li><li>可以避免函数名和变量名冲突</li><li>包下的是模块，包中必包含<strong>init</strong>.py模块</li><li>注意模块命名不要与python原有模块冲突</li><li>模块名为<code>包名.模块名</code></li><li>类似于C的库</li></ul><h2 id="标准模块文件"><a href="#标准模块文件" class="headerlink" title="标准模块文件"></a>标准模块文件</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">' a test module '</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Michael Liao'</span></span><br></pre></td></tr></table></figure><ul><li>第一行：标准注释，表示该文件可以直接在Unix/Linux/Mac上运行</li><li>第二行：标准注释，表示该文件本身使用标准UTF-8编码</li><li>第四行：模块文档注释，任何模块代码的第一个字符串都被视为模块的文档注释</li><li>第六行：作者标注，使用<code>__author__</code>变量把作者写进去</li></ul><h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><ul><li>导入模块：<code>import 模块名</code></li></ul><h2 id="函数和变量的作用域"><a href="#函数和变量的作用域" class="headerlink" title="函数和变量的作用域"></a>函数和变量的作用域</h2><ul><li>正常的函数和变量名是公开的(public)，可以直接被引用</li><li>类似<code>__xxx__</code>的变量是特殊变量，可以被直接引用，但一般不建议这么做<ul><li>例如，如果调用<code>len()</code>试图获取一个对象的长度，会自动调用该类的<code>__len__</code>方法</li></ul></li><li>类似<code>_xxx</code>和<code>__xxx</code>的函数或变量是非公开的(private)，不应该被引用，但是Python不能完全限制它们的引用</li><li>外部不需要引用的函数和变量全部定义为private，只有外部需要引用的函数才定义为public</li></ul><h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install [模块名]</span><br></pre></td></tr></table></figure><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="comment"># Student是类名</span></span><br></pre></td></tr></table></figure><ul><li>类名一般首字母大写</li><li>括号中标明了从哪个类继承下来，所有类最终都继承自<code>object</code>(同Java)</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>创建实例：类名+()，如<code>bart = Student()</code></li><li>可以自由地给一个实例变量绑定属性</li><li><p>实例的初始化可以使用<code>__init__</code>函数</p><ul><li>将一些必须绑定的属性写上去</li><li><code>__init__</code>方法的第一个参数永远是<code>self</code>，需要声明但无需传递(类似于C的<code>this</code>)</li><li>不就是构造函数吗<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">bart = Student(<span class="string">'Bart Simpson'</span>,<span class="number">59</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>定义方法除了第一个参数是<code>self</code>外，与定义函数无异</p></li></ul><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><ul><li>私有变量：名称前加两个下划线<code>__xxx</code>，外部无法访问(其实只是Python解释器把它解释为了另一个名字)</li><li>单下划线实例变量名:“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”</li></ul><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><ul><li>基本类似Java的继承</li><li>子类继承父类的方法</li><li>子类和父类可以有相同的方法，但子类的方法会覆盖父类的方法</li><li>“鸭子类型”：一个对象只要“看起来像鸭子，走起路来像鸭子”，就可以被看成鸭子<ul><li>不要求严格的继承体系，调用方法时只要保证对象有这样的方法</li></ul></li></ul><h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><ul><li><p><code>type()</code>函数：判断对象、函数类型，返回对应的Class类型，可以用<code>if</code>语句比较两个变量的类型是否相同</p><ul><li>判断基本数据类型可以直接写<code>int</code>，<code>str</code>等</li><li>判断一个对象是否是函数可以使用<code>types</code>模块中定义的常量<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">123</span>) == int</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(fn) == types.FunctionType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(abs) == types.BuiltinFunctionType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="keyword">lambda</span> x : x) == types.LambdaType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))) == types.GeneratorType</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>isinstance()</code>可以用来判断继承关系</p><ul><li>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断</li><li>优先使用<code>isinstance()</code></li></ul></li><li><p><code>dir()</code>可以获得一个对象的所有属性和方法，返回一个包含字符串的list</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(<span class="string">'ABC'</span>)</span><br><span class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>,..., <span class="string">'__subclasshook__'</span>, <span class="string">'capitalize'</span>, <span class="string">'casefold'</span>,..., <span class="string">'zfill'</span>]</span><br></pre></td></tr></table></figure><ul><li><p>配合<code>getattr()</code>，<code>setattr()</code>和<code>hasattr()</code>可以直接操作一个对象的状态</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'x'</span>) <span class="comment"># 有属性'x'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性'y'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'y'</span>) <span class="comment"># 获取属性'y'</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.y <span class="comment"># 获取属性'y'</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'power'</span>) <span class="comment"># 有属性'power'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn = getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'并赋值到变量fn</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure><ul><li>只有在不知道对象具体信息时，才会去获取对象的信息<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#正确用法</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">readImage</span><span class="params">(fp)</span>:</span></span><br><span class="line"><span class="keyword">if</span> hasattr(fp, <span class="string">'read'</span>):</span><br><span class="line">    <span class="keyword">return</span> readData(fp)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"><span class="comment"># 假设我们希望从文件流fp中读取图像</span></span><br><span class="line"><span class="comment"># 我们首先要判断该fp对象是否存在read方法</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><ul><li>给实例绑定属性：通过实例变量或self变量</li><li>类本身需要绑定属性：直接在class中定义<ul><li>类的所有实例都可以访问类属性<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        Student.count += <span class="number">1</span> <span class="comment"># 类的属性增加一，而非实例的属性self.countA</span></span><br><span class="line"></span><br><span class="line">bart = Student(<span class="string">'Bart'</span>)</span><br><span class="line">print(Student.count)</span><br><span class="line">lisa = Student(<span class="string">'Lisa'</span>)</span><br><span class="line">print(Student.count)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h2><ul><li><p>实例可以绑定属性和方法</p><ul><li><p>绑定方法需要使用到types<code>模块中的</code>MethodType`方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></li><li><p>以上方法绑定的方法对其他的实例是不起作用的</p></li></ul></li><li><p>给类绑定方法可以给所有实例绑定方法，是一种动态绑定，绑定后所有实例均可调用</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line"><span class="meta">... </span>    self.score = score</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</span><br></pre></td></tr></table></figure></li><li><p>使用<code>__slots__</code>可以限制实例的属性</p><ul><li>仅对当前类的实例起作用，对继承的子类是不起作用的</li><li>如果在子类中也定义<code>__slots__</code>，则子类实例允许定义的属性 = 自身的<code>__slots__</code> + 父类的<code>__slots__</code></li></ul></li></ul><h2 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h2><ul><li><p><code>@property</code>是装饰器，负责把一个<code>setter</code>方法变成属性赋值</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class">    @<span class="title">property</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score <span class="comment"># getter属性</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span> <span class="comment"># setter属性</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 and 100'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><ul><li><code>@property</code>使得对实例属性操作时，通过getter和setter方法来实现</li><li>是定义getter方法就相当于定义了一个只读属性</li></ul></li></ul><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><ul><li><p>一个子类可以同时获得多个父类的所有功能</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, Runnable)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>MixIn:除主线之外的继承关系</p><ul><li>为了更好地看出继承关系，可以把主线外的继承类命名为<code>xxxMixIn</code>，如<code>RunnableMixIn</code></li><li>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类</li><li>Java是只允许单一继承的，不允许MixIn的继承</li></ul></li></ul><h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p>上文提到的 <code>__len__</code>方法能让class作用于<code>len()</code>函数，就是一种定制类的方法</p><h3 id="str"><a href="#str" class="headerlink" title="str"></a><strong>str</strong></h3><ul><li><p><code>__str__</code>方法可以改变类的实例的打印方式，类似于Java的<code>toString</code></p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Student object (name: %s)'</span> % self.name</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</span><br><span class="line">Student object (name: Michael)</span><br></pre></td></tr></table></figure></li></ul><h3 id="repr"><a href="#repr" class="headerlink" title="repr"></a><strong>repr</strong></h3><ul><li><code>__repr__</code>方法 直接显示变量调用(在交互模式下敲出变量名)<ul><li><code>__str__()</code>方法返回用户看到的字符串，<code>__repr__()</code>返回程序开发者看到的字符串，为调试服务</li><li>通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，有个偷懒的写法</li></ul></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line">__repr__ = __str__</span><br></pre></td></tr></table></figure><h3 id="iter"><a href="#iter" class="headerlink" title="iter"></a><strong>iter</strong></h3><ul><li><p><code>__iter__</code>方法返回一个迭代对象，让类可以被用用于<code>for ... in</code>循环</p><ul><li><p>配合<code>__next__</code>方法，for循环会不断调用该迭代对象的<code>__next__()</code>方法得到循环的下一个值，直到遇到<code>StopIteration</code>错误退出循环</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a,self.b = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a,self.b = self.b, self.a+self.b</span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopInteration()</span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line">            print(n)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">46368</span></span><br><span class="line">    <span class="number">75025</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="getitem"><a href="#getitem" class="headerlink" title="getitem"></a><strong>getitem</strong></h3><ul><li><p><code>__getitem__</code>方法使类可以像list那样根据下标取出元素</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(isinstance(n, int)): <span class="comment"># n是索引</span></span><br><span class="line">            a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                a,b = b,a+b</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">if</span>(isinstance(n, slice)): <span class="comment"># n是切片</span></span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.start</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span>  <span class="keyword">None</span>:</span><br><span class="line">                start = <span class="number">0</span></span><br><span class="line">            a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">            L = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(stop):</span><br><span class="line">                <span class="keyword">if</span> x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a,b = b,a+b</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fib()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">100</span>]</span><br><span class="line"><span class="number">573147844013817084101</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><ul><li>以上<code>__getitem__()</code>方法没有对步长和负数做处理，因此要正确实现一个<code>__getitem__()</code>还是有很多工作要做的</li><li>如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如<code>str</code>，与之对应的还有<code>__setitem__</code>和<code>__delitem__</code></li></ul></li></ul><h3 id="getattr"><a href="#getattr" class="headerlink" title="getattr"></a><strong>getattr</strong></h3><ul><li><p><code>__getattr__</code>方法能够动态返回一个属性，当调用不存在的属性时，会试图调用<code>__getattr__(self,属性)</code>来尝试获得属性</p><ul><li><p>只有在没有找到属性的情况下才会调用<code>__getattr__</code>，已有的属性是直接获取的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> attr==<span class="string">'age'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">'\'Student\' object has no attribute \'%s\''</span> % attr)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h3><ul><li><code>__call__</code>使实例自身能被当作函数调用</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'My name is %s.'</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s()</span><br><span class="line">My name <span class="keyword">is</span> Michael</span><br></pre></td></tr></table></figure><ul><li>通过<code>callable</code>函数可以判断一个对象是否能被调用</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(Student())</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(max)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(<span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(<span class="string">'str'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="枚举类Enum"><a href="#枚举类Enum" class="headerlink" title="枚举类Enum"></a>枚举类Enum</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>))</span><br></pre></td></tr></table></figure><ul><li>这样就得到了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量</li><li><p>也可以枚举该类的所有成员</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> name,member <span class="keyword">in</span> Month.__members.items()</span><br><span class="line">    print(name, <span class="string">'=&gt;'</span>, member, <span class="string">','</span>, member.value)</span><br></pre></td></tr></table></figure></li><li><p><code>value</code>属性是自动赋给<code>int</code>常量，默认<strong>从1开始</strong>计数(居然不是从0开始)</p></li><li>从<code>Enum</code>派生自定义类可以精确控制枚举类型  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique #装饰器，帮忙检查有无重复值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span><span class="params">(Enum)</span>:</span> <span class="comment"># Enum的子类</span></span><br><span class="line">    Sun = <span class="number">0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">Weekday.Mon</span><br><span class="line">Weekday[<span class="string">'Tue'</span>]</span><br><span class="line">Weekday(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="type-函数"><a href="#type-函数" class="headerlink" title="type()函数"></a>type()函数</h2><ul><li>动态语言的函数和类不是编译时定义的，而是运行时动态创建的</li><li><code>type()</code>函数可以查看一个类型或变量的类型</li><li><p><code>type()</code>函数可以创建出新的类型，而无需通过class定义</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(self, name=<span class="string">'world'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'Hello, %s.'</span> % name)</span><br><span class="line">Hello = type(<span class="string">'Hello'</span>, (object,), dict(hello=fn)) <span class="comment">#创建Hello类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = Hello()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.hello()</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure></li><li><p><code>type()</code>函数需依次传入3个参数</p><ul><li>class的名称</li><li>继承的父类的集合，<strong>注意单元素tuple的写法</strong></li><li>class的方法名称与函数绑定</li></ul></li></ul><h2 id="metaclass-函数"><a href="#metaclass-函数" class="headerlink" title="metaclass()函数"></a>metaclass()函数</h2><ul><li>先定义metaclass(元类)，就可以创建类，然后创建实例</li><li>可以把类看成metaclass创建出来的实例</li><li>metaclass正常情况下不会用到所以看不懂也没关系</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># metaclass是类的模板，所以必须从`type`类型派生：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        attrs[<span class="string">'add'</span>] = <span class="keyword">lambda</span> self, value: self.append(value)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用metaclass定制类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list, metaclass=ListMetaclass)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>创建Mylist时，通过<code>ListMetaclass.__new__()</code>来创建</li><li>可以用来修改类的定义，例如加上新的方法(样例中在<code>MyList</code>类中增加了<code>add</code>方法)</li><li><code>__new__()</code>方法接收的参数依次是<ul><li>当前准备创建的类的对象</li><li>类的名字</li><li>类继承的父类的集合</li><li>类的方法的集合</li></ul></li><li>应用上与SQL相结合的较多，等用到的时候再看了</li></ul><h1 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h1><h2 id="try"><a href="#try" class="headerlink" title="try"></a>try</h2><ul><li>当我们认为某些代码可能会出错时，可以用<code>try</code>来运行这段代码</li><li><p>如果出错，后续代码不会继续执行，而是直接跳转至错误处理代码</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    print(<span class="string">'result:'</span>, r)</span><br><span class="line"><span class="comment"># 错误处理代码</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:  <span class="comment"># 可以有多个except</span></span><br><span class="line">    print(<span class="string">'except:'</span>, e)</span><br><span class="line"><span class="keyword">finally</span>: <span class="comment"># finally无论如何都会被执行，表示执行结束</span></span><br><span class="line">    print(<span class="string">'finally...'</span>)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>except</code>后可加<code>else</code>语句块，当没有错误发生时会执行<code>else</code>语句块</p></li><li><code>try...except</code>可以跨越多层调用，被调用者出错，调用者也能捕捉到</li><li>Python的错误也是类，所有错误类型都继承自<code>BaseException</code></li><li><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">常见的错误类型和继承类型</a></li></ul><h2 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h2><ul><li>python有内置的<code>logging</code>模块，可以记录错误信息</li><li>程序打印完错误信息后会继续执行并正常退出</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">      bar(<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">      logging.exception(e)</span><br></pre></td></tr></table></figure><h2 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h2><ul><li>根据需要，可以定义一个错误的类，选择好继承关系，用<code>raise</code>语句抛出一个错误的实例</li><li>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型，尽量使用Python内置的错误类型</li><li>当前函数不知道如何处理该错误时，还可以在打印错误后再往上抛，让顶层调用者去处理<ul><li><code>raise</code>语句如果不带参数，就会将当前错误原样抛出</li><li>在<code>except</code>中<code>raise</code>一个Error，可以将错误转化成另一种类型</li></ul></li></ul><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><ul><li><code>print</code>调试法</li><li><p><code>assert</code>调试法</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> n != <span class="number">0</span>, <span class="string">'n is zero!'</span></span><br><span class="line"><span class="comment"># 表达式应该为True，否则输出AssertionError+后接的字符串</span></span><br></pre></td></tr></table></figure><ul><li>启动python解释器时可以用<code>-O</code>参数来关闭assert</li></ul></li><li><p><code>log</code>调试法(Python管这叫logging)</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO) <span class="comment"># 配置</span></span><br><span class="line">logging.info(<span class="string">'n = %d'</span> % n) </span><br><span class="line"><span class="comment"># logging.info: 输出信息</span></span><br></pre></td></tr></table></figure><ul><li>可以指定<code>DEBUG</code>&gt;<code>INFO</code>&gt;<code>WARNING</code>&gt;<code>ERROR</code>几个不同级别(level)的信息，级别越高越先被屏蔽，e.g.<code>level=INFO</code>时<code>DEBUG</code>的logging就不起作用了</li></ul></li><li>pdb调试法(命令同gdb)<ul><li><code>l</code>: 查看代码</li><li><code>n</code>: 单步执行</li><li><code>p 变量名</code>: 打印变量</li><li><code>c</code>: 继续执行</li></ul></li><li><p><code>pdb.set_trace()</code>在程序中设置断点，运行时程序会自动暂停并进入pdb</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">s = <span class="string">'0'</span></span><br><span class="line">n = int(s)</span><br><span class="line">pdb.set_trace() <span class="comment"># 运行到这里会自动暂停</span></span><br><span class="line">print(<span class="number">10</span> / n)</span><br></pre></td></tr></table></figure></li><li><p>PyCharm调试法</p></li></ul><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="comment"># 失败时会返回IOError</span></span><br><span class="line">f.read() <span class="comment">#一次性读取全部内容到内存，用一个str对象表示</span></span><br><span class="line">f.close() <span class="comment">#关闭文件，回收资源</span></span><br></pre></td></tr></table></figure><p>为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>嫌长可以简化为<code>with</code>语句<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="comment">#隐式调用了f.close()</span></span><br></pre></td></tr></table></figure></p><p>不想一次读取所有文件</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.read(size) <span class="comment"># 读取一定size个字节的内容</span></span><br><span class="line">f.readline() <span class="comment"># 一次读取一行</span></span><br><span class="line">f.readlines() <span class="comment"># 一次读取所有行并返回list</span></span><br></pre></td></tr></table></figure><p>还可以有效防止内存爆炸</p><p>内存的字节流，网络流，自定义流等等都是<strong>file-like Object</strong>，只需要写个<code>read()</code>方法就能用</p><p>二进制文件需要用<code>&#39;rb&#39;</code>模式打开</p><p>读取默认使用<strong>UTF-8</strong>编码，需要编码转换的时候要给<code>open()</code>传入<code>encoding</code>参数,<code>errors</code>参数表示出现错误后怎么处理，一般选择忽略</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/Users/michael/gbk.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'gbk'</span>,errors=<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>和读一样，把<code>r</code>改成<code>w</code>(跟C也差不多)</p><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>在内存中读写str</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO() <span class="comment"># 创建StringIO对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hello'</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">' '</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'world!'</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue()) <span class="comment">#getvalue()用于获得写入后的str</span></span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>可以用一个str初始化StringIO，然后，像读文件一样读取</p><h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>操作内存中的二进制数据</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87</span></span><br></pre></td></tr></table></figure><h3 id="操作系统命令"><a href="#操作系统命令" class="headerlink" title="操作系统命令"></a>操作系统命令</h3><p>Python内置的os模块可以直接调用操作系统提供的接口函数</p><p>文件名操作只对字符串进行，并不要求文件真实存在</p><p><code>shutil</code>中可以找到很多对<code>os</code>的补充</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.name <span class="comment">#查看操作系统名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ <span class="comment"># 查看操作系统中所有的环境变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ.get(<span class="string">'key'</span>) <span class="comment"># 获取某个环境变量的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">'.'</span>) <span class="comment"># 查看当前目录的绝对路径:</span></span><br><span class="line"><span class="string">'/Users/michael'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">'/Users/michael'</span>, <span class="string">'testdir'</span>)</span><br><span class="line"><span class="comment"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span></span><br><span class="line"><span class="string">'/Users/michael/testdir'</span></span><br><span class="line"><span class="comment"># 然后创建一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">'/Users/michael/testdir'</span>)</span><br><span class="line"><span class="comment"># 删掉一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">'/Users/michael/testdir'</span>)</span><br><span class="line"><span class="comment"># 拆分路径，把当前文件名与目录分开</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">'/Users/michael/testdir/file.txt'</span>)</span><br><span class="line">(<span class="string">'/Users/michael/testdir'</span>, <span class="string">'file.txt'</span>)</span><br><span class="line"><span class="comment"># 拆分文件扩展名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="string">'/path/to/file.txt'</span>)</span><br><span class="line">(<span class="string">'/path/to/file'</span>, <span class="string">'.txt'</span>)</span><br><span class="line"><span class="comment"># 对文件重命名:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">'test.txt'</span>, <span class="string">'test.py'</span>)</span><br><span class="line"><span class="comment"># 删掉文件:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.remove(<span class="string">'test.py'</span>)</span><br></pre></td></tr></table></figure><p>过滤文件<br><s>不都是一行命令行就能搞定的吗</s></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>) <span class="keyword">if</span> os.path.isdir(x)]</span><br><span class="line">[<span class="string">'.lein'</span>, <span class="string">'.local'</span>, <span class="string">'.m2'</span>, <span class="string">'.npm'</span>, <span class="string">'.ssh'</span>, <span class="string">'.Trash'</span>, <span class="string">'.vim'</span>, <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, ...]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>) <span class="keyword">if</span> os.path.isfile(x) <span class="keyword">and</span> os.path.splitext(x)[<span class="number">1</span>]==<span class="string">'.py'</span>]`</span><br><span class="line">[<span class="string">'apis.py'</span>, <span class="string">'config.py'</span>, <span class="string">'models.py'</span>, <span class="string">'pymonitor.py'</span>, <span class="string">'test_db.py'</span>, <span class="string">'urls.py'</span>, <span class="string">'wsgiapp.py'</span>]</span><br></pre></td></tr></table></figure><p>还有<code>psutil</code>模块提供了对cpu信息、内存和磁盘使用信息的访问</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><blockquote><p>把变量从内存中变成可存储或传输的过程叫作序列化(picking).序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p></blockquote><p>用到了再看吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;持续更新中&lt;/u&gt;&lt;br&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="Self-learning" scheme="https://mengzelev.github.io/categories/Self-learning/"/>
    
    
      <category term="Python" scheme="https://mengzelev.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数学建模几种常用算法</title>
    <link href="https://mengzelev.github.io/2019/01/19/matlab-usage/"/>
    <id>https://mengzelev.github.io/2019/01/19/matlab-usage/</id>
    <published>2019-01-19T08:41:45.000Z</published>
    <updated>2019-01-24T13:22:25.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据拟合"><a href="#数据拟合" class="headerlink" title="数据拟合"></a>数据拟合</h1><h2 id="多项式拟合"><a href="#多项式拟合" class="headerlink" title="多项式拟合"></a>多项式拟合</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [...];</span><br><span class="line">y = [...];</span><br><span class="line">P = polyfit(x,y,n); <span class="comment">% n是多项式的次数</span></span><br><span class="line">xi = <span class="number">0</span>: <span class="number">.2</span> :<span class="number">10</span>;</span><br><span class="line">yi = polyval(P, xi);</span><br><span class="line">plot(xi, yi, x, y, <span class="string">'r*'</span>);</span><br></pre></td></tr></table></figure><h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><p>标准型$$\min~c^Tx s.t. Ax\le b$$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = linprog(c, -a, -b, [], [], <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = fmincon(fun, x0, A, B, Aeq, Beq, LB, UB, [c,ceq], OPTIONS)</span><br><span class="line"><span class="comment">% fun:目标函数</span></span><br><span class="line"><span class="comment">% x0:x的初始条件</span></span><br><span class="line"><span class="comment">% A,B,Aeq,Beq:线性约束条件</span></span><br><span class="line"><span class="comment">% LB,UB:上下界</span></span><br><span class="line"><span class="comment">% [c,ceq]:.m文件定义的非线性约束条件,分别为不等式与等式约束</span></span><br></pre></td></tr></table></figure><h2 id="二次规划"><a href="#二次规划" class="headerlink" title="二次规划"></a>二次规划</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, fval] = quadprog(H, f, A, b, Aeq, Beq, LB, UB, X0, OPTIONS)</span><br></pre></td></tr></table></figure><h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><ul><li>隐枚举法</li><li>随机算法(蒙特卡洛)</li><li>分枝定界法</li></ul><h2 id="其他求解约束最优化问题的函数"><a href="#其他求解约束最优化问题的函数" class="headerlink" title="其他求解约束最优化问题的函数"></a>其他求解约束最优化问题的函数</h2><ul><li><code>fminbnd</code>:单变量非线性函数在区间上的极小值</li><li><code>fseminf</code></li><li><code>fminimax</code>:函数族的极大极小值</li></ul><h1 id="灰色预测"><a href="#灰色预测" class="headerlink" title="灰色预测"></a>灰色预测</h1><p>GM(1,1)模型适用于具有较强指数规律的序列，只能描述单调的变化过程，而Verhulst模型则适用于非单调的摆动发展序列或具有饱和状态的S形序列。<br>原始数列$x^{(0)}$，AGO累加生成数列$x^{(1)}$，加权均值数列$z^{(0)}$</p><h2 id="关联分析和优势分析"><a href="#关联分析和优势分析" class="headerlink" title="关联分析和优势分析"></a>关联分析和优势分析</h2><ul><li>根据bigger is better和smaller is better标准将数据分类进行初始化</li><li>根据公式算关联系数</li><li>根据关联系数计算关联度</li></ul><h2 id="灰色预测步骤"><a href="#灰色预测步骤" class="headerlink" title="灰色预测步骤"></a>灰色预测步骤</h2><ul><li>数据的检验与处理：计算级比，视情况进行必要的变换处理，使其落入可容覆盖内</li><li>建立模型 $x^{(1)}=…$可以得到预测值</li><li>残差检验</li><li>级比偏差检验</li><li>预测预报</li><li>另：灾变预测可以构造灾变数列</li></ul><h1 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h1><ul><li>求解多约束复杂非线性规划问题</li><li>直接调库吧，不可能看懂的</li></ul><h1 id="层次分析法-Analytic-Hierarchy-Process"><a href="#层次分析法-Analytic-Hierarchy-Process" class="headerlink" title="层次分析法(Analytic Hierarchy Process)"></a>层次分析法(Analytic Hierarchy Process)</h1><ul><li>用于解决较为复杂、模糊、难于定量分析的问题</li><li>当影响决策的因素较多且较主观时</li><li>分层、构造矩阵、检验一致性</li></ul><p>因为基本上做E或F题都会用到，所以详细展开一下</p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul><li>建立递阶层次结构模型；</li><li>构造出各层次中的所有判断矩阵；</li><li>层次单排序及一致性检验；</li><li>层次总排序及一致性检验。</li></ul><h2 id="层次结构的建立"><a href="#层次结构的建立" class="headerlink" title="层次结构的建立"></a>层次结构的建立</h2><p><img src="/2019/01/19/matlab-usage/1.png"></p><h2 id="构造判断矩阵"><a href="#构造判断矩阵" class="headerlink" title="构造判断矩阵"></a>构造判断矩阵</h2><p><img src="/2019/01/19/matlab-usage/2.png"></p><h2 id="层次单排序一致性检验"><a href="#层次单排序一致性检验" class="headerlink" title="层次单排序一致性检验"></a>层次单排序一致性检验</h2><ul><li>判断矩阵$A$对应于最大特征值$\lambda_{max}$的特征向量$W$ ，经归一化后即为同一层次相应因素对于上一层次某因素相对重要性的排序权值，这一过程称为层次单排序</li><li>如果比较结果是前后完全一致的，则矩阵$A$的元素还应当满足$a_{ij}a_{jk}=a_{ik}$，此时矩阵$A$成为一致矩阵</li><li>$n$阶正互反矩阵$A$为一致矩阵当且仅当其最大特征根$\lambda_{max}=n$，且当正互反矩阵$A$非一致时，必有$\lambda_{max}&gt;n$</li><li>一致性检验步骤<ul><li>计算一致性指标$CI=\frac{\lambda_{max}-n}{n-1}$</li><li>查找相应的平均随机一致性指标$RI$</li><li>计算一致性比例$CR=\frac{CR}{CI}$</li><li>$CR&lt;0.10$时，认为判断矩阵的一致性是可以接受的，否则应对判断矩阵作适当修正</li></ul></li></ul><h2 id="层次总排序一致性检验"><a href="#层次总排序一致性检验" class="headerlink" title="层次总排序一致性检验"></a>层次总排序一致性检验</h2><p>设A层(上一层次)包含$A_1,…A_m$共$m$个因素，层次总排序权重分别为$a_1,…a_m$，又设其后的下一层次B层包含$n$个因素$B_1,…B_n$，它们关于$A_j$的层次单排序权重分别为$b_{1j},…b_{nj}$(当$B_i$与$A_j$无关时，$b_{ij}=0$)。现求$B$层中各因素关于总目标的权重，即求$B$层个因素的层次总排序权重$b_1,…,b_n$。<br>$B$层各因素的层次总排序权重$b_i=\sum\limits_{j=1}^{m}b_{ij}a_{j}$<br>B层总排序随机一致性比例$$CR=\frac{\sum\limits_{j=1}^{m}CI(j)a_j}{\sum\limits_{j=1}^{m}RI(j)a_j}$$<br>$CR&lt;0.10$时认为层次总排序具有较满意的一致性并接受该分析结果</p><h1 id="方差分析-ANOVA"><a href="#方差分析-ANOVA" class="headerlink" title="方差分析(ANOVA)"></a>方差分析(ANOVA)</h1><ul><li>又称F检验</li><li>用数理统计分析试验结果、鉴别各因素对结果影响程度的方法</li></ul><h2 id="单因素方差分析"><a href="#单因素方差分析" class="headerlink" title="单因素方差分析"></a>单因素方差分析</h2><ul><li>任务：从试验结果推断某因素对指标有无显著影响</li><li>单因素方差分析表</li><li>方差分析命令<code>anoval</code>，<code>p = anoval(x,group)</code>将算得的概率<code>p</code>与<code>\alpha</code>进行比较</li></ul><h2 id="双因素方差分析"><a href="#双因素方差分析" class="headerlink" title="双因素方差分析"></a>双因素方差分析</h2><ul><li><code>p = anova2(x,reps)</code></li></ul><h2 id="多因素方差分析"><a href="#多因素方差分析" class="headerlink" title="多因素方差分析"></a>多因素方差分析</h2><ul><li><code>anovan</code></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y = [<span class="number">31</span> <span class="number">54</span> <span class="number">38</span> <span class="number">53</span> <span class="number">49</span> <span class="number">42</span> <span class="number">57</span> <span class="number">62</span> <span class="number">64</span>]; <span class="comment">%试验结果</span></span><br><span class="line">g1 = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]; <span class="comment">%正交表第一列</span></span><br><span class="line">g2 = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span>];</span><br><span class="line">g3 = [<span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>];</span><br><span class="line">[p,t,st] = anovan(y,&#123;g1,g2,g3&#125;)</span><br></pre></td></tr></table></figure><h1 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h1><ul><li><p>用来检验拟合函数的准确度</p></li><li><p>残差：实际观察值，估计值(拟合值)之间的差</p></li><li>$R^2$判定系数：可解释的变异占总变异的百分比</li></ul><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[b,bint,r,rint,stats] = regress(y,x,alpha);</span><br><span class="line"><span class="comment">% b为回归系数估计值</span></span><br><span class="line"><span class="comment">% bint为置信区间 </span></span><br><span class="line"><span class="comment">% r为残差，rint为残差的置信区间</span></span><br><span class="line"><span class="comment">% stats是用于检验回归模型的统计量[R^2,F,p,s^2]</span></span><br><span class="line"><span class="comment">% alpha显著性水平，缺省时为0.05</span></span><br></pre></td></tr></table></figure><h2 id="一元多项式回归"><a href="#一元多项式回归" class="headerlink" title="一元多项式回归"></a>一元多项式回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[p,s] =  polyfit(x0, y0, <span class="number">2</span>);</span><br><span class="line"><span class="comment">% s为用于计算函数值的数据结构，如</span></span><br><span class="line">[y,delta] = polyconf(p,x0,s);y</span><br><span class="line"><span class="comment">%可以得到y的拟合值、置信区间半径delta</span></span><br></pre></td></tr></table></figure><h2 id="多元二项式回归"><a href="#多元二项式回归" class="headerlink" title="多元二项式回归"></a>多元二项式回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rstool(x,y,model,alpha)</span><br><span class="line"><span class="comment">% x:n×m维矩阵</span></span><br><span class="line"><span class="comment">% y:n维向量</span></span><br><span class="line"><span class="comment">%model:线性、纯二次、交叉、完全二次四选一</span></span><br></pre></td></tr></table></figure><h1 id="主成成分分析"><a href="#主成成分分析" class="headerlink" title="主成成分分析"></a>主成成分分析</h1><ul><li>用较少的变量去解释原来资料中的大部分变异</li><li>选出比原始变量个数少、能解释大部分资料中的变异的几个新变量</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>对原始数据进行标准化处理</li><li>计算相关系数矩阵$R$</li><li>计算特征值和特征向量</li><li>选择$p$个主成分，计算综合评价值</li><li>计算综合得分</li></ul><h1 id="排队论"><a href="#排队论" class="headerlink" title="排队论"></a>排队论</h1><ul><li>有很多公式，用的时候再查吧</li><li>优化：最优服务率，最优服务台数</li></ul><h1 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h1><ul><li>当模型的数据中有一个或几个发生变化时，最优解会有什么变化</li><li>这些数据在什么范围内变化时，已求解的最优解不变</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据拟合&quot;&gt;&lt;a href=&quot;#数据拟合&quot; class=&quot;headerlink&quot; title=&quot;数据拟合&quot;&gt;&lt;/a&gt;数据拟合&lt;/h1&gt;&lt;h2 id=&quot;多项式拟合&quot;&gt;&lt;a href=&quot;#多项式拟合&quot; class=&quot;headerlink&quot; title=&quot;多项式拟合&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
