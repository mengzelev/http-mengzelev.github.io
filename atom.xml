<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengzelev&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mengzelev.github.io/"/>
  <updated>2019-05-01T15:14:35.465Z</updated>
  <id>https://mengzelev.github.io/</id>
  
  <author>
    <name>Mengzelev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>难问题求解-问题的形式化描述</title>
    <link href="https://mengzelev.github.io/2019/04/28/ps-4-10-Formal-description-of-problems/"/>
    <id>https://mengzelev.github.io/2019/04/28/ps-4-10-Formal-description-of-problems/</id>
    <published>2019-04-28T02:47:32.000Z</published>
    <updated>2019-05-01T15:14:35.465Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考书目：Juraj Hromkovic: Algorithmics for Hard Problems - Introduction to Combinatorial Optimization, Randomization, Approximation, and Heuristics, 2nd ed. Springer, 2004</p></blockquote><h1 id="字母表，单词和语言"><a href="#字母表，单词和语言" class="headerlink" title="字母表，单词和语言"></a>字母表，单词和语言</h1><p><strong>定义2.3.1.1</strong>：任意<strong>非空有限集</strong>都可以被称为<strong>字母表(alphabet)</strong>.字母表$\Sigma$中的任意元素都可以被称为$\Sigma$的符号</p><p><strong>定义2.3.1.2</strong>：设$\Sigma$是字母表。$\Sigma$上的单词(A word over $\Sigma$)是$\Sigma$中符号的任意有限序列。空单词$\bf{\lambda}$是唯一的零符号单词。$\Sigma$上所有单词的集合表示为$\Sigma^*$</p><p><strong>定义2.3.1.3</strong>：在字母表$\Sigma$上单词$\bm{w}$的<strong>长度</strong>是指$w$中符号的个数，记作$|w|$.对任意单词$x\in\Sigma^*$，任意符号$a\in\Sigma$，$#_a(w)$是单词$w$中符号$a$出现的次数。</p><script type="math/tex; mode=display">|w|=\sum\limits_{a\in\Sigma}\#_a(w)</script><p><strong>定义2.3.1.4</strong>：$\Sigma$为字母表，则对于任意$n\in\mathbb{N}$，$\bm{\Sigma^n}=\{x\in\Sigma^<em>\mid |x|=n \}$(长度为$n$的单词的集合)<br>$\bm{\Sigma^+}=\Sigma^</em>-\{\lambda\}$ (非空单词集)</p><p><strong>定义2.3.1.5</strong>：给定$\Sigma$中的两个单词$v$和$w$，定义$v$和$w$的<strong>拼接(concatenation)</strong>$\bm{vw}$(或表示为$v\cdot w$)为the word consists of the symbols of v in the same order, followed by the symbols of $w$ in the same order. <s>懒得翻译了</s></p><p>对任意单词$w\in\Sigma^*$, 定义</p><ul><li>$w^0=\lambda$</li><li>$w^{n+1}=w\cdot w^n=ww^n$ 对任意正整数$n$</li></ul><p>对任意单词$w\in\Sigma^*$,</p><ul><li>前缀(prefix)：任意单词$v$满足$w=vu$</li><li>后缀(suffix)：任意单词$u$满足$w=xu$</li><li>子词(subword)：任意单词$z$满足$w=uzv$</li></ul><p><strong>定义2.3.1.9</strong>：$\Sigma$是字母表，任意集合$L\subseteq\Sigma^<em>$称为$\Sigma$上的<strong>语言(Language)</strong>. 语言$L$关于$\Sigma$的<strong>补集(the complement of the language $L$ according to $\Sigma$)</strong>是$L^C=\Sigma^</em>-L$</p><p>设语言$L_1\subseteq\Sigma_1^<em>, L_2\subseteq\Sigma^{</em>}_2$，则$L_1$和$L_2$的<strong>拼接(concatenation)</strong>为$L_1L_2=L_1\circ L_2=\{uv\in(\Sigma_1\cup\Sigma_2)^*\mid u\in L_1 and~v\in L_2\}$</p><p>$L\cdot\emptyset=\emptyset\cdot L=\emptyset$，$L\cdot\{\lambda\}=\{\lambda\}\cdot L=\{\lambda\}$</p><p><strong>定义2.3.1.10</strong>：设$\Sigma=\{s_1,s_2,\cdots,s_m\},m\ge 1$是字母表，且$s_1&lt;s_2&lt;\cdots &lt;s_m$是$\Sigma$上的线性序(linear ordering). 如下定义$\Sigma^<em>$上的规范序：对于任意$u,v\in\Sigma^</em>$，$u&lt;v$ if $|u|&lt;|v|$ or $|u|=|v|, u=xs_iu’$, and $v=xs_jv’$ for some $x,u’,v’\in\Sigma^*$, and $i&lt;j$(其实就是字典序)</p><h1 id="算法问题"><a href="#算法问题" class="headerlink" title="算法问题"></a>算法问题</h1><p>难问题(Hard Problem)：不存在能解决这个问题的已知的多项式时间内的确定性算法的问题。(There is no known deterministic algorithm that solves it efficiently)</p><p>所有算法问题都可以看成$\Sigma_1^<em>\to\Sigma_2^</em>$的映射，或$\Sigma_1^<em>\times\Sigma_2^</em>$上的关系</p><p>两类问题</p><ul><li>Decision Problems: 决定给定的输入是否具有某一种性质</li><li>Optimization Prblems: 从某些限制决定的解空间中找到最优解</li></ul><h2 id="Decision-Problem"><a href="#Decision-Problem" class="headerlink" title="Decision Problem"></a>Decision Problem</h2><p><strong>定义2.3.2.1</strong>：判定问题(Decision problem)是一个三元组$(L,U,\Sigma)$,其中$\Sigma$是字母表且$L\subseteq U\subseteq\Sigma^*$. 算法$A$解决(decides)了这个问题如果：对于任意$x\in U$,</p><p>(i) $A(x)=1$ 若$x\in L$<br>(ii) $A(x)=0$ 若$x\in U-L(x\notin L)$</p><p>$A$计算了一个函数$U\to\{0,1\}$</p><p>等价表示形式：<br>Problem $(L,U,\Sigma)$</p><ul><li>Input: An $x\in U$</li><li>Output: “yes” if $x\in L$, “no” otherwise</li></ul><p>多数情况下$U=\Sigma^*$,因此问题集合可以简写为$(L,\Sigma)$</p><h3 id="质数测试-Primality-Testing"><a href="#质数测试-Primality-Testing" class="headerlink" title="质数测试(Primality Testing)"></a>质数测试(Primality Testing)</h3><p>确定给定的数是否为质数</p><script type="math/tex; mode=display">\bm{PRIM}=\{w\in\{0,1\}^*\mid Number(w) \text{ is a prime}\}</script><ul><li>Input: An $x\in\Sigma_{bool}^*$</li><li>Output: “yes” if $Number(x)$ is a prime, “no” otherwise</li></ul><h3 id="多项式的等价问题-Equivalence-Problem-for-Polynomials"><a href="#多项式的等价问题-Equivalence-Problem-for-Polynomials" class="headerlink" title="多项式的等价问题(Equivalence Problem for Polynomials)"></a>多项式的等价问题(Equivalence Problem for Polynomials)</h3><p>对于一个给定的质数$p$，两个多项式$p_1(x_1,…,x_m)$和$p_2(x_1,…,x_m)$ 在$\mathbb{Z}_p$上是否等价</p><p>EQ-POL</p><ul><li>Input: A prime $p$, two polynomials $p_1$ and $p_2$ over variables from $X=\{x_1,x_2,…\}$</li><li>Output: “yes” if $p_1\equiv p_2\pmod p$, “no” otherwise</li></ul><h3 id="Equivalence-Problem-for-One-Time-Only-Branching-Programs"><a href="#Equivalence-Problem-for-One-Time-Only-Branching-Programs" class="headerlink" title="Equivalence Problem for One-Time-Only Branching Programs"></a>Equivalence Problem for One-Time-Only Branching Programs</h3><p>给定两个单次分支程序$B_1$和$B_2$，确定$B_1$和$B_2$是否对应了同一个布尔函数</p><p>EQ-1BP</p><ul><li>Input: One-time-only branching program $B_1$ and $B_2$ over a set of Boolean variables $X=\{x_1,x_2,…\}$</li><li>Output: “yes” if $B_1$ and $B_2$ are equivalent (represent the same Boolean function); “no” otherwise</li></ul><h3 id="Satisfiability-Problem"><a href="#Satisfiability-Problem" class="headerlink" title="Satisfiability Problem"></a>Satisfiability Problem</h3><p>对于一个给定的和取范式(CNF)判断是否可以被满足</p><script type="math/tex; mode=display">\bm{SAT}=\{w\in\Sigma^+_{logic}\mid w\text{ is a code of a satisfiable formula in CNF}\}</script><h3 id="Clique-Problem"><a href="#Clique-Problem" class="headerlink" title="Clique Problem"></a>Clique Problem</h3><p>对于一个给定的图$G$和正整数$k$，判断$G$中是否存在大小为$k$的团簇($K_k$)</p><p>$\bm{CLIQUE}=\{x#w\in\{0,1,#^<em>\}\mid x\in\{0,1\}^</em> \text{ and w represents a graph that contains a clique of size} Number(x) \}$</p><ul><li>Input: A positive integer $k$ and a Graph $G$</li><li>Output: “yes” if $G$ contains a clique of size $k$, “no” otherwise</li></ul><h3 id="点覆盖问题-Vertex-Cover-Problem，-VCP"><a href="#点覆盖问题-Vertex-Cover-Problem，-VCP" class="headerlink" title="点覆盖问题(Vertex Cover Problem， VCP)"></a>点覆盖问题(Vertex Cover Problem， VCP)</h3><p>对于一个给定的图$G$和正整数$k$，判断$G$中是否存在大小为$k$的点覆盖集</p><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/vc.png"></p><h3 id="哈密尔顿回路问题-Hamilton-Cycle-Problem，-HC"><a href="#哈密尔顿回路问题-Hamilton-Cycle-Problem，-HC" class="headerlink" title="哈密尔顿回路问题(Hamilton Cycle Problem， HC)"></a>哈密尔顿回路问题(Hamilton Cycle Problem， HC)</h3><p>顾名思义</p><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/hc.png"></p><h3 id="线性规划中的存在性问题"><a href="#线性规划中的存在性问题" class="headerlink" title="线性规划中的存在性问题"></a>线性规划中的存在性问题</h3><p>判断线性规划系统是否有解</p><script type="math/tex; mode=display">\bm{SOL-IP}=\{\langle A,b\rangle\in\{0,1,\#\}^*\mid Sol_{\mathbb{Z}(A,b)}\neq\emptyset\}</script><p>还有$SOL-0/1-IP$和$SOL-IP_{p}$</p><h2 id="最优化问题-Optimization-Problem"><a href="#最优化问题-Optimization-Problem" class="headerlink" title="最优化问题(Optimization Problem)"></a>最优化问题(Optimization Problem)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>定义2.3.2.2</strong>：一个最优化问题是一个7元组$U=\{\Sigma_I, \Sigma_O, L, L_I, \mathcal{M},cost, goal\}$，其中</p><ol><li>$\Sigma_I$是<strong>输入字母表(input alphabet)</strong></li><li>$\Sigma_O$是<strong>输出字母表(output alphabet)</strong></li><li>$L\subseteq\Sigma_I^<em>$是<em>*可行问题实例语言(language of feasible problem instance)</em></em></li><li>$L_I\subseteq L$是$U$的<strong>实际问题实例语言(language of the actual problem instances of $U$)</strong></li><li>$\mathcal{M}$是$L\to Pot(\Sigma_O^<em>)$的函数($Pot$表示幂集)，对任意$x\in L$，$\mathcal{M}(x)$称为$x$的<em>*可行解集合(set of feasible solutions for $x$)</em></em></li><li>$cost$是<strong>cost function</strong>，给任意pair$(u,x)$，其中$u\in\mathcal{M}(x)\text{for some }x$，分配一个正实数作为$cost(u,x)$</li><li>$goal\in\{minimum, maximum\}$</li></ol><ul><li>$L$类似于定义域</li><li>$L_I$是定义域中实际会被取的数值，$U$的hardness主要由$L_I$衡量</li><li>$\mathcal{M}(x)$是$x$给定的所有满足问题限制的解的集合</li><li>如果输入的$x$是固定的，最优解就是$\mathcal{x}$中cost最大/小的那个</li></ul><p><strong>定义2.3.2.3</strong>：设$U<em>1=\{\Sigma_I, \Sigma_O, L, L</em>{I,1} \mathcal{M},cost, goal\}$,$U<em>2=\{\Sigma_I, \Sigma_O, L, L</em>{I,2} \mathcal{M},cost, goal\}$是两个最优化问题。若$L<em>{I,1}\subseteq L</em>{I,2}$，则称$U_1$是$U_2$的子问题</p><p>为了简化定义，通常省略$\Sigma_I$和$\Sigma_O$，只关心以下成分(?):</p><ul><li>$L_I$</li><li>输入实例给出的限制，即$\mathcal{M}(x)$</li><li>cost function</li><li>goal</li></ul><p>对任意$x\in L_I$，可行解$y\in\mathcal{M}(x)$被称为$x$和$U$的<strong>最优解(optimal for $x$ and $U$)</strong>，记作$Opt(u)$</p><p>称算法$A$与问题$U$是<strong>一致的(consistent for $U$)</strong>，如果对于任意$x\in L_I$，输出$A(x)\in\mathcal{M}(x)$</p><p>称算法$B$解决了最优化问题$U$当：</p><ol><li>$B$ is consistent for $U$</li><li>for every $x\in L_I$，$B(x)$ is an optimal solution for $x$ and $U$</li></ol><h3 id="旅行商问题-Traveling-Salesperson-Problem-TSP"><a href="#旅行商问题-Traveling-Salesperson-Problem-TSP" class="headerlink" title="旅行商问题(Traveling Salesperson Problem, TSP)"></a>旅行商问题(Traveling Salesperson Problem, TSP)</h3><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/tsp.png"></p><p>推销员走遍所有城市所需的最小路程(权重)</p><p>TSP还有两个子问题</p><h4 id="Metric-TSP-Delta-TSP"><a href="#Metric-TSP-Delta-TSP" class="headerlink" title="Metric TSP($\Delta$-TSP)"></a>Metric TSP($\Delta$-TSP)</h4><p>所有问题实例$(G,c)$都满足三角不等式<script type="math/tex">c(\{u,v\})\le c(\{u,w\})+c(\{w,v\})</script></p><h4 id="Geometrical-Euclidean-TSP"><a href="#Geometrical-Euclidean-TSP" class="headerlink" title="Geometrical/Euclidean TSP"></a>Geometrical/Euclidean TSP</h4><p>二维欧式空间中的图，权重$c$是两点间的欧氏距离<br>是$\Delta$-TSP的子问题</p><h3 id="分批调度问题-Makespan-Scheduling-Problem-MS"><a href="#分批调度问题-Makespan-Scheduling-Problem-MS" class="headerlink" title="分批调度问题(Makespan Scheduling Problem, MS)"></a>分批调度问题(Makespan Scheduling Problem, MS)</h3><p>在$m$台相同的机器上安排$n$个指定任务的调度，找出处理时间最短的调度策略</p><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/ms.png"></p><h3 id="覆盖问题-Cover-Problems"><a href="#覆盖问题-Cover-Problems" class="headerlink" title="覆盖问题(Cover Problems)"></a>覆盖问题(Cover Problems)</h3><h4 id="最小点割集问题-MIN-VCP"><a href="#最小点割集问题-MIN-VCP" class="headerlink" title="最小点割集问题(MIN-VCP)"></a>最小点割集问题(MIN-VCP)</h4><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/minvcp.png"></p><h4 id="集合覆盖问题-SCP"><a href="#集合覆盖问题-SCP" class="headerlink" title="集合覆盖问题(SCP)"></a>集合覆盖问题(SCP)</h4><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/scp.png"></p><p>MIN-VCP可以看成SCP问题的子问题</p><h4 id="带权最小点覆盖集问题-WEIGHT-VCP"><a href="#带权最小点覆盖集问题-WEIGHT-VCP" class="headerlink" title="带权最小点覆盖集问题(WEIGHT-VCP)"></a>带权最小点覆盖集问题(WEIGHT-VCP)</h4><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/weightvcp.png"></p><h4 id="最大团问题-Maximum-Clique-Problemm-MAX-CL"><a href="#最大团问题-Maximum-Clique-Problemm-MAX-CL" class="headerlink" title="最大团问题(Maximum Clique Problemm MAX-CL)"></a>最大团问题(Maximum Clique Problemm MAX-CL)</h4><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/maxcl.png"></p><h3 id="割问题-Cut-Problem"><a href="#割问题-Cut-Problem" class="headerlink" title="割问题(Cut Problem)"></a>割问题(Cut Problem)</h3><h4 id="最大割问题-MAX-CUT"><a href="#最大割问题-MAX-CUT" class="headerlink" title="最大割问题(MAX-CUT)"></a>最大割问题(MAX-CUT)</h4><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/maxcut.png"></p><h3 id="背包问题-Knapsack-Problem"><a href="#背包问题-Knapsack-Problem" class="headerlink" title="背包问题(Knapsack Problem)"></a>背包问题(Knapsack Problem)</h3><h4 id="简单背包问题-SKP"><a href="#简单背包问题-SKP" class="headerlink" title="简单背包问题(SKP)"></a>简单背包问题(SKP)</h4><p>往一定容量的背包里装物品最多能装几个</p><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/skp.png"></p><h4 id="背包问题-KP"><a href="#背包问题-KP" class="headerlink" title="背包问题(KP)"></a>背包问题(KP)</h4><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/kp.png"></p><h3 id="装箱问题-Bin-Packing-Problem，-BIN-P"><a href="#装箱问题-Bin-Packing-Problem，-BIN-P" class="headerlink" title="装箱问题(Bin-Packing Problem， BIN-P)"></a>装箱问题(Bin-Packing Problem， BIN-P)</h3><p>求装一批货物所需的最小箱子的数目</p><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/binp.png"></p><h3 id="Maximum-Satisfiability-Problem-MAX-SAT"><a href="#Maximum-Satisfiability-Problem-MAX-SAT" class="headerlink" title="Maximum Satisfiability Problem (MAX-SAT)"></a>Maximum Satisfiability Problem (MAX-SAT)</h3><p>找到公式$\Phi$的变量的一种赋值，使得满足的句子最多</p><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/maxsat.png"></p><h3 id="线性规划-LP"><a href="#线性规划-LP" class="headerlink" title="线性规划(LP)"></a>线性规划(LP)</h3><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/lp.png"></p><h4 id="整数规划-IP"><a href="#整数规划-IP" class="headerlink" title="整数规划(IP)"></a>整数规划(IP)</h4><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/ip.png"></p><p>IP不是LP的子问题，因为除了输入被限制外，constraints也被限制了</p><h4 id="Maximum-Linear-Equation-Problem-Mod-k-MAX-LINMOD-k"><a href="#Maximum-Linear-Equation-Problem-Mod-k-MAX-LINMOD-k" class="headerlink" title="Maximum Linear Equation Problem Mod $k$(MAX-LINMOD$k$)"></a>Maximum Linear Equation Problem Mod $k$(MAX-LINMOD$k$)</h4><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/maxlinmod.png"></p><h1 id="复杂度理论"><a href="#复杂度理论" class="headerlink" title="复杂度理论"></a>复杂度理论</h1><p>衡量复杂度有两种指标</p><ul><li>标准指标(uniform cost  measurement)</li><li>对数指标(logarithmic cost measurement)<ul><li>参与计算的变量的长度不受限制时，标准指标会失真，一般使用对数指标</li><li>每一个原子操作的花费是所有参与运算的变量的长度之和</li><li>乘除法一般花费$O(n\log~n)$,加减法和赋值是线性的</li></ul></li></ul><p><strong>定义2.3.3.1</strong>：设$\Sigma_I$和$\Sigma_O$是字母表，$A$是从$\Sigma_I^<em>$映射到$\Sigma_O^</em>$的算法。对任意$x\in\Sigma_I^*$, $Time(A)$表示$A$计算输入$x$时间复杂度，$Space(A)$代表空间复杂度</p><p><strong>定义2.3.3.2</strong>：<strong>(worst case) time complexity</strong>最坏时间复杂度<script type="math/tex">Time_A(n)=\max\{Time_A(x)\mid x\in\Sigma_I^n \}</script><br><strong>(worst case) space complexity</strong>最坏空间复杂度<script type="math/tex">Time_A(n)=\max\{Space_A(x)\mid x\in\Sigma_I^n \}</script></p><p><strong>定理2.3.3.3</strong>：存在一个decision problem$(L,\Sigma_{bool})$,对任意判断$L$的算法$A$，都存在另一个算法$B$，使得对无限多的正整数$n$，$Time_B(n)=\log_2(Time_A(n))$<br>这说明$L$没有最佳算法</p><p><strong>定义2.3.3.4</strong>：设$U$是算法问题，$f,g$是$\mathbb{N}\to\mathbb{R}^+$的函数。</p><ul><li>$O(g(n))$是$U$的<strong>时间复杂度的上界(an upper bound on the time complexity of $U$)</strong>，当存在算法$A$使得$Time_A(n)\in O(g(n))$</li><li>$\Omega(f(n))$是$U$的<strong>时间复杂度的下界(an lower bound on the time complexity of $U$)</strong>，当存在算法$B$使得$Time_B(n)\in \Omega(f(n))$</li><li>算法$C$对于问题$U$是最优的(optimal)，当$Time_C(n)\in O(g(n))$且$\Omega(g(n))$是$U$的时间复杂度的下界</li></ul><h2 id="P问题"><a href="#P问题" class="headerlink" title="P问题"></a>P问题</h2><p><strong>定义2.3.3.5</strong>：定义复杂度类(complexity class)$P$表示可以在多项式时间内判定的语言如下：</p><script type="math/tex; mode=display">\bm{P}=\{L=L(M)\mid M \text{is a TM(an alg) with } Time_M(n)\in O(n^c)\text{ for sone positive integer}~c\}</script><p>语言$L$(decision problem)称为<strong>tractable(praticallt solvable)</strong>当且仅当$L\in\bm{P}$<br>,否则称为intractable</p><ul><li>所有可计算的模型都是<strong>多项式等价的(Polynomially equivalent)</strong></li><li>求解非$P$中问题的常用方法：随机和近似</li></ul><h2 id="NP完全性-NP-completeness"><a href="#NP完全性-NP-completeness" class="headerlink" title="NP完全性(NP-completeness)"></a>NP完全性(NP-completeness)</h2><h3 id="非确定性计算-non-deterministic-computation"><a href="#非确定性计算-non-deterministic-computation" class="headerlink" title="非确定性计算(non-deterministic computation)"></a>非确定性计算(non-deterministic computation)</h3><ul><li>非确定图灵机可以同时对一个输入做很多运算，而确定性图灵机只能做一个</li><li>通常用计算树来表示非确定性算法</li></ul><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/tree.png"></p><p><strong>定义2.3.3.6</strong>：设$M$是非确定性图灵机(算法)，则称$M$接受语言$L$，$L=L(M)$，当满足如下条件：</p><ol><li>对任意$x\in L$，存在至少一个$M$的计算接受$x$</li><li>对任意$y\notin L$，所有$M$计算拒绝$y$</li></ol><p>$Time_M(w)$($M$上$w$的时间复杂度)是最短接受运算的时间复杂度</p><script type="math/tex; mode=display">Time_M(n)=\max\{Time_M(n)\mid x\in L(M)\cap\Sigma^n\}</script><h3 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h3><script type="math/tex; mode=display">NP=\{L(M)\mid M\text{ is a polynomial-time nondeterministic TM} \}</script><p>对于多项式时间的计算，非确定性计算的时间复杂度与确定性验证的复杂度相同</p><p><strong>定义2.3.3.7</strong>：设$L\subseteq\Sigma^<em>$是语言。计算来自$\Sigma^</em>\times\{0,1\}^<em>$的算法$A$称为$L$的<em>*verifier(verifier for $L$)</em></em>，表示为$L=V(A)$，若</p><script type="math/tex; mode=display">L=\{w\in\Sigma^*\mid A \text{ accepts (w,c) for some }c\in\{0,1\}^*\}</script><p>若$A$接受$(w,c)$，则称$c$是事实$x\in L$的<strong>证明(proof or certificate)</strong><br>$A$是多项式时间verifier，若存在正整数$d$满足，对任意$w\in L$, $Time_A(w,c)\in O(|w|^d)$</p><p><strong>多项式时间可验证语言(polynomially verifiable languages)</strong></p><script type="math/tex; mode=display">\bm{VP}=\{V(A)\mid A \text{ is a polynomial-time verifier} \}</script><p>这里可以理解为：</p><ul><li>$w$是OJ的输入</li><li>$c$是你写的程序的输出，可以不用是严格的数学证明，只是一个能简化证明$w\in L$的额外信息</li><li>$A$是Special Judge，来检验你输出的答案对不对</li></ul><p><strong>定理2.3.3.9</strong>：NP=VP</p><h2 id="多项式时间缩减"><a href="#多项式时间缩减" class="headerlink" title="多项式时间缩减"></a>多项式时间缩减</h2><p><strong>定义2.3.3.10</strong>： 设$L_1\subseteq\Sigma_1^<em>$和$L_2\subseteq\Sigma_2^</em>$是两种语言。称$L_1$<strong>多项式时间可化简为$L_2$(polynomial-time reducible to $L_2$)</strong>，若存在多项式时间算法$A$计算$\Sigma_1^<em>\to\Sigma_2^</em>$的映射，满足对任意$x\in\Sigma_1^<em>$,$x\in L_1\Leftrightarrow A(x)\in L_2$,记作$L_1\le_p L_2$<br>$A$称为$L_1$到$L_2$的<em>*多项式时间缩减(polynomial-time reduction)</em></em></p><ul><li>语言$L$是<strong>NP-hard</strong>当对任意$U\in NP, U\le_p L$</li><li>语言$L$是<strong>NP-complete</strong>当$L\in NP$且$L$ is NP-hard</li></ul><p><strong>引理2.3.3.11</strong>：若$L$是NP-hard且$L\in P$，则$P=NP$</p><p><strong>定理2.3.3.12(Cook’s Theorem)</strong>： SAT是NP-complete的</p><p><strong>观察2.3.3.13</strong>：若$L_1\le_p L_2$且$L_1$是NP-hard的，则$L_2$是NP-hard的。<br>这说明证明一个问题是NP-hard的只需要找一个能多项式时间化简为它的NP-hard问题。</p><p>一个NP-complete问题可以看成编码了其他所有NP问题，例如所有NP问题都可以看成SAT问题，即所有decision problem都可以表示成布尔函数的形式</p><h3 id="几个栗子"><a href="#几个栗子" class="headerlink" title="几个栗子"></a>几个栗子</h3><p><strong>引理2.3.3.15</strong>： SAT$\le_p$CLIQUE</p><p><strong>引理2.3.3.16</strong>：CLIQUE$\le_p$VC</p><p><strong>引理2.3.3.19</strong>：3SAT$\le_p$SOL-0/1-LP</p><h2 id="Optimization-Problem的难度"><a href="#Optimization-Problem的难度" class="headerlink" title="Optimization Problem的难度"></a>Optimization Problem的难度</h2><p><strong>定义2.3.3.21</strong>：最优化问题$U\in$<strong>NPO</strong>当满足以下条件</p><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/23321.png"></p><p>人话：$U$是NPO问题当</p><ul><li>可以高效的认定一个对象是否是$U$中的实例</li><li>解的size是问题实例size的多项式且可以在多项式时间内认定一个对象是否为$U$的解</li><li>任何解的cost函数都可以高效算出</li></ul><p><strong>定义2.3.3.23</strong>：PO是满足如下条件的最优化问题</p><ol><li>$U\in \bf{NPO}$</li><li>存在多项式时间的算法，对任意$x\in L_I$,能计算出$x$的最优解</li></ol><p><strong>定义2.3.3.24</strong>：$U$的临界语言(threshold language)</p><script type="math/tex; mode=display">Lang_u=\{(x,a)\in L_I\times\Sigma_{bool}^*\mid Opt_U(x)\le Number(a) \}</script><p>if goal = minimum, and as </p><script type="math/tex; mode=display">Lang_u=\{(x,a)\in L_I\times\Sigma_{bool}^*\mid Opt_U(x)\ge Number(a) \}</script><p>if goal = maximum</p><p>若$Lang_U$是NP-hard则$U$是NP-hard.</p><p><strong>引理2.3.3.25</strong>：若最优化问题$U\in PO$，则$Lang_U\in P$</p><p><strong>定理2.3.326</strong>：若$Lang_U$是NP-hard且$P\neq NP$，则$U\notin PO$<br>这个定理可以用来证明最优化问题的NP-hardness</p><h4 id="几个栗子-1"><a href="#几个栗子-1" class="headerlink" title="几个栗子"></a>几个栗子</h4><p><strong>引理2.3.3.27</strong>：MAX-SAT是NP-hard</p><p><strong>引理2.3.3.28</strong>：MAX-CL是NP-hard</p><h1 id="算法设计技巧"><a href="#算法设计技巧" class="headerlink" title="算法设计技巧"></a>算法设计技巧</h1><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p><img src="/2019/04/28/ps-4-10-Formal-description-of-problems/divide.png"></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>见算法导论</p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;参考书目：Juraj Hromkovic: Algorithmics for Hard Problems - Introduction to Combinatorial Optimization, Randomization, Approximat
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-代数编码</title>
    <link href="https://mengzelev.github.io/2019/04/20/ps-4-9-algebraic-coding/"/>
    <id>https://mengzelev.github.io/2019/04/20/ps-4-9-algebraic-coding/</id>
    <published>2019-04-20T14:15:05.000Z</published>
    <updated>2019-05-15T10:57:32.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="检错码与纠错码"><a href="#检错码与纠错码" class="headerlink" title="检错码与纠错码"></a>检错码与纠错码</h1><p>数电你都学过了</p><p>信仰</p><ul><li>传送错误是非常罕见的</li><li>它们在每一位出现是独立的（概率可以相乘）</li><li>采用最大可能译码：每一串编码都被翻译成离它最近的字</li></ul><p><strong>血的教训</strong>： 奇（偶）校验是当1的个数为奇（偶）数时该位为0.</p><p><img src="/2019/04/20/ps-4-9-algebraic-coding/binary.png" height="200"></p><p><strong>定理8.7</strong>: 传送$n$位二进制编码，每一位出错的概率为$q=1-p$，则正好有$k$位出错的概率为$(_k^n)q^kp^{n-k}$</p><h2 id="划区编码"><a href="#划区编码" class="headerlink" title="划区编码"></a>划区编码</h2><p>定义：一个$(n,m)-$<strong>blocking code</strong> 包含了编码函数$E:\mathbb{Z}_2^m\to\mathbb{Z}_2^n$和译码函数$D:\mathbb{Z}_2^n\to\mathbb{Z}_2^m$ </p><ul><li>$E$需要是单射</li><li>如果需要纠错能力，则$D$需要是满射</li></ul><p><strong>汉明距离(Hamming distance)</strong>：你懂的<br><strong>最小距离(minimum distance)</strong>：一套编码所有码字中最小的汉明距离<br><strong>权重</strong>：码字$\bf{x}$的权重$w(\mathbf{x})$是$\bf{x}$中1的个数，很明显$w(\bf{x})=d(\bf{x},0)$</p><p><img src="/2019/04/20/ps-4-9-algebraic-coding/811.png"><br>(正确的废话们)</p><p><strong>定理8.13</strong>: $C$是最小距离$d_{min}=2n+1$的编码，则$C$可以纠正最多$n$位错和检测最多$2n$位的错</p><h1 id="线性编码-Linear-Codes"><a href="#线性编码-Linear-Codes" class="headerlink" title="线性编码(Linear Codes)"></a>线性编码(Linear Codes)</h1><p><strong>群编码(group code)</strong>: 是指一套为$\mathbb{Z}^n_2$的子群的编码系统(运算为+,也可以理解为异或)</p><ul><li>如果我们将编码系统中任意2个元素相加，则一定会得到一个该系统中的编码</li><li>不需要检查元素的逆，因为每个元素的逆都是他本身</li><li>也不需要检查$\bf{0}$是单位元</li></ul><p><strong>定理8.17</strong>: 设$\bf{x}$与$\bf{y}$是$n$位二进制数，则$w(\bf{x}+\bf{y})=d(\bf{x},\bf{y})$.</p><p><strong>定理8.18</strong>：在group code中，$d_{\min}=\min\{w(\bf{x}):\bf{x}\neq 0\}$.</p><p><strong>零空间(null space)</strong>: $H\in\mathbb{M}_{m\times n}(\mathbb{Z}_2)$，所有$\bf{x}\in H，H\bf{x}=0$，记作Null$(H)$.</p><p><strong>定理8.21</strong>：若$H\in\mathbb{M}_{m\times n}(\mathbb{Z}_2)$，则$H$的null space是group code.</p><p>一个编码系统是线性编码当且仅当它由某个矩阵的null space决定</p><h1 id="奇偶校验与生成矩阵"><a href="#奇偶校验与生成矩阵" class="headerlink" title="奇偶校验与生成矩阵"></a>奇偶校验与生成矩阵</h1><p>设$H$是$m\times n$的二进制矩阵且$n&gt;m$。若$m$的右$m$列组成了单位阵$I_m$，则这个矩阵称为<strong>规范奇偶校验矩阵(canonical parity-check matrix)</strong>，即$H=(A|I_m)$</p><p>每个规范奇偶校验矩阵都对应一个标准生成矩阵$G=\left(\frac{I_k}{A}\right), k=n-m$<br>存在$\bf{x}$满足$G\bf{x}=\bf{y}$当且仅当$H\bf{y}=0$</p><p><strong>定理8.26</strong>：若$H$是规范奇偶校验矩阵，则$Null(H)$由所有满足前$n-m$位任意但后$m$位由$H\bf{x}=0$决定的$\bf{x}$组成. 后$m$位充当前$n-m$位中某些位的偶校验。因此$H$产生了一个$(n,n-m)$的block code.<br>前$n-m$位叫<strong>信息位(information bits)</strong>，后$m$位叫做<strong>校验位(check bits)</strong></p><p><strong>定理8.26</strong>：设$G$是$n\times k$的标准生成矩阵，则$C=\{\bf{y}:G\bf{x}=\bf{y}~\text{for}~\bf{x}\in\mathbb{Z}_2^k\}$是一套$(n,k)-block code$.更确切地说，$C$是group code.</p><p><strong>引理8.27</strong>：设$H=(A|I_m)$是规范奇偶校验矩阵，$G=\left(\frac{I_k}{A}\right), k=n-m$是相应的标准生成矩阵，则$HG=0$</p><p><strong>定理8.28</strong>：$G,H,C$定义同上。$\bf{y}\in C$当且仅当$H\bf{y}=\bf{0}$.特别地，$C$是以$H$为规范奇偶校验矩阵的线性编码</p><p><strong>命题8.30</strong>：乘单位列向量可以把矩阵的某一列取出来</p><p><strong>定理8.31</strong>：设$H$为$m\times n$的二进制矩阵，则$H$的null space是单错误检测矩阵当且仅当$H$没有全0的列</p><p><strong>定理8.34</strong>：设$H$为$m\times n$的二进制矩阵，则$H$的null space是单错误纠错矩阵当且仅当$H$没有全0的列且没有两列是相同的</p><p>$m$位单位纠错码可以有$2^m-(1+m)$个</p><h1 id="高效译码"><a href="#高效译码" class="headerlink" title="高效译码"></a>高效译码</h1><p>若$H$是$m\times n$的矩阵且$\bf{x}\in\mathbb{Z}_2^n$，则$H\bf{x}$称为$\bf{x}$的<strong>syndrome</strong></p><p><strong>命题8.36</strong>：将$\bf{x}$写成$\bf{x}=\bf{c}+\bf{e}$，此处$\bf{c}$是编码后的码字，$\bf{e}$是传送错误，则$H\bf{x}$也是$\bf{e}$的syndrome,即$H\bf{x}$=$H\bf{e}$.</p><p><strong>定理8.37</strong>：设$\bf{r}$是最多错一位的接收到的编码。若$\bf{r}=\bf{0}$则没有出错，否则，若$r$的syndrome与$H$的第$i$列相同，则错误出现在第$i$位</p><h2 id="陪集译码"><a href="#陪集译码" class="headerlink" title="陪集译码"></a>陪集译码</h2><p>陪集中权重最小的码字叫做<strong>coset leader</strong>.</p><p>译码表：为每个syndrome指定一个coset leader</p><p><img src="/2019/04/20/ps-4-9-algebraic-coding/table.png" height="300"></p><p><strong>定理8.43</strong>： 两个$n$位编码在同一个陪集中当且仅当它们的syndrome相同</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;检错码与纠错码&quot;&gt;&lt;a href=&quot;#检错码与纠错码&quot; class=&quot;headerlink&quot; title=&quot;检错码与纠错码&quot;&gt;&lt;/a&gt;检错码与纠错码&lt;/h1&gt;&lt;p&gt;数电你都学过了&lt;/p&gt;
&lt;p&gt;信仰&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传送错误是非常罕见的&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自己看得惯的板子整理</title>
    <link href="https://mengzelev.github.io/2019/04/19/oj-templates/"/>
    <id>https://mengzelev.github.io/2019/04/19/oj-templates/</id>
    <published>2019-04-19T08:20:44.000Z</published>
    <updated>2019-04-20T10:55:16.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h2><h3 id="dfs版"><a href="#dfs版" class="headerlink" title="dfs版"></a>dfs版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> rnd, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (status == two[num] - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[i][status] &gt; <span class="number">0</span>) <span class="keyword">return</span> f[i][status];</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = num; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (j != i &amp;&amp; (!(status &amp; temp))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q &gt; dfs(j, rnd + <span class="number">1</span>, status | temp) + a[need[i]][need[j]]) &#123;</span><br><span class="line">                q = dfs(j, rnd + <span class="number">1</span>, status | temp) + a[need[i]][need[j]];</span><br><span class="line">                c[i][status] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[i][status] = q;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bfs版"><a href="#bfs版" class="headerlink" title="bfs版"></a>bfs版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(start);</span><br><span class="line">    vis[start] = <span class="literal">true</span>;</span><br><span class="line">    s[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = u + ok[i];</span><br><span class="line">            <span class="keyword">int</span> v2 = u - ok[i];</span><br><span class="line">            <span class="keyword">if</span> (v1 &lt;= n &amp;&amp; !vis[v1]) &#123;</span><br><span class="line">                Q.push(v1);</span><br><span class="line">                s[v1] = s[u] + <span class="number">1</span>;</span><br><span class="line">                vis[v1] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v2 &gt;= <span class="number">0</span> &amp;&amp; !vis[v2]) &#123;</span><br><span class="line">                Q.push(v2);</span><br><span class="line">                s[v2] = s[u] + <span class="number">1</span>;</span><br><span class="line">                vis[v2] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) e[i] = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">int</span> sn = <span class="number">1</span> &lt;&lt; cnt1; <span class="comment">//状态数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sn; ++i) f[i] = INF;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sn; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &amp; e[j]) ++j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p = j + <span class="number">1</span>; p &lt; cnt1; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(i &amp; e[p]) &amp;&amp; dist[p+<span class="number">1</span>][j+<span class="number">1</span>]) &#123;</span><br><span class="line">            f[i | e[j] | e[p]] = min(f[i | e[j] | e[p]], f[i] + dist[p+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> f[sn<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//别忘了初始化f[i]=i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = f[x];</span><br><span class="line">    <span class="keyword">while</span>(root != f[root]) root = f[root];</span><br><span class="line">    <span class="keyword">int</span> y = f[x];</span><br><span class="line">    <span class="keyword">while</span>(f[x] != root)&#123;</span><br><span class="line">        f[x] = f[y];</span><br><span class="line">        y = f[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(a, b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(a);</span><br><span class="line">    <span class="keyword">int</span> fb = find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa != fb) f[fa] = fb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> temp = f[x];</span><br><span class="line">    f[x] = find(temp);</span><br><span class="line">    rel[x] = (rel[x] + rel[temp]) % <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//rel[x]初始化为全0</span></span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">        f[fy] = fx;</span><br><span class="line">        rel[fy] = (<span class="number">3</span> + d + rel[x] - rel[y]) % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span>) <span class="keyword">return</span> (rel[x] == rel[y]);</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">1</span>) <span class="keyword">return</span> ((<span class="number">3</span> - rel[x] + rel[y]) % <span class="number">3</span> == d); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fu = find(e[i].u);</span><br><span class="line">        <span class="keyword">int</span> fv = find(e[i].v);</span><br><span class="line">        <span class="keyword">if</span> (fu != fv) &#123;</span><br><span class="line">            f[fv] = fu;</span><br><span class="line">            ans += e[i].weight;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">//序号，找边权用</span></span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;y) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &lt; y.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;vertex[MAXN] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue &lt;node&gt; q;</span><br><span class="line">    vertex[<span class="number">0</span>].d = <span class="number">0</span>;</span><br><span class="line">    q.push(vertex[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u.id].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> vid = son[u.id][i];</span><br><span class="line">            <span class="keyword">double</span> weight = w[u.id][i];</span><br><span class="line">            <span class="keyword">if</span>(vertex[vid].d &lt; u.d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vertex[vid].d &gt; u.d + weight)&#123;</span><br><span class="line">                vertex[vid].d = u.d + weight;</span><br><span class="line">                q.push(vertex[vid]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j] &gt; <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j])</span><br><span class="line">                    <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="各种tarjan"><a href="#各种tarjan" class="headerlink" title="各种tarjan"></a>各种tarjan</h1><h2 id="有向图强连通分量数"><a href="#有向图强连通分量数" class="headerlink" title="有向图强连通分量数"></a>有向图强连通分量数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfn[u] u的时间戳</span></span><br><span class="line"><span class="comment">//low[u] u或u的子树能够追溯到的最早栈中节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++cnt;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    stack1[++index] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v]) low[u] = min(low[u], dfn[v]); <span class="comment">//u-v is a back edge</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">        scnum ++; <span class="comment">//强连通分量数</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            belong[stack1[index]] = scnum;</span><br><span class="line">            num[scnum] ++;</span><br><span class="line">            vis[stack1[index]] = <span class="literal">false</span>;</span><br><span class="line">            index --;</span><br><span class="line">        &#125;<span class="keyword">while</span>(u != stack1[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">//     if(!dfn[i]) &#123;</span></span><br><span class="line"><span class="comment">//         cnt = 1;</span></span><br><span class="line"><span class="comment">//         tarjan(i);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="无向图割点与割边"><a href="#无向图割点与割边" class="headerlink" title="无向图割点与割边"></a>无向图割点与割边</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">    dfs_clock ++;</span><br><span class="line">    dfn[u] = low[u] = dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v,u);</span><br><span class="line">            child ++;</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>((u == <span class="number">1</span> &amp;&amp; child &gt; <span class="number">1</span>) || (u != <span class="number">1</span> &amp;&amp; dfn[u] &lt;= low[v])) &#123;</span><br><span class="line">                cut.push_back(u); <span class="comment">//割点判定</span></span><br><span class="line">                <span class="comment">//iscut[u] = true;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u]) </span><br><span class="line">                bridge.push_back(&#123;min(u,v), max(u,v)&#125;); <span class="comment">//割边判定</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v != pre)</span><br><span class="line">                low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tarjan(1,-1);</span></span><br></pre></td></tr></table></figure><h2 id="无向图双连通分量"><a href="#无向图双连通分量" class="headerlink" title="无向图双连通分量"></a>无向图双连通分量</h2><p>点（边）双连通分量：若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥），则称作点（边）双连通图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    dfs_clock ++;</span><br><span class="line">    dfn[u] = low[u] = dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v,u);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v != pre) low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计无向图的边双连通分量，在一个双连通分量中当且仅当low[u] == low[v]</span></span><br></pre></td></tr></table></figure><h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">directed_euler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> moreout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> morein = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ver[i].indeg &gt; ver[i].outdeg) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ver[i].indeg == ver[i].outdeg + <span class="number">1</span>) morein ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ver[i].deg &lt; ver[i].outdeg) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ver[i].outdeg == ver[i].indeg + <span class="number">1</span>) moreout++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("morein = %d, moreout = %d", morein, moreout);</span></span><br><span class="line">    <span class="keyword">if</span>(morein &lt;= <span class="number">1</span> &amp;&amp; moreout &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断连通有向图是否含欧拉迹</span></span><br><span class="line"><span class="comment">//至多一顶点出度=入度+1</span></span><br><span class="line"><span class="comment">//至多一顶点入度=出度+1</span></span><br><span class="line"><span class="comment">//其余顶点：入度=出度</span></span><br></pre></td></tr></table></figure><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">undirected_euler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(ver[i].deg % <span class="number">2</span> == <span class="number">1</span>) odd++;</span><br><span class="line">    <span class="keyword">if</span>(odd == <span class="number">0</span> || odd == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈密尔顿回路"><a href="#哈密尔顿回路" class="headerlink" title="哈密尔顿回路"></a>哈密尔顿回路</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hamilton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    path.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size() - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[path[j]][i] &amp;&amp; <span class="built_in">map</span>[i][path[j + <span class="number">1</span>]])&#123;</span><br><span class="line">                path.insert(path.begin() + j + <span class="number">1</span>, i);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[path.back()][i]) path.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> path.insert(path.begin(), i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h1><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">0</span> || find(match[i]))&#123;</span><br><span class="line">                match[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">if</span>(find(i)) ans ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KM：最小权匹配"><a href="#KM：最小权匹配" class="headerlink" title="KM：最小权匹配"></a>KM：最小权匹配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    S[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!T[j] &amp;&amp; ls[i] + lt[j] == <span class="built_in">map</span>[i][j]) &#123;</span><br><span class="line">            T[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!match[j] || find(match[j])) &#123;</span><br><span class="line">                match[j] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> relax_val = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(n,m); ++i)</span><br><span class="line">        <span class="keyword">if</span>(S[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j)</span><br><span class="line">                <span class="keyword">if</span>(!T[j] &amp;&amp; ls[i] + lt[j] &gt; <span class="built_in">map</span>[i][j]) relax_val = min(relax_val, ls[i] + lt[j] - <span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    assert(relax_val &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i]) ls[i] -= relax_val;</span><br><span class="line">        <span class="keyword">if</span> (T[i]) lt[i] += relax_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match, <span class="number">0</span>, <span class="keyword">sizeof</span>(match));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(m,n); ++i) &#123;</span><br><span class="line">        ls[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j) ls[i] = max(<span class="built_in">map</span>[i][j], ls[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) lt[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(n,m); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(S, <span class="number">0</span>, <span class="keyword">sizeof</span>(S));</span><br><span class="line">            <span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T));</span><br><span class="line">            <span class="keyword">if</span> (find(i)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> relax();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="Dinic-当前弧优化"><a href="#Dinic-当前弧优化" class="headerlink" title="Dinic+当前弧优化"></a>Dinic+当前弧优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0</span> , <span class="keyword">sizeof</span>(depth));</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    depth[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[u][v] &gt; <span class="number">0</span> &amp;&amp; !depth[v]) &#123;</span><br><span class="line">                depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth[t] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 寻找当前增广路径上的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> dist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i = cur[u]; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(depth[v] == depth[u] + <span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[u][v] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> minc = dfs(v, min(dist, <span class="built_in">map</span>[u][v]));</span><br><span class="line">            <span class="keyword">if</span>(minc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">map</span>[u][v] -= minc;</span><br><span class="line">                <span class="built_in">map</span>[v][u] += minc;</span><br><span class="line">                <span class="keyword">return</span> minc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span> , <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">int</span> minc = dfs(s, INF)) &#123;</span><br><span class="line">            ans += minc;</span><br><span class="line">            <span class="comment">//printf("minc=%d\n",minc);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2row</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) swap(a[x][i], a[y][i]);</span><br><span class="line">    <span class="comment">//printf("**swap row %d with row %d**\n",x,y);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot_one</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> temp = a[x][y];</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i &lt;= n + <span class="number">1</span>; ++i) a[x][i] /= temp;</span><br><span class="line">    <span class="comment">//printf("**pivot one at row %d**\n", x);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul_and_add</span><span class="params">(<span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">double</span> cof)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        a[dst][i] -= a[src][i] * cof;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("**mul row %d with %lf add to row %d**\n", src, cof, dst);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_matrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">printf</span>(<span class="string">"%lf "</span>, a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"| %lf\n"</span>, a[i][n + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">iszero</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(a[row][i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Guass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">1</span>, col = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(row &lt;= n &amp;&amp; col &lt;= n) &#123;</span><br><span class="line">        <span class="comment">//printf("Now row=%d, col=%d\n",row, col);</span></span><br><span class="line">        <span class="keyword">if</span>(a[row][col] == <span class="number">0.0</span>) &#123;</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = row + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                <span class="keyword">if</span>(a[i][col] != <span class="number">0</span>) &#123;</span><br><span class="line">                    swap2row(row, i);</span><br><span class="line">                    ok = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(ok == <span class="literal">false</span>) &#123;col++; <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="comment">//else print_matrix();</span></span><br><span class="line">        &#125;</span><br><span class="line">        pivot_one(row,col);</span><br><span class="line">        <span class="keyword">if</span>(col == n &amp;&amp; row == n &amp;&amp; a[row][col] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//print_matrix();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(i != row &amp;&amp; a[i][col] != <span class="number">0</span>) &#123;</span><br><span class="line">                assert(a[row][col] != <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">double</span> cof = a[i][col] / a[row][col];</span><br><span class="line">                <span class="keyword">if</span>(cof != <span class="number">0</span>) mul_and_add(row, i, cof);</span><br><span class="line">                assert(a[i][col] == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//print_matrix();</span></span><br><span class="line">        row ++; col ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性规划-—-simplex单纯形算法"><a href="#线性规划-—-simplex单纯形算法" class="headerlink" title="线性规划 — simplex单纯形算法"></a>线性规划 — simplex单纯形算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; -EPS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; EPS ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    swap(id[n + r], id[c]);</span><br><span class="line">    <span class="keyword">double</span> x = -a[r][c];</span><br><span class="line">    a[r][c] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) a[r][i] /= x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sgn(a[i][c]) &amp;&amp; i != r) &#123;</span><br><span class="line">            x = a[i][c];</span><br><span class="line">            a[i][c] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) a[i][j] += x * a[r][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* important: revert symbols of conditions */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            a[i][j] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = i;</span><br><span class="line">    <span class="comment">/* initial-simplex */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[i][<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123; x = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[x][i]) &gt; <span class="number">0</span>) &#123; y = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!y) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// infeasible</span></span><br><span class="line">        pivot(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* solve-simplex */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[<span class="number">0</span>][i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        printf("choose x%d, cof=%d\n", x, a[0][x]);</span></span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">break</span>; <span class="comment">// finished</span></span><br><span class="line">        <span class="keyword">double</span> w = <span class="number">0</span>, t = <span class="number">0</span>; <span class="comment">//t是最苛刻的非基本变量能取到的最大值</span></span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[i][x]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                t = ((<span class="keyword">double</span>)-a[i][<span class="number">0</span>]) / ((<span class="keyword">double</span>)a[i][x]);</span><br><span class="line"><span class="comment">//                if(x==3) printf("t: -%d / %d = %.lf\n", a[i][0], a[i][x], t);</span></span><br><span class="line">                <span class="keyword">if</span> (f || t &lt; w) &#123;</span><br><span class="line">                    w = t, y = i, f = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="comment">// unbounded</span></span><br><span class="line">        pivot(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) v[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; ++i) v[id[i]] = a[i - n][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">  kmp[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len2; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s2[i] != s2[j + <span class="number">1</span>]) j = kmp[j];</span><br><span class="line">    <span class="keyword">if</span>(s2[j + <span class="number">1</span>] == s2[i]) j ++;</span><br><span class="line">    kmp[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s1[i] != s2[j + <span class="number">1</span>]) j = kmp[j];</span><br><span class="line">    <span class="keyword">if</span>(s1[i] == s2[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    <span class="keyword">if</span>(j == len2 - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - len2 + <span class="number">2</span>);</span><br><span class="line">      j = kmp[j];</span><br><span class="line">      ok = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="comment">/*字典树*/</span></span><br><span class="line">    <span class="keyword">int</span> tot, root;</span><br><span class="line">    <span class="keyword">int</span> nxt[MAXN][<span class="number">26</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">      tot = <span class="number">1</span>;</span><br><span class="line">      root = newNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">memset</span>(nxt[tot], <span class="number">0</span> ,<span class="keyword">sizeof</span>(nxt[tot]));</span><br><span class="line">      <span class="keyword">return</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> cur = root;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(nxt[cur][id] == <span class="number">0</span>) nxt[cur][id] = newNode();</span><br><span class="line">        cur = nxt[cur][id];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">          <span class="keyword">if</span>(nxt[i][j] != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"S.nxt[%d][%c]=%d\n"</span>,i, j+<span class="string">'a'</span>, nxt[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;S;</span><br></pre></td></tr></table></figure><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n, ll mod)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*快速幂*/</span></span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  a %= mod;</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = (ans * a) % mod;</span><br><span class="line">    a = (a * a) % mod;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;状态压缩dp&quot;&gt;&lt;a href=&quot;#状态压缩dp&quot; class=&quot;headerlink&quot; title=&quot;状态压缩d
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>os期中复习</title>
    <link href="https://mengzelev.github.io/2019/04/15/os-midterm/"/>
    <id>https://mengzelev.github.io/2019/04/15/os-midterm/</id>
    <published>2019-04-15T14:17:55.000Z</published>
    <updated>2019-04-17T15:14:52.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用眼中的OS"><a href="#应用眼中的OS" class="headerlink" title="应用眼中的OS"></a>应用眼中的OS</h1><ul><li>操作系统一方面需要提供程序的<strong>执行的环境</strong>和<strong>相应的资源</strong>，还要提供<strong>和操作系统世界中其他对象交互的方法和约定</strong></li></ul><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="共享内存多线程"><a href="#共享内存多线程" class="headerlink" title="共享内存多线程"></a>共享内存多线程</h2><ul><li>并发定义：一个程序、算法或问题的不同部分乱序或偏序执行而不影响最终结果的能力</li><li>程序经历了什么？<ul><li>编译器优化$\to$顺序丧失</li><li>操作系统中断，多处理器、缓存(硬件)$\to$原子性)(all or nothing)丧失</li><li>缓存，乱序（硬件）$\to$可见性丧失</li></ul></li></ul><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>评估一把锁的基本准则</p><ul><li>所能够完成基本任务：提供互斥性质</li><li>锁的分配是公平的：不会有现成想要上锁却永远得不到它</li><li>锁的高效的：无等待时性能？多线程同时等待时性能？多CPU每个核的线程都要上锁时性能？</li></ul><h3 id="几种上锁方法"><a href="#几种上锁方法" class="headerlink" title="几种上锁方法"></a>几种上锁方法</h3><ul><li>TestAndSet；相当于<code>atomic_xchg</code></li><li>CompareAndWait</li><li>LL&amp;SC</li><li>FetchAndAdd：彩票锁，保证公平性</li></ul><h2 id="同步-CV"><a href="#同步-CV" class="headerlink" title="同步(CV)"></a>同步(CV)</h2><ul><li><code>wait(&amp;cond)</code>：当前进程进入睡眠状态，等待cond被满足后唤醒</li><li><code>signal(&amp;cond)</code>：唤醒在等待cond条件的某个进程</li><li><code>broadcast(&amp;cond)</code>: 唤醒在等待cond条件的所有进程</li><li>需要配合互斥锁使用：读取状态到<code>wait()</code>之间不能被打断，改变状态到<code>signal</code>之间也不能被打断</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>互斥锁(二元信号量)和同步都可以使用信号量来实现<br>信号量就相当于有一个管理员manage了一堆资源，进程需要资源时先向管理员请求(<code>semi_wait</code>)，暂时没有资源就等，使用完毕后归还(<code>semi_post</code>)给管理员</p><h3 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h3><ul><li><code>sem_wait</code>：信号量-1，表示在等待的线程增加了一个，消耗一个执行名额；如果信号量&lt;0, 表示等待的线程数多于可执行线程数，当前线程进入睡眠</li><li><code>sem_post</code>：信号量+1，表示执行的线程少了一个，可以让出一个执行名额</li></ul><h2 id="并发Bugs"><a href="#并发Bugs" class="headerlink" title="并发Bugs"></a>并发Bugs</h2><ul><li>原子性违反(AV) —&gt; 上锁</li><li>顺序违反(OV) -&gt; 同步</li></ul><h3 id="死锁出现的四个条件"><a href="#死锁出现的四个条件" class="headerlink" title="死锁出现的四个条件"></a>死锁出现的四个条件</h3><ul><li>互斥</li><li>请求与保持(同一个进程要同时上多把锁)</li><li>没有抢占(不能强制解锁)</li><li>循环等待</li></ul><h3 id="对付死锁"><a href="#对付死锁" class="headerlink" title="对付死锁"></a>对付死锁</h3><ul><li>避免：规定上锁顺序</li><li>检测：打log</li></ul><h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><p>每个进程都以为自己独占CPU和整个内存空间<br>进程：OS提供的对运行程序的抽象</p><h2 id="进程抽象"><a href="#进程抽象" class="headerlink" title="进程抽象"></a>进程抽象</h2><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>Running: 进程正在处理器上执行命令</li><li>Ready：进程准备执行，但由于某些原因OS决定现在不让它运行</li><li>Blocked：进程此前执行了某些操作(e.g. I/O)，让它在其他事件发生前停止执行</li></ul><h3 id="实现进程"><a href="#实现进程" class="headerlink" title="实现进程"></a>实现进程</h3><ul><li>进程=线程+地址空间</li><li>进程就是个结构体<ul><li>名字</li><li>pid</li><li>上下文</li><li>地址空间</li><li>堆栈</li><li>状态</li><li>其他信息（如父进程、文件描述符等）</li></ul></li></ul><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>一个指向os内对象的指针<br><code>fork-exec</code>不改变文件描述符</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"a.txt"</span>);</span><br><span class="line">dup2(STDOUT_FILENO, fd); <span class="comment">//???</span></span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pipe(fds) != <span class="number">0</span>) &#123;panic(<span class="string">"pipe error"</span>);&#125;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;<span class="comment">//child</span></span><br><span class="line">    dup2(fds[<span class="number">1</span>], STUOUT_FILENO); <span class="comment">//连接写口，往管道内写数据</span></span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; <span class="comment">//parent</span></span><br><span class="line">    dup2(fds[<span class="number">0</span>], STDIN_FILENO); <span class="comment">//连接读口，从管道内读数据</span></span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>进程组实现</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h3><ul><li>轮转时间(turnaround time): $\sum t<em>{complete}-t</em>{arrival}$</li><li>响应时间(response time): $\sum t<em>{firstrun}-t</em>{arrival}$</li></ul><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><ul><li>优点：简单易实现</li><li>缺点： 会产生护航效应</li></ul><h3 id="SJF-Shortest-Job-First"><a href="#SJF-Shortest-Job-First" class="headerlink" title="SJF(Shortest Job First)"></a>SJF(Shortest Job First)</h3><ul><li>当假设所有任务同时到达时的最优算法</li><li>非抢占式(preemptive)算法</li></ul><h3 id="STCF-Shortest-Time-to-Completion-First"><a href="#STCF-Shortest-Time-to-Completion-First" class="headerlink" title="STCF(Shortest Time-to-Completion First)"></a>STCF(Shortest Time-to-Completion First)</h3><ul><li>抢占式策略，又名Preemptive Shortest Job First(PSJF)</li><li>轮转时间短但响应时间长</li></ul><h3 id="RR-Round-Robin"><a href="#RR-Round-Robin" class="headerlink" title="RR(Round Robin)"></a>RR(Round Robin)</h3><ul><li>每个进程运行一段时间片(time slice, sometimes called scheduling quantum)</li><li>时间片越短，响应时间越短，但是切换上下文的时间会变长(trade-off)</li><li>当考虑轮转时间时非常糟糕</li><li>保证了公平性但是损失了效率</li></ul><h3 id="MLFQ-Multi-level-Feedback-Queue"><a href="#MLFQ-Multi-level-Feedback-Queue" class="headerlink" title="MLFQ(Multi-level Feedback Queue)"></a>MLFQ(Multi-level Feedback Queue)</h3><p>MLFQ有很多种实现但都大同小异，书上只介绍一种</p><ul><li>有很多队列，每个队列具有不同的优先级，优先级高的先运行</li><li>通过观察进程过去的行为调整优先级<ul><li>如果一个进程频繁让出CPU，保持高优先级；反之一个进程如果长时间占用CPU则会被降低优先级</li></ul></li><li>并不知道一个任务是长是短，因此先假设是短的，然后根据进程的后续表现修改认知</li></ul><h4 id="优先级的修改"><a href="#优先级的修改" class="headerlink" title="优先级的修改"></a>优先级的修改</h4><p>workload: 交互式短时间任务(会频繁让出CPU)+不交互的长时间任务(响应时间不那么重要)</p><h4 id="Basic-Rules"><a href="#Basic-Rules" class="headerlink" title="Basic Rules"></a>Basic Rules</h4><ol><li>If Priority(A)&gt;Priority(B), A runs (B doesn’t)</li><li>If Priority(B)==Priority(B), A &amp; B runs in RR</li><li>一个任务最初进入系统时位于最高优先级<br>4(a). 如果一个任务耗尽了时间片，则优先级下降<br>4(b). 如果一个任务在时间片耗尽之前放弃了CPU,优先级不变<br>4(改进). 当一个任务在一定程度上用尽了被分配到的时间，优先级就下降<br>5(新增). 在一段时间$S$后，将所有任务移到最高优先级上(Priority-boost) </li></ol><p>缺陷： </p><ul><li>饥饿：如果交互式进程很多就会完全占用CPU使得长任务得不到调度(5解决)</li><li>有些心脏的应用可以玩弄这个规则，一直主动让出一小会儿CPU来使自己停留在高优先级上(4解决)</li><li>任务的行为可能会随着时间改变(5解决)</li></ul><h3 id="PS-Proportional-share"><a href="#PS-Proportional-share" class="headerlink" title="PS(Proportional-share)"></a>PS(Proportional-share)</h3><ul><li>老子才不管什么的轮转时间和响应时间，老子只要每个任务都能按比例分到一定时间</li></ul><h4 id="lottery-scheduling"><a href="#lottery-scheduling" class="headerlink" title="lottery scheduling"></a>lottery scheduling</h4><blockquote><p>随机的好处</p><ul><li>防止了边界情况</li><li>轻量级，需要记录的信息少</li><li>快(太快了可能会变成伪随机数)</li></ul></blockquote><p>怎么分配彩票也是个很棘手的问题</p><h4 id="stride-scheduling"><a href="#stride-scheduling" class="headerlink" title="stride scheduling"></a>stride scheduling</h4><ul><li>根据每个任务的彩票数决定每次调度执行的时间长短</li><li>每次调度都选取运行时间最短的任务</li></ul><h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><p>不想看了【瘫</p><h2 id="链接和加载"><a href="#链接和加载" class="headerlink" title="链接和加载"></a>链接和加载</h2><ul><li>静态链接下的加载：<code>_start-&gt;__libc_start_main-&gt;generic_start_main-&gt;...-&gt;main</code></li><li>动态链接：<ul><li>PLT：程序链接表，放入进行链接的代码，方便lazy linking</li><li>GOT：全局偏移表，存放函数代码开始的地址</li></ul></li></ul><h2 id="虚存抽象"><a href="#虚存抽象" class="headerlink" title="虚存抽象"></a>虚存抽象</h2><ul><li>mmap：把操作系统里的对象映射到进程的地址空间<ul><li>e.g.加载可执行文件的时候把文件搬到某个地址处</li><li>不映射任何文件的时候就相当于malloc</li><li>只记录相关信息，余下的等发生缺页时再处理，所以非常快</li><li>可以用红黑树维护分配的内存</li><li>fork采用写时复制</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;应用眼中的OS&quot;&gt;&lt;a href=&quot;#应用眼中的OS&quot; class=&quot;headerlink&quot; title=&quot;应用眼中的OS&quot;&gt;&lt;/a&gt;应用眼中的OS&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;操作系统一方面需要提供程序的&lt;strong&gt;执行的环境&lt;/strong&gt;和&lt;strong
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>问题求解学习笔记-密码算法</title>
    <link href="https://mengzelev.github.io/2019/04/13/ps-4-7-cryptographic-algorithm/"/>
    <id>https://mengzelev.github.io/2019/04/13/ps-4-7-cryptographic-algorithm/</id>
    <published>2019-04-13T04:04:44.000Z</published>
    <updated>2019-04-14T04:05:17.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RSA公钥加密系统"><a href="#RSA公钥加密系统" class="headerlink" title="RSA公钥加密系统"></a>RSA公钥加密系统</h1><p>每个参与者都有一把公钥($P$)和密钥($S$)</p><p>$\mathcal{D}$表示允许信息的集合，要求公钥与密钥指定一种从$\mathcal{D}$到自身的一一对应的函数。<br>Alice的公钥函数$P_A()$和密钥函数$S_A()$都是$\mathcal{D}$的排列</p><p>系统中任何参与者的公钥与密钥都是匹配对，指定函数互为反函数，对任何消息$M\in \mathcal{D}$，有</p><script type="math/tex; mode=display">M=S_A(P_A(M))</script><script type="math/tex; mode=display">M=P_A(S_A(M))</script><h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><ul><li>Bob取得Alice的公钥$P_A$</li><li>Bob计算出相应与$M$的密文$C=P_A(M)$，并把$C$发送给Alice</li><li>当Alice收到密文$C$后，运用自己的密钥$S_A$恢复原始信息$M$</li></ul><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul><li>Alice运用密钥$S_A$和等式$\sigma=S_A)M’$计算出信息$M’$的数字签名$\sigma$</li><li>Alice把消息/签名对$(M’,\sigma)$发给Bob</li><li>Bob收到$(M’,\sigma)$时，通过验证等式$M’=P_A(\sigma)$来证实消息的确是来自Alice</li></ul><p>任何人都可以把数字签名翻译出来，但只有密钥持有者可以生成数字签名</p><h2 id="RSA加密系统"><a href="#RSA加密系统" class="headerlink" title="RSA加密系统"></a>RSA加密系统</h2><p><img src="/2019/04/13/ps-4-7-cryptographic-algorithm/rsa.png"></p><p>加密</p><script type="math/tex; mode=display">P(M)=M^e\bmod n</script><p>解密</p><script type="math/tex; mode=display">S(C)=C^d\bmod n</script><p>上述加密解密操作可以使用快速幂实现。</p><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>假定：</p><ul><li>公钥$(e,n)$和密钥$(d,n)$满足$\lg~e=O(1), \lg~d\le\beta, \lg~n\le\beta$</li><li>应用公钥需要执行$O(1)$次模乘法运算和$O(\beta^2)$次位操作</li><li>应用密钥需要执行$O(\beta)$次模乘法运算和$O(\beta^2)$次位操作。</li></ul><h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p><strong>定理31.36(RSA的正确性)</strong>：RSA加密和解密等式定义了满足再上面两个等式的$\mathbb{Z}_n$的逆变换</p><p>RSA加密系统的安全性主要来源于对大整数进行因式分解的困难性</p><h3 id="效率提高"><a href="#效率提高" class="headerlink" title="效率提高"></a>效率提高</h3><ul><li>无公钥加密系统</li><li>抗冲突散列函数$h$</li><li>证书</li></ul><h1 id="整数的因子分解"><a href="#整数的因子分解" class="headerlink" title="整数的因子分解"></a>整数的因子分解</h1><h3 id="Pollard的rho启发式方法"><a href="#Pollard的rho启发式方法" class="headerlink" title="Pollard的rho启发式方法"></a>Pollard的rho启发式方法</h3><p><img src="/2019/04/13/ps-4-7-cryptographic-algorithm/pr.png"></p><ul><li>通过随机数寻找$n$的非平凡约数</li><li>可能会出现”$\rho$”字型回路，在出现回路之前预计要执行的步数为$\Theta(\sqrt{n})$</li><li>一种找出大整数的小素数因子的可供选择的办法</li></ul><h2 id="私钥密码学"><a href="#私钥密码学" class="headerlink" title="私钥密码学"></a>私钥密码学</h2><p>仿射密码系统(affine cryptosystem)：$f(p)=ap+b\bmod 26$, $f^{-1}(p)=a^{-1}p-a^{-1}b\bmod 26$</p><p>多字码密码系统(polyalphabetic cryptosystem): $f(\textbf(p))=A\textbf{p}+b$,其中$A$是矩阵，$b$是列向量，$f^{-1}(\textbf{p})=A^{-1}\textbf{p}-A^{-1}\textbf{p}$</p><h2 id="公钥密码学"><a href="#公钥密码学" class="headerlink" title="公钥密码学"></a>公钥密码学</h2><p>RSA加密系统（CLRS上已讲</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RSA公钥加密系统&quot;&gt;&lt;a href=&quot;#RSA公钥加密系统&quot; class=&quot;headerlink&quot; title=&quot;RSA公钥加密系统&quot;&gt;&lt;/a&gt;RSA公钥加密系统&lt;/h1&gt;&lt;p&gt;每个参与者都有一把公钥($P$)和密钥($S$)&lt;/p&gt;
&lt;p&gt;$\mathcal{
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-数论算法</title>
    <link href="https://mengzelev.github.io/2019/04/06/clrs-31Number-Theoretic-Algorithms/"/>
    <id>https://mengzelev.github.io/2019/04/06/clrs-31Number-Theoretic-Algorithms/</id>
    <published>2019-04-06T03:18:48.000Z</published>
    <updated>2019-04-14T08:07:09.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输入规模和算数计算的代价"><a href="#输入规模和算数计算的代价" class="headerlink" title="输入规模和算数计算的代价"></a>输入规模和算数计算的代价</h1><p>给定$k$个整数输入$a_1,a_2,\cdots ,a_k$，如果算法可以在关于$\lg~a_1,\lg~a_2,\cdots ,\lg~a_k$的多项式时间内完成，即算法在<strong>关于二进制编码后的输入长度</strong>的多项式时间内完成，则称该算法为<strong>多项式时间</strong>算法</p><p>当输入很大时，基本运算也会变得耗时。<br>两个$\beta$位整数相乘需要耗时$\Theta(\beta^2)$.<br>一个$\beta$为整数除以另一个较短整数的商或余数需要耗时$\Theta(\beta^2)$</p><h1 id="基础数论概念"><a href="#基础数论概念" class="headerlink" title="基础数论概念"></a>基础数论概念</h1><h2 id="整除性与约数"><a href="#整除性与约数" class="headerlink" title="整除性与约数"></a>整除性与约数</h2><p>你懂的</p><h2 id="素数与合数"><a href="#素数与合数" class="headerlink" title="素数与合数"></a>素数与合数</h2><p>你也懂的</p><h2 id="除法定理、余数和等模"><a href="#除法定理、余数和等模" class="headerlink" title="除法定理、余数和等模"></a>除法定理、余数和等模</h2><p><strong>定理31.1(除法定理)</strong>: 对于任何整数$a$和任何正整数$n$，存在唯一整数$q$和$r$，满足$0\le r&lt;n$且$a=qn+r$</p><p>根据整数模$n$的余数，可以将所有整数划分成$n$个等价类。<br>包含整数$a$的模$n$等价类为$\left[a\right]_n=\{a+kn:k\in\mathbb{Z}\}$<br>所有这类等价类的集合是$\mathbb{Z}_n=\{[a]_n:0\le a\le n-1\}$</p><h2 id="公约数与最大公约数"><a href="#公约数与最大公约数" class="headerlink" title="公约数与最大公约数"></a>公约数与最大公约数</h2><p>公约数的重要性质：</p><ul><li>$d\mid a$且$d\mid b$蕴含$d\mid (a+b)$且$d\mid (a-b)$</li><li>对任意整数$x$和$y$，都有$d\mid a$且$d\mid b$蕴含$d\mid(ax+by)$</li><li>$a\mid b$且$b\mid a$蕴含$a=\pm b$</li></ul><p><strong>定理31.2</strong>: 如果任意整数$a$和$b$不都为0，则gcd$(a,b)$是$a$与$b$线性组合集$\{ax+by:x,y\in\mathbb{Z}\}$中的<strong>最小正元素</strong>。(最小正线性组合)</p><p><strong>推论31.3</strong>: 对任意整数$a$与$b$，如果$d\mid a$且$d\min b$，则$d\mid gcd(a,b)$</p><p><strong>推论31.4</strong>: 对所有整数$a$和$b$以及任意非负整数$n$，有$gcd(an,bn)=n~gcd(a,b)$</p><p><strong>推论31.5</strong>: 对于任意正整数$n,a$和$b$，如果$n\mid ab$且$gcd(a,n)=1$,则$n\mid b$.</p><h2 id="互质数"><a href="#互质数" class="headerlink" title="互质数"></a>互质数</h2><p><strong>定理31.6</strong>: 对任意整数$a,b$与$p$,如果$gcd(a,p)=1$且$gcd(b,p)=1$，则$gcd(ab,p)=1$.</p><h2 id="唯一因子分解定理"><a href="#唯一因子分解定理" class="headerlink" title="唯一因子分解定理"></a>唯一因子分解定理</h2><p><strong>定理31.7</strong>: 对所有素数$p$和所有整数$a,b$，如果$p\mid ab$,则$p\mid a$或$p\mid b$(或两者都成立)。</p><p><strong>定理31.8(唯一因子分解定理)</strong>: 合数$a$仅能以一种方式写成如下乘积形式</p><script type="math/tex; mode=display">a=p_1^{e_1}p_2^{e_2}\cdots p_r^{e_r}</script><p>其中$p_i$为素数，$p_1&lt;p_2&lt;\cdots p_r$且$e_i$为正整数</p><h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><p><strong>定理31.9(GCD递归定理)</strong>: 对任意非负整数$a$和任意正整数$b$，$gcd(a,b)=gcd(b,a\bmod b)$</p><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p><strong>引理31.10</strong>: 如果$a&gt;b\ge 1$并且EUCLID($a,b$)执行了$k\ge 1$次递归调用，则$a\ge F<em>{k+2}， b\ge F</em>{k+1}$.($F_n$为斐波那契数列的第$n$项)</p><p><strong>定理31.11(Lame定理)</strong>: 对任意整数$k\ge 1$,如果$a&gt;b\ge 1$,且$b&lt;F<em>{k+1}$,则EUCLID($a,b$)的递归调用次数少于$k$次<br>该上界是最优的，因为$k\ge 2$时，EUCLID$(F</em>{k+1},F_k)$正好调用了$k$次</p><p>$F_k$约为$\phi^k/\sqrt{5}$, $\phi=(1+\sqrt{5})/2$<br>EUCLID执行中递归调用的次数为$O(\lg b)$<br>如果EUCLID作用于两个$\beta$位数，则将执行$O(\beta)$次算术运算和$O(\beta^3)$次位操作</p><h3 id="扩展形式"><a href="#扩展形式" class="headerlink" title="扩展形式"></a>扩展形式</h3><p>用于计算满足下列条件的整系数$x$和$y$(可能为0或负数):</p><script type="math/tex; mode=display">d=gcd(a,b)=ax+by</script><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/exEUCLID.png"></p><p>运行时间与EUCLID相同</p><h1 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h1><p>群论复习</p><h2 id="模-n-加法群"><a href="#模-n-加法群" class="headerlink" title="模$n$加法群"></a>模$n$加法群</h2><p>你懂的</p><h2 id="模-n-乘法群"><a href="#模-n-乘法群" class="headerlink" title="模$n$乘法群"></a>模$n$乘法群</h2><script type="math/tex; mode=display">(\mathbb{Z}_n^*, \cdot_n)</script><script type="math/tex; mode=display">\mathbb{Z}_n^*=\{[a]_n\in\mathbb{Z}_n: gcd(a,n)=1\}</script><p><strong>定理31.13</strong>: 模$n$乘法群是有限交换群</p><p>$\mathbb{Z}_n^*$中的除法由等式$a/b\equiv ab^{-1}\pmod n$定义</p><p>$\mathbb{Z}_n^*$的规模表示为欧拉phi函数($\phi(n)$)</p><script type="math/tex; mode=display">\phi(n)=n\prod\limits_{p:\text{p is prime and }p\mid n}(1-\frac{1}{p})</script><p>直观理解(类似筛法求质数思想)：开始有一张$n$个余数组成的表，然后对于每个能整除$n$的素数$p$,在表中划掉所有$p$的倍数。</p><ul><li>若$p$是素数，则$\phi(p)=p-1$</li><li>若$n$是合数，<script type="math/tex">\frac{n}{e^\gamma\ln\ln n+\frac{3}{\ln\ln n}}<\phi(n)<n-1</script>($n\ge 3$, $\gamma=0.5772156649\cdots$是欧拉常数)<ul><li>$n&gt;5$时有个更松弛的下界<script type="math/tex">\phi(n)>\frac{n}{6\ln\ln n}</script></li></ul></li></ul><h2 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h2><p><strong>定理31.14</strong>: 一个有限群的非空封闭子集是一个子群</p><p><strong>定理31.15(拉格朗日定理)</strong>: 如果$(S,+)$是一个有限群，$(S’,+)$是$(S,+)$的一个子群，则$|S’|$是$|S|$的一个约数</p><p><strong>推论31.16</strong>: 如果$S’$是$S$的有限子群，则$|S’|\le |S|/2$</p><h2 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h2><p><strong>定理31.17</strong>: 对任意有限群$(S,+)$和任意$a\in S$, 一个元素的阶等于它所生成的循环子群的规模，即$ord(a)=|\langle a\rangle|$</p><p>$a^{(0)}=e, a^{(i)}=a^{(i\bmod t)}(t=\bmod a)$</p><p><strong>推论31.18</strong>: 序列$a^{(1)},a^{(2)},\cdots$是周期序列，其周期为$t=\bmod a$, 即$a^{(i)}=a^{(j)}$当且仅当$i\equiv j\pmod t$</p><p><strong>推论31.19</strong>: 如果$(S,+)$是具有单位元$e$的有限群，则对所有$a\in S$，$a^{(|S|)}=e$</p><h1 id="求解模线性方程"><a href="#求解模线性方程" class="headerlink" title="求解模线性方程"></a>求解模线性方程</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><script type="math/tex; mode=display">ax\equiv b\pmod n</script><p>假设已知$a,b$和$n$，求出所有满足上述方程的对模$n$的$x$的值<br>该方程可能无解、仅有一解或有多解</p><h2 id="数学准备"><a href="#数学准备" class="headerlink" title="数学准备"></a>数学准备</h2><p><strong>定理31.20</strong>: 对任意正整数$a$和$n$，如果$d=gcd(a,n)$, 则在$\mathbb{Z}_n^*$中，<script type="math/tex">\langle a\rangle=\langle d\rangle=\{0,d,2d,\cdots,((n/d)-1)d\}</script><br>因此，$|\langle a\rangle|=n/d$.</p><p><strong>推论31.21</strong>: 当且仅当$d\mid b$时，方程$ax\equiv b\pmod n$对于未知量$x$有解。这里$d=gcd(a,n)$.<br>i.e. 当且仅当$[b]\in\langle a\rangle$时，方程有解</p><p><strong>推论31.22</strong>: 方程$ax\equiv b\pmod n$或者对模$n$有$d$个不同的解，或者无解。这里$d=gcd(a,d)$.</p><p><strong>定理31.23</strong>: 令$d=gcd(a,n)$, 假设对某些整数$x’$和$y’$,有$d=ax’+ny’$(例如EXTENDED-EUCLID所计算出的结果)。如果$d\mid b$,则方程$ax\equiv b\pmod n$有一个解的值为$x_0$,这里$x_0=x’(b/d)\pmod n$.\\</p><p><strong>定理31.24</strong>: 假设方程$ax\equiv b\pmod b$有解(即$d\mid b$),且$x_0$是该方程的任意一个解。因此，该方程对模$n$恰好有$d$个不同的解，分别为$x_i=x_0+i(n/d)$, 这里$i=0,1,\cdots,d-1$.</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/mod.png"></p><h2 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h2><p>执行$O(\lg n+gcd(a,n))$次算术运算</p><p><strong>推论31.25</strong>： 对任意$n&gt;1$, $a$和$n$互质时方程对模$n$有唯一解</p><p><strong>推论31.26</strong>： 对任意$n&gt;1$，若$a,n$互质，则方程$ax\equiv 1\bmod n$对模$n$有唯一解，否则方程无解。<br>因此，当$a$和$n$互质时，可以用记号$a^{-1}\bmod n$表示$a$对模$n$的乘法逆元</p><h1 id="中国余数定理"><a href="#中国余数定理" class="headerlink" title="中国余数定理"></a>中国余数定理</h1><p><strong>定理31.27(中国余数定理)</strong>: 令$n=n<em>1n_2\cdots n_k$,其中因子$n_i$两两互质。考虑以下对应关系:<script type="math/tex">a\leftrightarrow(a_1,a_2,\cdots,a_k)</script>这里$a\in\mathbb{Z}_n,a_i\in\mathbb{Z}</em>{n_i}$, 而且对$i=1,2,\cdots,k$, <script type="math/tex">a_i=a\bmod n_i</script>.</p><p>该映射是一个在$\mathbb{Z}_n$ 与笛卡尔积 $\mathbb{Z}_{n<em>1}\times\mathbb{Z}\</em>{n<em>2}\times\cdots\times\mathbb{Z}</em>{n_k}$之间的一一对应，对$\mathbb{Z}_n$中元素所执行的运算可以等价地作用于对应的$k$元组</p><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/a+b.png"></p><p>从$(a_1,a_2,\cdots,a_k)$计算$a$：</p><ul><li>定义$m<em>i=n/n_i=n_1n_2\cdots n</em>{i-1}n_{i+1}\cdots n_l$</li><li>对$i=1,2, \cdots l$, 定义$c_i=m_i(m_i^{-1}\bmod n_i)$<ul><li>In fact, $c_i\leftrightarrow(0,0,\cdots ,0,1,0,\cdots 0)$ 除了在$i$个坐标上为1外其余坐标均为0</li></ul></li><li>$a\equiv (a_1c_1+a_2c_2+\cdots +a_kc_k)\pmod n$</li></ul><p>对任意$x$和$i=1,2,\cdots k,$有$x\bmod n_i=(x\bmod n)\mod n_i$.</p><p><strong>推论31.28</strong>: 如果$n_1,n_2,\cdots ,n_k$两两互质，$n=n_1n_2\cdots n_k$,则对任意整数$a_1,a_2,\cdots ,a_k$, 关于未知量$x$的联立方程组<script type="math/tex">x\equiv a_i\pmod n_i,i=1,2,\cdots k</script>对模$n$有唯一解</p><p><strong>推论31.29</strong>: 如果$n_1,n_2,\cdots ,n_k$两两互质，$n=n_1n_2\cdots n_k$, 则对所有整数$x$和$a$，$x\equiv a\pmod n_i$(其中$i=1,2,\cdots k$)当且仅当$x\equiv a\pmod n$.</p><p><strong>可以把模大数的线性方程转换为模小数的线性方程组</strong></p><h1 id="元素的幂"><a href="#元素的幂" class="headerlink" title="元素的幂"></a>元素的幂</h1><p><strong>定理31.30</strong>: 对于任意整数$n&gt;1$, $a^{\phi(n)}\equiv 1\pmod n$对所有$a\in\mathbb{Z}_n^*$都成立</p><p><strong>定理31.31</strong>: 若$p$是素数，则$a^{p-1}\equiv 1\pmod p$对所有$a\in\mathbb{Z}_p^*$都成立</p><p><strong>定理31.32</strong>: 对所有素数$p&gt;2$和所有正整数$e$，使得$\mathbb{Z}_n^*$是循环群的$n&gt;1$的值为2,4，$p^e$和$2p^e$。</p><p>若$g$是$\mathbb{Z}<em>n^<em>$的生成元，则对于任意$a\in\mathbb{Z}_n^</em>$存在一个$z$，使得$g^z\equiv a\pmod n$. 这个$z$称为对模$n$到基$g$上的$a$的一个<strong>离散对数</strong>或<strong>指数</strong>，记为$ind</em>{n,g}(a)$</p><p><strong>定理31.33(离散对数定理)</strong>: 如果$g$是$\mathbb{Z}_n^*$的一个生成元，则当且仅当等式$x\equiv y\pmod {\phi(n)}$ 成立时，有等式$g^x\equiv g^y\pmod n$成立。</p><p><strong>定理31.34</strong>: 如果$p$是一个奇素数且$e\ge 1$，则方程<script type="math/tex">x^2\equiv 1\pmod p^e</script>仅有两个解，即$x=\pm 1$。</p><p>如果$x$满足$x^2\equiv 1\pmod n$， 但$x$不等于以$n$为模的两个平凡平方根，则$x$是一个以$n$为模的<strong>非平凡平方根</strong></p><p><strong>推论31.35</strong>: 如果对模$n$存在1的非平凡平方根，则$n$是合数</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>又名：用反复平方法求数的幂</p><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/modex.png"></p><p>$c$只是用来辅助正确性证明的变量</p><p>循环不变式：</p><ul><li>$c$的值与$b$的二进制表示的前缀$\langle b<em>k,b</em>{k-1},\cdots b_{i+1}\rangle$相同</li><li>$d=a^c\pmod n$</li></ul><p>时间复杂度$O(\beta^3)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;输入规模和算数计算的代价&quot;&gt;&lt;a href=&quot;#输入规模和算数计算的代价&quot; class=&quot;headerlink&quot; title=&quot;输入规模和算数计算的代价&quot;&gt;&lt;/a&gt;输入规模和算数计算的代价&lt;/h1&gt;&lt;p&gt;给定$k$个整数输入$a_1,a_2,\cdots ,a_k
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
  </entry>
  
  <entry>
    <title>问题求解学习笔记-数论基础</title>
    <link href="https://mengzelev.github.io/2019/03/30/ps-4-6-basic-number-theory/"/>
    <id>https://mengzelev.github.io/2019/03/30/ps-4-6-basic-number-theory/</id>
    <published>2019-03-30T06:49:23.000Z</published>
    <updated>2019-03-30T14:15:07.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h1><p>你都懂的</p><h1 id="辗转相除法-Division-Algorithm"><a href="#辗转相除法-Division-Algorithm" class="headerlink" title="辗转相除法(Division Algorithm)"></a>辗转相除法(Division Algorithm)</h1><p><strong>定理2.9(辗转相除法)</strong>: $a,b$为整数，满足$b&gt;0$，则存在唯一的整数$q$和$r$使得$a=bq+r$，此处$0\le r&lt;b$</p><p>$a\mid b$: $a$能整除$b$,$b$能被$a$整除</p><p><strong>定理2.10</strong>: $a,b$为非零整数，则存在整数$r,s$使得gcd($a,b)=ar+bs$. $gcd(a,b)$是唯一的。但$r,s$不唯一</p><p><strong>推论2.11</strong>: $a,b$为互质的整数，则存在整数$r,s$使得$ar+bs=1$【事实上是当且仅当的关系】</p><h2 id="欧几里得算法-The-Euclidean-Algorithm"><a href="#欧几里得算法-The-Euclidean-Algorithm" class="headerlink" title="欧几里得算法(The Euclidean Algorithm)"></a>欧几里得算法(The Euclidean Algorithm)</h2><p>使用多次除法得到一个递减的序列来求出gcd$(a,b)$<br>$b=aq<em>1+r$<br>$a=r_1q_2+r_2$<br>$r_1=r_2q_3+r_3$<br>$\vdots$<br>$r</em>{n-2}=r<em>{n-1}a_n+r_n$<br>$r</em>{n-1}=r<em>nq</em>{n+1}$<br>将这一系列等式反过来书写可以得到$d$的表示(略)</p><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p><strong>引理2.13(Euclid)</strong>: $a,b$为整数，$p$为质数。如果$p\mid ab$,则$p\mid a$或$p\mid b$</p><p><strong>定理2.14(Euclid)</strong>: 质数的个数是无限的</p><p><strong>定理2.15(算术基本定理Fundamental Theorem of Arithmetic)</strong>: $n$为大于1的整数，则$n=p_1p_2\cdots p_k$，其中$p_1,…,p_k$为质数。这个分解是唯一的，即若$n=q_1q_2\cdots q_l$，则$k=l$且$q_i$只是$p_i$的排列</p><p>以下内容出自CZ</p><h2 id="mathbb-Z-n-上的乘法逆元"><a href="#mathbb-Z-n-上的乘法逆元" class="headerlink" title="$\mathbb{Z}_n$上的乘法逆元"></a>$\mathbb{Z}_n$上的乘法逆元</h2><p><strong>乘法逆元(multiplicative inverse)</strong>: $a’\cdot_{n}a=1$,则称$a’$是$a$在$\mathbb{Z}_n<br>$中的乘法逆元</p><p><strong>引理2.5</strong>: 设$a$在$\mathbb{Z}<em>n$中存在乘法逆元$a’$. 则对于任意$b\in\mathbb{Z}_n$,等式$a\cdot</em>{n}x=b$有唯一解$x=a’\cdot_{n}b$.</p><p><strong>推论2.6</strong>: 若存在$b\in\mathbb{Z}<em>n$使得$a\cdot</em>{n}x=b$的$a$无解，则$a$在$\mathbb{Z}_n$上不存在乘法逆元</p><p><strong>定理2.7</strong>: 若$\mathbb{Z}_n$中的元素有一个乘法逆元，则它的乘法逆元是唯一的。<br>因此可以用$a^{-1}$来表示乘法逆元。</p><p><strong>引理2.8</strong>: $a\cdot_{n}x=1$有解当且仅当存在整数$x,y$使得$ax+ny=1$</p><p><strong>定理2.9</strong>: $a$在$\mathbb{Z}_n$中有乘法逆元当且仅当存在整数$x,y$使得$ax+ny=1$</p><p><strong>推论2.10</strong>: 若$a\in\mathbb{Z}_n$q且$x,y$是满足$ax+ny=1$的整数，则$a$在$\mathbb{Z}_n$中的乘法逆元是$x\bmod n$</p><p><strong>引理2.11</strong>: 若存在整数$x,y$使得$ax+ny=1$，则$a,n$互质</p><p><strong>定理2.12(欧几里得除法定理)</strong>: 同最TJ的定理2.9</p><p><strong>引理2.13</strong>: 若$j,k,q,r$是满足$k=jq+r$的正整数，则gcd($j,k$)=gcd($r,j$)</p><h2 id="欧几里得扩展算法"><a href="#欧几里得扩展算法" class="headerlink" title="欧几里得扩展算法"></a>欧几里得扩展算法</h2><p>其实就是计算$x$和$y$的算法</p><p><strong>定理2.15</strong>: 两个正整数$j$和$k$互质当且仅当存在整数$x,y$使得$jx+ky=1$</p><p><strong>推论2.16</strong>: 对于任意正整数$n$A，$\mathbb{Z}_n$的元素$a$有乘法逆元当且仅当$gcd(a,n)=1$</p><p><strong>推论2.17</strong>: 对任意质数$p$,$\mathbb{Z}_p$的任意非零元素存在乘法逆元。</p><h2 id="计算乘法逆元"><a href="#计算乘法逆元" class="headerlink" title="计算乘法逆元"></a>计算乘法逆元</h2><p>跑欧几里得算法求出满足$ax+ny=1$的$x$,就是$a$在$\mathbb{Z}_n$中的乘法逆元</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数学归纳法&quot;&gt;&lt;a href=&quot;#数学归纳法&quot; class=&quot;headerlink&quot; title=&quot;数学归纳法&quot;&gt;&lt;/a&gt;数学归纳法&lt;/h1&gt;&lt;p&gt;你都懂的&lt;/p&gt;
&lt;h1 id=&quot;辗转相除法-Division-Algorithm&quot;&gt;&lt;a href=&quot;#辗转相除法
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-字符串匹配</title>
    <link href="https://mengzelev.github.io/2019/03/23/clrs-32String-Mathcing/"/>
    <id>https://mengzelev.github.io/2019/03/23/clrs-32String-Mathcing/</id>
    <published>2019-03-23T06:42:50.000Z</published>
    <updated>2019-03-23T15:40:43.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="问题的形式化定义"><a href="#问题的形式化定义" class="headerlink" title="问题的形式化定义"></a>问题的形式化定义</h2><ul><li>文本是一个长度为$n$的数组$T[1,…n]$</li><li>模式是一个长度为$m$的数组$P<a href="m\le n">1,…m</a>$</li><li>$P$和$T$的元素都是来自一个有限字母集$\Sigma$的字符</li><li>若$0\le s\le n-m$,且$T[s+1,…s+m]=P[1,…m]$,则称模式$P$在文本$T$中<strong>出现</strong>，且<strong>偏移</strong>为$s$(模式$P$在文本$T$中出现的位置是$s+1$开始的)</li><li>如果$P$在$T$中以偏移$s$出现，那么称$s$是<strong>有效偏移</strong>，否则是无效偏移</li><li>字符串匹配问题：找到<strong>所有</strong>的有效偏移</li><li>算法总运行时间=预处理时间+匹配时间</li></ul><p><img src="/2019/03/23/clrs-32String-Mathcing/time.png"></p><h2 id="符号和术语"><a href="#符号和术语" class="headerlink" title="符号和术语"></a>符号和术语</h2><ul><li>$\Sigma^*$: 包含所有有限长度的字符串的集合</li><li>$\varepsilon$: 长度为0的空字符串，$\varepsilon\in\Sigma^*$</li><li>$|x|$: 字符串$x$的长度</li><li>$xy$: 两个字符串$x$和$y$的<strong>连结(concatenation)</strong></li><li>若对某个字符串$y\in \Sigma^<em>$有$x=wy$，则称字符串$w$是字符串$x$的<em>*前缀</em></em>，记作$w\sqsubset x$</li><li>若对某个字符串$y$有$x=yw$，则称字符串$w$是字符串$x$的后缀，记作$w\sqsupset x$</li><li>空字符串$\varepsilon$同时是任何一个字符串的前缀和后缀</li><li>$x\sqsupset y$当且仅当$xa\sqsupset ya$</li><li>$\sqsubset$和$sqsupset$都是<strong>传递关系</strong></li></ul><p><strong>引理32.1(后缀重叠引理)</strong>: 假设$x,y$满足$x\sqsupset z$和$y\sqsupset z$的字符串。如果$|x|\le |y|$, 那么$x\sqsupset y$; 如果$|x|\ge |y|$, 那么$y\sqsupset x$; 如果$|x|=|y|$, 那么$x=y$</p><ul><li>把模式$P[1..m]$的由$k$个字符组成的前缀$P[1..k]$记作$P_k$，因此$P_0=\varepsilon$,$P_m=P=P[1..m]$</li><li>把文本$T$中由$k$个字符组成的前缀记为$T_k$</li><li>采用这种记号，字符串匹配问题能被表述为：找到所有偏移$s(0\le s\le n-m)$, 使得$P\sqsupset T_{s+m}$</li><li>假设：检测$x==y$需要时间$\Theta(t+1)$，其中$t$是满足$z\sqsubset x$和$z\sqsubset y$的最长字符串$z$的长度</li></ul><h1 id="朴素字符串匹配算法"><a href="#朴素字符串匹配算法" class="headerlink" title="朴素字符串匹配算法"></a>朴素字符串匹配算法</h1><p>通过循环找到所有有效偏移<br>对$n-m+1$个可能的$s$进行检测</p><p><img src="/2019/03/23/clrs-32String-Mathcing/naive.png"></p><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>最坏情况下：$O((n-m+1)m)$<br>无预处理时间</p><h1 id="Rabin-Karp算法"><a href="#Rabin-Karp算法" class="headerlink" title="Rabin-Karp算法"></a>Rabin-Karp算法</h1><p>为了便于说明，假设$\Sigma=\{0,1,2,…,9\}$<br>在通常情况下可以假定每个字符都是以$d$为基数表示的数字<br>$p$: 模式$P$表示的十进制值<br>$t_s$: 文本$T[s+1..s+m]$对应的十进制值<br><strong>把字符串匹配转化为数值匹配</strong></p><p>计算$t<em>1,…t_s$时，可以根据$t_s$计算$t</em>{s+1}$</p><script type="math/tex; mode=display">t_{s+1}=10(t_s-10^{m-1}T[s+1])+T[s+m+1]</script><p>(去掉高位数字，左移，加上低位数字)</p><p>如果$p$和$t_s$的值太大，可以选取一个合适的模$q$来计算$p$和$t_s$的模<br>在一般情况下，选取一个$q$，使得$dq$在一个计算机字长内，调整递归式</p><script type="math/tex; mode=display">t_{s+1}=(d(t_s-T[s+1]h)+T[s+m+1])\mod~q</script><p>其中$h\equiv d^{m-1}(mod q)$是一个具有$m$数位的文本窗口的高位数位上的数字”1”的值</p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/RK.png"></p><ul><li>计算所有长度为$m$的文本窗口对$q$取模的值</li><li>找出$t_s\equiv q(\mod~q)$的$s$值(<strong>伪命中点</strong>)</li><li>进行字符串匹配检验</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/RKM.png"></p><ul><li>去除$t$的下标不会影响程序运行</li><li>循环不变量：$t_s=T[s+1…s+m]\mod~q$</li></ul><h2 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h2><p>预处理：$\Theta(m)$<br>最坏情况运行时间: $\Theta((n-m+1)m)$(e.g.$P=a^m$且$T=a^n$时需要对所有可能进行字符串匹配验证，相当于退化为朴素算法)</p><p>若有效便宜只有常数$c$个，算法的期望匹配时间为$O((n-m+1)+cm)=O(n+m)$</p><p>若假设$q$是从适当大的整数中随机得出的，则伪命中的次数为$O(n/q)$(因为任意$t_s$模A$q$与$p$同余的概率为$1/q$)。 第10行中的测试会在$O(n)$个位置上失败，每次命中的时间代价是$O(m)$。因此Rabin-Karp算法的期望运行时间是<script type="math/tex">O(n)+O(m(v+n/q))</script>其中$v$为有效偏移量</p><p>若选取的素数$q$大于模式的长度，则可以估计Rabin-Karp算法的匹配时间为$O(n+m)=O(n)$</p><h1 id="利用有限自动机进行字符串匹配"><a href="#利用有限自动机进行字符串匹配" class="headerlink" title="利用有限自动机进行字符串匹配"></a>利用有限自动机进行字符串匹配</h1><h2 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h2><p>一个有限自动机$M$是一个五元组$(Q,q_0,A,\Sigma,\delta)$,其中：</p><ul><li>$Q$是<strong>状态</strong>的有限集合</li><li>$q_0\in Q$是<strong>初始状态</strong></li><li>$A\subseteq Q$是一个特殊的<strong>接受状态</strong>集合</li><li>$\Sigma$是<strong>有限输入字母表</strong></li><li>$\delta$是一个从$Q\times\Sigma$到$Q$的函数，称为$M$的<strong>转移函数</strong> </li></ul><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><ul><li>开始状态为$q_0$，每次读入输入字符串的一个字符</li><li>如果在状态$q$时读入字符$a$，就从状态$q$变为状态$\delta(q,a)$(进行了一次转移)</li><li>当前状态$q\in A$时，就说$M$<strong>接受</strong>了迄今为止所读入的字符串，没有被接受的输入称为<strong>被拒绝</strong>的输入</li></ul><h3 id="终态函数"><a href="#终态函数" class="headerlink" title="终态函数"></a>终态函数</h3><p>终态函数$\phi:\Sigma^*\to Q$<br>$\phi(w)$: $M$在扫描字符串$w$后终止时的状态<br>当且仅当$\phi(w)\in A$时，$M$接受字符串$w$</p><p>用转移函数递归定义$\phi$:</p><script type="math/tex; mode=display">\phi(\varepsilon)=q_0,</script><script type="math/tex; mode=display">\phi(wa)=\delta(\phi(w),a), ~~w\in\Sigma^*,a\in\Sigma</script><h2 id="字符匹配自动机"><a href="#字符匹配自动机" class="headerlink" title="字符匹配自动机"></a>字符匹配自动机</h2><p>后缀函数$\sigma:\Sigma^*\to\{0,1,…,m\}$，满足$\sigma(x)$是同时是$x$的后缀和$P$的前缀的字符串的长度</p><script type="math/tex; mode=display">\sigma(x)=\max\{k:P_k\sqsupset x\}</script><p>对于任意的状态$q$和字符串$a$，转移函数$\delta$定义如下：</p><script type="math/tex; mode=display">\delta(q,a)=\sigma(P_qa)</script><p>记录已得到的与模式$P$匹配的文本字符串$T$的最长前缀</p><p><img src="/2019/03/23/clrs-32String-Mathcing/auto.png"></p><p>匹配时间为$\Theta(n)$</p><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p><strong>引理32.2(后缀函数不等式)</strong>: 对任意字符串$x$和字符$a$，$\sigma(xa)\le\sigma(x)+1$</p><p><strong>引理32.3(后缀函数递归引理)</strong>: 对任意$x$和字符$a$，若$q=\sigma(x)$,则$\sigma(xa)=\sigma(P_qa)$</p><p><strong>定理32.4</strong>: 如果$\phi$是字符串匹配自动机关于给定模式$P$的终态函数，$T[1..n]$是自动机的输入文本，则对$i=0,1,..,n,\phi(T_i)=\sigma(T_i)$(终态函数的值=后缀函数的值)</p><h2 id="计算转移函数"><a href="#计算转移函数" class="headerlink" title="计算转移函数"></a>计算转移函数</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/compute.png"></p><p>计算转移函数的运行时间为$O(m^3|\Sigma|)$，可以改进为$O(m\Sigma)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h1&gt;&lt;h2 id=&quot;问题的形式化定义&quot;&gt;&lt;a href=&quot;#问题的形式化定义&quot; class=&quot;headerlink&quot; title=&quot;问
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-群同构基本定理与正规子群</title>
    <link href="https://mengzelev.github.io/2019/03/14/ps-4-4-isomorphism/"/>
    <id>https://mengzelev.github.io/2019/03/14/ps-4-4-isomorphism/</id>
    <published>2019-03-14T08:20:40.000Z</published>
    <updated>2019-03-23T07:29:34.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同构-Isomorphisms"><a href="#同构-Isomorphisms" class="headerlink" title="同构(Isomorphisms)"></a>同构(Isomorphisms)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对两个群$(G,\cdot)$和$(H,\circ)$，若存在一个保群运算的双射$\phi:G\to H$，即对于任意$a,b\in G$</p><script type="math/tex; mode=display">\phi(a\cdot b)=\phi(a)\circ\phi(b)</script><p>则称$G$和$H$<strong>同构(isomorphic)</strong>，记作$G\cong H$. $\phi$称为<strong>同构函数(isomorphism)</strong>。</p><h2 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h2><p><strong>定理9.6</strong>: Let $\phi: G\to H$ be an isomorphism of two groups. Then the following statements are true.</p><ol><li>$\phi^{-1}:H\to G$ is an isomorphism (废话)</li><li>$|G|=|H|$ (废话)</li><li>If $G$ is abelian, then $H$ is abelian.</li><li>If $G$ is cyclic, then $H$ is cyclic.</li><li>If $G$ has a subgroup of order $n$, then $H$ has a subgroup of order $n$.</li></ol><p><strong>定理9.7</strong>: All cyclic groups of infinite order are isomorphic to $\mathbb{Z}$. 无穷阶循环群与$\mathbb{Z}$同构。</p><p><strong>定理9.8</strong>: If $G$ is a cyclic group of order $n$, then $G$ is isomorphic to $\mathbb{Z}_n$.</p><p><strong>推论9.9</strong>: If $G$ is a group of order $p$, where $p$ is a prime number, then $G$ is isomorphic to $\mathbb{Z}_p$. (不需要是循环群)</p><p><strong>定理9.10</strong>: The isomorphism of groups determines an equivalence relation on the class of all groups. 群的同构关系将群划分成等价类。</p><h2 id="Cayley’s-Theorem"><a href="#Cayley’s-Theorem" class="headerlink" title="Cayley’s Theorem"></a>Cayley’s Theorem</h2><p><strong>定理9.12(Cayley定理)</strong>: Every group is isomorphic to a group of permutations. 任意群都与一个置换群同构。</p><p>The isomorphism $g\mapsto \lambda_g$ is known as the <strong>left regular representation</strong>of G.</p><h1 id="直积-Direct-Products"><a href="#直积-Direct-Products" class="headerlink" title="直积(Direct Products)"></a>直积(Direct Products)</h1><p>qlz管它叫直和</p><h2 id="外直积"><a href="#外直积" class="headerlink" title="外直积"></a>外直积</h2><p>定义运算<script type="math/tex">G\times H: (g_1,h_1)(g_2,h_2)=(g1\cdot g_2, h_1\circ h_2)</script></p><p><strong>命题9.13</strong>: Let $G$ and $H$ be groups. The set $G\times H$ is a group under the operation $(g_1,h_1)(g_2,h_2)=(g1\cdot g_2, h_1\circ h_2)$ where $g_1, g_2\in G$ and $h_1, h_2\in H$.</p><p>群$G\times H$称为$G$和$H$的<strong>外直积(external direct product)</strong></p><p><strong>定理9.17</strong>: 设$(g,h)\in G\times H$. 若$g$和$h$分别为有限阶$r$和$s$,则$(g,h)$在$G\times H$中的阶数是$r$和$s$的<strong>最小公倍数(least common multiple)</strong></p><p><strong>推论9.18</strong>: 设$(g_1,…g_n)\in \prod G_i$. 若$g_i$在$G_i$中为有限阶$r_i$，则$(G-1,..g_n)$在$\prod G_i$中的阶数为$lcm(r_1,…r_n)$.</p><p><strong>定理9.21</strong>: 群$\mathbb{Z}<em>m\times\mathbb{Z}_n$与$Z</em>{mn}$同构当且仅当$m,n$互质($gcd(m,n)=1$). (From定理9.17)</p><p><strong>推论9.22</strong>: $n<em>1,…n_k$为正整数，则$\prod\limits</em>{i=1}^{k}\mathbb{Z}_{n_1…n_k}$当且仅当$gcd(i,j)=1$对任意$i\neq j$恒成立。</p><h2 id="内直积-Internal-Direct-Product"><a href="#内直积-Internal-Direct-Product" class="headerlink" title="内直积(Internal Direct Product)"></a>内直积(Internal Direct Product)</h2><p>外直积把小群组建成大群，内直积把大群打碎成小群</p><p>群$G$拥有子群$H,K$满足以下条件:</p><ul><li>$G=HK=\{hk:h\in H, k\in K\}$</li><li>$H\cap K=\{e\}$</li><li>$hk=kh$ for all $k\in K$ and $h\in H$</li></ul><p>称$G$是$H$和$K$的<strong>内直积</strong></p><p>不是所有的群都可以写成其真子群的内积的形式</p><p><strong>定理9.27</strong>: 设$G$是其子群$H$和$K$的内直积，则$G$与$H\times K$同构。(外直积群与内直积群同构)</p><p>推广到多维：</p><ul><li>$G=H_1H_2…H_n=\{h_1h_2…h_n:h_i\in H_i\}$</li><li>$H<em>i\cap\left\langle \cup</em>{j\neq i}H_j\right\rangle=\{e\}$</li><li>$H_ih_j=h_jh_i$ for all $h_i\in H_i$ and $h_j\in H_j$</li></ul><p><strong>定理9.29</strong>: 若$G$是其子集$H_i(i=1,2,…n)$的内直积，则$G$与$\prod_i H_i$同构</p><h1 id="正规子群-Normal-Subgroups"><a href="#正规子群-Normal-Subgroups" class="headerlink" title="正规子群(Normal Subgroups)"></a>正规子群(Normal Subgroups)</h1><p>若对任意$g\in G$有$gH=Hg$, 则称$H$是$G$的正规子群。(左陪集与右陪集相同)<br>交换群的所有子群都是正规的。</p><p><strong>定理10.3</strong>: 设$N$为$G$的子群，则如下命题等价：</p><ol><li>$N$是$G$的正规子群</li><li>$\forall g\in G, gNg^{-1}\subseteq N$.</li><li>$\forall g\in G, gNg^{-1}=N$.</li></ol><h1 id="商群-Factor-Group"><a href="#商群-Factor-Group" class="headerlink" title="商群(Factor Group)"></a>商群(Factor Group)</h1><p><strong>定理10.4</strong>: $N$为$G$的正规子群，$N$在$G$中的陪集构成了一个群$G/N$, 阶为$[G:N]$(复习: $[G:N]=|G|/|N|$). 该群的运算为$(aN)(bN)=abN$.<br>这个群被称为<strong>商群(fatcor or quotient group)</strong>.<br>$eN=N$是单位元，$g^{-1}N$是$gN$的逆元。<br>商群是<strong>集合</strong>组成的群。</p><p>对于反组$D_n$, 旋转群$R_n$是$D_n$的一个正规子群。</p><h1 id="交替群的简单性"><a href="#交替群的简单性" class="headerlink" title="交替群的简单性"></a>交替群的简单性</h1><p><strong>单群(simple group)</strong>: 没有非平凡正规真子群的群 e.g.$\mathbb{Z}_p$($p$为质数)</p><p><strong>引理10.8</strong>: 替换群$A_n(n\ge 3)$是由3-cycles生成的。</p><p><strong>引理10.9</strong>: $N$是$A_n(n\ge 3)$的正规子群.若$N$包含了一个3-cycle，则$N=A_n$.</p><p><strong>引理10.10</strong>: 对$n\ge 5$, $A_n$的每一个非平凡正规子群$N$都包含一个3-cycle.</p><p><strong>引理10.11</strong>: $n\ge 5$的替换群$A_n$是单群。</p><h1 id="同态-homomorphism"><a href="#同态-homomorphism" class="headerlink" title="同态(homomorphism)"></a>同态(homomorphism)</h1><p>两个群$(G,\cdot)$和$(H,\circ)$间的同态函数是一个映射$\phi:G\to H$，满足$\phi(g_1\cdot g_2)=\phi(g_1)\circ\phi(g_2)$,其中$g_1,g_2\in G$.<br>$\phi$在$H$中的值域被称为<strong>同态像(homomorphism image)</strong>.<br>若$\phi$是双射，则$G$和$H$同构。</p><p><strong>命题11.4</strong>: 设$\phi:G_1\to G_2$是群间的同态函数，则</p><ol><li>若$e$是$G_1$的单位元，则$e$是$G_2$的单位元</li><li>对于任意$g\in G_1$, $\phi(g^{-1})=[\phi(g)]^{-1}$</li><li>若$H_1$是$G_1$的子群，则$\phi(H_2)$是$G_2$的子群</li><li>若$H_2$是$G_2$的子群，则$\phi^{-1}(H_2)=\{g\in G_1: \phi(g)\in H_2\}$是$G_1$的子群。此外，若$H_2$是$G_2$的正规子群，则$\phi^{-1}(H_2)$是$G_1$的正规子群</li></ol><p>由命题11.4知，$\phi^{-1}(\{e\})$是$G$的子群，这个子群被称为$\phi$的<strong>核(kernel)</strong>,记为$ker\phi$. 该子群是正规的。</p><p><strong>定理11.5</strong>： 设$\phi:G\to H$是群的同态函数，则$\phi$的核是$G$的一个正规子群<br>潜台词：对于每一个同态函数都能找到一个正规子群$ker\phi$</p><p>核函数可以用来推测两个群间是否存在同态函数。(e.g. Example11.9 $\mathbb{Z}<em>7$与$\mathbb{Z}</em>{12}$)</p><h1 id="同态定理"><a href="#同态定理" class="headerlink" title="同态定理"></a>同态定理</h1><p>设$H$是$G$的正规子群。定义<strong>自然同态函数</strong>或<strong>规范同态函数</strong>(<strong>natural</strong> or <strong>canonical homomorphism</strong>) <script type="math/tex">\phi:G\to G/H</script>为<script type="math/tex">\phi(g)=gH</script><br>该同态函数的核为$H$</p><p><strong>定理11.10(第一同态定理)</strong>:  若$\varphi:G\to H$是核为$K$的同态函数， 则$K$是$G$的正规子群。设$\phi:G\to G/K$是规范同态函数。则存在唯一的同构函数$\eta:G/K\to\varphi(G)$使得$\varphi=\eta\phi$<br>规范同态函数产生的商群与原同态函数的像同构</p><p><strong>定理11.12(第二同态定理)</strong>: 设$H$是$G$的子群(不需要正规)，$N$是$G$的正规子群，则$HN$是$G$的子群，$H\cap N$是$H$的正规子群，且</p><script type="math/tex; mode=display">H/H\cap N\cong HN/N</script><p><strong>定理11.13(一致性定理)</strong>: 设$N$是$G$的正规子群，则$H\mapsto H/N$是<strong>包含$N$的子群$H$</strong>的集合与<strong>$G/N$的子群</strong>的集合间的一对一关系。此外，包含$N$的$G$的正规子群与$G/N$的正规子群相对应。</p><p><img src="/2019/03/14/ps-4-4-isomorphism/corr.png" alt="wiki上的解释"></p><p><strong>定理11.14(第三同构定理)</strong>: 设$N$和$H$是$G$的正规子群满足$N\subseteq H$,则<script type="math/tex">G/H\cong\frac{G/N}{H/N}</script>. (可以当成分数来直观理解)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;同构-Isomorphisms&quot;&gt;&lt;a href=&quot;#同构-Isomorphisms&quot; class=&quot;headerlink&quot; title=&quot;同构(Isomorphisms)&quot;&gt;&lt;/a&gt;同构(Isomorphisms)&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-置换群与拉格朗日定理</title>
    <link href="https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/"/>
    <id>https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/</id>
    <published>2019-03-09T09:15:13.000Z</published>
    <updated>2019-03-10T07:40:08.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="置换群-Permutation-Group"><a href="#置换群-Permutation-Group" class="headerlink" title="置换群(Permutation Group)"></a>置换群(Permutation Group)</h1><p><strong>定理5.1</strong>:The symmetric group on $n$ letters, $S_n$, is a group with $n!$ elements, where<br>the binary operation is the composition of maps.</p><p>置换群(permutation group):所有排列的集合$S_n$的一个子集</p><h2 id="Cycle-Notation"><a href="#Cycle-Notation" class="headerlink" title="Cycle Notation"></a>Cycle Notation</h2><p>A permutation $\sigma\in S_X$ is a <strong>cycle of length</strong> $k$ if there exite elements $a_1,a_2,…a_k\in X$ such that</p><script type="math/tex; mode=display">\sigma(a_1) = a_2</script><script type="math/tex; mode=display">\sigma(a_2) = a_3</script><script type="math/tex; mode=display">...</script><script type="math/tex; mode=display">\sigma(a_k) = a_1</script><p>and $\sigma(x)=x$ for all other elements $x\in X$. </p><p>We write $(a_1,a_2,…a_k)$ to denote the cycle $\sigma$.</p><p>Cycles are the building blocks of all permutations.循环是所有排列的基石。</p><p>Two cycles in $S_X$, $\sigma=(a_1,a-2,…a_k)$, $\tau=(b_1,b_2,…b_l)$, are <strong>disjoint</strong> if $a_i\neq b_j$ for all $i$ and $j$</p><p><strong>命题5.8</strong>: Let $\sigma$ and $\tau$ be 2 disjoint cycles in $S_X$. Then $\sigma\tau=\tau\sigma$.</p><p><strong>定理5.9</strong>: $S_n$中的所有排列都可以被写成不相交循环的乘积的形式。</p><p><strong>Transpositions</strong>: a cycle of length 2 (任意两个数交换位置)</p><p><strong>命题5.12</strong>: 任意至少含有两个元素的有限集的排列都可以写成transposition乘积的形式<br>e.g. (253)=(23)(25)</p><p><strong>引理5.14</strong>: identity(恒等变换)只能写成<strong>偶数个</strong>transposition的乘积的形式</p><p><strong>定理5.15</strong>: 如果一个排列能被写成偶数个置换乘积的形式，那么另一个与之等价的排列也一定拥有偶数项置换乘积。奇数同理。<br>据此定理可以将排列分为奇偶两类</p><h3 id="交替组-The-Alternating-Groups"><a href="#交替组-The-Alternating-Groups" class="headerlink" title="交替组(The Alternating Groups)"></a>交替组(The Alternating Groups)</h3><p>交替组$A_n$是所有偶排列的集合</p><p><strong>定理5.16</strong>: 集合$A_n$是$S_n$的子群</p><p><strong>命题5.17</strong>: $S_n$中奇排列和欧排列的数目相等，都为$n!/2$</p><h1 id="反组-Dihedral-Groups"><a href="#反组-Dihedral-Groups" class="headerlink" title="反组(Dihedral Groups)"></a>反组(Dihedral Groups)</h1><p>the <strong>nth dihedral group</strong>($D_n$): the group of rigid motions of a regular n-gon(正多边形的刚性运动=转动+反射)</p><p><strong>定理5.20</strong>: $D_n$ is a subgroup of $S_n$ of order $2n$</p><p><strong>定理5.23</strong>: The group $D_n$, $n\ge 3$, consists of all products of the two elements $r$ and $s$, satisfying the relations</p><script type="math/tex; mode=display">r^n=1</script><script type="math/tex; mode=display">s^2=1</script><script type="math/tex; mode=display">srs=r^{-1}</script><p>($r,s$分别为转动和反射)</p><script type="math/tex; mode=display">D_n=\{1,r,r^2,..,r^{n-1},s,sr,sr^2,...,sr^{n-1}\}</script><h2 id="立方体的运动"><a href="#立方体的运动" class="headerlink" title="立方体的运动"></a>立方体的运动</h2><p><strong>命题5.27</strong>: The group of rigid motions of a cube contains 24 elements.</p><p><strong>命题5.28</strong>: The group of rigid motions of a cube is $S_4$.(看体对角线)</p><h1 id="陪集-Coset"><a href="#陪集-Coset" class="headerlink" title="陪集(Coset)"></a>陪集(Coset)</h1><p>$G$为群，$H$为$G$的子群，定义<br><strong>左陪集(left coset)</strong>: $gH=\{gh:~h\in H\}$<br><strong>右陪集(left coset)</strong>: $Hg=\{hg:~h\in H\}$ <s>(这真的不是汞吗)</s><br>其中$g\in G$称为<strong>代表元(representative)</strong></p><p>在交换群中，左陪集与右陪集是相同的。</p><p><strong>引理6.3</strong>: $g_1,g_2\in G$，以下条件等价:<br>$1. g_1H=g_2H$;<br>$2. Hg_1^{-1}=Hg_2^{-1}$;<br>$3. g_1H\subset g_2H$;<br>$4. g_2\in g_1H$;<br>$5. g_1^{-1}g_2\in H$;</p><p><strong>定理6.4</strong>: $H$为$G$的子群。$H$的左陪集分割(partition)了$G$,即$G$是$H$的左陪集的disjoint union. (右陪集同理)</p><p><strong>index</strong> of $H$: the number of left cosets of $H$ in $G$. 表示为$[G:H]$</p><p><strong>定理6.8</strong>: $H$在$G$中的左陪集与右陪集的个数相等。</p><h1 id="拉格朗日定理"><a href="#拉格朗日定理" class="headerlink" title="拉格朗日定理"></a>拉格朗日定理</h1><p><strong>命题6.9</strong>: 定义映射$H\to gH$ by $\phi(h)=gh$. 该映射是双射，$H$中元素的个数等于$gH$中元素的个数。</p><p><strong>定理6.10(拉格朗日定理)</strong>: Let $G$ be a finite group and let $H$ be a subgroup of $G$. Then $|G|/|H|=[G:H]$ is the number of distinct left cosets of $H$ in $G$. In particular, the number of elements in $H$ must divide the number of elements in $G$.</p><script type="math/tex; mode=display">|G|=[G:H]|H|</script><p><strong>推论6.11</strong>: Suppose that $G$ is a finite group and $g\in G$. Then the order of $g$ must divide the number of elements in $G$.</p><p><strong>推论6.12</strong>: Let $|G|=p$ with $p$ a prime number. Then $G$ is cyclic and any $g\in G$ such that $g\neq e$ is a generator. 含有质数个元素的群为循环群且任何非单位元的元素都是生成元。</p><p><strong>推论6.13</strong>: Let $H$ and $K$ be subgroups of a finite group $G$ such that $G\supset H\supset K$. Then $[G:K]=[G:H][H:K]$.</p><p><strong>拉格朗日定理的逆命题是不成立的</strong></p><p><strong>命题6.15</strong>: The group $A_4$ has no subgroup of order 6.</p><p><strong>定理6.16</strong>: Two cycles $\tau$ and $\mu$ in $S_n$ have the same length if and only if there exists a $\sigma\in S_n$ such that $\mu=\sigma\tau\sigma^{-1}$.</p><h1 id="费马与欧拉定理"><a href="#费马与欧拉定理" class="headerlink" title="费马与欧拉定理"></a>费马与欧拉定理</h1><p>欧拉函数$\phi(n)$表示$n$以内与$n$互质的数的个数<br>对任意质数$p$, $\phi(p)=p-1$</p><p><strong>定理6.17</strong>: Let $U(n)$ be the group of units in $\mathbb{Z}_n$. Then $|U(n)|=\phi(n)$</p><p><s>怎么又是欧拉</s><br><strong>定理6.18(欧拉定理)</strong>: Let $a$ and $n$ be integers such that $n&gt;0$ and $gcd(a,n)=1$. Then $a^{\phi(n)}\equiv 1(\mod~n)$</p><p><strong>定理6.19(费马小定理)</strong>: Let $p$ be ant prime number and suppose that $p\nmid a$($p$ does not divide $a$). Then $a^{p-1}\equiv 1(\mod p)$.<br>Furthermore, for any integer $b$, $b^p\equiv b(\mod p)$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;置换群-Permutation-Group&quot;&gt;&lt;a href=&quot;#置换群-Permutation-Group&quot; class=&quot;headerlink&quot; title=&quot;置换群(Permutation Group)&quot;&gt;&lt;/a&gt;置换群(Permutation Group)
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-群论初步</title>
    <link href="https://mengzelev.github.io/2019/03/02/ps-4-2-group/"/>
    <id>https://mengzelev.github.io/2019/03/02/ps-4-2-group/</id>
    <published>2019-03-02T06:03:29.000Z</published>
    <updated>2019-03-09T09:16:30.471Z</updated>
    
    <content type="html"><![CDATA[<p>由于接下来的书没有中文版了，因此笔记中英文都<u>看心情</u></p><h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><h2 id="整数等价类"><a href="#整数等价类" class="headerlink" title="整数等价类"></a>整数等价类</h2><p><strong>命题3.4</strong>：模运算下的整数等价类具有以下性质：</p><ol><li>加法和乘法交换律</li><li>加法和乘法结合律</li><li>加法(0)与乘法(1)恒等式</li><li>乘法分配律</li><li>任意元素都存在加法逆元</li><li>$a$为非零整数，$gcd(a,n)=1$当且仅当$a$存在乘法逆元，即存在非零整数$b$，使得$ab\equiv 1(mod n)$</li></ol><p>(虽然我觉得这玩意儿记了应该没什么卵用)</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>二元运算(binary operation)或合成律(law of composition):a function $G\times G\to G$ that assigns to each pair $(a,b)\in G\times G$ a unique element $a\circ b$, or $ab$ in $G$, called the composition of $a$ and $b$</li><li>群(group): a set $G$ together with a law of composition $(a,b)\mapsto a\circ b$ that satisfies the following axioms:<ol><li>合成律满足<strong>结合律</strong>(asscociative)</li><li>存在<strong>单位元(identity element)</strong>$e\in G$，满足$e\circ a = a\circ e = a$</li><li>对于每个$a\in G$，都存在<em>逆元</em>$a^{-1}$，使得$a\circ a^{-1}=a^{-1}\circ a=e$</li></ol></li><li>群 = 运算封闭+结合律+单位元+逆元</li><li>阿贝尔群(Abelian)或交换群(commutative):满足$a\circ b=b\circ a$的群，反之为nonabelian或noncommutative</li><li>凯莱表(Cayley table):用加法或乘法描述群的表格</li><li>可逆元素群(group of units): 拥有逆元的元素组成的群</li><li>一般线性群(general linear group)</li><li>四元群(quaternion group)</li><li>群是<strong>有限的(finite)</strong>，或者说有<strong>有限序数(has finite order)</strong>，当它具有有限个元素，否则是无限的(infinite)或有无限序数(infinite order)</li></ul><h2 id="群的基本性质"><a href="#群的基本性质" class="headerlink" title="群的基本性质"></a>群的基本性质</h2><p><strong>命题3.17</strong>: 群中的单位元是唯一的<br><strong>命题3.18</strong>: 逆元是唯一的<br><strong>命题3.19</strong>: $G$是群，$a,b\in G$，则$(ab)^{-1}=b^{-1}a^{-1}$<br><strong>命题3.20</strong>: $(a^{-1})^{-1}=a$<br><strong>命题3.21</strong>: $ax=b$和$xa=b$在$G$中有唯一解<br><strong>命题3.22</strong>(左右消去律right and left cancellation law): $ba=ca$ implies $b=c$ and $ab=ac$ implies $b=c$</p><p>对群中的元素，可以定义乘方</p><p><strong>定理3.23</strong>: 在群中，一般指数的运算律成立</p><h2 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h2><ul><li>子群(subgroup):仿照子空间的定义<ul><li>平凡子群(trivial subgroup):$H=\{e\}$</li><li>真子群(proper subgroup)</li></ul></li><li>子群必须继承群的二元运算</li></ul><h3 id="子群相关的定理"><a href="#子群相关的定理" class="headerlink" title="子群相关的定理"></a>子群相关的定理</h3><p><strong>命题3.30</strong>: $G$的子集$H$是子群当且仅当</p><ol><li>$G$的单位元$e\in H$</li><li>$H$对$G$的运算封闭：If $h_1,h_2\in H$, then $h_1h_2\in H$</li><li>If $h\in H$, then $h^{-1}\in H$</li></ol><p><strong>命题3.31</strong>: $H$是$G$的子群当且仅当$H\neq\emptyset$ and whenever $g,h\in H$ then $gh^{-1}$ is in $H$</p><h1 id="循环子群-Cyclic-Subgroups"><a href="#循环子群-Cyclic-Subgroups" class="headerlink" title="循环子群(Cyclic Subgroups)"></a>循环子群(Cyclic Subgroups)</h1><p><strong>定理4.3</strong>: Let $G$ be a group and $a$ be any element in $G$. Then the set $\left⟨a\right⟩=\{a^k:k\in\mathbb{Z}\}$is a subgroup of $G$. Furthermore, $⟨a⟩$ is the <strong>smallest</strong> subgroup of $G$ that contains $a$.</p><p><strong>循环子群(Cyclic Subgroup)</strong>:$⟨a⟩$<br><strong>循环群(Cyclic group)</strong>: 包含了某个元素$a$，使得$G=⟨a⟩$.此时$⟨a⟩$是$G$的<strong>生成器(generator)</strong>.<br>The <strong>order</strong> of $a$: 最小的整数$n$满足$a^n=e$，表示为$|a|=n$。如果不存在满足要求的$n$，则称$a$是<strong>无穷的(infinite)</strong>，表示为$|a|=\infty$<br>e.g. $\mathbb{Z}$和$\mathbb{Z}_n$都是循环群，1和-1是$\mathbb{Z}$的生成器，1是$\mathbb{Z}_n$的生成器但不一定是唯一的。</p><p><strong>定理4.9</strong>: 所有循环群都是可交换的。(Every cyclic group is abelian).</p><p><strong>定理4.10</strong>: 循环群的子群都是循环子群。(Every subgroup of a cyclic group is cyclic.)</p><p><strong>引理4.11</strong>: The subgroups of $\mathbb{Z}$ are exactly $n\mathbb{Z}$ for $n=0,1,2…$</p><p><strong>命题4.12</strong>: Let $G$ be a cyclic group of order $n$ and suppose that $a$ is a generator<br>for $G$. Then $a^k = e$ if and only if $n$ divides $k$.($n$能整除$k$,$k$能被$n$整除)</p><p><strong>定理4.13</strong>: Let $G$ be a cyclic group of order $n$ and suppose that $a\in G$ is a generator<br>of the group. If $b = a^k$, then the order of $b$ is $n/d$, where $d = gcd(k, n)$.</p><p><strong>引理4.14</strong>: The generators of $\mathbb{Z}_n$ are the integers $r$ such that $1\le r&lt; n$ and<br>$gcd(r,n) = 1$. $\mathbb{Z}_n$的生成器与$n$互质。</p><h2 id="复数乘法群-Multiplicative-Group-of-Complex-Numbers"><a href="#复数乘法群-Multiplicative-Group-of-Complex-Numbers" class="headerlink" title="复数乘法群(Multiplicative Group of Complex Numbers)"></a>复数乘法群(Multiplicative Group of Complex Numbers)</h2><p>一堆复数的基础知识…….</p><p>$r(\cos\theta+i\sin\theta)$ 会被简写为 $r~cis\theta$</p><p><strong>命题4.20</strong>: $z=r~cis\theta$ and $w=s~cis\phi$. Then $zw=rs~cis(\theta+\phi)$</p><h3 id="圆群-The-circle-group"><a href="#圆群-The-circle-group" class="headerlink" title="圆群(The circle group)"></a>圆群(The circle group)</h3><p>定义: <script type="math/tex">\mathbb{T}=\{z\in\mathbb{C}: |z|=1\}</script></p><p><strong>命题4.24</strong>: 圆群是$\mathbb{C}^*$的子群</p><p><strong>定理4.25</strong>: If $z^n=1$, then the nth roots of unity are <script type="math/tex">z=cis(\frac{2k\pi}{n})</script><br>where $k-0,1,…n-1$. Furthermore, the nth roors of unity form a cyclic subgroup of $\mathbb{T}$ of order $n$.</p><p>A generator for the group of the nth roots of unity is called a <strong>primitive nth root of<br>unity</strong>.</p><h2 id="重复平方法-The-Method-of-Repeated-Squares"><a href="#重复平方法-The-Method-of-Repeated-Squares" class="headerlink" title="重复平方法(The Method of Repeated Squares)"></a>重复平方法(The Method of Repeated Squares)</h2><p>其实就是快速幂</p><p>理论基础: If $b\equiv a^x (\mod n)$ and $c\equiv a^y (\mod n)$, then $bc\equiv a^{x+y}(\mod n)$<br>$(a^{2n})^2\equiv a^{2\cdot 2n}\equiv a^{2^{n+1}}(\mod n)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于接下来的书没有中文版了，因此笔记中英文都&lt;u&gt;看心情&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&quot;群&quot;&gt;&lt;a href=&quot;#群&quot; class=&quot;headerlink&quot; title=&quot;群&quot;&gt;&lt;/a&gt;群&lt;/h1&gt;&lt;h2 id=&quot;整数等价类&quot;&gt;&lt;a href=&quot;#整数等价类&quot; class
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
  <entry>
    <title>2019年寒假计划(flags)</title>
    <link href="https://mengzelev.github.io/2019/02/18/2019-winter-flags/"/>
    <id>https://mengzelev.github.io/2019/02/18/2019-winter-flags/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-01-31T10:11:55.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美赛准备"><a href="#美赛准备" class="headerlink" title="美赛准备"></a>美赛准备</h1><ul><li>MATLAB入门《MATLAB数学工具软件实例简明教程》</li><li>《MATLAB在数学建模中的应用》</li><li>研读优秀论文，总结模板</li></ul><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul><li>学习Python</li><li>分析minilab的git log中的CE数据</li></ul><h1 id="HK学术竞赛"><a href="#HK学术竞赛" class="headerlink" title="HK学术竞赛"></a>HK学术竞赛</h1><ul><li>等打完美赛再来研究</li></ul><h1 id="番剧"><a href="#番剧" class="headerlink" title="番剧"></a>番剧</h1><h2 id="追番"><a href="#追番" class="headerlink" title="追番"></a>追番</h2><ul><li>多罗罗</li><li>灵能百分百第二季</li><li>关于我转生成为史莱姆的这档事</li><li>强风吹拂</li><li>不吉波普不笑</li><li>约定的梦幻岛 </li></ul><h2 id="补番"><a href="#补番" class="headerlink" title="补番"></a>补番</h2><ul><li>战栗杀机</li><li>小林家的龙女仆</li></ul><h1 id="吉他"><a href="#吉他" class="headerlink" title="吉他"></a>吉他</h1><ul><li>看B站教学视频</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;美赛准备&quot;&gt;&lt;a href=&quot;#美赛准备&quot; class=&quot;headerlink&quot; title=&quot;美赛准备&quot;&gt;&lt;/a&gt;美赛准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MATLAB入门《MATLAB数学工具软件实例简明教程》&lt;/li&gt;
&lt;li&gt;《MATLAB在数学建模中的应用》&lt;
      
    
    </summary>
    
      <category term="Flags" scheme="https://mengzelev.github.io/categories/Flags/"/>
    
    
      <category term="Flags" scheme="https://mengzelev.github.io/tags/Flags/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-线性规划</title>
    <link href="https://mengzelev.github.io/2019/02/13/clrs-29Linear-Programming/"/>
    <id>https://mengzelev.github.io/2019/02/13/clrs-29Linear-Programming/</id>
    <published>2019-02-13T12:28:03.000Z</published>
    <updated>2019-02-27T06:24:13.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识背景"><a href="#知识背景" class="headerlink" title="知识背景"></a>知识背景</h1><ul><li>一个<strong>线性规划问题</strong>是一个线性函数最小化或最大化的问题，该线性函数服从一组有限个线性约束，分为最小化线性规划和最大化线性规划</li><li><strong>可行解</strong>：所有满足约束条件的自变量的取值</li><li><strong>可行区域</strong>：所有可行解在二维空间中构成的凸区域</li><li><strong>目标函数</strong>：希望最大化的函数</li><li><strong>目标值</strong>：目标函数在一个特定点上的值</li><li><strong>最优解</strong>：所有目标值中最大的一个，其目标值为<strong>最优目标值</strong></li><li><strong>不可行的</strong>：一个线性规划没有可行解</li><li><strong>无界的</strong>：一个线性规划有可行解但没有有限的最优目标值</li></ul><h1 id="标准型和松弛型"><a href="#标准型和松弛型" class="headerlink" title="标准型和松弛型"></a>标准型和松弛型</h1><h2 id="标准型"><a href="#标准型" class="headerlink" title="标准型"></a>标准型</h2><ul><li>所有的约束都是不等式</li><li>标准型=目标函数+约束+非负约束</li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/std.png"></p><ul><li>重写为向量与矩阵的形式，可以用一个元组$(A,b,c)$来表示一个标准型的线性规划</li></ul><p>最大化<script type="math/tex">c^Tx</script><br>满足约束<script type="math/tex">Ax\le b</script></p><script type="math/tex; mode=display">x\ge 0</script><ul><li><strong>线性规划的等价</strong>：对两个最大化线性规划$L$和$L’$，如果对$L$的每个目标值为$z$的可行解$\overline{x}$，都存在一个对应的$L’$的目标值为$z$的可行解的$\overline{x}’$；(反过来同理)，则称$L$和$L’$是等价的。<ul><li>最小化线性规划和目标函数取负后得到的最大化线性规划是等价的</li></ul></li></ul><h3 id="非标准型的标准化"><a href="#非标准型的标准化" class="headerlink" title="非标准型的标准化"></a>非标准型的标准化</h3><ul><li>目标函数是最小化：取负</li><li>某些变量不具有非负约束：假设$x<em>j$无线性约束，则将所有出现的$x_j$替换为$x</em>{j}’-x<em>{j}’’$，并令$x</em>{j}’\ge 0, x_{j}’’\ge 0$</li><li>存在等式约束：$\ge + \le$</li><li>存在大于等于约束：取负</li></ul><h2 id="松弛型"><a href="#松弛型" class="headerlink" title="松弛型"></a>松弛型</h2><ul><li>松弛变量$s=b<em>i-\sum\limits</em>{j=1}^{n}a_{ij}x_i,s\ge 0$</li><li>只有非负约束是不等式，其余都是等式</li><li><p>当从标准型转换到松弛型时，我们将使用$x<em>{n+i}$表示与第$i$个不等式相关的松弛变量$$x</em>{n+i}=b<em>i-\sum\limits</em>{j=1}^{n}a<em>{ij}x_i,x</em>{n+i}\ge 0$$</p><p><img src="/2019/02/13/clrs-29Linear-Programming/slack.png"></p></li><li><p><strong>基本变量</strong>：等式左边的变量</p></li><li><strong>非基本变量</strong>：等式右边的变量</li><li>有时描述时会省略词语“最大化”和“满足约束”以及明显的非负约束要求</li><li>简洁记号<ul><li>$N$:非基本变量下标的集合</li><li>$B$:基本变量下标的集合</li><li>$N\cup B=\{1,2,…,n+m\}$</li><li>用一个元组$(N,B,A,b,c,v)$来表示松弛型</li><li>这里的$a_{ij}$是“出现”在松弛型中的 负数</li><li>$A,b,c$的小标不必是连续整数的集合，依赖于索引集合$B$和$N$</li></ul></li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/slack2.png"></p><h1 id="将问题表达为线性规划"><a href="#将问题表达为线性规划" class="headerlink" title="将问题表达为线性规划"></a>将问题表达为线性规划</h1><h2 id="单对最短路径"><a href="#单对最短路径" class="headerlink" title="单对最短路径"></a>单对最短路径</h2><p>如下的线性规划可以计算从$s$到$t$的最短路径权值<br><img src="/2019/02/13/clrs-29Linear-Programming/sssp.png"></p><p>之所以是<strong>最大化目标函数</strong>，是因为最短路径问题的一个最优解把每一个$\overline{d}_v$设置成所有$\overline{d}_u+w(u,v)$的最小值，使得$\overline{d}_v$是小于等于集合$\{\overline{d}_u+w(u,v)\}$所有值的最大值；而最小化目标函数会使所有$\overline{d}_v=0$，这个解显然没有意义</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>最大流问题表示为一个线性规划<br><img src="/2019/02/13/clrs-29Linear-Programming/maxflow.png"></p><p>这个线性规划可以重写为有$O(V+E)$个约束的表示，这样计算起来会更高效</p><h2 id="最小费用流"><a href="#最小费用流" class="headerlink" title="最小费用流"></a>最小费用流</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>最大流的推广</li><li>每条边除了容量还有费用值$a(u,v)$。如果通过边$(u,v)$传送了$f<em>{uv}$个单位的流，那么产生了一个费用$a(u,v)f</em>{uv}$。</li><li>求从$s$到$t$发送$d$个单位的流(流目标)，使得流上发生的总费用$\sum\limits<em>{(u,v)\in E}a(u,v)f</em>{uv}$最小</li></ul><p>最小费用流有专门设计的多项式时间算法，但算导上没有涉及到</p><h3 id="线性规划建模"><a href="#线性规划建模" class="headerlink" title="线性规划建模"></a>线性规划建模</h3><p><img src="/2019/02/13/clrs-29Linear-Programming/mincost.png"></p><p><s>这不是很直观吗</s></p><h2 id="多商品流"><a href="#多商品流" class="headerlink" title="多商品流"></a>多商品流</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>在最小费用流问题的基础上，有$k$种不同的商品$K_1,K_2,…,K_k$，其中用三元组$K_i=(s_i,t_i,d_i)$来详细说明商品的源点、汇点和需求</li><li>定义商品$i$的流$f<em>i$，汇聚流为各种商品流的总和$f</em>{uv}=\sum\limits<em>{i=1}^{k}f</em>{iuv}$</li><li>不用最小化任何目标函数，只需要确定是否存在这样的一个流</li></ul><h3 id="线性规划建模-1"><a href="#线性规划建模-1" class="headerlink" title="线性规划建模"></a>线性规划建模</h3><p><img src="/2019/02/13/clrs-29Linear-Programming/multi.png"></p><h1 id="单纯性算法"><a href="#单纯性算法" class="headerlink" title="单纯性算法"></a>单纯性算法</h1><ul><li>求解线性规划的经典方法</li><li>在最坏情况下执行时间非多项式</li><li>在实际中次算法通常相当快速</li><li>可以看成不等式上的<strong>高斯消元法</strong></li></ul><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><ul><li>每轮迭代都关联一个“基本解”<ul><li>从松弛型中得到“基本解”</li><li>将每个非基本变量设为0，并从等式约束中计算基本变量的值</li></ul></li><li>每轮迭代把一个松弛型转换成一个等价的松弛型 </li><li>如果一个<strong>非基本变量</strong>从0开始增加时目标值也增加(目标函数中系数为正)，则增加该非基本变量直到某<strong>基本变量</strong>为0</li><li>重写松弛型，<strong>交换</strong>此基本变量和选定的非基本变量，这个操作称为<strong>转动</strong><ul><li>一个转动选取一个非基本变量$x_e$(替入变量)和一个基本变量$x_l$(替出变量)</li></ul></li></ul><p>单纯型算法执行了两个操作</p><ol><li>重写等式使得变量再等式的左边与右边之间移动</li><li>替换一个等式为另一个等式</li></ol><p>这两个操作都建立了等价的问题</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在目标函数中选一个<strong>最大正系数非基本变量</strong>$x_1$，尝试增大$x_1$，使得$z$增大(增大时必须满足约束条件)</li><li>找到最紧的约，解出$x_1$</li><li>将$x_1$代入系统中其他约束和目标函数【转动】</li><li>找到新系统的基本解</li></ol><h2 id="转动"><a href="#转动" class="headerlink" title="转动"></a>转动</h2><ul><li>输入：元组$(N,B,A,b,c,v)$，替出变量$x_l$的下标$l$(从左边调到右边),以及替入变量$x_e$的下标$e$(从右边调到左边)<strong>出入是相对非基本变量集合$N$而言的</strong></li><li>输出：新松弛的元组$(\hat{N},\hat{B},\hat{A},\hat{b},\hat{c},\hat{v})$</li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/pivot.png"></p><h2 id="正式的单纯性算法"><a href="#正式的单纯性算法" class="headerlink" title="正式的单纯性算法"></a>正式的单纯性算法</h2><p>SIMPLEX</p><ul><li>输入：一个标准型的线性规划</li><li>输出：一个$n$维向量，表示该线性规划的一个最优解</li><li>假设INITIALIZE-SIMPLEX过程返回一个初始基本解可行的松弛型或不可解信息</li><li>3~12行：算法主体<ul><li>如果都是目标函数所有系数为负，则while循环终止，否则第4行选择替入变量$x_e$</li><li>5~9行检查每个约束，然后挑出一个最严格限制$x_e$增加幅度的约束相关联的基本变量$x_l$，如果没有约束能够限制替入变量增加的幅度，则在第11行返回<strong>“无界”</strong></li><li>调用PIVOT交换替入变量和替出变量</li><li>13~16行吧所有非基本变量设为0，把基本变量$\overline{x_i}$设为$b_i$</li><li>17行返回这些值</li></ul></li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/simplex.png"></p><h3 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h3><p>while循环每次迭代开始：</p><ul><li>此松弛型等价于调用INITIALIZE-SIMPLEX返回的松弛型</li><li>对每个$i\in B$，有$b_i\ge 0$(保证新系统的基本解可行)</li><li>此松弛型相关的基本解是可行的</li></ul><p>需要保证while循环终止，可以通过第4行和第9行总是选择具有最小下标的变量来打破目标值不变的局面</p><p>假设INITIALIZE-SIMPLEX返回一个基本解可行的松弛型，那么SIMPLEX要么报告一个线性规划是无界的，要么以一个可行解结束，且至多$(^{m+n}_{m})$次循环内终止</p><h1 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h1><p>对偶性：给定一个最大化问题，我们定义一个相关的最小化问题，使得这两个问题具有同样的最优目标值(e.g.最大流最小割)</p><p>给定一个标准型的原式线性规划，我们定义其对偶线性规划为(将最大化改为最小化，交换右边系数与目标函数的系数)<br><img src="/2019/02/13/clrs-29Linear-Programming/duality.png"></p><p>弱对偶性：原式线性规划的任意可行解的值不大于此对偶线性规划的任意可行解的对应值</p><p><strong>引理 29.8</strong>：线性规划对偶性</p><p><img src="/2019/02/13/clrs-29Linear-Programming/29-10.png"></p><p>证明涉及大量数学推导</p><p>对偶问题都可以像最大流最小割一样，用来转移火力，找到一个等价的问题来求解原来的问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;知识背景&quot;&gt;&lt;a href=&quot;#知识背景&quot; class=&quot;headerlink&quot; title=&quot;知识背景&quot;&gt;&lt;/a&gt;知识背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个&lt;strong&gt;线性规划问题&lt;/strong&gt;是一个线性函数最小化或最大化的问题，该线性函数服从一组有限个线
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>SVM的临时抱佛脚for HK</title>
    <link href="https://mengzelev.github.io/2019/02/12/SVM-getstart/"/>
    <id>https://mengzelev.github.io/2019/02/12/SVM-getstart/</id>
    <published>2019-02-12T06:28:39.000Z</published>
    <updated>2019-03-02T02:32:09.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/av9912938/?p=76" target="_blank" rel="noopener">B站 机器学习（Machine Learning）- 吴恩达（Andrew Ng）</a></p><h1 id="关于调参"><a href="#关于调参" class="headerlink" title="关于调参"></a>关于调参</h1><p>使用SVM需要指定的参数</p><ul><li>参数$C$<ul><li>$C$较大：小偏差，大方差</li><li>$C$较小：大偏差，小方差</li></ul></li><li>核函数(kernel)的选择<ul><li>线性核函数(Linear Kernel/No Kernel)</li><li>高斯核函数(Gaussian Kernel)</li><li>以上是两个最常用的核函数</li><li>多项式核函数</li><li>字符串核函数</li><li>卡方核函数</li><li>….</li></ul></li></ul><p>$n=$number of features, $m=$number of training examples</p><ul><li>If $n$ is large(relative to $m$),e.g.$n\ge m$, use logistic regression or SVM without a kernel</li><li>If $n$ is small, $m$ is intermediate, use SVM with Gaussian kernel</li><li>If $n$ is is small, $m$ is large, create/add more features, then use logistic regression or SVM without a kernel</li></ul><h2 id="线性核函数"><a href="#线性核函数" class="headerlink" title="线性核函数"></a>线性核函数</h2><p>特征数较多，样本数较少时选择</p><h2 id="高斯核函数"><a href="#高斯核函数" class="headerlink" title="高斯核函数"></a>高斯核函数</h2><script type="math/tex; mode=display">f_i=exp(-\frac{\Vert{x-l^{(i)}}^2}{2\sigma^2}),\text{where} l^{(i)}=x^{(i)}</script><p>选择高斯核的情况：特征数较少，样本较多</p><p>$\sigma$的选取：</p><ul><li>大$\sigma$: high bias, low variance</li><li>小$\sigma$: low bias, high variance</li></ul><p>Note:在使用高斯核之前记得<strong>特征归一化</strong>(feature scaling)</p><h2 id="多项式核函数"><a href="#多项式核函数" class="headerlink" title="多项式核函数"></a>多项式核函数</h2><script type="math/tex; mode=display">(x^Tl + C)^d</script><ul><li>当$x$和$l$都是严格的非负数时才会使用</li><li>用得不多</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av9912938/?p=76&quot; targe
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Machine Learning" scheme="https://mengzelev.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>HKUST项目讨论内容</title>
    <link href="https://mengzelev.github.io/2019/02/11/HKUST-discussion/"/>
    <id>https://mengzelev.github.io/2019/02/11/HKUST-discussion/</id>
    <published>2019-02-11T07:12:48.000Z</published>
    <updated>2019-02-19T07:05:47.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题理解"><a href="#问题理解" class="headerlink" title="问题理解"></a>问题理解</h1><h2 id="原文【来自有道机翻】"><a href="#原文【来自有道机翻】" class="headerlink" title="原文【来自有道机翻】"></a>原文【来自有道机翻】</h2><h3 id="预测Sklearn程序的运行时间"><a href="#预测Sklearn程序的运行时间" class="headerlink" title="预测Sklearn程序的运行时间"></a>预测Sklearn程序的运行时间</h3><p>在共享基础设施上高效运行分布式应用程序具有挑战性。过去的研究表明，选择合适的硬件配置可以显著提高性能和降低成本。为了选择最佳配置，需要准确地预测不同应用程序的性能。</p><p>我们考虑这个挑战的一个简化版本:<strong>预测单个服务器上机器学习程序的性能</strong>。Scikit-learn (sklearn)是一个用于python的机器学习库。提供的数据集描述了在sklearn中运行SGDClassifier的几个示例。数据集的特征描述了SGDClassifier以及用于生成综合训练数据的特征。待分析数据为SGDClassifier的训练时间。</p><p>在这个文件夹中，您可以找到一个样例训练数据集(“sample_train.csv”)。“Time”是模型的训练时间。具体来说，“n_samples”、“n_features”描述了如何使用<code>sklearn.dataset.make_classification</code>生成训练合成数据集。在生成数据集之后，即使用SGDClassifier进行分类。‘l1_ratio’，‘alpha’，‘max_iter’描述了<code>sklearn.linear.model.SGDClassifier</code>的设置。所有特性名称都遵循sklearn文档中的定义。</p><p>本项目的目标是<strong>最小化预测运行时间的误差</strong>，即您应该预测接近真实运行时间的测试集的运行时间。使用的评价指标是<strong>均方误差</strong>。您可以找到“sample_test.csv”和“sample_submission”，用于测试集和解决方案提交格式。</p><p>项目分为两个阶段:</p><ul><li>阶段1：在访问HKUST前，你可浏览样本数据集及草拟解决方案。建议您提前处理数据集并准备模型。</li><li>阶段2:在您访问期间，我们将为您提供一个更大的数据集，包含更多的示例和特性。然后，您可以使用扩展的数据集处理您的解决方案。请注意，我们在阶段1中提供的数据只是一个示例，在示例数据集上建立一个准确的模型并不一定意味着在这个阶段在真实数据集上具有良好的性能。</li></ul><p>项目的其他信息和要求:</p><ul><li>所有的训练和测试数据集都在同一个服务器上生成。</li><li>不受编程语言或机器学习技术的限制。但是，您不允许运行sklearn程序来扩展训练集或预测测试集。</li><li>你需要在你自己的笔记本电脑上编程和训练你的模型。</li></ul><p>任何查询欢迎发送邮件至jxiaab @ust.hk与Jiacheng Xia联络</p><h2 id="相关名词说明"><a href="#相关名词说明" class="headerlink" title="相关名词说明"></a>相关名词说明</h2><ul><li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_classification.html" target="_blank" rel="noopener">make_classification</a></li><li><a href="https://scikit-learn.org/stable/modules/sgd.html" target="_blank" rel="noopener">sklearn.linear_model.SGDclassifier</a></li></ul><h2 id="任务概括"><a href="#任务概括" class="headerlink" title="任务概括"></a>任务概括</h2><ul><li>得到一个时间关于<code>l1_ratio</code>, <code>alpha</code>, <code>max_iter</code>, <code>n_samples</code>, <code>n_features</code>这5个参数的回归方程</li><li>将以上5个参数重新命名一下，即求$T(x_1,x_2,x_3,x_4,x_5)$</li></ul><h2 id="任务理解"><a href="#任务理解" class="headerlink" title="任务理解"></a>任务理解</h2><p>看到这个问题，有以下两种思路</p><ol><li>把SGDclassifier当成黑盒处理，不管SGD分类器算法的内部运作，用现有的算法作回归分析，拟合回归方程</li><li>根据SGD分类器具体运行的原理，自己确定一个时间函数</li></ol><p>后者需要的数学知识过多，几乎是不可能做到的，而且到时候还会有一个更大、feature更多的数据集，所以采用前者</p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><h3 id="SGD分类器模型相关"><a href="#SGD分类器模型相关" class="headerlink" title="SGD分类器模型相关"></a>SGD分类器模型相关</h3><ul><li><code>penalty</code>:惩罚函数的选择</li><li><code>l1_ratio</code>:混合惩罚函数中l1和l2方法的比例</li><li><code>alpha</code>:乘以正则项的常数</li><li><code>max_iter</code>:最大迭代次数</li><li><code>random_state</code>:随机数种子</li><li><code>n_jobs</code>:运算使用的CPU个数，’-1’表示使用了所有的CPU</li></ul><h3 id="数据生成相关"><a href="#数据生成相关" class="headerlink" title="数据生成相关"></a>数据生成相关</h3><ul><li><code>n_samples</code>:样本个数</li><li><code>n_features</code>:feature个数</li><li><code>n_classes</code>:类别的个数</li><li><code>n_clusters</code>: 每一个分类中的团簇个数</li><li><code>n_informative</code>:看不懂orz</li><li><code>flip_y</code>:随机交换所属类别，越大噪声越多</li><li><code>scale</code>:对每个值乘以一个数</li></ul><h1 id="演讲思路"><a href="#演讲思路" class="headerlink" title="演讲思路"></a>演讲思路</h1><ul><li>问题分析(如果已经有人讲过可以简单带过<ul><li>简述问题【提取关键字</li><li>简要介绍一下SGDclassifier</li><li>拉出我们参考的一篇论文，仿照论文决定训练模型计算</li></ul></li><li>我们尝试了诸多算法，决策树表现得比较好【数据可视化列举各种算法的表现情况</li><li>介绍决策树</li><li>对决策树进行改进【决策树，随机森林</li><li>总结结果</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题理解&quot;&gt;&lt;a href=&quot;#问题理解&quot; class=&quot;headerlink&quot; title=&quot;问题理解&quot;&gt;&lt;/a&gt;问题理解&lt;/h1&gt;&lt;h2 id=&quot;原文【来自有道机翻】&quot;&gt;&lt;a href=&quot;#原文【来自有道机翻】&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019美赛经历</title>
    <link href="https://mengzelev.github.io/2019/01/30/ICM-feelings/"/>
    <id>https://mengzelev.github.io/2019/01/30/ICM-feelings/</id>
    <published>2019-01-30T09:45:38.000Z</published>
    <updated>2019-01-31T10:09:50.651Z</updated>
    
    <content type="html"><![CDATA[<p>在经过了一夜的通宵之后终于把论文交上去惹，然后睡了一天，摸了一天，终于想起来要写这篇blog了。</p><h1 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h1><ul><li>学习MATLAB基本语法，笔记见<a href="https://mengzelev.github.io/2019/01/16/matlab-getstart/">MATLAB临时抱佛脚</a></li><li>学习数模基本算法，资料见<a href="https://github.com/NJUBroccoli/Material-of-MCM-ICM" target="_blank" rel="noopener">NJUBroccoli的github仓库</a></li><li>抄写常用算法模板，如：规划问题、AHP、灰色系统、灰色预测、主成分分析、方差分析等</li><li>阅读往年赛题和O奖论文，摸清套路</li><li><s>和朋友出去看电影</s></li><li>和队友做迫真模拟</li><li><s>补番</s></li></ul><h1 id="团队配置"><a href="#团队配置" class="headerlink" title="团队配置"></a>团队配置</h1><ul><li>po主：cs大二狗，会C/C++，LaTeX，以及Java和Verilog的皮毛，MATLAB是比赛前速成的。建模、计算、写论文、校对多面打杂，兼职美工和排版工人。</li><li>队友A：数学系大二小姐姐。建模扛把子。</li><li>队友B：大气科学大二小哥哥。负责给建模提供灵感，负责抱大气老师教授大腿，负责询问环科同学、商科同学…<s>这么写会不会被打死</s></li></ul><h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><ul><li>模型是一起讨论建的</li><li>数据是一起找的(虽然后来没怎么用上)</li><li>编程队友B不会所以我和队友A小姐姐一起负责</li><li>论文是每个人挑几个部分一起写的</li><li>翻译是交给有道姬完成的，由我和队友A校对<s>因为队友B校对的质量堪忧</s></li><li>排版由原po一人完成</li></ul><h1 id="比赛过程"><a href="#比赛过程" class="headerlink" title="比赛过程"></a>比赛过程</h1><h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><p>之前和队友商量好了选E或F题，因为MCM比较有难度，<s>D题需要排队论和马氏链不想看</s>。比赛当天题目公布的时候，看到F题需要不少硬核经济学知识果断放弃了，然后果断就上了E题这条贼船。MCM碰都没碰所以错过了养龙的机会，<s>我想养康娜酱啊呜呜呜</s></p><p>今年赛题内容大致为</p><ul><li>A题：养龙</li><li>B题：救救难民</li><li>C题：美国总统五大洲四日游</li><li>D题：逃离卢浮宫</li><li>E题：生态服务成本估价</li><li>F题：电子货币</li></ul><p>(只有E题是认真看过的，如有偏差欢迎指出)</p><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>E题按照惯例是环境问题，今年是要求对生态系统服务(ecological services)进行估价。生态系统服务是指生态系统提供的诸如净化空气、水体自净、保持水土等功能。要求大概有以下几点</p><ul><li>建立生态系统估价模型(ecological services valuation model)</li><li>对不同规模的土地开发利用项目进行成本效益分析(CBA)，评估这些项目的真实经济成本</li><li>决策者和管理者提出建议(implication)</li><li>随着时间推移模型如何修改</li></ul><p>本来是抱着AHP+GRA+PCA的觉悟来选的E题，结果一看这tm难道不是$\sum$单价$\times$数量的小学生模型吗，只要我找到每吨废水处理的价格，每吨垃圾回收的价格etc.<br>然后标准结局出现了：找不到！！！<br>比如污水处理费，中国大陆，HK和法国是按吨收的，美国英国是每年交固定的类似于下水道保护费一样的费用。<br>而且题干里都说了“现在的土地利用项目一般不考虑环境成本”，所以根本就找不到工程前后环境相关的数据。几篇类似的论文都是有自己的监测站的啊！！！！我们上哪找去啊！！！<br>环境经济学的书查了一堆啊！！！直接说环境估价是一个尚未解决的难题啊！！！！【废话要是解决了还会出成赛题吗<br>如此绝望了一天半之后，我们决定，死马当活马医：gtnd，上AHP！<br>然后就开始了玄学AHP玄学建模玄学论文解释<br>由于只是个心路历程记录，所以就不详细解释了</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>我们的玄学模型只有CBA那一块有一丢丢计算量，直接上MATLAB<br>甚至把图调得更好看花的时间还多一些【丢人</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p>是大家一起写的中文稿，然后扔给有道姬翻成英文，再手动修改</p><h2 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h2><p>DAY1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选题</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    讨论模;</span><br><span class="line">    找论文;</span><br><span class="line">    找数据;</span><br><span class="line">    推翻模型;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAY2：</p><ul><li>找数据</li><li>推翻模型</li><li>玄学建模开始</li><li>玄学AHP</li><li>玄学CBA</li><li>玄学编程</li><li>队友B开始玄学扯淡写论文</li></ul><p>DAY3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    论文扯淡;</span><br><span class="line">    发现模型有问题;</span><br><span class="line">    打补丁;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAY4(通宵)：</p><ul><li>写论文</li><li>继续给模型打补丁</li><li>翻译并校对</li><li>排版</li><li>提交</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><ul><li>美赛是<strong>真的很累</strong>！！！【不过也有些队伍早早就做完提交了根本没有通宵</li><li>前面不知道做些什么，所以每天都睡足了8小时，事情都积到最后一天做了，所以不得不通宵，所幸还是赶上了的</li><li>没有养龙好遗憾啊，反正哪题都不会做，不如养龙爽一把，非要吊死在E题上</li><li>美赛过于昂贵。3人平分100美元的报名费不说，因为作死没有留在学校里打，导致只能去市图书馆讨论，花费大量金钱在吃饭上，最后一天为了通宵还开了个房</li><li>这次的E题感觉还是挺坑的，涉及到不少环境经济学的知识，外行人慎选。<s>其实哪道题都是坑</s></li><li>我们的模型后来算出来西气东输是个失败的工程，感觉小命不保了</li><li>33.33美元，体验通宵的感觉，参赛一次，受益一生【棒读】</li></ul><blockquote><p>MCM/ICM真是一个骗钱又坑爹的比赛啊</p></blockquote><p><img src="/2019/01/30/ICM-feelings/trump.jpeg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在经过了一夜的通宵之后终于把论文交上去惹，然后睡了一天，摸了一天，终于想起来要写这篇blog了。&lt;/p&gt;
&lt;h1 id=&quot;赛前准备&quot;&gt;&lt;a href=&quot;#赛前准备&quot; class=&quot;headerlink&quot; title=&quot;赛前准备&quot;&gt;&lt;/a&gt;赛前准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Diary" scheme="https://mengzelev.github.io/categories/Diary/"/>
    
    
      <category term="Math Modeling" scheme="https://mengzelev.github.io/tags/Math-Modeling/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记</title>
    <link href="https://mengzelev.github.io/2019/01/23/python-getstart/"/>
    <id>https://mengzelev.github.io/2019/01/23/python-getstart/</id>
    <published>2019-01-23T07:37:50.000Z</published>
    <updated>2019-03-13T03:42:01.600Z</updated>
    
    <content type="html"><![CDATA[<p><u>持续更新中</u><br>参考：</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰的Python3教程</a></li><li>《Python编程：从入门到实践》</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Python是动态语言，即变量本身类型不固定，不需要提前声明变量类型的<br>Python有三大数据类型：整数、浮点数、字符串</p><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>整数可以是任意大小的</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数可以是任意精度的【但是运算也会出现误差】</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>字符串用单引号或双引号括起来</li><li>会涉及到转义符的问题</li><li>在字符串前加<code>r</code>表示让所有的转义符都不转</li><li>字符串拼接：<code>+</code>号</li></ul><h3 id="几个骚方法"><a href="#几个骚方法" class="headerlink" title="几个骚方法"></a>几个骚方法</h3><ul><li><code>title()</code>首字母大写</li><li><code>upper()</code>全部大写</li><li><code>lower()</code>全部小写</li><li><p><code>rstrip()</code>暂时删除字符串右端的空白</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'python '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rstrip()</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'python '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = rstrip() <span class="comment">#永久删除右端空格</span></span><br></pre></td></tr></table></figure></li><li><p><code>lstrip()</code>暂时删除字符串左端的空白</p></li><li><code>strip()</code>同时暂时删除字符串两端空白</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>Python中使用<code>#</code>注释掉一整行</li><li>PyCharm中可以使用<code>Ctrl+/</code></li></ul><h2 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h2><ul><li><code>int(x)</code>把<code>x</code>转化为整数</li><li><code>float(x)</code>把<code>x</code>转化为浮点数</li><li><code>str(x)</code>把<code>x</code>转化为字符串</li></ul><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><blockquote><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p></blockquote><ul><li>Python 3的字符串是以Unicode编码的</li><li><code>ord()</code>获取字符的整数表示，<code>chr()</code>把编码转换为对应的字符</li><li>字符串类型是<code>str</code>，加前缀<code>b&#39;</code>可以转换为<code>bytes</code>类型</li><li><p>Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为<code>bytes</code>类型，反过来<code>bytes</code>类型可以通过<code>decode()</code>方法解码为<code>str</code>类型</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">b'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'中文'</span></span><br></pre></td></tr></table></figure></li><li><p>len()函数返回字符串长度或<code>bytes</code>字节数</p></li><li>始终坚持使用UTF-8对<code>str</code>和<code>bytes</code>进行转换</li><li><p>开头通常需要加上</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure></li><li><p>格式化字符串<code>%</code>，用法同C的<code>printf</code></p></li></ul><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><ul><li>值为<code>True</code>或<code>False</code></li><li>运算<code>and</code>、<code>or</code>、<code>not</code></li></ul><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><ul><li><code>None</code>，是一个特殊变量</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul><li>习惯用全部大写的变量名表示常量</li><li>然而并不能保证该变量不会改变，不像C有<code>const</code></li></ul><h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h2><ul><li>[]表示list</li><li>[]为下标索引，从0开始，同C</li><li>[-1]表示最后一个元素,负号索引-n就表示倒数第n个<s>这也太nb了吧</s></li><li>list里的数据类型可以不同</li><li>list可以嵌套</li></ul><h3 id="list方法"><a href="#list方法" class="headerlink" title="list方法"></a>list方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">len(mylist) <span class="comment">#获得list元素的个数 </span></span><br><span class="line">mylist.append(<span class="string">'a'</span>) <span class="comment"># 往list中追加元素到末尾</span></span><br><span class="line">mylist.insert(<span class="number">1</span>, <span class="string">'a'</span>) <span class="comment"># 把元素插入到指定位置</span></span><br><span class="line">mylist.pop() <span class="comment"># 删除list末尾的元素</span></span><br><span class="line">mylist.pop(<span class="number">1</span>) <span class="comment"># 删除指定位置的元素</span></span><br><span class="line"><span class="comment">#pop返回值为被删除的元素</span></span><br><span class="line"><span class="keyword">del</span> mylist[<span class="number">1</span>] <span class="comment">#使用del可以删除任何位置的列表元素，条件是知道索引</span></span><br><span class="line">mylist.remove() <span class="comment">#按值删除元素，只删除第一个指定的值</span></span><br><span class="line"><span class="comment"># `pop和`del`的选择：删除后是否还要使用该元素</span></span><br><span class="line">mylist.sort() <span class="comment">#永久排序</span></span><br><span class="line">mylist.sort(reverse = <span class="keyword">True</span>) <span class="comment">#倒序排序</span></span><br><span class="line">sorted(mylist) <span class="comment">#暂时排序，也可以加入倒序参数</span></span><br><span class="line">mylist.reverse() <span class="comment">#永久倒置</span></span><br><span class="line">mylist[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#list切片，同MATLAB，首尾可缺省</span></span><br><span class="line">copy_list = mylist[:] <span class="comment">#通过切片赋值list</span></span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L[head : tail :step]</span><br><span class="line">L[:<span class="number">3</span>] <span class="comment">#取出从第0个到第3个元素</span></span><br><span class="line">L[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#取出从第1个到第3个元素</span></span><br><span class="line">L[:<span class="number">10</span>:<span class="number">2</span>] <span class="comment">#前10个数，每2个取一个</span></span><br><span class="line">L[::<span class="number">5</span>] <span class="comment">#所有数，每5个取一个</span></span><br><span class="line">L[:] <span class="comment">#原样复制一个list</span></span><br><span class="line"><span class="string">'ABCDEFG'</span>[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#字符串也可以看成List</span></span><br></pre></td></tr></table></figure><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squares = [value ** <span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">squares = [value ** <span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> value % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>] <span class="comment">#两两组合双重循环</span></span><br><span class="line">[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L] <span class="comment">#将一个list中所有字符串变成小写</span></span><br></pre></td></tr></table></figure><p>上述代码等价于对<code>squares</code>这个list执行了一个<code>for</code>循环，每个元素都平方(<code>**</code>是乘方的意思)<br><s>自然语言编程指日可待</s></p><h3 id="生成器generator"><a href="#生成器generator" class="headerlink" title="生成器generator"></a>生成器generator</h3><ul><li>lits保存的是数据，generator保存的是算法</li><li>使用<code>next()</code>函数可以获得generator的下一返回值</li><li>generator也是可迭代对象</li><li>定义generator<ul><li>把list的[]变成()</li><li>使用<code>yield</code>关键字把函数变成generator</li></ul></li><li>变成generator的函数，每次调用<code>next()</code>时执行，遇到<code>yield</code>语句返回，再次执行时</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)) <span class="comment">#把list的[]变成()就可以得到生成器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(n &lt; max):</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        <span class="comment">#相当于(a,b) = (b, a+b)</span></span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> fib:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#杨辉三角生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangles</span><span class="params">()</span>:</span></span><br><span class="line">    L = [<span class="number">1</span>,]</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> L</span><br><span class="line">        L = [<span class="number">1</span>,] + [L[i<span class="number">-1</span>] + L[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(L))] + [<span class="number">1</span>,]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> triangles():</span><br><span class="line">    print(t)</span><br><span class="line">    results.append(t)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h2><ul><li>与list类似，但是一旦初始化就<strong>不能修改</strong>，类似于C的<code>enum</code></li><li>不可变的tuple使代码更安全</li><li>注：定义一个元素的tuple时需要加一个逗号<code>,</code></li><li><code>tuple</code>的不变是<strong>指向不变</strong>，即给元组变量赋值是合法的</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = () <span class="comment">#定义空tuple</span></span><br><span class="line">t = (<span class="number">1</span>,) <span class="comment">#定义单元素tuple</span></span><br><span class="line">dim = (<span class="number">200</span>, <span class="number">5</span>)</span><br><span class="line">dim = (<span class="number">400</span>, <span class="number">10</span>) <span class="comment">#合法，相当于重新定义了整个元组</span></span><br></pre></td></tr></table></figure><h1 id="分支语句if"><a href="#分支语句if" class="headerlink" title="分支语句if"></a>分支语句if</h1><ul><li>除了不要括号、冒号换行、缩进代替大括号外，其他都和C语言一样</li><li><code>else if</code>可以缩写为<code>elif</code></li><li><code>if mylist</code> 可以检验列表是否非空</li><li><code>if a in mylist</code>你以为我是自然语言编程其实我只是检查某个元素在不在列表里哒</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">s = input(<span class="string">'birth:'</span>)</span><br><span class="line">birth = int(s) //将字符串输入转化为数字类型</span><br><span class="line"><span class="keyword">if</span> birth &gt;= <span class="number">2000</span>:</span><br><span class="line">    print(<span class="string">'00后'</span>)</span><br><span class="line"><span class="keyword">elif</span> birth &lt; <span class="number">1960</span>:</span><br><span class="line">    print(<span class="string">'60前'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'00前'</span>)</span><br></pre></td></tr></table></figure><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>python有2种循环</p><ul><li><code>for x in ...</code>循环，依次把list或者tuple中的每个元素迭代出来</li><li><code>range(m,n,step)</code>函数生成从m开始到n的整数序列，步长为step，<code>m</code>缺省为0，<code>step</code>缺省为1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>): <span class="comment">#行尾要有冒号</span></span><br><span class="line">    print(value) <span class="comment">#别忘了缩进对齐</span></span><br><span class="line">numbers = list(range(<span class="number">1</span>,<span class="number">11</span>,<span class="number">2</span>)) <span class="comment">#list()函数将参数转换为列表</span></span><br></pre></td></tr></table></figure><h3 id="类似C语言的循环"><a href="#类似C语言的循环" class="headerlink" title="类似C语言的循环"></a>类似C语言的循环</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]):</span><br><span class="line">    print(i, value)</span><br><span class="line"><span class="comment"># enumerate可以将list变成索引-元素对，相当于数组</span></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">9</span>)]:</span><br><span class="line">    print(x,y)</span><br><span class="line"><span class="comment">#同时对两个变量进行迭代</span></span><br></pre></td></tr></table></figure><h3 id="迭代对象"><a href="#迭代对象" class="headerlink" title="迭代对象"></a>迭代对象</h3><p><code>for</code>可以作用于所有可迭代对象</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以通过isinstance()函数判断一个对象是否为Iterable(可迭代对象)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">100</span>, Iterable)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li>可以被next()调用并不断返回下一个值的对象成为<strong>迭代器</strong><code>Iterator</code></li><li><code>Iterator</code>对象表示的是一个数据流</li><li>生成器都是<code>Iterator</code>对象</li><li><code>Iterable</code>可迭代对象不一定是<code>Iterator</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">n = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    ans += n</span><br><span class="line">    n -= <span class="number">2</span> <span class="comment"># 没有n--这种语法糖了</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><p><code>break</code>和<code>continue</code>都可以像以前一样用</p><h1 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h1><ul><li><code>dict</code>就相当于C++里的<code>map</code>，功能类似于Hash Table</li><li>是关键字-值对(key-value),key和value只是名字，并不规定类型</li><li>dict相比于list，是在用<strong>空间换时间</strong></li><li>dict的key必须是<strong>不可变对象</strong></li></ul><h2 id="创建dict"><a href="#创建dict" class="headerlink" title="创建dict"></a>创建dict</h2><p>注意dict的初始化使用的<code>{}</code>花括号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'Michael'</span>:<span class="number">95</span>, <span class="string">'Bob'</span>:<span class="number">75</span>, <span class="string">'Tracy'</span>:<span class="number">85</span>&#125; <span class="comment">#将名字和成绩对应起来，项比较多的时候可以加上换行</span></span><br><span class="line">d[<span class="string">'Adam'</span>] = <span class="number">67</span> <span class="comment">#直接通过关键字索引放入数据</span></span><br></pre></td></tr></table></figure><ul><li>多次对一个关键字放入数据，后面的值会把前面的冲掉</li><li>访问了不存在的关键字时会报错</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Thomas'</span> <span class="keyword">in</span> d <span class="comment">#返回布尔值，判断某关键字是否在该字典中</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">'Bob'</span>] <span class="comment">#删除指定关键字</span></span><br></pre></td></tr></table></figure><h2 id="dict方法"><a href="#dict方法" class="headerlink" title="dict方法"></a>dict方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.get(<span class="string">'Thomas'</span>,<span class="number">-1</span>) <span class="comment">#寻找某个关键字的值，-1是规定的不存在时的返回值，缺省时返回None，Python交互环境不显示结果</span></span><br><span class="line">d.pop(<span class="string">'Bob'</span>) <span class="comment">#删除一个关键字</span></span><br></pre></td></tr></table></figure><h2 id="遍历dict"><a href="#遍历dict" class="headerlink" title="遍历dict"></a>遍历dict</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> d.items(): <span class="comment"># 使用items()方法可以访问所有条目</span></span><br><span class="line">    print(key + <span class="string">":"</span> + value)</span><br><span class="line"><span class="comment"># 需要声明两个变量，命名任意</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d.keys(): <span class="comment"># 使用keys()方法可以访问所有的关键字</span></span><br><span class="line">    print(key.title())</span><br><span class="line"><span class="comment">#遍历字典时默认遍历所有key</span></span><br><span class="line"><span class="comment">#同理有values()方法</span></span><br></pre></td></tr></table></figure><h1 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h1><ul><li>无序、无重复元素的集合</li><li>不能放入可变对象</li></ul><h2 id="创建set"><a href="#创建set" class="headerlink" title="创建set"></a>创建set</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#需要提供一个list作为输入，重复元素自动过滤</span></span><br></pre></td></tr></table></figure><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">4</span>) <span class="comment">#添加元素</span></span><br><span class="line">s.remove(<span class="number">4</span>) <span class="comment">#删除元素</span></span><br></pre></td></tr></table></figure><h2 id="set操作"><a href="#set操作" class="headerlink" title="set操作"></a>set操作</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 &amp; s2 <span class="comment">#交集</span></span><br><span class="line">s1 | s2 <span class="comment">#并集</span></span><br></pre></td></tr></table></figure><h2 id="可变对象与不可变对象"><a href="#可变对象与不可变对象" class="headerlink" title="可变对象与不可变对象"></a>可变对象与不可变对象</h2><p>不可变对象：调用对象自身的方法不会改变该对象自身的内容，而是会创建新的对象并返回，如str<br>可变对象：恰恰相反，如list</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>函数名可以像变量一样赋值【太骚了</li></ul><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span> <span class="comment">#行尾加个冒号</span></span><br><span class="line">    <span class="keyword">if</span> x = <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure><h3 id="空操作"><a href="#空操作" class="headerlink" title="空操作"></a>空操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># pass可以用作占位符，没想好写什么但函数可以先运行起来</span></span><br></pre></td></tr></table></figure><h3 id="参数类型检查"><a href="#参数类型检查" class="headerlink" title="参数类型检查"></a>参数类型检查</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x,(int, float)): <span class="comment">#数据类型检查</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>) <span class="comment">#异常处理(后续会提到)</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure><h3 id="返回多值"><a href="#返回多值" class="headerlink" title="返回多值"></a>返回多值</h3><p>这也太骚了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle=<span class="number">0</span>)</span>:</span></span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br></pre></td></tr></table></figure><p>事实上返回的是一个tuple</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>位置参数：普通意义上的参数</li><li>默认参数：有缺省值的参数，如<code>def power(x,n=2)</code><ul><li>必选参数在前，默认参数在后</li><li>多个默认参数时，可以按顺序调用，也可以将需要修改的参数值的名称写好，不写的使用默认值，如<code>enroll(&#39;Adam&#39;, &#39;M&#39;,city=&#39;Tianjin&#39;)</code></li><li>默认参数必须指向<strong>不变对象</strong>，例如默认参数为list时用<code>None</code>代替<code>[]</code></li></ul></li><li><p>可变参数：参数个数不确定时，可以使用list或tuple传参，带<code>*</code>表示可变参数</p><ul><li>参数在函数调用时自动组装为tuple<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(*numbers)</span>:</span> <span class="comment">#加*表示可变参数</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        ans += n * n</span><br><span class="line">    <span class="keyword">return</span> ans   </span><br><span class="line"><span class="comment">#传参</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cal(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#传递变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cal(*number) <span class="comment">#传递list和tuple</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>关键字参数：允许传入0个或任意个含参数名的参数</p><ul><li>参数在内部自动组装为dict<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span> <span class="comment">#表示接受关键字参数`kw`</span></span><br><span class="line">        print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br><span class="line">    <span class="comment">#调用</span></span><br><span class="line">    &gt;&gt;&gt; person(<span class="string">'Michael'</span>, <span class="number">30</span>) <span class="comment">#可以只传入必选参数</span></span><br><span class="line">    &gt;&gt;&gt; person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">    &gt;&gt;&gt; person(<span class="string">'Adam'</span>, <span class="number">45</span>, **extra) <span class="comment">#将现成的dict作为参数</span></span><br><span class="line">+ 命名关键字参数：在函数内部检查传入了哪些参数</span><br><span class="line">  + 为了限制调用者可以传入的参数名，同时可以提供默认值。</span><br><span class="line">  + 必须传入参数名，否则调用将报错</span><br><span class="line">  + 命名关键字参数可以有缺省值</span><br><span class="line">  + 使用时，如果没有可变参数，必须加一个`*`作为分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数</span><br><span class="line">    ```py</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'city'</span> <span class="keyword">in</span> kw: <span class="comment">#有city参数</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'job'</span> <span class="keyword">in</span> kw: <span class="comment">#有job参数</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span> </span><br><span class="line">    <span class="comment">#限制关键字参数的名字，分隔符*后的参数被视为命名关键字参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *args, city, job)</span>:</span></span><br><span class="line">    <span class="comment">#有可变参数时后面的命名关键字参数不再需要分隔符*</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>参数定义顺序：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</p></li><li>对于任何函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用</li></ul><p>P.S.</p><ul><li>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code></li><li>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code></li><li><code>*args</code>和<code>**kw</code>是习惯写法</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><ul><li>函数名也是变量</li><li>有点C里面函数指针的感觉</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = abs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul><li>接收函数作为参数的函数叫做<strong>高阶函数</strong></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li><code>map(f,L)</code>，<code>f</code>为函数，<code>L</code>为一个list，表示将<code>f</code>作用于<code>L</code>的每一个元素上</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><ul><li><code>reduce(f,L)</code>，把结果继续和序列的下一个元素做累计计算</li><li><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></li><li>使用时需要加上<code>from functools import reduce</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="comment">#求和运算可以直接用sum()函数</span></span><br></pre></td></tr></table></figure><p><code>map()</code>与<code>reduce()</code>结合使用可以用很少的代码写出<code>str2int</code>函数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num = &#123;<span class="string">'0'</span>:<span class="number">0</span>, <span class="string">'1'</span>:<span class="number">1</span>, <span class="string">'2'</span>:<span class="number">2</span>, <span class="string">'3'</span>:<span class="number">3</span>, <span class="string">'4'</span>:<span class="number">4</span>, <span class="string">'5'</span>:<span class="number">5</span>, <span class="string">'6'</span>:<span class="number">6</span>, <span class="string">'7'</span>:<span class="number">7</span>, <span class="string">'8'</span>:<span class="number">8</span>, <span class="string">'9'</span>:<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2num</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> num[s]</span><br><span class="line">    <span class="keyword">return</span> reduce(fn, map(char2num, s))</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul><li>用于过滤list</li><li>把传入的函数依次作用于某个元素，根据返回值是True还是False决定保留还是丢弃该元素</li><li>返回的是一个惰性序列，需要用<code>list()</code>函数将所有结果组织为list</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#筛选回文数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(n)</span>:</span></span><br><span class="line">    s = str(n)</span><br><span class="line">    rev = s[::<span class="number">-1</span>] <span class="comment">#使用切片倒转字符串</span></span><br><span class="line">    <span class="keyword">return</span> s == rev</span><br><span class="line"></span><br><span class="line">output = filter(is_palindrome, range(<span class="number">1</span>, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><ul><li>可以直接对全是数据的list排序，<code>sort(L)</code>返回升序排序的<code>L</code></li><li>可以接受一个<code>key</code>函数来实现自定义的排序，<code>sort(L,key)</code><ul><li><code>key</code>指定的函数将作用于list的每一个元素上，并根据<code>key</code>函数返回的结果进行排序</li><li>然后<code>sorted()</code>函数按照keys进行排序，并按对应关系返回<strong>原list</strong>的相应元素</li><li>要进行反向排序可以传入第三个参数<code>reverse=True</code></li></ul></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">by_name</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> t[<span class="number">0</span>] <span class="comment">#按姓名字母顺序排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">by_score</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> -t[<span class="number">1</span>] <span class="comment">#按分数降序排序</span></span><br><span class="line"></span><br><span class="line">L = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</span><br><span class="line">L1 = sorted(L, key=by_name)</span><br><span class="line">L2 = sorted(L, key=by_score)</span><br><span class="line">print(L1)</span><br><span class="line">print(L2)</span><br></pre></td></tr></table></figure><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><ul><li>函数作为返回值的函数</li><li>“闭包”程序结构：相关参数和变量都包含在返回的函数中</li><li>返回的函数不会被立刻执行，而是直到调用了才执行</li><li><strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong></li><li>有啥卵用：保存当前的运行环境。被引用的自由变量与函数同在，即使离开了创造它的环境也不例外</li><li>将外部函数的变量与内部函数绑定</li></ul><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul><li><p>关键字<code>lambda</code>表示匿名函数，冒号前的<code>x</code>表示函数参数</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x : x * x</span><br><span class="line"><span class="comment">#相当于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure></li><li><p>只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果</p></li><li>好处：没有名字，不用担心和其他函数名冲突</li><li>匿名函数也是函数对象，可以把匿名函数赋值给一个变量，再利用变量来调用该函数【有毒吗，不能直接def吗</li><li>匿名函数也可以作为返回值返回</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = list(filter((<span class="keyword">lambda</span> x : x%<span class="number">2</span>==<span class="number">1</span>), range(<span class="number">1</span>,<span class="number">20</span>)))</span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>函数对象有个<code>__name__</code>属性，可以获得函数的名字</li><li>在代码运行期间动态增加函数的功能的方式成为<strong>装饰器(decorator)</strong></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func) # 把原始函数的属性复制到wrapper()函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__) <span class="comment"># 先打印日志</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw) <span class="comment"># 再调用原函数</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log # @语法，相当于执行now=log(now)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"2019-2-6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2019</span><span class="number">-2</span><span class="number">-6</span></span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><ul><li>把一个函数的某些参数固定住(设置一个参数的默认值)，返回一个新的函数，可以直接调用这个新的函数</li><li><code>functools.partial(f,*args,**kw)</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int2 = functools.partial(int, base=<span class="number">2</span>) </span><br><span class="line"><span class="comment">#固定转化为二进制的函数</span></span><br></pre></td></tr></table></figure><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><ul><li>一个.py文件就是一个模块</li><li>可以避免函数名和变量名冲突</li><li>包下的是模块，包中必包含<strong>init</strong>.py模块</li><li>注意模块命名不要与python原有模块冲突</li><li>模块名为<code>包名.模块名</code></li><li>类似于C的库</li></ul><h2 id="标准模块文件"><a href="#标准模块文件" class="headerlink" title="标准模块文件"></a>标准模块文件</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">' a test module '</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Michael Liao'</span></span><br></pre></td></tr></table></figure><ul><li>第一行：标准注释，表示该文件可以直接在Unix/Linux/Mac上运行</li><li>第二行：标准注释，表示该文件本身使用标准UTF-8编码</li><li>第四行：模块文档注释，任何模块代码的第一个字符串都被视为模块的文档注释</li><li>第六行：作者标注，使用<code>__author__</code>变量把作者写进去</li></ul><h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><ul><li>导入模块：<code>import 模块名</code></li></ul><h2 id="函数和变量的作用域"><a href="#函数和变量的作用域" class="headerlink" title="函数和变量的作用域"></a>函数和变量的作用域</h2><ul><li>正常的函数和变量名是公开的(public)，可以直接被引用</li><li>类似<code>__xxx__</code>的变量是特殊变量，可以被直接引用，但一般不建议这么做<ul><li>例如，如果调用<code>len()</code>试图获取一个对象的长度，会自动调用该类的<code>__len__</code>方法</li></ul></li><li>类似<code>_xxx</code>和<code>__xxx</code>的函数或变量是非公开的(private)，不应该被引用，但是Python不能完全限制它们的引用</li><li>外部不需要引用的函数和变量全部定义为private，只有外部需要引用的函数才定义为public</li></ul><h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install [模块名]</span><br></pre></td></tr></table></figure><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="comment"># Student是类名</span></span><br></pre></td></tr></table></figure><ul><li>类名一般首字母大写</li><li>括号中标明了从哪个类继承下来，所有类最终都继承自<code>object</code>(同Java)</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>创建实例：类名+()，如<code>bart = Student()</code></li><li>可以自由地给一个实例变量绑定属性</li><li><p>实例的初始化可以使用<code>__init__</code>函数</p><ul><li>将一些必须绑定的属性写上去</li><li><code>__init__</code>方法的第一个参数永远是<code>self</code>，需要声明但无需传递(类似于C的<code>this</code>)</li><li>不就是构造函数吗<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">bart = Student(<span class="string">'Bart Simpson'</span>,<span class="number">59</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>定义方法除了第一个参数是<code>self</code>外，与定义函数无异</p></li></ul><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><ul><li>私有变量：名称前加两个下划线<code>__xxx</code>，外部无法访问(其实只是Python解释器把它解释为了另一个名字)</li><li>单下划线实例变量名:“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”</li></ul><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><ul><li>基本类似Java的继承</li><li>子类继承父类的方法</li><li>子类和父类可以有相同的方法，但子类的方法会覆盖父类的方法</li><li>“鸭子类型”：一个对象只要“看起来像鸭子，走起路来像鸭子”，就可以被看成鸭子<ul><li>不要求严格的继承体系，调用方法时只要保证对象有这样的方法</li></ul></li></ul><h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><ul><li><p><code>type()</code>函数：判断对象、函数类型，返回对应的Class类型，可以用<code>if</code>语句比较两个变量的类型是否相同</p><ul><li>判断基本数据类型可以直接写<code>int</code>，<code>str</code>等</li><li>判断一个对象是否是函数可以使用<code>types</code>模块中定义的常量<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">123</span>) == int</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(fn) == types.FunctionType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(abs) == types.BuiltinFunctionType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="keyword">lambda</span> x : x) == types.LambdaType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))) == types.GeneratorType</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>isinstance()</code>可以用来判断继承关系</p><ul><li>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断</li><li>优先使用<code>isinstance()</code></li></ul></li><li><p><code>dir()</code>可以获得一个对象的所有属性和方法，返回一个包含字符串的list</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(<span class="string">'ABC'</span>)</span><br><span class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>,..., <span class="string">'__subclasshook__'</span>, <span class="string">'capitalize'</span>, <span class="string">'casefold'</span>,..., <span class="string">'zfill'</span>]</span><br></pre></td></tr></table></figure><ul><li><p>配合<code>getattr()</code>，<code>setattr()</code>和<code>hasattr()</code>可以直接操作一个对象的状态</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'x'</span>) <span class="comment"># 有属性'x'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性'y'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'y'</span>) <span class="comment"># 获取属性'y'</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.y <span class="comment"># 获取属性'y'</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'power'</span>) <span class="comment"># 有属性'power'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn = getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'并赋值到变量fn</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure><ul><li>只有在不知道对象具体信息时，才会去获取对象的信息<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#正确用法</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">readImage</span><span class="params">(fp)</span>:</span></span><br><span class="line"><span class="keyword">if</span> hasattr(fp, <span class="string">'read'</span>):</span><br><span class="line">    <span class="keyword">return</span> readData(fp)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"><span class="comment"># 假设我们希望从文件流fp中读取图像</span></span><br><span class="line"><span class="comment"># 我们首先要判断该fp对象是否存在read方法</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><ul><li>给实例绑定属性：通过实例变量或self变量</li><li>类本身需要绑定属性：直接在class中定义<ul><li>类的所有实例都可以访问类属性<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        Student.count += <span class="number">1</span> <span class="comment"># 类的属性增加一，而非实例的属性self.countA</span></span><br><span class="line"></span><br><span class="line">bart = Student(<span class="string">'Bart'</span>)</span><br><span class="line">print(Student.count)</span><br><span class="line">lisa = Student(<span class="string">'Lisa'</span>)</span><br><span class="line">print(Student.count)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h2><ul><li><p>实例可以绑定属性和方法</p><ul><li><p>绑定方法需要使用到types<code>模块中的</code>MethodType`方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></li><li><p>以上方法绑定的方法对其他的实例是不起作用的</p></li></ul></li><li><p>给类绑定方法可以给所有实例绑定方法，是一种动态绑定，绑定后所有实例均可调用</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line"><span class="meta">... </span>    self.score = score</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</span><br></pre></td></tr></table></figure></li><li><p>使用<code>__slots__</code>可以限制实例的属性</p><ul><li>仅对当前类的实例起作用，对继承的子类是不起作用的</li><li>如果在子类中也定义<code>__slots__</code>，则子类实例允许定义的属性 = 自身的<code>__slots__</code> + 父类的<code>__slots__</code></li></ul></li></ul><h2 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h2><ul><li><p><code>@property</code>是装饰器，负责把一个<code>setter</code>方法变成属性赋值</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class">    @<span class="title">property</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score <span class="comment"># getter属性</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span> <span class="comment"># setter属性</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 and 100'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><ul><li><code>@property</code>使得对实例属性操作时，通过getter和setter方法来实现</li><li>是定义getter方法就相当于定义了一个只读属性</li></ul></li></ul><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><ul><li><p>一个子类可以同时获得多个父类的所有功能</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, Runnable)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>MixIn:除主线之外的继承关系</p><ul><li>为了更好地看出继承关系，可以把主线外的继承类命名为<code>xxxMixIn</code>，如<code>RunnableMixIn</code></li><li>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类</li><li>Java是只允许单一继承的，不允许MixIn的继承</li></ul></li></ul><h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p>上文提到的 <code>__len__</code>方法能让class作用于<code>len()</code>函数，就是一种定制类的方法</p><h3 id="str"><a href="#str" class="headerlink" title="str"></a><strong>str</strong></h3><ul><li><p><code>__str__</code>方法可以改变类的实例的打印方式，类似于Java的<code>toString</code></p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Student object (name: %s)'</span> % self.name</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</span><br><span class="line">Student object (name: Michael)</span><br></pre></td></tr></table></figure></li></ul><h3 id="repr"><a href="#repr" class="headerlink" title="repr"></a><strong>repr</strong></h3><ul><li><code>__repr__</code>方法 直接显示变量调用(在交互模式下敲出变量名)<ul><li><code>__str__()</code>方法返回用户看到的字符串，<code>__repr__()</code>返回程序开发者看到的字符串，为调试服务</li><li>通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，有个偷懒的写法</li></ul></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line">__repr__ = __str__</span><br></pre></td></tr></table></figure><h3 id="iter"><a href="#iter" class="headerlink" title="iter"></a><strong>iter</strong></h3><ul><li><p><code>__iter__</code>方法返回一个迭代对象，让类可以被用用于<code>for ... in</code>循环</p><ul><li><p>配合<code>__next__</code>方法，for循环会不断调用该迭代对象的<code>__next__()</code>方法得到循环的下一个值，直到遇到<code>StopIteration</code>错误退出循环</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a,self.b = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a,self.b = self.b, self.a+self.b</span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopInteration()</span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line">            print(n)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">46368</span></span><br><span class="line">    <span class="number">75025</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="getitem"><a href="#getitem" class="headerlink" title="getitem"></a><strong>getitem</strong></h3><ul><li><p><code>__getitem__</code>方法使类可以像list那样根据下标取出元素</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(isinstance(n, int)): <span class="comment"># n是索引</span></span><br><span class="line">            a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                a,b = b,a+b</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">if</span>(isinstance(n, slice)): <span class="comment"># n是切片</span></span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.start</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span>  <span class="keyword">None</span>:</span><br><span class="line">                start = <span class="number">0</span></span><br><span class="line">            a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">            L = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(stop):</span><br><span class="line">                <span class="keyword">if</span> x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a,b = b,a+b</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fib()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">100</span>]</span><br><span class="line"><span class="number">573147844013817084101</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><ul><li>以上<code>__getitem__()</code>方法没有对步长和负数做处理，因此要正确实现一个<code>__getitem__()</code>还是有很多工作要做的</li><li>如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如<code>str</code>，与之对应的还有<code>__setitem__</code>和<code>__delitem__</code></li></ul></li></ul><h3 id="getattr"><a href="#getattr" class="headerlink" title="getattr"></a><strong>getattr</strong></h3><ul><li><p><code>__getattr__</code>方法能够动态返回一个属性，当调用不存在的属性时，会试图调用<code>__getattr__(self,属性)</code>来尝试获得属性</p><ul><li><p>只有在没有找到属性的情况下才会调用<code>__getattr__</code>，已有的属性是直接获取的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> attr==<span class="string">'age'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">'\'Student\' object has no attribute \'%s\''</span> % attr)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h3><ul><li><code>__call__</code>使实例自身能被当作函数调用</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'My name is %s.'</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s()</span><br><span class="line">My name <span class="keyword">is</span> Michael</span><br></pre></td></tr></table></figure><ul><li>通过<code>callable</code>函数可以判断一个对象是否能被调用</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(Student())</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(max)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(<span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(<span class="string">'str'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="枚举类Enum"><a href="#枚举类Enum" class="headerlink" title="枚举类Enum"></a>枚举类Enum</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>))</span><br></pre></td></tr></table></figure><ul><li>这样就得到了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量</li><li><p>也可以枚举该类的所有成员</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> name,member <span class="keyword">in</span> Month.__members.items()</span><br><span class="line">    print(name, <span class="string">'=&gt;'</span>, member, <span class="string">','</span>, member.value)</span><br></pre></td></tr></table></figure></li><li><p><code>value</code>属性是自动赋给<code>int</code>常量，默认<strong>从1开始</strong>计数(居然不是从0开始)</p></li><li>从<code>Enum</code>派生自定义类可以精确控制枚举类型  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique #装饰器，帮忙检查有无重复值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span><span class="params">(Enum)</span>:</span> <span class="comment"># Enum的子类</span></span><br><span class="line">    Sun = <span class="number">0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">Weekday.Mon</span><br><span class="line">Weekday[<span class="string">'Tue'</span>]</span><br><span class="line">Weekday(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="type-函数"><a href="#type-函数" class="headerlink" title="type()函数"></a>type()函数</h2><ul><li>动态语言的函数和类不是编译时定义的，而是运行时动态创建的</li><li><code>type()</code>函数可以查看一个类型或变量的类型</li><li><p><code>type()</code>函数可以创建出新的类型，而无需通过class定义</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(self, name=<span class="string">'world'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'Hello, %s.'</span> % name)</span><br><span class="line">Hello = type(<span class="string">'Hello'</span>, (object,), dict(hello=fn)) <span class="comment">#创建Hello类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = Hello()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.hello()</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure></li><li><p><code>type()</code>函数需依次传入3个参数</p><ul><li>class的名称</li><li>继承的父类的集合，<strong>注意单元素tuple的写法</strong></li><li>class的方法名称与函数绑定</li></ul></li></ul><h2 id="metaclass-函数"><a href="#metaclass-函数" class="headerlink" title="metaclass()函数"></a>metaclass()函数</h2><ul><li>先定义metaclass(元类)，就可以创建类，然后创建实例</li><li>可以把类看成metaclass创建出来的实例</li><li>metaclass正常情况下不会用到所以看不懂也没关系</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># metaclass是类的模板，所以必须从`type`类型派生：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        attrs[<span class="string">'add'</span>] = <span class="keyword">lambda</span> self, value: self.append(value)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用metaclass定制类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list, metaclass=ListMetaclass)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>创建Mylist时，通过<code>ListMetaclass.__new__()</code>来创建</li><li>可以用来修改类的定义，例如加上新的方法(样例中在<code>MyList</code>类中增加了<code>add</code>方法)</li><li><code>__new__()</code>方法接收的参数依次是<ul><li>当前准备创建的类的对象</li><li>类的名字</li><li>类继承的父类的集合</li><li>类的方法的集合</li></ul></li><li>应用上与SQL相结合的较多，等用到的时候再看了</li></ul><h1 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h1><h2 id="try"><a href="#try" class="headerlink" title="try"></a>try</h2><ul><li>当我们认为某些代码可能会出错时，可以用<code>try</code>来运行这段代码</li><li><p>如果出错，后续代码不会继续执行，而是直接跳转至错误处理代码</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    print(<span class="string">'result:'</span>, r)</span><br><span class="line"><span class="comment"># 错误处理代码</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:  <span class="comment"># 可以有多个except</span></span><br><span class="line">    print(<span class="string">'except:'</span>, e)</span><br><span class="line"><span class="keyword">finally</span>: <span class="comment"># finally无论如何都会被执行，表示执行结束</span></span><br><span class="line">    print(<span class="string">'finally...'</span>)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>except</code>后可加<code>else</code>语句块，当没有错误发生时会执行<code>else</code>语句块</p></li><li><code>try...except</code>可以跨越多层调用，被调用者出错，调用者也能捕捉到</li><li>Python的错误也是类，所有错误类型都继承自<code>BaseException</code></li><li><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">常见的错误类型和继承类型</a></li></ul><h2 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h2><ul><li>python有内置的<code>logging</code>模块，可以记录错误信息</li><li>程序打印完错误信息后会继续执行并正常退出</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">      bar(<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">      logging.exception(e)</span><br></pre></td></tr></table></figure><h2 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h2><ul><li>根据需要，可以定义一个错误的类，选择好继承关系，用<code>raise</code>语句抛出一个错误的实例</li><li>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型，尽量使用Python内置的错误类型</li><li>当前函数不知道如何处理该错误时，还可以在打印错误后再往上抛，让顶层调用者去处理<ul><li><code>raise</code>语句如果不带参数，就会将当前错误原样抛出</li><li>在<code>except</code>中<code>raise</code>一个Error，可以将错误转化成另一种类型</li></ul></li></ul><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><ul><li><code>print</code>调试法</li><li><p><code>assert</code>调试法</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> n != <span class="number">0</span>, <span class="string">'n is zero!'</span></span><br><span class="line"><span class="comment"># 表达式应该为True，否则输出AssertionError+后接的字符串</span></span><br></pre></td></tr></table></figure><ul><li>启动python解释器时可以用<code>-O</code>参数来关闭assert</li></ul></li><li><p><code>log</code>调试法(Python管这叫logging)</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO) <span class="comment"># 配置</span></span><br><span class="line">logging.info(<span class="string">'n = %d'</span> % n) </span><br><span class="line"><span class="comment"># logging.info: 输出信息</span></span><br></pre></td></tr></table></figure><ul><li>可以指定<code>DEBUG</code>&gt;<code>INFO</code>&gt;<code>WARNING</code>&gt;<code>ERROR</code>几个不同级别(level)的信息，级别越高越先被屏蔽，e.g.<code>level=INFO</code>时<code>DEBUG</code>的logging就不起作用了</li></ul></li><li>pdb调试法(命令同gdb)<ul><li><code>l</code>: 查看代码</li><li><code>n</code>: 单步执行</li><li><code>p 变量名</code>: 打印变量</li><li><code>c</code>: 继续执行</li></ul></li><li><p><code>pdb.set_trace()</code>在程序中设置断点，运行时程序会自动暂停并进入pdb</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">s = <span class="string">'0'</span></span><br><span class="line">n = int(s)</span><br><span class="line">pdb.set_trace() <span class="comment"># 运行到这里会自动暂停</span></span><br><span class="line">print(<span class="number">10</span> / n)</span><br></pre></td></tr></table></figure></li><li><p>PyCharm调试法</p></li></ul><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="comment"># 失败时会返回IOError</span></span><br><span class="line">f.read() <span class="comment">#一次性读取全部内容到内存，用一个str对象表示</span></span><br><span class="line">f.close() <span class="comment">#关闭文件，回收资源</span></span><br></pre></td></tr></table></figure><p>为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>嫌长可以简化为<code>with</code>语句<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="comment">#隐式调用了f.close()</span></span><br></pre></td></tr></table></figure></p><p>不想一次读取所有文件</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.read(size) <span class="comment"># 读取一定size个字节的内容</span></span><br><span class="line">f.readline() <span class="comment"># 一次读取一行</span></span><br><span class="line">f.readlines() <span class="comment"># 一次读取所有行并返回list</span></span><br></pre></td></tr></table></figure><p>还可以有效防止内存爆炸</p><p>内存的字节流，网络流，自定义流等等都是<strong>file-like Object</strong>，只需要写个<code>read()</code>方法就能用</p><p>二进制文件需要用<code>&#39;rb&#39;</code>模式打开</p><p>读取默认使用<strong>UTF-8</strong>编码，需要编码转换的时候要给<code>open()</code>传入<code>encoding</code>参数,<code>errors</code>参数表示出现错误后怎么处理，一般选择忽略</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/Users/michael/gbk.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'gbk'</span>,errors=<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>和读一样，把<code>r</code>改成<code>w</code>(跟C也差不多)</p><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>在内存中读写str</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO() <span class="comment"># 创建StringIO对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hello'</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">' '</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'world!'</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue()) <span class="comment">#getvalue()用于获得写入后的str</span></span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>可以用一个str初始化StringIO，然后，像读文件一样读取</p><h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>操作内存中的二进制数据</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87</span></span><br></pre></td></tr></table></figure><h3 id="操作系统命令"><a href="#操作系统命令" class="headerlink" title="操作系统命令"></a>操作系统命令</h3><p>Python内置的os模块可以直接调用操作系统提供的接口函数</p><p>文件名操作只对字符串进行，并不要求文件真实存在</p><p><code>shutil</code>中可以找到很多对<code>os</code>的补充</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.name <span class="comment">#查看操作系统名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ <span class="comment"># 查看操作系统中所有的环境变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ.get(<span class="string">'key'</span>) <span class="comment"># 获取某个环境变量的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">'.'</span>) <span class="comment"># 查看当前目录的绝对路径:</span></span><br><span class="line"><span class="string">'/Users/michael'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">'/Users/michael'</span>, <span class="string">'testdir'</span>)</span><br><span class="line"><span class="comment"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span></span><br><span class="line"><span class="string">'/Users/michael/testdir'</span></span><br><span class="line"><span class="comment"># 然后创建一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">'/Users/michael/testdir'</span>)</span><br><span class="line"><span class="comment"># 删掉一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">'/Users/michael/testdir'</span>)</span><br><span class="line"><span class="comment"># 拆分路径，把当前文件名与目录分开</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">'/Users/michael/testdir/file.txt'</span>)</span><br><span class="line">(<span class="string">'/Users/michael/testdir'</span>, <span class="string">'file.txt'</span>)</span><br><span class="line"><span class="comment"># 拆分文件扩展名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="string">'/path/to/file.txt'</span>)</span><br><span class="line">(<span class="string">'/path/to/file'</span>, <span class="string">'.txt'</span>)</span><br><span class="line"><span class="comment"># 对文件重命名:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">'test.txt'</span>, <span class="string">'test.py'</span>)</span><br><span class="line"><span class="comment"># 删掉文件:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.remove(<span class="string">'test.py'</span>)</span><br></pre></td></tr></table></figure><p>过滤文件<br><s>不都是一行命令行就能搞定的吗</s></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>) <span class="keyword">if</span> os.path.isdir(x)]</span><br><span class="line">[<span class="string">'.lein'</span>, <span class="string">'.local'</span>, <span class="string">'.m2'</span>, <span class="string">'.npm'</span>, <span class="string">'.ssh'</span>, <span class="string">'.Trash'</span>, <span class="string">'.vim'</span>, <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, ...]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>) <span class="keyword">if</span> os.path.isfile(x) <span class="keyword">and</span> os.path.splitext(x)[<span class="number">1</span>]==<span class="string">'.py'</span>]`</span><br><span class="line">[<span class="string">'apis.py'</span>, <span class="string">'config.py'</span>, <span class="string">'models.py'</span>, <span class="string">'pymonitor.py'</span>, <span class="string">'test_db.py'</span>, <span class="string">'urls.py'</span>, <span class="string">'wsgiapp.py'</span>]</span><br></pre></td></tr></table></figure><p>还有<code>psutil</code>模块提供了对cpu信息、内存和磁盘使用信息的访问</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><blockquote><p>把变量从内存中变成可存储或传输的过程叫作序列化(picking).序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p></blockquote><p>用到了再看吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;持续更新中&lt;/u&gt;&lt;br&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="Self-learning" scheme="https://mengzelev.github.io/categories/Self-learning/"/>
    
    
      <category term="Python" scheme="https://mengzelev.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数学建模几种常用算法</title>
    <link href="https://mengzelev.github.io/2019/01/19/matlab-usage/"/>
    <id>https://mengzelev.github.io/2019/01/19/matlab-usage/</id>
    <published>2019-01-19T08:41:45.000Z</published>
    <updated>2019-01-24T13:22:25.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据拟合"><a href="#数据拟合" class="headerlink" title="数据拟合"></a>数据拟合</h1><h2 id="多项式拟合"><a href="#多项式拟合" class="headerlink" title="多项式拟合"></a>多项式拟合</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [...];</span><br><span class="line">y = [...];</span><br><span class="line">P = polyfit(x,y,n); <span class="comment">% n是多项式的次数</span></span><br><span class="line">xi = <span class="number">0</span>: <span class="number">.2</span> :<span class="number">10</span>;</span><br><span class="line">yi = polyval(P, xi);</span><br><span class="line">plot(xi, yi, x, y, <span class="string">'r*'</span>);</span><br></pre></td></tr></table></figure><h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><p>标准型<script type="math/tex">\min~c^Tx s.t. Ax\le b</script></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = linprog(c, -a, -b, [], [], <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = fmincon(fun, x0, A, B, Aeq, Beq, LB, UB, [c,ceq], OPTIONS)</span><br><span class="line"><span class="comment">% fun:目标函数</span></span><br><span class="line"><span class="comment">% x0:x的初始条件</span></span><br><span class="line"><span class="comment">% A,B,Aeq,Beq:线性约束条件</span></span><br><span class="line"><span class="comment">% LB,UB:上下界</span></span><br><span class="line"><span class="comment">% [c,ceq]:.m文件定义的非线性约束条件,分别为不等式与等式约束</span></span><br></pre></td></tr></table></figure><h2 id="二次规划"><a href="#二次规划" class="headerlink" title="二次规划"></a>二次规划</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, fval] = quadprog(H, f, A, b, Aeq, Beq, LB, UB, X0, OPTIONS)</span><br></pre></td></tr></table></figure><h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><ul><li>隐枚举法</li><li>随机算法(蒙特卡洛)</li><li>分枝定界法</li></ul><h2 id="其他求解约束最优化问题的函数"><a href="#其他求解约束最优化问题的函数" class="headerlink" title="其他求解约束最优化问题的函数"></a>其他求解约束最优化问题的函数</h2><ul><li><code>fminbnd</code>:单变量非线性函数在区间上的极小值</li><li><code>fseminf</code></li><li><code>fminimax</code>:函数族的极大极小值</li></ul><h1 id="灰色预测"><a href="#灰色预测" class="headerlink" title="灰色预测"></a>灰色预测</h1><p>GM(1,1)模型适用于具有较强指数规律的序列，只能描述单调的变化过程，而Verhulst模型则适用于非单调的摆动发展序列或具有饱和状态的S形序列。<br>原始数列$x^{(0)}$，AGO累加生成数列$x^{(1)}$，加权均值数列$z^{(0)}$</p><h2 id="关联分析和优势分析"><a href="#关联分析和优势分析" class="headerlink" title="关联分析和优势分析"></a>关联分析和优势分析</h2><ul><li>根据bigger is better和smaller is better标准将数据分类进行初始化</li><li>根据公式算关联系数</li><li>根据关联系数计算关联度</li></ul><h2 id="灰色预测步骤"><a href="#灰色预测步骤" class="headerlink" title="灰色预测步骤"></a>灰色预测步骤</h2><ul><li>数据的检验与处理：计算级比，视情况进行必要的变换处理，使其落入可容覆盖内</li><li>建立模型 $x^{(1)}=…$可以得到预测值</li><li>残差检验</li><li>级比偏差检验</li><li>预测预报</li><li>另：灾变预测可以构造灾变数列</li></ul><h1 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h1><ul><li>求解多约束复杂非线性规划问题</li><li>直接调库吧，不可能看懂的</li></ul><h1 id="层次分析法-Analytic-Hierarchy-Process"><a href="#层次分析法-Analytic-Hierarchy-Process" class="headerlink" title="层次分析法(Analytic Hierarchy Process)"></a>层次分析法(Analytic Hierarchy Process)</h1><ul><li>用于解决较为复杂、模糊、难于定量分析的问题</li><li>当影响决策的因素较多且较主观时</li><li>分层、构造矩阵、检验一致性</li></ul><p>因为基本上做E或F题都会用到，所以详细展开一下</p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul><li>建立递阶层次结构模型；</li><li>构造出各层次中的所有判断矩阵；</li><li>层次单排序及一致性检验；</li><li>层次总排序及一致性检验。</li></ul><h2 id="层次结构的建立"><a href="#层次结构的建立" class="headerlink" title="层次结构的建立"></a>层次结构的建立</h2><p><img src="/2019/01/19/matlab-usage/1.png"></p><h2 id="构造判断矩阵"><a href="#构造判断矩阵" class="headerlink" title="构造判断矩阵"></a>构造判断矩阵</h2><p><img src="/2019/01/19/matlab-usage/2.png"></p><h2 id="层次单排序一致性检验"><a href="#层次单排序一致性检验" class="headerlink" title="层次单排序一致性检验"></a>层次单排序一致性检验</h2><ul><li>判断矩阵$A$对应于最大特征值$\lambda_{max}$的特征向量$W$ ，经归一化后即为同一层次相应因素对于上一层次某因素相对重要性的排序权值，这一过程称为层次单排序</li><li>如果比较结果是前后完全一致的，则矩阵$A$的元素还应当满足$a<em>{ij}a</em>{jk}=a_{ik}$，此时矩阵$A$成为一致矩阵</li><li>$n$阶正互反矩阵$A$为一致矩阵当且仅当其最大特征根$\lambda<em>{max}=n$，且当正互反矩阵$A$非一致时，必有$\lambda</em>{max}&gt;n$</li><li>一致性检验步骤<ul><li>计算一致性指标$CI=\frac{\lambda_{max}-n}{n-1}$</li><li>查找相应的平均随机一致性指标$RI$</li><li>计算一致性比例$CR=\frac{CR}{CI}$</li><li>$CR&lt;0.10$时，认为判断矩阵的一致性是可以接受的，否则应对判断矩阵作适当修正</li></ul></li></ul><h2 id="层次总排序一致性检验"><a href="#层次总排序一致性检验" class="headerlink" title="层次总排序一致性检验"></a>层次总排序一致性检验</h2><p>设A层(上一层次)包含$A<em>1,…A_m$共$m$个因素，层次总排序权重分别为$a_1,…a_m$，又设其后的下一层次B层包含$n$个因素$B_1,…B_n$，它们关于$A_j$的层次单排序权重分别为$b</em>{1j},…b<em>{nj}$(当$B_i$与$A_j$无关时，$b</em>{ij}=0$)。现求$B$层中各因素关于总目标的权重，即求$B$层个因素的层次总排序权重$b<em>1,…,b_n$。<br>$B$层各因素的层次总排序权重$b_i=\sum\limits</em>{j=1}^{m}b<em>{ij}a</em>{j}$<br>B层总排序随机一致性比例<script type="math/tex">CR=\frac{\sum\limits_{j=1}^{m}CI(j)a_j}{\sum\limits_{j=1}^{m}RI(j)a_j}</script><br>$CR&lt;0.10$时认为层次总排序具有较满意的一致性并接受该分析结果</p><h1 id="方差分析-ANOVA"><a href="#方差分析-ANOVA" class="headerlink" title="方差分析(ANOVA)"></a>方差分析(ANOVA)</h1><ul><li>又称F检验</li><li>用数理统计分析试验结果、鉴别各因素对结果影响程度的方法</li></ul><h2 id="单因素方差分析"><a href="#单因素方差分析" class="headerlink" title="单因素方差分析"></a>单因素方差分析</h2><ul><li>任务：从试验结果推断某因素对指标有无显著影响</li><li>单因素方差分析表</li><li>方差分析命令<code>anoval</code>，<code>p = anoval(x,group)</code>将算得的概率<code>p</code>与<code>\alpha</code>进行比较</li></ul><h2 id="双因素方差分析"><a href="#双因素方差分析" class="headerlink" title="双因素方差分析"></a>双因素方差分析</h2><ul><li><code>p = anova2(x,reps)</code></li></ul><h2 id="多因素方差分析"><a href="#多因素方差分析" class="headerlink" title="多因素方差分析"></a>多因素方差分析</h2><ul><li><code>anovan</code></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y = [<span class="number">31</span> <span class="number">54</span> <span class="number">38</span> <span class="number">53</span> <span class="number">49</span> <span class="number">42</span> <span class="number">57</span> <span class="number">62</span> <span class="number">64</span>]; <span class="comment">%试验结果</span></span><br><span class="line">g1 = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]; <span class="comment">%正交表第一列</span></span><br><span class="line">g2 = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span>];</span><br><span class="line">g3 = [<span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>];</span><br><span class="line">[p,t,st] = anovan(y,&#123;g1,g2,g3&#125;)</span><br></pre></td></tr></table></figure><h1 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h1><ul><li><p>用来检验拟合函数的准确度</p></li><li><p>残差：实际观察值，估计值(拟合值)之间的差</p></li><li>$R^2$判定系数：可解释的变异占总变异的百分比</li></ul><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[b,bint,r,rint,stats] = regress(y,x,alpha);</span><br><span class="line"><span class="comment">% b为回归系数估计值</span></span><br><span class="line"><span class="comment">% bint为置信区间 </span></span><br><span class="line"><span class="comment">% r为残差，rint为残差的置信区间</span></span><br><span class="line"><span class="comment">% stats是用于检验回归模型的统计量[R^2,F,p,s^2]</span></span><br><span class="line"><span class="comment">% alpha显著性水平，缺省时为0.05</span></span><br></pre></td></tr></table></figure><h2 id="一元多项式回归"><a href="#一元多项式回归" class="headerlink" title="一元多项式回归"></a>一元多项式回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[p,s] =  polyfit(x0, y0, <span class="number">2</span>);</span><br><span class="line"><span class="comment">% s为用于计算函数值的数据结构，如</span></span><br><span class="line">[y,delta] = polyconf(p,x0,s);y</span><br><span class="line"><span class="comment">%可以得到y的拟合值、置信区间半径delta</span></span><br></pre></td></tr></table></figure><h2 id="多元二项式回归"><a href="#多元二项式回归" class="headerlink" title="多元二项式回归"></a>多元二项式回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rstool(x,y,model,alpha)</span><br><span class="line"><span class="comment">% x:n×m维矩阵</span></span><br><span class="line"><span class="comment">% y:n维向量</span></span><br><span class="line"><span class="comment">%model:线性、纯二次、交叉、完全二次四选一</span></span><br></pre></td></tr></table></figure><h1 id="主成成分分析"><a href="#主成成分分析" class="headerlink" title="主成成分分析"></a>主成成分分析</h1><ul><li>用较少的变量去解释原来资料中的大部分变异</li><li>选出比原始变量个数少、能解释大部分资料中的变异的几个新变量</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>对原始数据进行标准化处理</li><li>计算相关系数矩阵$R$</li><li>计算特征值和特征向量</li><li>选择$p$个主成分，计算综合评价值</li><li>计算综合得分</li></ul><h1 id="排队论"><a href="#排队论" class="headerlink" title="排队论"></a>排队论</h1><ul><li>有很多公式，用的时候再查吧</li><li>优化：最优服务率，最优服务台数</li></ul><h1 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h1><ul><li>当模型的数据中有一个或几个发生变化时，最优解会有什么变化</li><li>这些数据在什么范围内变化时，已求解的最优解不变</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据拟合&quot;&gt;&lt;a href=&quot;#数据拟合&quot; class=&quot;headerlink&quot; title=&quot;数据拟合&quot;&gt;&lt;/a&gt;数据拟合&lt;/h1&gt;&lt;h2 id=&quot;多项式拟合&quot;&gt;&lt;a href=&quot;#多项式拟合&quot; class=&quot;headerlink&quot; title=&quot;多项式拟合&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MATLAB临时抱佛脚</title>
    <link href="https://mengzelev.github.io/2019/01/16/matlab-getstart/"/>
    <id>https://mengzelev.github.io/2019/01/16/matlab-getstart/</id>
    <published>2019-01-16T09:04:59.000Z</published>
    <updated>2019-01-20T03:49:08.093Z</updated>
    
    <content type="html"><![CDATA[<p>来源：王正盛 《MATLAB数学工具软件实例简明教程》</p><h1 id="入门技能"><a href="#入门技能" class="headerlink" title="入门技能"></a>入门技能</h1><h2 id="命令行命令"><a href="#命令行命令" class="headerlink" title="命令行命令"></a>命令行命令</h2><p>matlab基本可以看成一个有自己语法的命令行终端使用<br>下面列举一些我觉得自己将来可能会用到的</p><ul><li><code>clc</code>:擦除当前工作窗中所有显示内容</li><li><code>dir</code>:相当于<code>ls</code></li><li><code>cd</code>:你懂的</li><li><code>who</code>:检查内存变量</li><li><code>whos</code>:检查驻留变量的详细情况</li><li><code>help</code>:召唤FM</li><li><code>lookfor</code>:对<code>man</code>进行<code>grep</code></li></ul><p>MATLAB也是有当前工作路径的，同Linux的bash</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量基本以矩阵形式存在<br>还有一些预定义的变量</p><ul><li><code>eps</code>:计算机表示的最小正数</li><li><code>pi</code>:圆周率</li><li><code>inf</code>或<code>Inf</code></li><li><code>NaN</code></li><li><code>i,j</code></li><li><code>flops</code>:浮点运算次数，用于统计计算量</li></ul><h2 id="显示格式"><a href="#显示格式" class="headerlink" title="显示格式"></a>显示格式</h2><ul><li><code>short</code></li><li><code>long</code></li><li><code>short/long e</code> 科学计数法显示</li><li><code>bank</code> 银行格式</li><li><code>hex</code> 十六进制格式</li><li><code>+</code>用于大矩阵的紧凑格式 </li></ul><h1 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h1><h2 id="矩阵创建"><a href="#矩阵创建" class="headerlink" title="矩阵创建"></a>矩阵创建</h2><ul><li>直接输入法</li><li><code>reshape</code>把长行向量拆成$n\times m$的矩阵</li><li><code>diag</code>可以实现向量和对角阵之间的互相转化</li><li><code>.m</code>和<code>.mat</code>文件</li></ul><h2 id="矩阵运算与数组运算"><a href="#矩阵运算与数组运算" class="headerlink" title="矩阵运算与数组运算"></a>矩阵运算与数组运算</h2><ul><li>矩阵运算：按矩阵法则进行的运算</li><li>数组运算：对元素逐个进行</li><li>可以将数组直接作为参数传入函数中，而不用写循环，不同于C<br><img src="/2019/01/16/matlab-getstart/sign.png"></li><li>MATLAB推荐：尽量使用除运算，少用逆运算</li></ul><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><ul><li>系数行向量表示：$p=[a_0,a_1,…a_n]$</li><li>指令<code>p=poly(AR)</code>产生多项式<ul><li>若<code>AR</code>是方阵，则产生特征多项式</li><li>若<code>AR</code>是向量，则<code>AR</code>中每个数是该多项式=0的解</li></ul></li></ul><h3 id="多项式运算"><a href="#多项式运算" class="headerlink" title="多项式运算"></a>多项式运算</h3><ul><li><code>R = roots(p)</code>：求根</li><li><code>PA = polyval(p,S)</code>:按数组运算规则计算多项式的值</li><li><code>PA = polyvalm(p,S)</code>:按矩阵运算规则计算多项式的值</li><li><code>P = polyfit(x,y,n)</code>:用$n$阶多项式拟合$x,y$给定的数据</li></ul><h2 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h2><ul><li><code>S = quad(&#39;fname&#39;, a, b, tol, trace)</code> 自适用Simpson数值积分法</li><li><code>S = quad8(&#39;fname&#39;, a, b, tol, trace)</code>自适用Newton-Cotes数值积分法</li><li><code>quad8</code>比<code>quad</code>性能和精度更好</li></ul><h2 id="非线性方程"><a href="#非线性方程" class="headerlink" title="非线性方程"></a>非线性方程</h2><ul><li><code>r = roots(p)</code> 多项式非线性函数求根</li><li><code>z = fzero(&#39;fname&#39;, x0, tol, trace)</code> 单变量函数求零点，只给出离<code>x0</code>最近的根</li></ul><h2 id="微分方程的数值解"><a href="#微分方程的数值解" class="headerlink" title="微分方程的数值解"></a>微分方程的数值解</h2><ul><li><code>[t,x] = ode23/45(&#39;xprime&#39;, [t0,tf], x0, tol, trace)</code></li></ul><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul><li><code>cd, type, delete, dir</code>，和bash用起来差不多</li><li><code>!</code>可用于执行外部程序</li></ul><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><ul><li><p><code>fopen</code>打开二进制文件</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fid = fopen(<span class="string">'a.dat'</span>, <span class="string">'r'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>fread</code>将数据装入变量</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = fread(fid);</span><br><span class="line">a = fread(fid, <span class="number">100</span>);</span><br><span class="line">a = fread(fid, [<span class="number">10</span>,<span class="number">10</span>]);</span><br></pre></td></tr></table></figure></li><li><p><code>fwrite</code>按照指定的书精度将矩阵中的元素写入文件</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt = fwrite(fid, <span class="built_in">magic</span>(<span class="number">5</span>), <span class="string">'integer * 4'</span>);</span><br><span class="line"><span class="comment">%返回写入数据的个数</span></span><br><span class="line">status = fclose(fid);</span><br></pre></td></tr></table></figure></li><li><p><code>save</code>命令及<code>-ascii</code>选项</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">rand</span>(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">save a.dat a -ascii</span><br></pre></td></tr></table></figure></li></ul><h1 id="符号计算"><a href="#符号计算" class="headerlink" title="符号计算"></a>符号计算</h1><h2 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h2><ul><li><p><code>sym</code>定义符号或表达式</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sym(<span class="string">'x'</span>)</span><br><span class="line">sym(`<span class="number">1</span> + x / <span class="number">2</span>`)</span><br><span class="line">syms a b c d </span><br><span class="line"><span class="comment">%syms可以定义多个符号</span></span><br></pre></td></tr></table></figure></li><li><p><code>findsym</code>确认符号表达式中的符号</p></li></ul><h2 id="微积分运算"><a href="#微积分运算" class="headerlink" title="微积分运算"></a>微积分运算</h2><h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><ul><li><code>diff(f,t,n)</code>函数<code>f</code>对变量<code>t</code>求<code>n</code>阶导，<code>t</code>缺省时对<code>x</code>求导，<code>n</code>缺省为1</li><li>参数为矩阵时，作用于每个元素</li></ul><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><ul><li><code>int(f,t)</code> 函数<code>f</code>对变量<code>t</code>求不定积分</li><li><code>int(f,t,a,b)</code> 函数<code>f</code>对符号变量求从<code>a</code>到<code>b</code>的定积分</li></ul><h3 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h3><ul><li><code>limita(f,t,a)</code>当符号变量<code>t-&gt;a</code>时，函数<code>f</code>的极限，<code>t</code>缺省<code>x</code>，<code>a</code>缺省为0</li></ul><h3 id="级数和"><a href="#级数和" class="headerlink" title="级数和"></a>级数和</h3><ul><li><code>symsum(s,t,a,b)``s</code>中的符号变量<code>t</code>从<code>a</code>到<code>b</code>的级数和</li></ul><h3 id="Taylor展开"><a href="#Taylor展开" class="headerlink" title="Taylor展开"></a>Taylor展开</h3><ul><li><code>taylor(f,n,a)</code>函数<code>f</code>对符号变量<code>x</code>或最接近字母<code>x</code>的符号变量在<code>a</code>点的<code>n-1</code>阶泰勒多项式,<code>n</code>缺省时值为6,<code>a</code>缺省值为0</li></ul><h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><ul><li><code>solve(f,t)</code>对<code>f</code>中的符号标量<code>t</code>解方程<code>f=0</code></li><li><code>solve(&#39;fname&#39;,t)</code> 求解形如<code>f(x)=g(x)</code>的方程</li><li><code>dsolve(&#39;S&#39;,&#39;s1&#39;,...&#39;x&#39;)</code> </li></ul><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><ul><li>用，都可以用</li></ul><h2 id="化简和代换"><a href="#化简和代换" class="headerlink" title="化简和代换"></a>化简和代换</h2><ul><li><code>collect</code>合并同类项</li><li><code>expand</code>将乘积展开为和式</li><li><code>factor</code>将和式展开为乘积</li><li><code>horner</code>嵌套多项式</li><li><code>simplify</code>利用各种</li></ul><h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><ul><li><code>plot(x,y)</code>其中<code>x</code>和<code>y</code>为坐标向量</li><li><p>在<code>plot</code>指令中增加一些参数，可以绘制出不同颜色与不同线性的图形，e.g.</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(x, y1, <span class="string">'k:'</span>, x, y2, <span class="string">'b-'</span>)</span><br></pre></td></tr></table></figure></li><li><p>每条曲线的线型和颜色由字符串<code>&#39;cs&#39;</code>指定，其中<code>&#39;c&#39;</code>表示颜色，<code>&#39;s&#39;</code>表示线型<br>  <img src="/2019/01/16/matlab-getstart/cs.png"></p></li><li>图形标记指令<code>title</code>,<code>xlabel</code>,<code>ylabel</code>,<code>text</code>,<code>legend</code></li><li><code>axis([xmin, xmax, ymin, ymax])</code>设定坐标轴</li><li><code>hold on</code>保持已有图形绘制新的图形</li><li><code>fplot(fname, lims, tol)</code>为函数提供自适应采样</li><li><code>loglog(x,y)</code>双对数坐标</li><li><code>semilogx,semilogy</code> 单对数坐标</li><li><code>polar(theat, rho)</code> 极坐标</li></ul><p><img src="/2019/01/16/matlab-getstart/plot.png"></p><h2 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h2><ul><li><code>plot3</code>用法同<code>plot</code></li><li><code>mesh(x,y,z,c)</code>绘制三维网格图</li><li><code>surf(x,y,z,c)</code>三维曲面图</li><li><code>view</code>指定视点</li><li><code>contour3</code>等高线图</li></ul><h1 id="MATLAB程序设计"><a href="#MATLAB程序设计" class="headerlink" title="MATLAB程序设计"></a>MATLAB程序设计</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul><li><p><code>input</code>函数</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = input(<span class="string">'Enter matrix A=&gt;'</span>)</span><br><span class="line"><span class="comment">%这样可以在执行该语句时首先给出提示，再接收键盘输入</span></span><br></pre></td></tr></table></figure></li><li><p><code>pause(延迟秒数)</code></p></li><li><code>Disp()</code>输出函数， 输出项可以为矩阵或字符串</li></ul><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><ul><li>结尾需要加<code>end</code></li><li><code>else</code>和<code>if</code>可以连起来写成<code>elseif</code></li></ul><h3 id="swith语句"><a href="#swith语句" class="headerlink" title="swith语句"></a>swith语句</h3><p>与C相比：</p><ul><li><code>default</code>改为<code>otherwise</code></li><li>结尾加<code>end</code></li></ul><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><ul><li>for 初始条件:步长(缺省为1):终值</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">2</span> : <span class="number">2</span>*n<span class="number">-1</span></span><br><span class="line">    <span class="comment">%循环体</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>for 循环变量=矩阵表达式，使循环变量取遍矩阵里每个数的值(以行为周期)</li></ul><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><ul><li>结尾加<code>end</code>，用法同C</li></ul><h2 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h2><ul><li>一般格式为</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 输出形参表 = 函数名<span class="params">(输入形参表)</span></span></span><br><span class="line">    <span class="comment">%注释说明部分</span></span><br><span class="line">    <span class="comment">%函数体</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>当输出形参多于1个时，用方括号括起来</li><li>函数调用<code>[输出参数表]=函数名(输入参数表)</code>，支持嵌套调用和递归</li><li>参数个数可变：通过变量<code>nargin</code>和<code>nargout</code>实现</li><li>函数内部申明的变量都是局部变量</li><li>全局变量前缀<code>global</code>，所有函数都可以对其进行存取和修改</li></ul><h1 id="关于括号"><a href="#关于括号" class="headerlink" title="关于括号"></a>关于括号</h1><h2 id="圆括号"><a href="#圆括号" class="headerlink" title="() 圆括号"></a>() 圆括号</h2><p>引用数组中的元素</p><h2 id="方括号"><a href="#方括号" class="headerlink" title="[] 方括号"></a>[] 方括号</h2><p>表示向量或矩阵</p><h2 id="花括号"><a href="#花括号" class="headerlink" title="{} 花括号"></a>{} 花括号</h2><p>用于元胞(cell)数组的分配和引用<br>元胞与矩阵的区别是能放任何类似的元素，而矩阵只能放数值型数据</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D=&#123;[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>],<span class="string">'abc'</span>,&#123;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>&#125;，[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>;<span class="number">11</span> <span class="number">22</span> <span class="number">33</span>]&#125;</span><br><span class="line"></span><br><span class="line">D&#123;<span class="number">1</span>&#125; <span class="comment">%表示D中第一个元素        显示为 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">D&#123;<span class="number">1</span>&#125;(<span class="number">2</span>) <span class="comment">%表示D中第一个元素中第二个元素        显示为 2</span></span><br><span class="line">D&#123;<span class="number">3</span>&#125;&#123;<span class="number">1</span>&#125; <span class="comment">%表示第三个元素中第一个元素        显示为 7</span></span><br><span class="line"></span><br><span class="line">D&#123;<span class="number">3</span>&#125;(<span class="number">1</span>) <span class="comment">%表示第三个元素中第一个元素        显示为&#123;[7]&#125;</span></span><br><span class="line"></span><br><span class="line">D&#123;[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]&#125; <span class="comment">%表示前三个元素        显示为1 2 3 4 ;    ‘abc’  ;&#123;[7]&#125;  &#123;[8]&#125;  &#123;[9]&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：王正盛 《MATLAB数学工具软件实例简明教程》&lt;/p&gt;
&lt;h1 id=&quot;入门技能&quot;&gt;&lt;a href=&quot;#入门技能&quot; class=&quot;headerlink&quot; title=&quot;入门技能&quot;&gt;&lt;/a&gt;入门技能&lt;/h1&gt;&lt;h2 id=&quot;命令行命令&quot;&gt;&lt;a href=&quot;#命令行命令
      
    
    </summary>
    
      <category term="Self-learning" scheme="https://mengzelev.github.io/categories/Self-learning/"/>
    
    
      <category term="MATLAB" scheme="https://mengzelev.github.io/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>问题求解3-总复习</title>
    <link href="https://mengzelev.github.io/2019/01/07/Problem-Solving-3/"/>
    <id>https://mengzelev.github.io/2019/01/07/Problem-Solving-3/</id>
    <published>2019-01-07T11:21:20.000Z</published>
    <updated>2019-01-08T15:40:21.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><ul><li>问题的最优解由相关子问题的最优解组合而成，这些子问题可以独立求解</li><li>使用“剪切-粘贴”技术证明：假设原问题取得最优解时，子问题没有取最优解，那么可以将子结构从整体删除替换为最优解，这与原问题取得最优解的前提矛盾</li><li>子问题间互相独立</li><li>运行时间：子问题总数*每个问题要考察的选择数</li></ul><p>求解时先找出最优子结构，列出递推式</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>自顶向下的备忘算法（带备忘的递归）</li><li>自底向上的动态规划算法（难写，但是快）</li><li>并没有板子</li></ul><h2 id="能解决的问题"><a href="#能解决的问题" class="headerlink" title="能解决的问题"></a>能解决的问题</h2><ul><li>矩阵乘法问题</li><li>最长公共子序列</li><li>最长上升子序列</li></ul><p><s>&gt;主要就是一个列递推式的问题但是就是列不出来</s></p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h2><ul><li>进行选择时，直接做出当前问题中看来最优的选择，而不必考虑子问题的解</li><li>贪心不太方便时可以进行预处理</li><li>证明：替换法<ul><li>贪心算法得到一个解S，假设存在一个抽象的最优解S’，证明S’可以通过若干步满足要求的替换变成S</li><li>也可以证明S优于S(e.g.S的代价$\le$S’的代价)，加上S’优于S的天然条件，可知S与S’都是最优解</li></ul></li></ul><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ul><li>教室安排问题</li><li>Huffman编码树【可以等价为叶结点的带权路径长度之和最小问题</li><li>区间选点问题<ul><li>数轴上有n个闭区间$[a_i,b_i]$。取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以是同一个）</li><li>将区间按右端点升序排序，优先处理小区间</li></ul></li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul><li>这个完全就是因题而异的了啊【哭了</li></ul><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="三个基本操作"><a href="#三个基本操作" class="headerlink" title="三个基本操作"></a>三个基本操作</h2><ul><li>MAKE-SET($x$)</li><li>UNION($x,y$)</li><li>FIND-SET($x$)：返回$x$所在集合的代表元</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>时间复杂度make和find是$O(1)$，UNION$O(n\lg n)$</li><li>简单加权合并式启发策略（小的并到大的上</li></ul><h2 id="不相交集合森林"><a href="#不相交集合森林" class="headerlink" title="不相交集合森林"></a>不相交集合森林</h2><ul><li>按秩合并，路径压缩</li><li>make和find$O(1)$，UNION$O(m_{\alpha}(n))$</li></ul><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = i;            </span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*递归版*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[i] == i ? i : f[i] = find(f[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*非递归版*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = f[x];</span><br><span class="line">    <span class="keyword">while</span>(root != f[root]) root = f[root];</span><br><span class="line">    <span class="keyword">int</span> y = f[x];</span><br><span class="line">    <span class="keyword">while</span>(x != root) &#123;</span><br><span class="line">        y = f[x];</span><br><span class="line">        f[x] = root;</span><br><span class="line">        x = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(a);</span><br><span class="line">    <span class="keyword">int</span> fb = find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa != fb) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rank[a] &lt; rank[b]) f[a] = fb;</span><br><span class="line">        <span class="keyword">else</span> f[b] = fa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h2><ul><li>带权并查集</li><li>分类并查集</li></ul><p><s>&gt;考到自求多福</s></p><h2 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h2><ul><li>无向图连通分量个数</li></ul><h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><p>参考了ytr的整理</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>诱导子图</li><li>链walk，迹trail，路path</li><li>回路circuit，圈cycle</li><li>连通性，连通分支</li><li>距离，测地线(长度为$u-v$距离的$u-v$路)，直径</li><li>环(loop)，你 连 你 自 己</li><li>平行边：重边</li><li>度数deg，最小度数$\delta(G)$，最大度数$\Delta(G)$</li><li>度序列，可图的</li></ul><h2 id="几种图"><a href="#几种图" class="headerlink" title="几种图"></a>几种图</h2><ul><li>完全图$K_n$</li><li>补图</li><li>二部图，完全二部图($K<em>{s,t}$)，星图star($K</em>{1,s}$)</li><li>多部图，完全多部图(K_{s,s,s})</li><li>$G+H$：$G$和$H$放一起，顶点两两连起来</li><li>$G\times H$：$G$的每个点都替换成一个$H$</li><li>n方体cube($Q<em>n=Q</em>{n-1}\times K_2$)</li><li>$r-$正则图：每个点度数都为$r$</li></ul><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><ul><li>设$G$是一个阶至少为3的图，则$G$是连通的当且仅当$G$包含两个不同的顶点$u$和$v$,使得$G-u$和$G-v$都是连<br>通的</li><li>非平凡图$G$是二部的当且仅当$G$不含奇圈</li><li><strong>图论第一定理</strong>：度数和=边数*2</li><li>每一个图都有偶数个奇点</li><li>设$G$为$n$阶图,若对于$G$中任意两个不邻接的顶点$u$和$v$, 都满足<script type="math/tex">deg~u+deg~v\geq n-1</script>，则$G$是连通的且$diam(G)\leq$2</li><li>设$r$和$n$为满足$0\leq r\leq n-1$的整数． 则存在n阶的r正则图当且仅当$r$和$n$中至少有一个为偶数</li><li>度序列可图的充要条件(删掉一个点依然可图)</li></ul><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>割边</li><li>树，森林</li></ul><h2 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h2><ul><li>某条边是割边当且仅当该边不在任何一个cycle上</li><li>每一棵非平凡树都至少有两个端点(最长路径的两个端点)<ul><li><strong>【可以成为数学归纳法的依据】</strong></li><li>使用数学归纳法证明图论问题的关键在于找到一个端点</li></ul></li><li>有$k$个连通分量的森林有$n-k$条边，树就有$n-1$条边</li><li>每一个有$n$个顶点的连通图至少有$n-1$条边【证明：最小数原理】</li><li>任意两条可得树：连通、无环、$m=n-1$</li><li>每个连通图都包含一棵生成树</li><li>Matrix Tree Theorem：连通图$G$的生成树个数可以用行列式求得</li><li>$T$是唯一最小生成树当且仅当$\forall e\in G\setminus T: w(e)&gt;w(\text{every other edge on the cycle in $T+e$})$<ul><li>推论：distinct weights $\Leftarrow$ unique MST</li><li>推论：Maximum-weight edge in any cycle is unique $\Leftarrow$ unique MST </li></ul></li><li>若每个点度数大于等于2，则该图有cycle</li><li>$e$是割边当且仅当$e$存在于$G$的某一棵生成树上</li></ul><h2 id="最小生成树性质"><a href="#最小生成树性质" class="headerlink" title="最小生成树性质"></a>最小生成树性质</h2><ul><li>Cut Property <ul><li>VER I:$X$是某棵最小生成树的一部分，$(S,V\setminus S)$是一个$X$没有横跨的切割，$e$为横跨$(S,V\setminus)$的一条最轻的边，则$X\cup \{e\}$是某棵最小生成树$T_2$的一部分。</li><li>VER II:$e$为横跨$(S,V\setminus)$的一条最轻的边，则$e$属于某棵最小生成树</li><li>贪心选择性质，可由替换法证明</li></ul></li><li>Cycle Property<ul><li>若$e$为任意一个cycle上权重最大的一条边，则存在一棵最小生成树$T$，使$e\notin T$</li></ul></li></ul><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><ul><li>$O(E\lg~V)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(edge, edge + m, cmp);<span class="comment">//将边按权重从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;<span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edge[i].u;</span><br><span class="line">        <span class="keyword">int</span> b = edge[i].v;</span><br><span class="line">        <span class="keyword">int</span> fa = find(a), fb = find(b);</span><br><span class="line">        <span class="keyword">if</span>(fa != fb) &#123;</span><br><span class="line">            f[fa] = fb;</span><br><span class="line">            ans += edge[i].w;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><ul><li>$O(E\lg V)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        mincost[i] = INF;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; (v == <span class="number">-1</span> || mincost[i] &lt; mincost[v])) v = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">        ans += mincost[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            mincost[i] = min(mincost[i], <span class="built_in">map</span>[v][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图的计算机表示及其遍历"><a href="#图的计算机表示及其遍历" class="headerlink" title="图的计算机表示及其遍历"></a>图的计算机表示及其遍历</h1><h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><ul><li>邻接链表</li><li>邻接矩阵</li></ul><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ul><li>维护一个队列</li><li>时间复杂度$O(V+E)$</li><li>搜完了会得到广度优先树</li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ul><li>前驱子图：深度优先森林</li><li>边的类型<ul><li>树边</li><li>前向边F：祖宗指向儿子</li><li>后向边B：儿子指向祖宗</li><li>横向边C：没有亲缘关系</li></ul></li><li>复杂度$O(V+E)$</li><li>每个结点有两个时间戳<ul><li>$v.d$：记录该结点第一次被发现的时间</li><li>$v.f$：记录搜索完成对$v$的邻接链表的扫描的时间</li><li>$v.d&lt;v.f$</li></ul></li></ul><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul><li>根据DFS后的$v.f$时间戳降序排序，即拓扑序最前的最晚结束访问</li><li>若$(u,v)\in G$，则$v.f&lt;u.f$</li><li>只有DAG才有拓扑排序</li></ul><h2 id="SCC"><a href="#SCC" class="headerlink" title="SCC"></a>SCC</h2><p>算法描述</p><ul><li>DFS($G$)</li><li>DFS($G^{T})$，在主循环根据$v.f$的大小降序访问其邻接点，得到的每棵树都是一个强连通分量</li></ul><h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><ul><li><strong>松弛操作</strong>是<strong>唯一</strong>导致最短路径估计和前驱结点发生变化的操作</li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>三角不等式性质：$s,u,v$</li><li>上界性质：$v.d$撑死就是$\delta(s,v)$</li><li>非路径性质：$s-v$之间没路则$\delta(s,v)=+\infty$</li><li>收敛性质：松弛前是最短路径，松弛后也是最短路径</li><li>路径松弛性质：一条最短路径上的点按先后顺序松弛，则终点的估计值等于最短路径长度</li><li>前驱子图性质：$v.d=\delta(s,v)$，则前驱子图是一棵根结点为$s$的最短路径树</li></ul><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><ul><li>对每条边进行$|V|-1$次relax</li><li>可以识别负权重环</li><li>$O(VE)$</li><li>本质上是DP</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[e[j].u &lt; INF &amp;&amp; dist[e[j].v] &gt; dist[e[j].u] + e[j].w) &#123;</span><br><span class="line">                dist[e[j].v] = dist[e[j].u] + e[j].w;</span><br><span class="line">                pre[e[j].v] = e[j].u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        <span class="keyword">if</span>(dist[e[j].v] &gt; dist[e[j].u] + e[j].w) flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h2><ul><li>按拓扑序松弛结点（路径松弛性质保证）</li><li>$\Theta(V+E)$</li></ul><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><ul><li>所有权重都非负</li><li>二叉堆实现$O(E\lg V)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prority_queue &lt;node&gt; q;</span><br><span class="line">    ver[<span class="number">0</span>].d = <span class="number">0</span>;</span><br><span class="line">    q.push(ver[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> vid = son[u.id][i];</span><br><span class="line">            <span class="keyword">if</span>(ver[vid].d &lt; u.d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(ver[vid].d &gt; u.d + <span class="built_in">map</span>[u.id][vid]) &#123;</span><br><span class="line">                ver[vid].d = u.d + <span class="built_in">map</span>[u.id][vid];</span><br><span class="line">                q.push(ver[vid]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><ul><li>差分图：若$x_j-x_i\le b_k$，则$w(v_i,v_j)=b_k$</li><li>Bellman-Ford可以求解</li></ul><h1 id="所有结点对最短路"><a href="#所有结点对最短路" class="headerlink" title="所有结点对最短路"></a>所有结点对最短路</h1><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><ul><li>我不想管了！！</li><li>是$n$维的Bellman-Ford</li></ul><h2 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h2><ul><li>本质DP，枚举最短路径上的中间结点</li><li>不允许负权重环，但是能报错（看对角元是否有负数）</li><li>$\Theta(n^3)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(); <span class="comment">//记得将所有map[i][i]置零</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) </span><br><span class="line">                <span class="built_in">map</span>[i][j] = min(<span class="built_in">map</span>[i][j], <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Johnson算法"><a href="#Johnson算法" class="headerlink" title="Johnson算法"></a>Johnson算法</h2><ul><li>用于稀疏图</li><li>重新赋值<ul><li>新增源点$s$，该点与各点有权重为0的边</li><li>先跑一次Bellman-Ford，没有负权重环就重新赋值为$\hat{w}(u,v)=w(u,v)+\delta(s,u)-\delta(s,v)$</li><li>对每个点Dijkstra</li><li>恢复权重并返回</li></ul></li><li>$O(VE\lg E)$</li></ul><h1 id="连通度"><a href="#连通度" class="headerlink" title="连通度"></a>连通度</h1><h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><ul><li>$v$与割边相连，则$v$是割点当且仅当$deg~v\ge 2$</li><li>对于至少有3个顶点的连通图，只要有割边，就一定有割点</li><li>$v$是连通图$G$的割点，当且仅当存在两个不同的顶点$u$和$w$，使得$v$位于$u-w$的任意一条路径上</li><li>非平凡连通图中，距离某个点最远的点不是割点</li><li>任意非平凡连通图至少包含两个非割点的顶点</li><li>不可分图：没有割点的非平凡连通图</li></ul><h2 id="块"><a href="#块" class="headerlink" title="块"></a>块</h2><ul><li>图的一个最大不可分子图【类比连通分量</li><li>任意两个不同块的性质<ul><li>不相交</li><li>至多一个公共点</li><li>如果有公共点，则该公共点为割点</li></ul></li></ul><h2 id="连通度-1"><a href="#连通度-1" class="headerlink" title="连通度"></a>连通度</h2><ul><li>$\kappa(G)$点连通度=最小顶点割基数</li><li>$\lambda(G)$边连通度=最小边割基数</li><li>点连通度$\le$边连通度$\le$最小度数    <ul><li>$\kappa(G)\le \lfloor\frac{2m}{n}\rfloor$</li></ul></li></ul><h2 id="Menger定理"><a href="#Menger定理" class="headerlink" title="Menger定理"></a>Menger定理</h2><ul><li>设$u$和$v$是$G$中两个不邻接的顶点，则$u-v$的最小分离集的顶点个数等于内部不相交$u-v$路的最大个数</li><li><p>类似的有边定理：分离$u-v$的边的最小个数等于边不相交$u-v$路的最大个数</p></li><li><p>$k$连通当且仅当任意两个顶点至少有$k$条内部不相交路</p></li><li>$k$连通图中任意$k$个顶点均位于某一个圈上</li></ul><h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*无向图tarjan*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">    dfs_clock ++;</span><br><span class="line">    dfn[u] = low[u] = dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;<span class="comment">//(u,v)是树边</span></span><br><span class="line">            tarjan(v,u);</span><br><span class="line">            child ++;</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>((u == <span class="number">1</span> &amp;&amp; child &gt; <span class="number">1</span>) || (u != <span class="number">1</span> &amp;&amp; dfn[u] &lt;= low[v])) &#123;</span><br><span class="line">                cut_node.push_back(u);</span><br><span class="line">            &#125;<span class="comment">//割点判定：根结点有多个子树，或非根结点的访问序数小于等于能回溯的最大祖先</span></span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u]) bridge.push_back(&#123;min(u,v), max(u,v)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v !=  pre) low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="旅行问题"><a href="#旅行问题" class="headerlink" title="旅行问题"></a>旅行问题</h1><h2 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h2><ul><li>欧拉回路【闭合】/欧拉迹</li><li>有欧拉回路才算欧拉图</li><li>一个非平凡连通图是Euler的 当且仅当它的每个顶点的度都为偶数</li><li>有欧拉迹当且仅当只有两个奇度点</li></ul><h2 id="哈密尔顿图"><a href="#哈密尔顿图" class="headerlink" title="哈密尔顿图"></a>哈密尔顿图</h2><ul><li>哈密尔顿圈/哈密尔顿路</li><li>性质<ul><li>$G$的任一非空子集$S$，都有$k(G-S)\ge |S|$（$G$是哈密尔顿图，$k(G)$指图$G$的连通分支数）</li></ul></li><li>充分条件<ul><li>(Ore定理)对于不少于3个顶点的图，任意两个不邻接的顶点度数之和大于等于$n$，则$G$是哈密尔顿的。</li><li>推论：每个点的度数大于等于$n/2$</li><li>$u$和$v$是不邻接的两个顶点，且度数之和大于等于$n$，则$G+uv$是哈密尔顿的当且仅当$G$是哈密尔顿的</li><li>一个图是哈密尔顿的当且仅当它的闭包是哈密尔顿的</li><li>对于每个整数$j(1\le j\le n/2)$，$G$中度数至多为$j$的顶点数小于$j$，则$G$是哈密尔顿的</li></ul></li></ul><h1 id="匹配与覆盖"><a href="#匹配与覆盖" class="headerlink" title="匹配与覆盖"></a>匹配与覆盖</h1><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><ul><li>Hall条件：$\forall X\subseteq U, |N(X)\ge |X|$</li><li>婚姻定理：$r$个女人，$s$个男人，可能出现$r$对婚姻当且仅当对任意$k$，任意$k$个女人共认识至少$k$个男人。</li><li>最大匹配</li><li>完美匹配：阶为$2k$的图存在一个基数为$k$的匹配</li><li>任意$r$正则二部图均有一个完美匹配</li></ul><h2 id="独立性参数"><a href="#独立性参数" class="headerlink" title="独立性参数"></a>独立性参数</h2><ul><li>最大边独立数$\alpha’(G)$</li><li>最下边覆盖数$\beta’(G)$</li><li>最大点独立数$\alpha’(G)$</li><li>最小点覆盖数$\beta(G)$</li><li>Gallai恒等式<ul><li>点独立数+点覆盖数=$n$</li><li>边独立数+边覆盖数=$n$</li></ul></li><li>一般独立集比覆盖集好求</li></ul><h2 id="因子分解"><a href="#因子分解" class="headerlink" title="因子分解"></a>因子分解</h2><ul><li>$r-$因子：图$G$的$r-$正则生成图</li><li>完美匹配产生1-因子</li><li>图$G$包含1-因子当且仅当对于$V(G)$的任意真子集$S$,$k_O(G-S)\le |S|$。($k_O(G)$表示$G$的奇连通分支个数)</li><li>Petersen定理：所有无割边的3-正则图包含1-因子</li><li>任一至多有两条割边的3-正则图包含1-因子</li><li>可因子分解：能划分成多个因子</li><li>Petersen图不可1-因子分解</li></ul><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">0</span> || find(match[i])) &#123;</span><br><span class="line">                match[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span> ,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(find(i)) ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li>$f:V\times V\to\mathbb{R}$</li><li><strong>容量限制</strong>：$0\le f(u,v)\le c(u,v)$</li><li><strong>流量守恒</strong>：$\forall u\in V-s,t, \sum\limits<em>{v\in V}f(u,v)=\sum</em>\limits_{v\in V}f(v,u)$【流入=流出】</li><li>流的值$|f|=\sum\limits<em>{v\in V}f(s,v)-\sum\limits</em>{v\in V}f(v,s)$(从源结点流出的总流量-流入源结点的总流量)</li></ul><h2 id="几种特殊处理"><a href="#几种特殊处理" class="headerlink" title="几种特殊处理"></a>几种特殊处理</h2><ul><li>反平行边：拆其中一条边为两条边</li><li>多源多汇</li></ul><h2 id="残存网络"><a href="#残存网络" class="headerlink" title="残存网络"></a>残存网络</h2><p>残存容量</p><script type="math/tex; mode=display">c_f=(u,v)=\begin{cases}c(u,v)-f(u,v) & (u,v)\in E \\f(v,u) & (v,u)\in E\\0 & o.w.</script><h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><ul><li>把$V$划分为$S$和$T$两个集合，其中$s\in S, t\in T$</li><li>横跨该切割的净流量：$f(S,T)=\sum\limits<em>{u\in S}\sum\limits</em>{v\in T}f(u,v)-\sum\limits<em>{u\in S}\sum\limits</em>{v\in T}f(v,u)$【所有结点对的流量之和</li><li>切割的容量：$c(S,T)=\sum\limits<em>{v\in S}\sum\limits</em>{v\in T}c(u,v)$【只考虑$S$出发进入$T$的容量</li><li>最小切割：容量最小的切割</li><li>最大流最小割定理</li></ul><h2 id="网络流解决最大匹配"><a href="#网络流解决最大匹配" class="headerlink" title="网络流解决最大匹配"></a>网络流解决最大匹配</h2><ul><li>一个集合连$s$，一个集合连$t$，两个集合间两两连，每条边都是单位容量</li><li>$O(VE)$</li></ul><h1 id="图论证明方法"><a href="#图论证明方法" class="headerlink" title="图论证明方法"></a>图论证明方法</h1><p>解题时可能会用到一个或多个</p><ul><li>反证法</li><li>构造法</li><li>临界法(最小/最大的满足条件的一个图)</li><li>归纳法</li><li>算两次</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;最优子结构&quot;&gt;&lt;a href=&quot;#最优子结构&quot; class=&quot;headerlink&quot; title=&quot;最优子结构&quot;&gt;
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
  </entry>
  
</feed>
