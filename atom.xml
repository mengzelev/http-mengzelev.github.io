<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengzelev&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mengzelev.github.io/"/>
  <updated>2019-01-07T11:15:17.436Z</updated>
  <id>https://mengzelev.github.io/</id>
  
  <author>
    <name>Mengzelev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lab4 实验报告</title>
    <link href="https://mengzelev.github.io/2018/12/29/lab4-report/"/>
    <id>https://mengzelev.github.io/2018/12/29/lab4-report/</id>
    <published>2018-12-29T09:22:55.000Z</published>
    <updated>2019-01-07T11:15:17.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验进度描述"><a href="#实验进度描述" class="headerlink" title="实验进度描述"></a>实验进度描述</h1><p>我已完成所有内容。</p><p>以下是可以忽略的碎碎念：</p><ul><li>实验开始一小时：写代码；实验开始两小时推翻前一个小时写的代码；实验开始四小时：推翻前两小时写的代码……</li><li>会发生上面的情况其实是因为写<code>cache_read</code>的时候觉得调入调出可以封装为函数，写到<code>cache_write</code>的时候觉得<code>cache_read</code>里的寻找比对、缺失处理都可以封装成函数。在写PA的时候深受Copy-paste其害，所以想把能共享的代码都尽量封装成函数，减轻debug的痛苦</li><li>测试的时候曾经出现过写过的地址从cache调出之后回写到内存不成功。加了回写检查函数<code>check_write_back()</code>依然没有定位错误。出去吹了冷风突然意识到可能是回写的内存地址算错了。回去一看发现是cache装入的时候tag没有更新。结论：吹冷风调试法真有用</li><li>一开始在虚拟机里用vim写的时候，为了区分变量，都取了超长的名字，打起来很累，后来无奈先在windows里用CLion打开写了基本框架再放到Linux里进行调试(因为虚拟机里开CLion会卡爆)。CLion写代码真的是体验极佳，下学期OSLab双系统走起了</li><li>我个**！！！第一遍做完数据没用给定的trace！第二遍做的数据被我一个手抖永久删除了！！！excel还没办法脚本导入！！！一个数据做了3遍！！！</li></ul><h1 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h1><p>为了提高代码的复用率、降低debug负担，我封装了很多API。</p><ul><li>为了模拟cache结构定义了如下结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CacheLine</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid; <span class="comment">//有效位</span></span><br><span class="line">    <span class="keyword">bool</span> dirty; <span class="comment">//脏位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag; <span class="comment">//标记位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> data[<span class="number">16</span>]; <span class="comment">//一行64B数据</span></span><br><span class="line">&#125;line[<span class="number">1024</span>];</span><br></pre></td></tr></table></figure><ul><li>定义了如下全局变量来记录cache的相关信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* cache info */</span></span><br><span class="line"><span class="keyword">int</span> ass_width; <span class="comment">//关联宽度</span></span><br><span class="line"><span class="keyword">int</span> total_width; <span class="comment">//总宽度</span></span><br><span class="line"><span class="keyword">int</span> group_width; <span class="comment">//组宽度(指cache组号在主存地址中的位数)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_ASS exp2(ass_width) <span class="comment">//宏定义，组内行数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET  0x3f <span class="comment">//与操作后可以取出块内偏移量</span></span></span><br></pre></td></tr></table></figure><p>将以下功能封装为了API。因为宏定义会涉及到加括号等问题，怕出现奇奇怪怪的bug，所以并没有使用宏定义，而是直接用函数代替</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> get_tag(<span class="keyword">uintptr_t</span> addr) &#123;</span><br><span class="line"><span class="comment">//获得一个内存地址的tag字段</span></span><br><span class="line">    <span class="keyword">return</span> (addr &gt;&gt; (group_width + BLOCK_WIDTH));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> get_group(<span class="keyword">uintptr_t</span> addr) &#123;</span><br><span class="line">    <span class="comment">//获得一个内存地址的cache组号字段</span></span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; BLOCK_WIDTH) &amp; mask_with_len(group_width));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_in</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">int</span> line_num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将主存中某一块调入cache中</span></span><br><span class="line">assert(line[line_num].valid == <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">uint32_t</span> block_num = addr &gt;&gt; BLOCK_WIDTH;</span><br><span class="line">mem_read(block_num, (<span class="keyword">uint8_t</span>*)(line[line_num].data));</span><br><span class="line">line[line_num].valid = <span class="literal">true</span>;</span><br><span class="line">line[line_num].dirty = <span class="literal">false</span>;</span><br><span class="line">line[line_num].tag = get_tag(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_out</span><span class="params">(<span class="keyword">int</span> group_num, <span class="keyword">int</span> line_num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将cache的某一行调回到主存中，同时判断dirty bit并写回</span></span><br><span class="line">assert(line[line_num].valid == <span class="literal">true</span>);</span><br><span class="line">assert(line_num &lt; <span class="number">1024</span>);</span><br><span class="line">line[line_num].valid = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(line[line_num].dirty) &#123;</span><br><span class="line"><span class="keyword">uintptr_t</span> block_num = (line[line_num].tag &lt;&lt; group_width) + group_num;</span><br><span class="line"></span><br><span class="line">mem_write(block_num, (<span class="keyword">uint8_t</span>*)line[line_num].data);</span><br><span class="line">line[line_num].dirty = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//write back</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_in_group</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">int</span> group_num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//在某一组寻找找某主存地址对应的行，返回其所在行号，缺失则返回-1</span></span><br><span class="line"><span class="keyword">int</span> group_start = group_num * NR_ASS;</span><br><span class="line"><span class="keyword">int</span> group_end = group_start + NR_ASS;</span><br><span class="line"><span class="keyword">uint32_t</span> tag = get_tag(addr);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = group_start; i &lt; group_end; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(line[i].valid &amp;&amp; line[i].tag == tag) &#123;</span><br><span class="line">cycle_increase(<span class="number">1</span>);</span><br><span class="line">hit_visit ++;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">replace_in_group</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">int</span> group_num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将主存地址对应的主存块调入cache中</span></span><br><span class="line">miss_visit ++;</span><br><span class="line"><span class="keyword">int</span> group_start = group_num * NR_ASS;</span><br><span class="line"><span class="keyword">int</span> group_end = group_start + NR_ASS;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = group_start; i &lt; group_end; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(!line[i].valid) &#123;</span><br><span class="line">move_in(addr, i);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果组内有空行，则直接放入空行中</span></span><br><span class="line"><span class="keyword">int</span> line_out = group_start + choose(NR_ASS);</span><br><span class="line">assert(line_out &lt; group_end);</span><br><span class="line"></span><br><span class="line">move_out(group_num, line_out);</span><br><span class="line">move_in(addr, line_out);</span><br><span class="line"><span class="comment">//否则随机替换一行</span></span><br><span class="line"><span class="keyword">return</span> line_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_in_line</span><span class="params">(<span class="keyword">int</span> line_num, <span class="keyword">int</span> index, <span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> wmask)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将数据写入cache某一行的某个index中</span></span><br><span class="line">line[line_num].dirty = <span class="literal">true</span>;</span><br><span class="line">line[line_num].data[index] &amp;= (~wmask);</span><br><span class="line">line[line_num].data[index] |= (data &amp; wmask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样一来需要实现的3个函数只需要调用以上API即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">(<span class="keyword">int</span> total_size_width, <span class="keyword">int</span> associativity_width)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*设置cache的一系列参数*/</span></span><br><span class="line">total_width = total_size_width;</span><br><span class="line">assert(total_width &lt;= <span class="number">14</span>);</span><br><span class="line">ass_width = associativity_width;</span><br><span class="line">group_width = total_width - ass_width - BLOCK_WIDTH;</span><br><span class="line"><span class="comment">/*初始化用于统计的变量*/</span></span><br><span class="line">cycle_cnt = <span class="number">0</span>;</span><br><span class="line">total_visit = hit_visit = miss_visit = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* set all the valid bits and dirty bits to invalid */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NR_LINE; ++i) line[i].valid = line[i].dirty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> cache_read(<span class="keyword">uintptr_t</span> addr) &#123;</span><br><span class="line">total_visit ++;</span><br><span class="line"><span class="keyword">uint32_t</span> group_num = get_group(addr);</span><br><span class="line"><span class="keyword">uint32_t</span> index = (addr &amp; OFFSET) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">//index in group</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line_num = find_in_group(addr, group_num);</span><br><span class="line"><span class="keyword">if</span>(line_num &gt;= <span class="number">0</span>) <span class="keyword">return</span> line[line_num].data[index];</span><br><span class="line"><span class="comment">//hit则直接读出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line_out = replace_in_group(addr, group_num);</span><br><span class="line"><span class="keyword">return</span> line[line_out].data[index];</span><br><span class="line"><span class="comment">//否则从主存调入cache</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_write</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> wmask)</span> </span>&#123;</span><br><span class="line">total_visit++;</span><br><span class="line"><span class="keyword">uint32_t</span> group_num = get_group(addr);</span><br><span class="line"><span class="keyword">uint32_t</span> index = (addr &amp; OFFSET) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">//index in group</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line_num = find_in_group(addr, group_num);</span><br><span class="line"><span class="keyword">if</span>(line_num &gt;= <span class="number">0</span>) </span><br><span class="line">write_in_line(line_num, index, data, wmask);</span><br><span class="line"><span class="comment">//hit则直接写入</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> line_out = replace_in_group(addr, group_num);</span><br><span class="line">write_in_line(line_out, index, data, wmask);</span><br><span class="line">&#125;<span class="comment">//否则写分配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="cache性能测试"><a href="#cache性能测试" class="headerlink" title="cache性能测试"></a>cache性能测试</h1><h1 id="运行时间测算"><a href="#运行时间测算" class="headerlink" title="运行时间测算"></a>运行时间测算</h1><ul><li>框架代码已经给内存的读写赋好了相应的时钟周期数，所以我很自然地想到通过统计<strong>时钟周期数</strong>来统计运行的时间</li><li>关于怎么对cache读写操作的时钟周期测算，讲义说可以建立关于关联度的带参数的模型，但是我回想起来课本上讲过，组相联组内是用了很多比较器进行<strong>并行</strong>比较的。所以我认为读写的时钟周期数应该和关联度以及cache容量关系不大，所以将读写的时钟周期都设置为1。<s>&gt;可能也有想省事的惰性成分在里面</s></li><li>除时钟周期数外，还衡量一个缺失率。由于主存读写比cache读写慢得多，读写命中率也能表征cache的性能</li></ul><p>声明了一些用于统计的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* statistics */</span></span><br><span class="line"><span class="keyword">uint64_t</span> total_visit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> hit_visit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> miss_visit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>测算方法：控制变量法，控制组相联度或cache总宽度其中一个量不变，改变另外一个量。每种配置测量3次后取平均。根据结果使用excel作图，得到如下结果。【数据已经放在打包上传的.xlsx文件中】</li></ul><center><br><img src="/2018/12/29/lab4-report/miss-width.png"><br><img src="/2018/12/29/lab4-report/clk-width.png"><br><img src="/2018/12/29/lab4-report/miss-ass.png"><br><img src="/2018/12/29/lab4-report/clk-ass.png"><br></center><p>从以上数据和图表中可以看出：</p><ul><li>cache容量越大，缺失率越低，花费的总时钟周期数也越少。这是因为cache容量大了以后，能装入更多的主存块，缺失率就会相应地降低，需要进行替换的次数也会变少。但是cache大就意味着高昂的造价，而且SDRAM的材质(?)决定了cache不可能做到很大。而且由图中可以看出，当cache容量增大到一定大小时，其性能增长就很不明显了，因此一般会选择比较中等的大小。</li><li><p>缺失率与组相联度似乎并不是呈单调关系。原理上分析，组相联度越大，同一组内发生冲突的概率就越低，需要调出的次数也会越低。但有可能microbench-test中的访存顺序会导致某些经常访问的块，在相联度较小时被放到了不同的组中，而相联度较大时被放到了同一组中，导致发生冲突的次数增加。而且越高的组相联度，意味着越多的比较器，意味着更大的体积和更高的造价。</p></li><li><p>综上，对于microbench-test下的workload，我认为最佳的组相联宽度是2(4路组相联)。如果有钱任性，cache容量越大越好；如果要省钱经济，12或13的容量宽度(4KB或8KB的容量)是比较理想的。</p></li></ul><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h1 id="数据对齐和存储层次结构"><a href="#数据对齐和存储层次结构" class="headerlink" title="数据对齐和存储层次结构"></a>数据对齐和存储层次结构</h1><ul><li>如果没有对齐，同一个数据可能会被分配再两个主存块的交界处，读取这个数据的时候发生cache miss的概率更大，cache miss后可能需要调入两个主存块，代价更大，运行速度会大大降低。</li></ul><h1 id="不知道cache的复杂性对频率的影响"><a href="#不知道cache的复杂性对频率的影响" class="headerlink" title="不知道cache的复杂性对频率的影响?"></a>不知道cache的复杂性对频率的影响?</h1><ul><li>我不是很看得懂这里的建模的意思。我认为$ak^2+b$中%a,b$只是两个参数，考察它们对cache性能的影响是没有意义的，而是应该固定$a,b$，考察组相联度和cache容量对cache性能的影响。但是我已经在上文提到了我并没有把这两者与cache的读写速度关联起来。所以我没有建立带参数的模型。</li></ul><h1 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h1><ul><li>感谢不水的正经学习群的朋友们当我的小黄鸭，帮我调试</li><li>感谢*<em>的自己，因为一系列\</em>*行为，成功锻炼了心理承受能力</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验进度描述&quot;&gt;&lt;a href=&quot;#实验进度描述&quot; class=&quot;headerlink&quot; title=&quot;实验进度描述&quot;&gt;&lt;/a&gt;实验进度描述&lt;/h1&gt;&lt;p&gt;我已完成所有内容。&lt;/p&gt;
&lt;p&gt;以下是可以忽略的碎碎念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实验开始一小时：写代码
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
  <entry>
    <title>PA4实验报告</title>
    <link href="https://mengzelev.github.io/2018/12/28/PA4-report/"/>
    <id>https://mengzelev.github.io/2018/12/28/PA4-report/</id>
    <published>2018-12-28T08:00:32.000Z</published>
    <updated>2019-01-07T11:13:04.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h2><p>我已完成全部实验内容。</p><p>2018/12/15:<br>完成PA4.1。不少自认为关键的地方竟然怎么改都是对的，有点慌</p><p>2018/12/16:<br>PA4.2第一个任务完成，再不开始做数电大实验就要死了，只能封印PA</p><p>2018/12/23：<br>被数电大实验折磨完，PA4.2完成。仙剑跑得慢到感人。</p><p>2018/12/24：<br>平安夜，发现4.2最后一个task忘了跑了，定位了半天bug发现是<code>context_kload</code>忘了改成<code>context_uload</code>，心情简单。开始做4.3，但是由于前几天睡眠不足连着写了好几个沙雕bug，于是决定先放弃。</p><p>2018/12/25：<br>圣诞节，继续写PA4.3，花了一个小时解决了平安夜昏睡状态下写出的沙雕bug，花了4个小时解决了当天写出的沙雕bug，也就是PA最后一个bug。PA通关!</p><h2 id="蓝框思考题"><a href="#蓝框思考题" class="headerlink" title="蓝框思考题"></a>蓝框思考题</h2><p>迫于作业和复习考试压力，这次也一道都没做……</p><h2 id="我遇到的bug"><a href="#我遇到的bug" class="headerlink" title="我遇到的bug"></a>我遇到的bug</h2><ul><li>没看到讲义上要求把<code>loader</code>把文件映射到物理页的要求，映射到虚拟页上，结果一直出发<code>pte.present==0</code>的assert。仔细一想<code>loader</code>的确有义务把程序搬到合适的实际位置</li><li>即使是一个简单的dummy程序，其内容也有两页多。而且不能直接用文件大小/PGSIZE，否则余数部分会被丢弃</li><li><code>make run</code>的时候可能会碰到一大堆链接报错，原因不明，目前解决方案是在所有目录下都来一遍<code>clean(-update)-run</code>全家桶。<s>这时候调试公理1是不是被打破了呢？</s></li><li><code>_switch</code>是用来切换到下一个进程的，因此传入参数肯定为<code>next</code>而非<code>tf</code>【这不是我遇到的bug，是我不少同学都遇到的bug，所以也记下来了</li><li>增加时钟中断时需要填写idt表，太久没碰系统调用这个都忘了</li><li>4.3最后测试进程切换的时候千万不要因为嫌仙剑跑得太慢换成<code>bmptest</code>，这玩意儿是根本block了<code>events_read()</code>的，导致我debug了4个小时才发现</li></ul><h2 id="实验中的发现"><a href="#实验中的发现" class="headerlink" title="实验中的发现"></a>实验中的发现</h2><ul><li>与<code>cr3</code>和<code>cr0</code>有关的指令的译码函数其实可以使用框架代码提供的现成的译码函数,只不过需要研究一下怎么使用</li><li>在写<code>_map</code>函数时，我思考了很久，为什么当页目录的present位无效时，要用回调函数申请一个新的物理页。觉得应该是把这一页作为了存放页表的物理页</li><li>一些头文件里有不少讲义没提到的、可以方便coding的宏定义，例如<code>x86.h</code>和<code>mmu.h</code>,论RTFSC的重要性</li></ul><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ul><li>一定要好好读讲义</li><li>和同学交流了一下，发现不一定要全部理解了再开始写代码。可以把框架代码中提供的东西输出一下，根据输出的值来猜测这个变量的含义，或者这个函数的功能。做实验和理解理论是相辅相成的</li><li>每次开机，看着一行行初始化Log，就会想到这只是一个比我刚刚造完的<s>(其实大部分都是yzh写的)</s>的东西复杂一点<s>(这个一点有点多)</s>的家伙，就觉得五味杂陈</li><li>迫于时间压力不少挑战极限的选做题都没做</li><li>这学期做PA还是依赖了不少人的帮助，寒假想要二周目并完成PA5，希望也能把不少选做题都做一下</li></ul><h1 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h1><ul><li>感谢某人提供的探路和盯着写bug服务</li><li>感谢不水的正经学习群的群友们互帮互助的debug氛围</li></ul><p>本实验报告同样会将去掉必答题的版本同步上传至<a href="https://mengzelev.github.io/">个人blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验进度&quot;&gt;&lt;a href=&quot;#实验进度&quot; class=&quot;headerlink&quot; title=&quot;实验进度&quot;&gt;&lt;/a&gt;实验进度&lt;/h2&gt;&lt;p&gt;我已完成全部实验内容。&lt;/p&gt;
&lt;p&gt;2018/12/15:&lt;br&gt;完成PA4.1。不少自认为关键的地方竟然怎么改都是对的，
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
      <category term="ICS" scheme="https://mengzelev.github.io/tags/ICS/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-矩阵运算</title>
    <link href="https://mengzelev.github.io/2018/12/18/clrs28Matrix-Operation/"/>
    <id>https://mengzelev.github.io/2018/12/18/clrs28Matrix-Operation/</id>
    <published>2018-12-18T01:50:18.000Z</published>
    <updated>2019-01-07T11:16:02.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h1><p>$$Ax=b$$<br><strong>欠定的(underdetermined)</strong>：方程的数目少于未知变量数目$n$，则该线性方程组为欠定的<br><strong>超定的(overdetermined)</strong>:方程数目超过未知变量数目$n$<br><strong>非奇异矩阵</strong>：$A$的秩等于未知变量的个数$n$</p><h2 id="LUP分解"><a href="#LUP分解" class="headerlink" title="LUP分解"></a>LUP分解</h2><p>思想：找出3个$n\times n$矩阵$L,U,P$，满足$PA=LU$,其中<br>$L$是一个单位下三角矩阵<br>$U$是一个上三角矩阵<br>$P$是一个置换矩阵<br>每一个非奇异矩阵$A$都会有这样一种分解<br>$$Ax=b$$<br>$$PAx=Pb$$<br>$$LUx=Pbx$$<br>求解两个三角线性系统<br>下三角系统$Ly=Pb$<br>上三角系统$Ux=y$</p><h2 id="正向替换与方向替换"><a href="#正向替换与方向替换" class="headerlink" title="正向替换与方向替换"></a>正向替换与方向替换</h2><p>可在$\Theta(n^2)$时间内求解下三角系统</p><p>置换阵$P$可以用数组$\pi[1..n]$表示<br>$$P_{i,j}=<br>\begin{cases}<br>1 &amp; (j == \pi[i])\<br>0 &amp; (j\neq\pi[i])<br>\end{cases}<br>$$<br>从第一个式子开始正向替换，可以得到<br>$$y_i=b_{\pi[i]}-\sum\limits_{j=1}^{i-1}l_{ij}y_i$$</p><p>反向替换同理，最终可以得到<br>$$x_i=(y_i-\sum\limits_{j=i+1}^{n}u_{ij}x_j)/u_{ii}$$</p><p><img src="/2018/12/18/clrs28Matrix-Operation/LUP-SOLVE.png"></p><h2 id="LU分解计算"><a href="#LU分解计算" class="headerlink" title="LU分解计算"></a>LU分解计算</h2><p>Gauss消元法：</p><ul><li>行消元得到的行梯阵即$U$</li><li>$L$由消去变量所用的行的乘数组成</li></ul><p><img src="/2018/12/18/clrs28Matrix-Operation/1.png"><br><img src="/2018/12/18/clrs28Matrix-Operation/2.png"></p><p><img src="/2018/12/18/clrs28Matrix-Operation/LU-DE.png"></p><p>可以看成$$a_{ij}=a_{ij}-\frac{a_{ik}a_{kj}}{a_{kk}}$$</p><p>运行时间$\Theta(n^3)$</p><h2 id="LUP分解计算"><a href="#LUP分解计算" class="headerlink" title="LUP分解计算"></a>LUP分解计算</h2><p>在LU分解的基础上，为了保证除数不为0和减少数值不稳定，每次选择该列中具有最大绝对值的元素，交换到对角元的位置</p><p><img src="/2018/12/18/clrs28Matrix-Operation/LUP-DE.png"></p><p>运行时间$\Theta(n^3)$</p><h1 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h1><p>LUP分解可以用于计算逆矩阵(废话，高斯消元可以，LUP当然可以)$$AX_{i}=e_i$$</p><p>矩阵乘法和矩阵求逆具有相同的时间复杂度</p><p>证明时间复杂度相同：两个问题都能在O(另一个问题算法的时间复杂度)时间内解决</p><ul><li>证明的时候可能会用到分块阵的思想来转化问题</li></ul><h1 id="对称正定阵"><a href="#对称正定阵" class="headerlink" title="对称正定阵"></a>对称正定阵</h1><p><strong>引理28.3</strong>：任何对称正定矩阵都是非奇异矩阵<br>任何对称正定矩阵都有逆矩阵。</p><p><strong>引理28.4</strong>：如果$A$是一个对称正定矩阵，那么$A$的每一个主子矩阵都是对称正定的。</p><p><strong>舒尔补</strong>：矩阵$A$关于主子矩阵$A_k$的舒尔补为$S=C-B{A_k}^{-1}B^T$。其中，$A$为对称正定阵且<br>$$A=\left[<br>    \begin{matrix}<br>    A_k &amp; B^T \<br>    B &amp; C<br>    \end{matrix}<br>    \right]$$</p><p><strong>舒尔补定理</strong>：如果$A$是一个对称正定矩阵，$A_k$是$A$的$k\times k$主子矩阵，那么$A$关于$A_k$的舒尔补是对称正定的。</p><p><strong>推论28.6</strong>：一个对称正定矩阵的LU分解永远不会出现除数为0的情形</p><h1 id="最小二乘逼近"><a href="#最小二乘逼近" class="headerlink" title="最小二乘逼近"></a>最小二乘逼近</h1><p>就是看上去很厉害实际上真的很厉害的曲线拟合</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求解线性方程组&quot;&gt;&lt;a href=&quot;#求解线性方程组&quot; class=&quot;headerlink&quot; title=&quot;求解线性方程组&quot;&gt;&lt;/a&gt;求解线性方程组&lt;/h1&gt;&lt;p&gt;$$Ax=b$$&lt;br&gt;&lt;strong&gt;欠定的(underdetermined)&lt;/strong&gt;：
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-平面图与着色</title>
    <link href="https://mengzelev.github.io/2018/12/13/planar-graph-and-coloring/"/>
    <id>https://mengzelev.github.io/2018/12/13/planar-graph-and-coloring/</id>
    <published>2018-12-13T06:30:30.000Z</published>
    <updated>2018-12-15T03:40:57.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h1><p><strong>平面图(planar graph)：</strong>如果$G$能够被画在一个平面上而使得任何两条边都不会交叉</p><p><strong>平图(plane graph)</strong>：如果$G$是平面图且$G$的任何两条边都不交叉</p><p>平面图的例子：cycle, path, star, tree</p><p><strong>区域(regions)</strong>：一个平图把平面分成一些连通片<br><strong>外区域(exterior region)</strong>：每个平图中总有的一个无界的区域<br><strong>边界(boundary)</strong>：在一个平图中，顶点和边斗鱼某个给定区域$R$关联的子图称为是$R$的边界</p><p>割边总是恰好在一个区域的边界上<br>非割边一定位于两个区域的边界上</p><p>如果$G$是一个至少含有三条边的连通平图，则$G$的而每个区域的边界至少含有三条边</p><p><strong>定理9.1(Euler恒等式)</strong>：如果$G$是一个阶为$n$，边数为$m$且含有$r$个区域的连通平图，则$n-m+r=2$</p><p><strong>定理9.2</strong>：如果$G$是一个阶为$n\ge 3$且边数为$m$的平面图，则$m\le 3n-6$。(平面图的必要条件，非平面图的充分条件)<br>逆否命题：设$G$阶为$n$，若$m&gt;3n-6$，则$G$是非平面图。<br>注：满足$m\le 3n-6$的不一定是平面图</p><p><strong>推论9.3</strong>：每个平面图含有一个度小于或等于5的顶点。</p><p><strong>推论9.4</strong>：完全图$K_5$是非平面的。</p><p><strong>极大平面的(maximal planar)</strong>：若$G$是平面的，且在$G$的任意两个不邻接的顶点之间添加一条边即可产生一个非平面图。<br>另一种表述：$G$是平面的，但$G$不是任何一个平面图的生成子图<br>极大平面图满足$m=3n-6$</p><p><strong>定理9.5</strong>：图$K_{3,3}$是非平面的</p><p><strong>细分(subdivision)</strong>： 如果有一个或多个度为2的顶点被插入到$G$的一条或多条边中，则称图$G’$是图$G$的一个细分</p><p><strong>定理9.7(Kuratowski定理)</strong>：一个图$G$是平面图当且仅当$G$不含$K_5$，$K_{3,3}$，或者$K_5$或$K_{3,3}$的一个细分作为子图。</p><p>如果一个图$G$含有(1)至多4个度大于或等于4的顶点(2)至多5个度大于或等于3的顶点，则$G$必定是平面的。</p><h1 id="顶点染色"><a href="#顶点染色" class="headerlink" title="顶点染色"></a>顶点染色</h1><p><strong>对偶(dual)</strong>：每张地图都有一个与之关联的图$G$，称为该地图的对偶，其中$G$的顶点即为地图的区域，$G$的两个顶点是邻接的当且仅当它们所对应的区域是相邻的<br>每张地图的对偶图都是平面图，每个连通的平面图都是某个地图的对偶。</p><p><strong>真染色(proper coloring)</strong>：给$G$的顶点分配一些颜色(来自于某个颜色集合)，是的每个顶点都能分配到一种颜色，且邻接的顶点被染成不同的颜色，简称为<strong>染色(coloring)</strong></p><p><strong>色数(chromatic number)$\chi(G)$</strong>：在$G$的所有染色中，所用的最少颜色数</p><p><strong>$k$可染色的(k-colorable)</strong>：如果能用一个含有$k$种颜色的集合给$G$的顶点染色，则称$G$是$k$<strong>可染色的(k-colorable)</strong>，应用$k$种颜色的染色称为是<strong>$k$染色(k-coloring)</strong>。</p><p>若$\chi(G)=k$，则$G$也称为是<strong>$k$色的(k-chromatic)</strong>，并且$G$的每个$k$染色都是$G$的<strong>最小染色(minimum coloring)</strong></p><p><strong>定理10.1(四色定理)</strong>：每个平面图的色数至多是4</p><p><strong>色类(color classes)</strong>：若$G$是一个$k$色图，则可以把$V(G)$划分成$k$个独立集$V_1,V_2,…,V_k$，此时这些顶点集称为色类。</p><p><strong>定理10.2</strong>：图$G$的色数是2当且仅当$G$是一个非空的二部图。</p><p>(复习：<strong>定理1.12</strong>：图$G$是二部的当且仅当其不含奇圈)<br>若$G$含有奇圈，则$\chi(G)\ge 3$</p><p>$n$阶图$G$的色数为$n$当且仅当$G=K_n$</p><p>证明$\chi(G)=k$，必须证明：</p><ul><li>至少需要$k$种颜色来为$G$染色(不能用$k-1$种颜色为$G$染色)</li><li>存在$G$的一个$k$染色</li></ul><p>若$H$为$G$的一个子图，则$\chi(H)\le\chi(G)$</p><p><strong>团(clique)</strong>：$G$的一个完全子图<br><strong>团数(clique number)\omega(G)</strong>：图$G$中最大团的阶数<br>$\alpha(G)=k$当且仅当$\omega(G)=k$</p><p><strong>定理10.5</strong>：对每个$n$阶图$G$：$$\chi(G)\ge\omega(G), \chi(G)\ge\frac{n}{\alpha(G)}$$<br>(给出了图$G$的色数的下限)</p><p>图$G$的染色可以看成是$V(G)\to\mathbb{N}$的一个函数$c:V(G)\to\mathbb{N}$，使得当$uv\in E(G)$时，$c(u)\neq c(v)$</p><p><strong>定理10.7</strong>：对于每个图$G$，$\chi(G)\le 1+\Delta(G)$。($\Delta(G)$为$G$的最大度)</p><p><strong>定理10.8(Brooks定理)</strong>：对每个非奇圈也非完全的连通图$G$，$\chi(G)\le\Delta(G)$</p><p><strong>定理10.9</strong>：对于每个图$G$,$\chi(G)\le 1+\max{\delta(H)}$，其中$\max$取遍$G$的所有诱导子图$H$。</p><p><strong>影子图(shadow graph)$S(G)$</strong>:通过在$G$中，对其每个顶点$v$，增加一个新的顶点$v’$，称之为$v$的<strong>影子顶点(shadow vertex)</strong></p><p><img src="/2018/12/13/planar-graph-and-coloring/shadow.png"></p><p><strong>定理10.10</strong>：对于每个整数$k\ge 3$，都存在一个色数为$k$的无三角的图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平面图&quot;&gt;&lt;a href=&quot;#平面图&quot; class=&quot;headerlink&quot; title=&quot;平面图&quot;&gt;&lt;/a&gt;平面图&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;平面图(planar graph)：&lt;/strong&gt;如果$G$能够被画在一个平面上而使得任何两条边都不会交叉&lt;/p
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>卫宫家今天的饭</title>
    <link href="https://mengzelev.github.io/2018/12/10/Dinner/"/>
    <id>https://mengzelev.github.io/2018/12/10/Dinner/</id>
    <published>2018-12-10T08:22:19.000Z</published>
    <updated>2018-12-10T09:43:06.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题源"><a href="#题源" class="headerlink" title="题源"></a>题源</h1><p>POJ 3281 Dining<br><a href="http://bailian.openjudge.cn/practice/3479/" target="_blank" rel="noopener">openjudge传送门</a><br><s>饱受OJ折磨的我决定以德报怨给大家出道水题</s></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>基本只是把原题搬到了月球上</p><ul><li>N位客人，F种食物，D种饮料</li><li>每位客人有多种喜欢的事物和饮料</li><li>每位客人只吃一种食物、只喝一种饮料</li><li>每种食物，每种饮料只能被一位客人吃/喝</li></ul><p>可以看成两个二分图最大匹配问题</p><h1 id="构建流网络"><a href="#构建流网络" class="headerlink" title="构建流网络"></a>构建流网络</h1><ul><li>先尝试：食物-客人-饮料 <ul><li>会出现一位客人对应多份食物或饮料的情况</li><li>客人结点需要加上结点容量</li><li>将每个客人结点拆分为两个</li></ul></li><li>源点s-食物-客人1-客人2-饮料-汇点</li></ul><h1 id="最大流算法"><a href="#最大流算法" class="headerlink" title="最大流算法"></a>最大流算法</h1><ul><li>数据规模[1,100]</li><li>EK完全OK</li><li>没有刻意生成卡任何算法的数据，也许可以尝试暴力</li><li>板子写起来有丶难度</li><li>代码虽然我贴了，但是务必自己写一遍！</li></ul><h1 id="EK板子"><a href="#EK板子" class="headerlink" title="EK板子"></a>EK板子</h1><p><img src="/2018/12/10/Dinner/ff.png"></p><ul><li><s>容量c[N][N]，流量f[N][N]</s></li><li>只需要一个记录当前残存容量的数组map[N][N]</li><li>随便搜一下就能找到</li></ul><h2 id="板子代码"><a href="#板子代码" class="headerlink" title="板子代码"></a>板子代码</h2><pre><code>int edmonds_karp() {    int ans = 0;    int minc;    while((minc = bfs()) != -1) { //bfs找到一条增广路径        ans += minc;    //加上这条增广路径的流量        int tt = t,pt;          while(tt != s) {            pt = pre[tt];            map[pt][tt] -= minc;            map[tt][pt] += minc;            tt = pt;        }   //修改这条增广路径上的边的残存容量    }    return ans;}</code></pre><h2 id="bfs寻找增广路径"><a href="#bfs寻找增广路径" class="headerlink" title="bfs寻找增广路径"></a>bfs寻找增广路径</h2><pre><code>int bfs(){    memset(pre, -1, sizeof(pre));    int minc = 1e9;    queue &lt;int&gt; q;    q.push(s);    while(!q.empty()){        int u = q.front();        q.pop();        if(u == t) break;        for(int i = 1; i &lt;= t; ++i) {            if(pre[i] == -1 &amp;&amp; map[u][i]) {                minc = min(minc, map[u][i]);                //更新当前路径的最小残存容量                q.push(i);                pre[i] = u;                 //pre数组用于记录bfs找到的增广路径            }        }    }    if(pre[t] == -1) return -1;    else return minc;}</code></pre><h2 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h2><p>代码不贴惹，自己写吧:)</p><p>Tips:<br>为了将各种不同类型的所有点都囊括在一个数组里的同时，增强代码的可读性，可以使用宏定义</p><pre><code>#define FOOD(x) **我**#define GUEST1(x) **是**#define GUEST2(x) **马**#define DRINK(x) **赛**#define s **克**#define t **!**</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题源&quot;&gt;&lt;a href=&quot;#题源&quot; class=&quot;headerlink&quot; title=&quot;题源&quot;&gt;&lt;/a&gt;题源&lt;/h1&gt;&lt;p&gt;POJ 3281 Dining&lt;br&gt;&lt;a href=&quot;http://bailian.openjudge.cn/practice/3479/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PA3实验报告</title>
    <link href="https://mengzelev.github.io/2018/12/08/PA3-report/"/>
    <id>https://mengzelev.github.io/2018/12/08/PA3-report/</id>
    <published>2018-12-08T08:00:32.000Z</published>
    <updated>2019-01-07T11:11:41.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h1><p>我已完成所有内容。<br>好，下面是惯例碎碎念。</p><p>2018/11/18<br>心态爆炸的一天！先是因为脑子短路完全没有想到<code>idt</code>的地址就在<code>lidt</code>译码过后的<code>id_dest</code>里。然后还因为惯性思维从<code>id_dest-&gt;val</code>里读地址，疯狂出错才发现应该在<code>id_dest-&gt;addr</code>里（因为是地址）。组织Context的时候思考了半天，最后问了大腿才知道怎么判断上下文的组织结构。感觉还是课本知识学得不够扎实的恶果。今日不宜PA，关机睡觉。</p><p>2018/11/19<br>PA3.1完成。感觉测试手段都不太给力，不知道有没有埋下隐藏bug</p><p>2018/11/24<br>PA3.2完成。感觉莫名顺利，可能是3.3要自闭的征兆</p><p>2018/12/1<br>开始自闭PA3.3，实现了文件读写操作，死活看不到PASS!!!，文件读写时对长度超过文件大小的情况的处理有一些麻烦，调了半天，最后发现是PA3.2时就好了的SYS_write没有加上刚刚写的<code>fs_write</code>，喷了。开始编写设备文件操作，看不懂vga那块到底是要干啥，机房关门了，回去睡觉。</p><p>2018/12/2<br>继续自闭PA3.3。为了看懂VGA那块的架构直接翻出了bmptest的源码，然后一路摸到NDL库的源码，花了大概一个下去终于显示出了ProjectN的Logo。实现<code>events_read()</code>时还把事件的格式搞错了debug了半天，终于可以开始跑仙剑了。小心翼翼地开始游戏，没有注释掉<code>Log</code>因此看到了瀑布般的<code>Log</code>信息，然后50min才播放完片头对话，所幸无事。然后注释掉了所有<code>Log</code>，又胆战心惊地开始尝试所有存档点，尝试了穿墙和穿人，全部失败，确认了没有肉眼可见的bug。长舒一口气，然后加急写完了批处理系统，机房关门，走人。难以置信我居然跑出了仙剑，亢奋。</p><h1 id="必答题"><a href="#必答题" class="headerlink" title="必答题"></a>必答题</h1><p><s>其实我写PA的时候都在系统调用过程梳理里做好笔记了</s></p><h2 id="游戏的存档"><a href="#游戏的存档" class="headerlink" title="游戏的存档"></a>游戏的存档</h2><ul><li>仙剑奇侠传中调用C标准I/O库函数<code>fread()</code></li><li>库函数<code>fread()</code>会调用libos中的系统调用的封装函数<code>_read()</code></li><li>libos中的<code>_read()</code>函数通过调用<code>_syscall_()</code>，直接使用内联汇编语句编译出<code>int 0x81</code>的系统调用内陷指令，并将相应的参数放入约定的寄存器中(<code>%eax</code>,<code>%ebx</code>，<code>%ecx</code>，<code>%edx</code>)</li><li>nemu执行指令时遇到了<code>int 0x81</code>指令，译码后执行<code>raise_intr()</code>，将EFLAGS，CS，EIP的值压入栈中，并到am中的中断门描述符表<code>idt</code>中查询0x81对应的跳转目标的偏移量offset，为<code>vectrap()</code></li><li><code>vectrap()</code>直接通过汇编指令将错误码<code>irq</code>压栈，然后跳转到<code>asm_jmp</code>函数执行（nexus-am/am/arch/x86-nemu/src/trap.S中定义）</li><li>在<code>asm_trap</code>中通过<code>pusha</code>指令让nemu将所有寄存器压栈，然后执行<code>irq_handle()</code>函数（在nexus-am/am/arch/x86-nemu/src/cte.c中）</li><li><code>irq_handle()</code>把执行流切换的原因打包成事件，然后调用在<code>_cte_init()</code> 中注册的事件处理回调函数, 将事件交给Nanos-lite来处理</li><li>Nanos-lite中的<code>do_event()</code>函数根据nemu打包传过来的时间决定系统调用类型，此处是<code>_EVENT_SYSCALL</code>类型的，就调用<code>do_syscall()</code>函数来处理这个系统调用</li><li><code>do_syscall()</code>根据上下文中寄存器<code>%eax</code>保存的参数确定系统调用的类型，此时为<code>SYS_read</code>类型，就调用文件系统中的<code>fs_read()</code>并将相应的参数传入</li><li><code>fs_read()</code>根据传入的文件名（存档信息文件的名称）读取需要的长度到指定的位置，恢复成存档前的状态，就可以从存档点继续游戏</li><li><code>fs_read()</code>执行完成后，一路返回到<code>asm_trap</code>中，恢复之前压入栈中保存的寄存器，然后执行<code>iret</code>指令</li><li>nemu执行<code>iret</code>指令，恢复EFLAGS，CS，EIP，跳转到EIP所指向的地方继续执行之后的指令</li></ul><p>至此，一次读取存档的系统调用全部完成</p><h2 id="更新屏幕"><a href="#更新屏幕" class="headerlink" title="更新屏幕"></a>更新屏幕</h2><ul><li>仙剑奇侠传中调用libndl中的库函数<code>NDL_DrawRect()</code></li><li><code>NDL_DrawRect()</code>会调用C标准I/O库函数<code>fwrite()</code>，将当前的像素信息写入<code>stdout</code>中，这里的<code>stdout</code>不是终端里的标准输出，而是应用程序的标准输出<code>_REENT-&gt;stdout</code></li><li>系统调用过程同上，此处不再赘述。进入Nanos-lite的文件系统后，由于是对显示设备抽象成的文件<code>/dev/fb</code>进行读取，<code>fs_write()</code>调用的是<code>fb_write()</code></li><li><code>fb_write()</code>调用了am的klib中提供的<code>screen_width()</code>和<code>draw_rect()</code></li><li>am中的<code>draw_rect()</code>调用了vga设备的写函数<code>video_write()</code>，把相应的像素信息写入到映射到<code>vga_memory</code>的物理内存中</li><li>当nemu访问到从0x4000开始的一段被映射到I/O空间的物理地址时，就会通过<code>mmio_write</code>来修改I/O空间的数据</li><li>I/O空间的数据被修改后调用了<code>update_screen()</code>，由nemu把更新后的屏幕显示信息显示了出来</li><li>进行系统调用的返回操作，同样不再赘述</li></ul><p>至此，一次更新屏幕的系统调用完成</p><h1 id="蓝框思考题"><a href="#蓝框思考题" class="headerlink" title="蓝框思考题"></a>蓝框思考题</h1><p>最近太忙了一题都没写…<br>想写的时候讲义又挂了…<br>二周目的时候再思考吧orz</p><h1 id="实验中的发现"><a href="#实验中的发现" class="headerlink" title="实验中的发现"></a>实验中的发现</h1><h2 id="关于nanos-lite和nemu是怎么通讯的"><a href="#关于nanos-lite和nemu是怎么通讯的" class="headerlink" title="关于nanos-lite和nemu是怎么通讯的"></a>关于nanos-lite和nemu是怎么通讯的</h2><p>在写PA3.1中的<code>lidt</code>指令的时候，我有个很大的疑惑，<code>idt</code>是在nanos-lite里被定义的，nemu要怎么获取它的地址呢？<code>_cte_init</code>中有一步调用了<code>set_idt</code>函数，将idt的地址和大小用内联汇编语句写入了指令集。因此当nanos编译成nemu可执行的指令后，idt的地址就可以通过相应的译码函数写入<code>id_dest</code>中。<br>问了一位nb的学长后，学长给出了如下理解</p><blockquote><p>不在system.c里的指令，一般靠编译c文件成机器码就可以给nemu做事，所以pa2很顺利；而system.c的东西依赖于系统（比如中断），只靠编译c文件做不到int、lidt这些东西，所以要内联汇编</p></blockquote><h2 id="关于如何判断-Context结构的组织顺序"><a href="#关于如何判断-Context结构的组织顺序" class="headerlink" title="关于如何判断_Context结构的组织顺序"></a>关于如何判断<code>_Context</code>结构的组织顺序</h2><p><code>_Context</code>是在函数<code>irq_handle</code>里作为参数的类型被传入的，然而<code>irq_handle</code>是通过汇编代码直接调用的，因此没有显式的参数传递语句，实际的参数是存放在栈中<code>%ebp-8</code>的位置开始的位置，观察<code>call irq_handle</code>之前所有的<code>push</code>相关语句就可以得知寄存器的顺序。而<code>eip</code>,<code>eflags</code>和<code>eip</code>是硬件保存的，因此需要观察<code>int</code>指令中的入栈顺序才能知道这三者的顺序。</p><h2 id="系统调用过程梳理"><a href="#系统调用过程梳理" class="headerlink" title="系统调用过程梳理"></a>系统调用过程梳理</h2><ol><li>用户层navy-apps在相应的系统调用函数（如<code>_exit()</code>）中调用系统调用接口函数<code>_syscall_()</code></li><li><code>_syscall_</code>用内联汇编语句将<code>int 0x80</code>和相应的系统调用参数传给nemu</li><li>nemu执行<code>int</code>指令，叫出nanos-lite</li><li><code>irq_handler</code>通过<code>int</code>指令传入的参数识别出这是一次系统调用的event，打包传给<code>do_event</code></li><li><code>irq.c</code>中的<code>do_event()</code>函数调用<code>do_syscall()</code>执行系统调用事件</li><li><code>syscall.c</code>中的<code>do_syscall()</code>函数根据传入的参数（在上下文的相应寄存器中）执行相应的系统调用操作，设置返回值并返回</li></ol><h1 id="我遇到的bug"><a href="#我遇到的bug" class="headerlink" title="我遇到的bug"></a>我遇到的bug</h1><ul><li>堆区管理的时候声明的用于记录program break的变量<code>pbrk</code>没有初始化【所以说初始化真的是个好文明</li><li>写了<code>fs_write</code>却忘了修改相应的系统调用<code>SYS_write</code>找了一个下午</li><li>所有关于文件读写的系统操作都需要控制<code>open_offset</code>，不能超过当前文件的size，但是<code>serial_write</code>和<code>dispinfo_read</code>等不同文件的读写又不能一概而论，写bug和debug的时候要特别注意</li><li><code>fs_lseek</code>最后要控制当前的<code>open_offset</code>，不然可能会导致<code>fs_read</code>和<code>fs_write</code>的功能无法正常使用</li><li><code>fs_read</code>和<code>fs_write</code>需要对<code>open_offset</code>做出修改</li><li>函数指针的调用就跟函数一样用就行了</li><li><code>fb_write</code>里的<code>offset</code>怎么用，怎么给<code>draw_rect</code>传参，可能要一直摸到<code>libnbl</code>才能搞清楚</li><li>字符串不能x**初始化，会由于某些我搞不懂的原因编译出<code>STOS</code>指令，导致看到亲切的i386 Logo</li><li><code>if((keytemp &amp; 0x8000) == 1)</code>和<code>if(keytemp &amp; 0x8000)</code>是不一样的！！！！！！[你是沙雕吗.jpg]</li></ul><h1 id="对讲义的一些建议（你们选择性反馈给yzh）"><a href="#对讲义的一些建议（你们选择性反馈给yzh）" class="headerlink" title="对讲义的一些建议（你们选择性反馈给yzh）"></a>对讲义的一些建议（你们选择性反馈给yzh）</h1><ul><li>建议把能看到<code>PASS!!!</code>信息的放在<code>serial_write()</code>之后，不少同学都在实现完<code>SYS_write</code>之后没看到PASS！！！感到困惑（当然仔细想一下还是能想通）</li><li>堆区管理那一块太考验阅读理解水平了，而且大部分人会忘掉PA2还接触过AM里一个叫<code>heap</code>的结构体，就稍微提醒一下下呗（</li><li>让dummy实现<code>_syscall_</code>时，最好能提醒一下如果按照之前加系统调用一下加入<code>do_event</code>中会触发死循环，或者干脆把下面的必做部分并到一起写，减少困惑</li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>RTFSC是很难的，不要一下子看不出来就自闭，<s>不然会出事情的</s></li><li>要成为一名优秀的程序猿，首先你要学好语文</li><li>出bug不可怕，如果能通过debug的过程对框架代码和计算机系统的原理有更深刻的理解，其实是一件很赚的事情。听了助教讲课之后我深刻感受到，一出bug就问大腿“怎么写才是对的”，实在太亏了，应该搞清楚哪里写错了，为什么写的fault这个出现这样的failure。</li></ul><h1 id="Appreciation"><a href="#Appreciation" class="headerlink" title="Appreciation"></a>Appreciation</h1><ul><li>感谢某人提供的探路和debug服务，我觉得有点保护过度了再这样下去我要不会自己写代码了【捂脸</li><li>感谢名字一直在换的学习群的群友们互帮互助的debug氛围</li></ul><p>本实验报告同样会将去掉必答题的版本同步上传至<a href="https://mengzelev.github.io/">个人blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验进度&quot;&gt;&lt;a href=&quot;#实验进度&quot; class=&quot;headerlink&quot; title=&quot;实验进度&quot;&gt;&lt;/a&gt;实验进度&lt;/h1&gt;&lt;p&gt;我已完成所有内容。&lt;br&gt;好，下面是惯例碎碎念。&lt;/p&gt;
&lt;p&gt;2018/11/18&lt;br&gt;心态爆炸的一天！先是因为脑子短路
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-最大流</title>
    <link href="https://mengzelev.github.io/2018/12/05/clrs-26Maximum-Flow/"/>
    <id>https://mengzelev.github.io/2018/12/05/clrs-26Maximum-Flow/</id>
    <published>2018-12-05T07:03:20.000Z</published>
    <updated>2018-12-08T02:14:21.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流网络"><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h1><h2 id="流网络-1"><a href="#流网络-1" class="headerlink" title="流网络"></a>流网络</h2><ul><li>有向图$G=(V,E)$</li><li>图中中每条边$(u,v)\in E$有一个非负的<strong>容量值</strong>$c(u,v)\ge 0$</li><li>如果$(u,v)\notin E$，定义$c(u,v)=0$</li><li>如果边集合$E$包含一条边$(u,v)$，则图中不存在反方向的边$(v,u)$</li><li>有<strong>源结点$s$</strong>和<strong>汇点$t$</strong></li><li>流网络图是连通的</li><li>除源结点外的每个结点都至少有一条进入的边，$|E|\ge |V|-1$</li></ul><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>设$G=(V,E)$为一个流网络，其容量函数为$c$。设$s$为网络的源结点，$t$为汇点。$G$中的流是一个实值函数$f: V\times V \to \mathbb{R}$，满足下面两条性质：</p><ul><li><strong>容量限制</strong>：对于所有的结点$u,v\in V$，要求$0\le f(u,v)\le c(u,v)$</li><li><strong>流量守恒</strong>：对于所有的结点$u\in V-{s,t}$，要求$$\sum\limits f(v,u)=\sum\limits f(u,v)$$当$(u,v)\notin E$时，从结点$u$到结点$v$之间没有流，因此$f(u,v)=0$</li></ul><p>称非负数值$f(u,v)$为从结点$u$到结点$v$的流。（流入=流出）</p><p>一个流$f$的<strong>值</strong>$|f|=\sum\limits_{v\in V}f(s,v)-\sum\limits_{v\in V}f(v,s)$ （从源结点流出的总流量减去流入源结点的总流量）</p><p><strong>最大流问题</strong>：给定一个流网络$G$、一个源结点$s$、一个汇点$t$，找到值最大的一个流</p><h2 id="反平行边"><a href="#反平行边" class="headerlink" title="反平行边 "></a><strong>反平行边</strong> </h2><p>如果要使用反平行边来模拟一个流问题，就选择两条反平行边中的一条，加入一个新结点来将其分解为两段，并以新的结点到原来边的结点的两条路替换所选边，同时将两条新设立的边的容量设置为与原来的边的容量相同。</p><p><img src="/2018/12/05/clrs-26Maximum-Flow/antiparallel.png"></p><h2 id="具有多个源结点和多个汇点的网络"><a href="#具有多个源结点和多个汇点的网络" class="headerlink" title="具有多个源结点和多个汇点的网络"></a>具有多个源结点和多个汇点的网络</h2><p>加入一个<strong>超级源结点$s$</strong>和一个<strong>超级汇点$t$</strong></p><p><img src="/2018/12/05/clrs-26Maximum-Flow/multi.png"></p><h1 id="Ford-Fulkerson方法"><a href="#Ford-Fulkerson方法" class="headerlink" title="Ford-Fulkerson方法"></a>Ford-Fulkerson方法</h1><p><img src="/2018/12/05/clrs-26Maximum-Flow/ffm.png"></p><h2 id="残存网络"><a href="#残存网络" class="headerlink" title="残存网络"></a>残存网络</h2><p>给定流网络$G$和流量$f$，残存网络$G_f$由那些仍有空间对流量进行调整的边构成。</p><p>残存容量为$c_f(u,c)=c(u,v)-f(u,v)$</p><p>对正流量的<strong>缩减</strong>：将边$(v,u)$加入到图$G_f$中，并将其残存容量设置为$c_f(v,u)=f(u,v)$</p><p><strong>残存容量</strong>的形式化定义如下：<br><img src="/2018/12/05/clrs-26Maximum-Flow/residual_capacity.png"></p><p>给定一个流网络$G=(V,E)$和一个流$f$，则有$f$所诱导的图$G$的残存网络为$G_f=(V,E_f)$，其中$E_f={(u,v)\in V\times V: c_f(u,v)&gt;0}$，有$|E_f|\le 2|E|$</p><p><strong>递增</strong>：如果$f$是$G$的一个流，$f’$是对应的残存网络$G_f$的中的一个流，定义$$f’\uparrow f’:V\times V\to\mathbb{R}$$为流$f’$对流$f$的<strong>递增</strong></p><p><img src="/2018/12/05/clrs-26Maximum-Flow/augmentation.png"></p><p><strong>抵消操作</strong>：在残存网络中将流量推送回去</p><p><strong>引理26.1</strong>：$$|f\uparrow f’|=|f|+|f’|$$</p><h2 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h2><p><strong>增广路径</strong>$p$：残存网络$G_f$中一条从源结点$s$到汇点$t$的简单路径</p><p><strong>残存容量</strong>：在一条增广路径$p$上能够为每条边增加的流量的最大值$$c_f(p)=\min{c_f(u,v): (u,v)\in p}$$</p><p><img src="/2018/12/05/clrs-26Maximum-Flow/Lemma26-2.png"><br><img src="/2018/12/05/clrs-26Maximum-Flow/Lemma26-3.png"></p><h2 id="流网络的切割"><a href="#流网络的切割" class="headerlink" title="流网络的切割"></a>流网络的切割</h2><p><strong>流网络的切割</strong>：将结点集合$V$划分为$S$和$T=V-S$两个集合，使得$s\in S, t\in T$</p><p>横跨切割的$(S,T)$的<strong>净流量</strong>$f(S,T)$：$$f(S,T)=\sum\limits_{u\in S}\sum\limits_{v\in T}f(u,v)-\sum\limits_{u\in S}\sum\limits_{v\in T}f(v,u)$$</p><p>切割$(S,T)$的<strong>容量</strong>：$$c(S,T)=\sum\limits_{v\in S}\sum\limits_{v\in T}c(u,v)$$<br><strong>最小切割</strong>：整个网络中容量最小的切割</p><ul><li>对于容量，只计算从集合$S$发出进入集合$T$的边的容量，而忽略反方向边上的容量</li><li>对于流，考虑从$S$到$T$的流量减去从$T$到$S$的反方向的流量</li></ul><p><strong>引理26.4</strong>：整个流网络的流量与横跨某一个切割的流量相等$$f(S,T)=|f|$$</p><p><strong>推论26.5</strong>：$|f|\ge c(S,T)$</p><p><strong>定理26.6(最大流最小割定理)</strong><br><img src="/2018/12/05/clrs-26Maximum-Flow/Theorem26-6.png"></p><h2 id="基本的Ford-Fulkerson算法"><a href="#基本的Ford-Fulkerson算法" class="headerlink" title="基本的Ford-Fulkerson算法"></a>基本的Ford-Fulkerson算法</h2><p><img src="/2018/12/05/clrs-26Maximum-Flow/ff.png"></p><p>粗糙的时间复杂度上界：$O(E|f<em>|)$（$f</em>$为将有理数流网络转换成整数流网络后，网络中的一个最大流）</p><h2 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h2><p>在Ford-Fulkerson算法的第三行使用<strong>广度优先搜索</strong>来寻找增广路径。<br>每次在残存网络中选择的增广路径是一条从源结点$s$到汇点$t$的最短路径，其中每条边的权重为单位距离。</p><p>时间复杂度：$O(VE^2)$</p><p><strong>引理26.7</strong>：使用Edmonds-Karp算法，对于除源结点和汇点外的所有结点$v$，残存网络$G_f$中的最短路径距离$\delta_f(s,v)$随着每次流量的递增而单调递增。</p><p><strong>定理26.8</strong>：Edmonds-Karp算法所执行的流量递增操作的总次数为$O(VE)$</p><p><strong>关键边</strong>：在残存网络中，一条路径$p$的残存容量是该条路径上边$(u,v)$的残存容量，即$c_f(p)=c_f(u,v)$<br>对于$E$的每条边来说，其成为关键边的次数最多为$|V|/2$次。</p><h1 id="最大二分匹配"><a href="#最大二分匹配" class="headerlink" title="最大二分匹配"></a>最大二分匹配</h1><p>在一个二分图中，结点集合可以划分为$V=L\cup R$，其中$L$和$R$是不相交的，并且边集合$E$中所有的边都横跨$L$和$R$。</p><p>构造一个流网络$G=(V’,E’)$，其中$$V’=V\cup{s,t}$$$$E={(s,u):u\in L, u\in L}\cup {(u,v):(u,v)\in E}\cup {(v,t):v\in\mathbb{R}}$$<br>给$E’$中的每条边赋单位容量</p><p><img src="/2018/12/05/clrs-26Maximum-Flow/26-9.png"></p><p>流$f$是<strong>整数值</strong>的：对于所有的边$(u,v)\in V\times V$，$f(u,v)$都是整数值。</p><p><strong>定理26.10（完整性定理Integrality theorem）</strong>：如果容量函数$c$只能取整数值，则$Ford-Fulkerson$方法所生成的最大流$f$满足$|f|$是整数值的性质。而且，对于所有的结点$u$和$v$，$f(u,v)$都是整数。</p><p><strong>推论26.11</strong>：二分图$G$中的一个最大匹配$M$的基数等于其对应的流网络$G’$中某一最大流$f$的值。</p><p>时间复杂度：$O(VE)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;流网络&quot;&gt;&lt;a href=&quot;#流网络&quot; class=&quot;headerlink&quot; title=&quot;流网络&quot;&gt;&lt;/a&gt;流网络&lt;/h1&gt;&lt;h2 id=&quot;流网络-1&quot;&gt;&lt;a href=&quot;#流网络-1&quot; class=&quot;headerlink&quot; title=&quot;流网络&quot;&gt;&lt;/a&gt;流网
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
      <category term="Maximum Flow" scheme="https://mengzelev.github.io/tags/Maximum-Flow/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-图中的匹配与覆盖</title>
    <link href="https://mengzelev.github.io/2018/11/28/matchings/"/>
    <id>https://mengzelev.github.io/2018/11/28/matchings/</id>
    <published>2018-11-28T06:59:39.000Z</published>
    <updated>2018-12-01T02:14:22.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><h2 id="匹配的定义"><a href="#匹配的定义" class="headerlink" title="匹配的定义"></a>匹配的定义</h2><p><strong>独立</strong>：若图的边集中任意两条边不邻接，则称该集合是独立的</p><p><strong>匹配</strong>：图$G$中的边的一个独立集<br>$G$的<strong>匹配</strong>是一个边的集合$M={e_1,e_2,…,e_k}$，其中$e_i=u_iw_i(1\le i\le k)$，使得$u_1,u_2,…,u_k$是$U$中$k$个不同的顶点，$w_1,w_2,…,w_k$是$W$中$k$个不同的顶点。</p><h2 id="匹配存在的条件"><a href="#匹配存在的条件" class="headerlink" title="匹配存在的条件"></a>匹配存在的条件</h2><p><strong>邻域(neighbourhood)</strong>$N(X)$：设$G$为二部图，其部集为$U$和$W$，且$|U|\le |W|$，对于$U$的非空子集$X$，$X$中所有顶点的邻域的并。</p><p><strong>Hall’s condition/友好的(neighborly)</strong>：对于$U$的任意非空子集$X$，均有$|N(X)|\ge |X|$。</p><p><strong>定理8.3</strong>：设$G$为二部图，其部集为$U$和$W$，且$r=|U|\le |W|$。则$G$包含一个基数为$r$的匹配当且仅当$U$是<strong>友好的</strong>。 </p><p><strong>定理8.4</strong>：非空有限集族${S_1,S_2,…,S_n}$有一个互异代表元系(system of distinct representative) 当且仅当 对于任一整数$k(1\le k\le n)$，集族中任意$k$个集合的并至少包含$k$个元素。</p><p><strong>定理8.5(婚姻定理)</strong>:在一个由$r$个女人和$s$个男人构成的人群中，$1\le r\le s$，在熟识的男女之间可能出现$r$对婚姻当且仅当对每个整数$k(1\le k\le r)$，任意$k$个女人共认识至少$k$个男人。</p><p><strong>最大匹配(maximum matching)</strong>：具有最大基数的匹配</p><p><strong>完美匹配(perfect matching)</strong>：阶为$2k$的图$G$存在一个基数为$k$的匹配$M$，则称该匹配$M$为完美匹配</p><p><strong>定理8.6</strong>：任意$r$正则二部图$(r\ge 1)$均有一个完美匹配。</p><h2 id="边的独立性参数"><a href="#边的独立性参数" class="headerlink" title="边的独立性参数"></a>边的独立性参数</h2><p><strong>边独立数(edge independence number)</strong>$\alpha ‘(G)$：最大边独立集的基数</p><p><strong>覆盖</strong>：一个顶点和与其相连的一条边</p><p><strong>边覆盖数(edge covering number)</strong>$\beta ‘(G)$：$G$中所有边覆盖的最小基数</p><p><strong>最小边覆盖集(minimum edge cover)</strong>：具有最小基数的边覆盖集</p><p><strong>定理8.7</strong>：对于任意不包含孤立点的$n$阶图$G$，$$\alpha’(G)+\beta’(G)=n$$</p><h2 id="顶点的独立性参数"><a href="#顶点的独立性参数" class="headerlink" title="顶点的独立性参数"></a>顶点的独立性参数</h2><p>如果图中的一个顶点集合中任意两顶点都不邻接，则称该顶点的集合是<strong>独立</strong>的</p><p><strong>点独立数(vertex independence number)</strong>$\alpha(G)$:$G$中点独立集的最大基数，又称<strong>独立数</strong></p><p><strong>最大独立集(maximum independence set)</strong>：图$G$中基数为$\alpha(G)$的独立集</p><p><strong>点覆盖(vertex cover)</strong>：图$G$的某个顶点子集可以覆盖$G$的所有边</p><p><strong>点覆盖数(vertex covering number)</strong>$\beta(G)$：$G$的所有点覆盖的最小基数</p><p><strong>最小点覆盖(minimum vertex cover)</strong>：基数为$\beta(G)$的点覆盖</p><p><strong>定理8.8</strong>:对于任意不包含孤立点的$n$阶图，$$\alpha(G)+\beta(G)=n$$</p><p><strong>定理8.7</strong>与<strong>定理8.8</strong>合称为<strong>Gallai恒等式</strong></p><p>一般独立集比覆盖集好求</p><h1 id="因子分解"><a href="#因子分解" class="headerlink" title="因子分解"></a>因子分解</h1><h2 id="1因子"><a href="#1因子" class="headerlink" title="1因子"></a>1因子</h2><p><strong>1因子(1-factor)</strong>：图$G$的1正则生成子图。<br>$n$阶图$G$的完美匹配$M$的诱导的子图$F[M]$是$G$的1因子。<br>图$G$有1因子当且仅当$G$有完美匹配。</p><p>连通分支的<strong>奇偶性</strong>就是该连通分支的阶的<strong>奇偶性</strong>。<br>$k_O(G)$表示图$G$的<strong>奇连通分支</strong>的个数。</p><p><strong>定理8.10</strong>：图$G$包含1因子当且仅当对于$V(G)$的任意真子集$S$，$k_O(G-S)\le |S|$。</p><p><strong>定理8.11(Petersen定理)</strong>：所有无割边的3正则图包含1因子。</p><p><strong>定理8.12</strong>：任一至多含有两条割边的3正则图包含1因子。</p><h2 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h2><p><strong>可因子分解的(1-factorable)</strong>：若$G$有1因子$F_1,F_2,…,F_r$，使得${E(F_1),E(F_2),…,E(F_r)}$是$E(G)$的一个划分，此时我们称$G$被<strong>因子分解(factored)</strong>成1因子$F_1,F_2,…,F_r$；这些1因子构成了$G$的<strong>1因子分解(1-factorization)</strong></p><p>任一可1因子分解的图是正则的，反之不真，反例：Peterson图</p><p><strong>定理8.13</strong>：Petersen图是不可1因子分解的。</p><p><strong>定理8.14</strong>：对于任意正整数$k$，完全图$K_{2k}$是可1因子分解的。</p><p><strong>循环因子分解(cyclic factorization)</strong>：如图所示，所有因子分解可以由某一个因子分解旋转一定角度得到</p><p><img src="/2018/11/28/matchings/cyclic.png"></p><p><strong>定理8.15</strong>：任意$r$正则的二部图$(r\ge 1)$是可1因子分解的。</p><h2 id="2因子"><a href="#2因子" class="headerlink" title="2因子"></a>2因子</h2><p><strong>2因子(2-factor)</strong>：图$G$的二正则生成子图</p><p>2因子的任一连通分支是一个圈。</p><p><strong>可2因子分解的(2-factorable)</strong>：定义类似1因子</p><p><strong>定理8.16</strong>：图$G$是可2因子分解的当且仅当存在某个正偶数$r$，是的$G$是$r$正则的。</p><p><strong>*Hamilton因子分解(Hamilton factorization)</strong>：$G$的一个2因子分解，满足该分解中所有2因子均是Hamilton圈</p><p><strong>定理8.17</strong>：对于任一整数$k\ge 1$，完全图$K_{2k+1}$是可Hamilton分解的。<br>证明：构造法（如图）</p><p><img src="/2018/11/28/matchings/K9.png"></p><h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p><strong>因子(factor)</strong>：图$G$不含有孤立点的生成子图</p><p><strong>可因子分解(factorable)</strong>：因子$F_1,F_2,…,F_r$，满足${E(F_1),E(F_2),…,E(F_r)}$是$E(G)$的一个划分。</p><p><strong>可F-因子分解的(F-factorable)</strong>：若存在某个图$F$，是的每个因子$F_i\cong F$</p><h2 id="Kirkman三元系"><a href="#Kirkman三元系" class="headerlink" title="Kirkman三元系"></a>Kirkman三元系</h2><p><strong>n阶的Kirkman三元系(Kirkman triple system)</strong>：有一个基数为$n$的集合$S$，和$S$的三元子集（称为<strong>三元组(triple)</strong>）族$T$，以及$T$的一个划分$\mathcal{P}$构成，且满足如下性质：</p><ol><li>$S$中任意两个不同的元素属于$T$中唯一的三元组</li><li>$S$中任一元素属于划分$\mathcal{P}$的每一元素的唯一的三元组</li></ol><p>存在一个$6k+3$阶Kirkman三元系当且仅当存在一个$K_{6k+3}$的$(2k+1)K_3$因子分解</p><p><strong>定理8.19</strong>：$n(n\ge 3)$阶的Kirkman三元系存在当且仅当$n\equiv 3(mod 6)$，即$n=6k+3$</p><p><strong>定理8.20</strong>：对于每个整数$k\ge 1$，完全图$K_{2k}$可因子分解为$k-1$个Hamilton圈和一个1因子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;匹配&quot;&gt;&lt;a href=&quot;#匹配&quot; class=&quot;headerlink&quot; title=&quot;匹配&quot;&gt;&lt;/a&gt;匹配&lt;/h1&gt;&lt;h2 id=&quot;匹配的定义&quot;&gt;&lt;a href=&quot;#匹配的定义&quot; class=&quot;headerlink&quot; title=&quot;匹配的定义&quot;&gt;&lt;/a&gt;匹配的定
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
      <category term="Matchings" scheme="https://mengzelev.github.io/tags/Matchings/"/>
    
      <category term="Factorization" scheme="https://mengzelev.github.io/tags/Factorization/"/>
    
  </entry>
  
  <entry>
    <title>Lab3：链接与加载（2）实验报告</title>
    <link href="https://mengzelev.github.io/2018/11/24/lab3-report/"/>
    <id>https://mengzelev.github.io/2018/11/24/lab3-report/</id>
    <published>2018-11-24T09:17:47.000Z</published>
    <updated>2018-11-30T14:18:07.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现描述"><a href="#实现描述" class="headerlink" title="实现描述"></a>实现描述</h1><h2 id="寻找正确的入口地址"><a href="#寻找正确的入口地址" class="headerlink" title="寻找正确的入口地址"></a>寻找正确的入口地址</h2><p>在框架代码抽取出的<code>symtab</code>中主项寻找，如果该项的<code>Type</code>属性为<code>STT_FUNC</code>，就根据其<code>st_name</code>属性去字符串表<code>strtab</code>里寻找该函数的<code>Name</code>属性，并与<code>main</code>进行对比，就能找到<code>main</code>函数对应的表项，此时该表项的<code>st_value</code>属性即 我们需要的入口地址。</p><h2 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h2><p><code>loader()</code>函数的实现需要程序头表，模仿<code>load_elf_table()</code>函数的写法可将程序头表抽取到结构体<code>Elf32_phdr</code>中，找到<code>p_type</code>为<code>PT_LOAD</code>的表项，读取其<code>p_offset</code>，<code>p_vaddr</code>，<code>p_filesz</code>，<code>p_memsz</code>属性，按照讲义的描述，使用<code>fread</code>函数将可执行文件中相对文件偏移<code>p_offset</code>的内容读取<code>p_filedz</code>到内存地址为<code>[p_addr, p_addr + p_filesz</code>的地方，并用<code>memset</code>函数将<code>[p_vaddr + p_filesz, p_vaddr + p_memsiz)</code>对应的物理区间清零。</p><h2 id="打印栈帧链"><a href="#打印栈帧链" class="headerlink" title="打印栈帧链"></a>打印栈帧链</h2><p>第一次打印<code>eip</code>的值作为当前地址，之后每次都取内存中<code>ebp-4</code>的地址存放的返回地址作为函数调用的地址。函数的名字通过去<code>symtab</code>中寻找对应表项并从<code>strtab</code>中提取而得。仿照gdb的<code>bt</code>命令输出打印出来。对<code>ebp</code>的值解引用能得到上一个函数的<code>ebp</code>的值。如此循环直到<code>ebp</code>的信息为0为止。</p><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p>留着以后当笑话看的碎碎念</p><h2 id="寻找正确的入口地址-1"><a href="#寻找正确的入口地址-1" class="headerlink" title="寻找正确的入口地址"></a>寻找正确的入口地址</h2><p>我本来以为这个只要做好RTFSC就不会花太多时间的，<code>man 5 elf</code>之后理所当然地写了如下代码：</p><pre><code>if(symtab[i].st_info == STT_FUNC)</code></pre><p>发现怎么都找不到<code>main</code>，各种调试了一个多小时之后，问了同学才意识到，<code>st_info</code>不是直接的<code>type</code>值，<code>type</code>只占了低四位，高四位为绑定属性<code>bind</code>，把FM继续往下翻可以看到</p><pre><code>ELF32_ST_BIND(info), ELF64_ST_BIND(info)                                                                    Extract a binding from an st_info value. </code></pre><p><s>泪，可以流下来吗</s><br>论耐心RTFM的重要性</p><h2 id="加载程序-1"><a href="#加载程序-1" class="headerlink" title="加载程序"></a>加载程序</h2><p>这部分基本是照抄框架代码抽取<code>El32_Shdr</code>的方法抽取了<code>Elf32_Phdr</code>，让我自己写大概还是写不出来的吧[自卑.jpg]</p><h2 id="打印栈帧连"><a href="#打印栈帧连" class="headerlink" title="打印栈帧连"></a>打印栈帧连</h2><p>先用gdb调试了给的<code>segmentfault.c</code>，摸索了一下<code>bt</code>命令的打印格式，确认了打印的栈帧链中的地址为函数调用时压入栈中的返回地址。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="堆和栈在哪里？"><a href="#堆和栈在哪里？" class="headerlink" title="堆和栈在哪里？"></a>堆和栈在哪里？</h2><p>经过PA3.2的调教，可以知道堆是程序运行时调用<code>malloc</code>动态向高地址申请空间维护的。堆区的开始位置就是数据段的结束位置。当调用<code>malloc</code>函数时，会触发系统调用<code>sbrk</code>查询并调整堆区的结束位置，即program break，以调整堆区的大小。<br>栈区是从内核虚存区开始向低地址方向生长的，栈顶的地址保存在寄存器<code>esp</code>中。通过<code>push</code>和<code>pop</code>等指令来调整栈区大小。<br>堆和栈的内容不放入可执行文件，我猜想一方面因为这些部分是动态生成的，程序执行过程中它们的大小时刻变化着，因此不能放入静态的可执行文件中。另一方面，栈区会有一个随机化操作来防止恶意攻击，不便于放入可读的可执行文件中。</p><h2 id="如何识别不同格式的可执行文件？"><a href="#如何识别不同格式的可执行文件？" class="headerlink" title="如何识别不同格式的可执行文件？"></a>如何识别不同格式的可执行文件？</h2><p>ELF可执行目标文件有ELF头，根据ELF可执行文件的各种规范书写。Windows生成的可执行文件应该也有自己的文件头的格式，在GNU/Linux下执行时，系统按照ELF头的格式解析该文件的文件头出现了错误，例如没有读到“魔数”，就会报告“格式错误”。</p><h2 id="消失的符号"><a href="#消失的符号" class="headerlink" title="消失的符号"></a>消失的符号</h2><p>因为这些符号只在本模块内被使用，其被动态分配在栈中，链接器并不需要这些符号的信息，因此不会出现在符号表中。符号是指参与链接的变量名和函数名。</p><h2 id="寻找”Hello-World-”"><a href="#寻找”Hello-World-”" class="headerlink" title="寻找”Hello World!”"></a>寻找”Hello World!”</h2><p>用上述方法找到<code>hello</code>程序的字符串表，会发现“Hello World!”字符串…它…根本不在字符串表中，而是在<code>.rodata</code>节中。</p><p><img src="/2018/11/24/lab3-report/HelloWorld.png"></p><p>因为<code>printf</code>中的格式化字符串是一个只读的字符串，所以编译时会被放入只读数据节<code>.rodata</code>节中。</p><h2 id="冗余的符号表"><a href="#冗余的符号表" class="headerlink" title="冗余的符号表"></a>冗余的符号表</h2><p>编译单独的hello程序没有问题，但是尝试对hello.o进行链接时就会链接报错（忘了截图了）。因为符号表用于链接中的符号解析，单独运行程序时没有符号表，单有指令就也没有问题。</p><h2 id="冗余的属性？"><a href="#冗余的属性？" class="headerlink" title="冗余的属性？"></a>冗余的属性？</h2><p>起初我猜测是.bss节的数据没有在<code>Filesz</code>中被计算，而是计算在了<code>Memsz</code>中。但是我把.bss节的大小加上<code>Filesz</code>后还是比<code>Memsz</code>小一些，STFW发现stackoverflow上有人问了类似的问题，欣喜地点进去发现并没有人回答….我再思考一下说不定就有stackoverflow首答了…</p><h2 id="为什么要清零？"><a href="#为什么要清零？" class="headerlink" title="为什么要清零？"></a>为什么要清零？</h2><p>数电和问求还没写完，溜了…….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实现描述&quot;&gt;&lt;a href=&quot;#实现描述&quot; class=&quot;headerlink&quot; title=&quot;实现描述&quot;&gt;&lt;/a&gt;实现描述&lt;/h1&gt;&lt;h2 id=&quot;寻找正确的入口地址&quot;&gt;&lt;a href=&quot;#寻找正确的入口地址&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-旅行问题</title>
    <link href="https://mengzelev.github.io/2018/11/21/traversability/"/>
    <id>https://mengzelev.github.io/2018/11/21/traversability/</id>
    <published>2018-11-21T13:05:50.000Z</published>
    <updated>2018-11-30T14:19:40.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Euler图"><a href="#Euler图" class="headerlink" title="Euler图"></a>Euler图</h1><p><strong>Euler回路(Euler cycle)</strong>：图$G$的一条包含$G$的每一条边的回路$C$</p><p><strong>Euler图(Euler graph)</strong>:含有Euler回路的连通图</p><p><strong>Euler迹(Euler trial)</strong>含有连通图$G$的每条边的开迹</p><p>当讨论图的Euler性质时，</p><p><strong>定理6.1</strong>：一个非平凡连通图$G$是Euler的 当且仅当 $G$的每个顶点的度都为偶数</p><p><strong>推论6.2</strong>：一个连通图$G$含有一条Euler迹当且仅当$G$恰有两个度为奇数的顶点，而且$G$的每一条Euler迹始于一个度为奇数的顶点而终止于另一个度为奇数的顶点。</p><p><strong>例6.3结论</strong>：设$G$和$H$是两个非平凡的连通图，则$G\times H$是Euler的当且仅当$G$和$H$都是Euler的或者$G$和$H$的每个顶点度均为奇数。</p><h1 id="Hamilton图"><a href="#Hamilton图" class="headerlink" title="Hamilton图"></a>Hamilton图</h1><p><strong>Hamilton圈(Hamiltonian cycle)</strong>：一个含图$G$的每个顶点的圈</p><p><strong>Hamilton图(Hamiltonian graph)</strong>：一个含有Hamilton圈的图</p><p><strong>Hamilton路(Hamiltonian path)</strong>：一条含图$G$的每个顶点的路</p><p>有Hamilton圈, 一定有Hamilton路；<br>有Hamilton路，不一定有Hamilton圈</p><h2 id="Hamilton图的特征"><a href="#Hamilton图的特征" class="headerlink" title="Hamilton图的特征"></a>Hamilton图的特征</h2><ul><li>$n\ge 3$阶图的一个Hamilton圈$C$是$n$阶的连通2正则子图</li><li>$C$不含有阶小于$n$的圈作为子图</li><li>$G$也不含有有度大于等于3的子图</li><li>如果$G$含有度为2的顶点，则与$v$关联的两条边一定位于$C$上</li></ul><p><strong>定理6.4</strong>：Peterson图不是Hamilton的</p><h2 id="Hamilton图的性质"><a href="#Hamilton图的性质" class="headerlink" title="Hamilton图的性质"></a>Hamilton图的性质</h2><p>$k(G)$：图的连通分支数</p><p><strong>定理6.5</strong>：如果$G$是一个Hamilton图，则对$G$顶点的任一非空真子集$S$，都有$k(G-S)\ge |S|$（一个图是Hamilton图的<strong>必要条件</strong>）<br>逆否命题：设$G$为一个图。如果对$V(G)$的某个非空真子集$S$,有$k(G-S)&gt;|S|$，则$G$不是Hamilton的（一个图为非Hamilton的充分条件）<br>如果图$G$含有一个割点$v$，则$G$不是Hamilton的</p><h2 id="Hamilton图的充分条件"><a href="#Hamilton图的充分条件" class="headerlink" title="Hamilton图的充分条件"></a>Hamilton图的充分条件</h2><p><strong>定理6.6(Ore 定理)</strong>：设$G$为一个$n(n\ge 3)$阶的图，如果对于$G$的每对不邻接的顶点$u,v$，有$deg u +deg v\ge n$,则$G$是Hamilton的。<br>该定理给出的界是紧的</p><p><strong>推论6.7</strong>：设$G$为一个$n\ge 3$的图，如果对于$G$的每个顶点$v$，均有$deg v\ge n/2$，则$G$是Hamilton的。</p><p><strong>定理6.8</strong>：设$u$和$v$是一个$n$阶图$G$的两个不邻接的顶点，并且$deg u + deg v\ge n$，则$G+uv$是Hamilton的当且仅当$G$是Hamilton的。</p><p><strong>闭包(closure)</strong>：由$G$出发递归地连接度数之和至少为$n$的不邻接顶点对，记为$C(G)$</p><p><strong>定理6.9</strong>：一个图是Hamilton的当且仅当它的闭包是Hamilton的。</p><p><strong>推论6.10</strong>：如果$G$是一个阶至少为3的图，且它的闭包$C(G)$是一个完全图，则$G$是一个Hamilton图</p><p><strong>定理 6.11</strong>：设$G$是一个$n(n\ge 3)$阶的图。如果对于每个整数$j(1\le j&lt;\frac{n}{2})$，$G$中度至多为$j$的顶点数小于$j$，则$G$是Hamilton的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Euler图&quot;&gt;&lt;a href=&quot;#Euler图&quot; class=&quot;headerlink&quot; title=&quot;Euler图&quot;&gt;&lt;/a&gt;Euler图&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Euler回路(Euler cycle)&lt;/strong&gt;：图$G$的一条包含$G$的每一条
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
      <category term="Traversibility" scheme="https://mengzelev.github.io/tags/Traversibility/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-图中的连通性与距离</title>
    <link href="https://mengzelev.github.io/2018/11/14/connectivity/"/>
    <id>https://mengzelev.github.io/2018/11/14/connectivity/</id>
    <published>2018-11-14T08:19:10.000Z</published>
    <updated>2018-11-30T14:19:28.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h1><p>割点的定义：去掉这个点后，原图不再连通</p><p><strong>定理5.1</strong>：设$v$是连通图$G$中与bridge相连的一个结点，则$v$是割点当且仅当$deg v\ge 2$<br>非简单树 = 端点 + 割点</p><p><strong>推论5.2</strong>：设$G$是一个至少有3个顶点的连通图，若$G$有bridge，则$G$一定有割点</p><p><strong>定理5.3</strong>：设$v$是连通图$G$的一个割点，$u$和$w$是$G-v$不同components中的两个顶点，则$v$位于$G$的任意一条$u-w$路径上。</p><p>回顾<strong>定理4.1</strong>：边$e$是bridge当且仅当$e$不存在于任何一个cycle上</p><p><strong>推论5.4</strong>：$v$是连通图$G$的一个割点 当且仅当 存在与$v$不同的两个顶点$u$和$w$，使得$v$位于$G$的任意一条$u-w$路上</p><p><strong>定理5.5</strong>：设$G$是非平凡连通图，$u\in V(G)$。若$v$是$G$中距离$u$最远的顶点，则$v$不是$G$的割点。</p><p><strong>推论5.6</strong>：任意非平凡的连通图至少包含两个非割点的顶点。</p><h1 id="块-Blocks"><a href="#块-Blocks" class="headerlink" title="块(Blocks)"></a>块(Blocks)</h1><p><strong>不可分图(nonseparable graph)：</strong>没有割点的非平凡连通图</p><p><strong>定理5.7</strong>：结点数不少于3的图是不可分的 当且仅当 任意两个顶点都位于某个圈上</p><p><strong>块(block)</strong>:图$G$的一个最大的不可分子图</p><p><strong>定理5.8</strong>：$R$是定义在非平凡连通图$G$的边集上的关系：对于$e,f\in E(G)$，若$e=f$或$e,f$位于$G$的同一个圈上，则$e,f$有关系$R$，即为$eRf$且$R$是等价关系。<br>该定理将图$G$的边画划分为了若干等价类。</p><p><strong>推论5.9</strong>：非平凡连通图$G$的任意两个不同的块$B_1$和$B_2$具有下面性质：</p><ul><li>$B_1$和$B_2$是不相交的</li><li>$B_1$和$B_2$至多有一个公共结点</li><li>若$B_1$和$B_2$有一个公共结点$v$，则$v$是$G$的割点</li></ul><h1 id="连通度"><a href="#连通度" class="headerlink" title="连通度"></a>连通度</h1><h2 id="顶点割"><a href="#顶点割" class="headerlink" title="顶点割"></a>顶点割</h2><p><strong>顶点割(vertex-cut)</strong>：顶点集$U$，$G-U$是不连通的</p><p><strong>最小顶点割</strong>：自行感受一下</p><p>只有非完全图才有顶点割，且所有非完全图都有顶点割</p><p><strong>(点)连通度(vertex-connectivity)</strong>:$\kappa(G)$=最小顶点割的基数<br>$$ 0\le \kappa(G)\le n-1 $$</p><p>图$G$是k-连通的(k-connected)，即$\kappa(G)\ge k$，随便去掉$k$个点之后依然是连通的</p><h2 id="边割-edge-cut"><a href="#边割-edge-cut" class="headerlink" title="边割(edge-cut)"></a>边割(edge-cut)</h2><p><strong>边割(edge-cut)</strong>：边集$X$，$G-X$是不连通的</p><p><strong>最小边割</strong>和<strong>极小边割</strong>是不同的概念</p><p><strong>边连通度(edge-connectivity)</strong>:$\lambda(G)$=最小边割的基数<br>$$ 0\le \lambda(G)\le n-1 $$</p><p>完全图的边连通度$\lambda(K_n)=n-1$</p><h2 id="点、边连通度间的关系"><a href="#点、边连通度间的关系" class="headerlink" title="点、边连通度间的关系"></a>点、边连通度间的关系</h2><p><strong>定理5.11</strong>：对于任意图$G$，$$\kappa(G)\le \lambda(G)\le \delta(G)$$<br>点连通度$\le$边连通度$\le$最小度数</p><p><strong>定理5.12</strong>：立方图$\kappa(G)=\lambda(G)$</p><p><strong>定理5.13</strong>：$G$顶点数为$n$，边数为$m$，则$\kappa(G)\le \lfloor\frac{2m}{n}\rfloor$</p><h2 id="Harary图"><a href="#Harary图" class="headerlink" title="Harary图"></a>Harary图</h2><p><strong>定理5.14</strong>：如果$G$是至少有3个结点的连通图，则$G^2$时候2-连通的。</p><p><strong>定理5.15</strong>：对于任意整数$r,n$满足$2\le r&lt;n$，有$$\kappa(H_{r,n})=r$</p><h1 id="Menger定理"><a href="#Menger定理" class="headerlink" title="Menger定理"></a>Menger定理</h1><p><strong>分离集(separating set)</strong>：$S$是图$G$的顶点集的一个子集，$u$和$v$是$G$的两个顶点。若$G-S$是不连通的且$u$和$v$属于$G-S$不同的连通分支，则称$S$<strong>分离</strong>$u$和$v$，$S$是一个<strong>$u-v$分离集</strong></p><p><strong>内点(internal vertex)</strong>:一条$u-v$路径上除去$u,v$的点<br><strong>内部不相交(internally disjoint)</strong>：两条路径除端点外没有公共点</p><p><strong>定理5.16(Menger定理)：</strong>设$u$和$v$是图$G$的不邻接的两个顶点，则$u-v$分离集中顶点的最小个数等于$G$中内部不相交$u-v$路的最大个数。<br>证明使用了数学归纳法，归纳步时分了3种情况讨论</p><p><strong>定理5.17</strong>：一个非平凡图$G$是$k$连通的($k\ge 2$) 当且仅当 对于$G$的任意两个顶点$u,v$，$G$至少有$k$条内部内部不相交的$u-v$路。</p><p><strong>推论5.18</strong>：设$G$为$k$连通图，$S$是由$G$中任意$k$个顶点构成的集合。若图$H$是由$G$通过添加一个新的顶点$w$以及连接$w$到$S$中所有的顶点所得，则$H$也是$k$连通的。</p><p><strong>推论5.19</strong>：若$G$为$k$连通图，$u,v_1,v_2,…,v_k$为$G$中$k+1$个不同的顶点，则$G$有内部不相交的$u-v_i$路($1\le i\le k$)</p><p><strong>定理5.20</strong>：若$G$为$k$连通图($k\ge 2$)，则$G$中任意$k$个顶点均位于某一个圈上。</p><p><strong>定理5.21</strong>：对于图$G$两个不同的顶点$u$和$v$，$G$中分离$u,v$的边的最小个额数等于$G$中边不相交$u-v$路的最大个数</p><p><strong>定理5.22</strong>：一个非平凡图$G$是$k$边连通的当且仅当对于$G$中任意两个不同的顶点$u,v$，$G$包含$k$条边不相交的$u-v$路</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;割点&quot;&gt;&lt;a href=&quot;#割点&quot; class=&quot;headerlink&quot; title=&quot;割点&quot;&gt;&lt;/a&gt;割点&lt;/h1&gt;&lt;p&gt;割点的定义：去掉这个点后，原图不再连通&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理5.1&lt;/strong&gt;：设$v$是连通图$G$中与bridge相
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
      <category term="Connectivity" scheme="https://mengzelev.github.io/tags/Connectivity/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-所有结点对的最短路径问题</title>
    <link href="https://mengzelev.github.io/2018/11/07/clrs-25All-Pairs-Shortest-Paths/"/>
    <id>https://mengzelev.github.io/2018/11/07/clrs-25All-Pairs-Shortest-Paths/</id>
    <published>2018-11-07T08:17:34.000Z</published>
    <updated>2019-01-07T11:15:54.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><p>$l_{ij}^(m)}$:从结点$i$到结点$j$的至多包含$m$条边的任意路径中的最小权重。<br>$$<br>l_{ij}^{(m)} = \min\limits_{1\lek\le n}{l_{ik}^{(m1)}+w_{kj}}<br>$$</p><h2 id="自底向上计算最短路径权重"><a href="#自底向上计算最短路径权重" class="headerlink" title="自底向上计算最短路径权重"></a>自底向上计算最短路径权重</h2><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/extend.png"></p><p>三重循环，时间复杂度为$\Theta(n^3)$</p><p>形式上与矩阵乘法的计算非常类似</p><p>计算$L^{(n-1)}=W^{n-1}$</p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/slowall.png"><br>这个算法本质上就是对$n$个点每个跑了一遍Bellman-Ford</p><h2 id="改进运行时间"><a href="#改进运行时间" class="headerlink" title="改进运行时间"></a>改进运行时间</h2><p>重复平方技术<br>二分计算矩阵的幂</p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/chongfu.png"></p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/faster.png"></p><p>优化后时间复杂度为$\Theta(n^3\lgn n)$</p><h1 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h1><p>枚举最短路径上的中间结点来进行递归的计算</p><ul><li>不允许有负权重环</li><li>但是可以做到在有负权重环的情况下报告（看对角元是否有负数）</li></ul><p>$d_{ij}^{(k)}$：从$i$到$j$经过的中间结点为${1,…k}$的子集的最短路径长度<br><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/d.png"></p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/floyd-alg.png"></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$\Theta(n^3)$</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>看似需要$\Theta(n^3)$，但是作业题中证明了只需要一个矩阵来存储，为$\Theta(n^2)$</p><h2 id="构建最短路径"><a href="#构建最短路径" class="headerlink" title="构建最短路径"></a>构建最短路径</h2><p>采用动态规划的思想，递推式如下</p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/pi0.png"></p><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/pik.png"></p><h1 id="用于稀疏图的Johnson算法"><a href="#用于稀疏图的Johnson算法" class="headerlink" title="用于稀疏图的Johnson算法"></a>用于稀疏图的Johnson算法</h1><p>用一种神奇的方式对图中每条边的权重进行重新赋值，使新的图满足</p><ul><li>所有权重都为非负值</li><li>新图中的最短路径就是旧图中的最短路径</li></ul><h2 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/11/07/clrs-25All-Pairs-Shortest-Paths/Johnson.png"></p><p>先增加一个新结点$s$，该点到原先各结点都有边相连，权重为0<br>对新图进行一次Bellman-Ford算法，寻找是否有负权重环路<br>没有负权重环，就用神奇的长得像顶点的势能函数一样的函数给每条边重新赋值<br>$$ \hat{w}(u,v)=w(u,v)+h(u)-h(v)$$<br>$$ h(u)=\delta(s,u)$$<br>然后对每个点进行Dijkstra<br>最后记得将最短路径的权重恢复，并存入矩阵$D$中返回</p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>二叉最小优先队列实现Dijkstra：$O(VE\lg V)$<br>斐波那契堆实现：$O(V^2\lgV+VE)$<br>在稀疏图的情况下，表现比Floyd-Warshall好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;矩阵乘法&quot;&gt;&lt;a href=&quot;#矩阵乘法&quot; class=&quot;headerlink&quot; title=&quot;矩阵乘法&quot;&gt;&lt;/a&gt;矩阵乘法&lt;/h1&gt;&lt;h2 id=&quot;最优子结构&quot;&gt;&lt;a href=&quot;#最优子结构&quot; class=&quot;headerlink&quot; title=&quot;最优子结构&quot;&gt;
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Lab2:链接与加载 实验报告</title>
    <link href="https://mengzelev.github.io/2018/11/06/lab2-report/"/>
    <id>https://mengzelev.github.io/2018/11/06/lab2-report/</id>
    <published>2018-11-06T09:17:47.000Z</published>
    <updated>2018-11-30T14:17:54.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>按照实验讲义的提示，首先找到了libc库所在的位置，输出基本与讲义中给出的一致，不作赘述。</p><p>编写的测试文件a.c的代码为</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main (){    int a = rand();    printf(&quot;%d\n&quot;,a);    return 0;}</code></pre><p>只需要有对<code>rand</code>的调用且保证不会被编译器优化掉就可以了。</p><p>找到动态库文件之后，对该二进制文件进行反汇编</p><pre><code>$ objdump -d /lib/x86_64-linux-gnu/libc.so.6 &gt; libc64</code></pre><p>然后对反汇编后的文件进行查看，可以看到一堆库函数的反汇编代码。此时我看到了讲义中的这句话：</p><blockquote><p>然后你会发现这个文件对你并没有什么卵用，好吧，其实一会儿是会用到的。</p></blockquote><p>导致我真的以为现在用不到这个文件，于是，我<s>傻fufu地</s>按照讲义的指示去找<code>rand</code>函数的地址了。<br><code>gdb</code>，启动！看到了一堆跳转语句，感受到了自己对课本内容掌握不足；<br>课本，打开！复习了一下动态链接相关的知识点；<br><code>gdb</code>，开始！单步执行到<code>&lt;rand@plt&gt;</code>处时，发现了<code>rand</code>对应的GOT表项的地址，为<code>0x55555575020</code></p><p><img src="/2018/11/06/lab2-report/rand_id.png"></p><p>然后疯狂<code>si</code>，会看一堆<code>dl_</code>开头的，八成是和动态链接有关的函数。一不小心回车过头，最后在<code>main</code>里停下来，总之动态链接过程已经完成了，这时候可以查看内存地址为<code>0x55555575020</code>处的内容为<code>0x7ffff7a70820</code>（忘了截图了）</p><p>打印<code>0x7ffff7a70820</code>的内容，确认了确实为<code>rand</code>函数的地址</p><p><img src="/2018/11/06/lab2-report/rand.png"></p><p>做到这里，感觉像是完成了什么，开始思考下一步要做什么。等一下，我们的最终目标不是只要得到<code>system</code>到<code>rand</code>的偏移量吗，那我费尽千辛万苦搞到<code>rand</code>的地址干什么……算了，就当复习了一下动态链接的相关知识点和回忆了一下<code>gdb</code>的使用方法吧</p><p>不管了，总之先打开之前反汇编的动态库看一下，分别找到<code>rand</code>和<code>system</code>的地址</p><p><img src="/2018/11/06/lab2-report/rand64.png"></p><p><img src="/2018/11/06/lab2-report/system64.png"></p><p>偏移量为<code>0x3f480-0x36820=0x8c60</code></p><p>为了验证一下正确性，使用<code>gdb</code>打印了和<code>rand</code>具有相应偏移量（其实就是后3位不同）出的内存内容</p><p><img src="/2018/11/06/lab2-report/system.png"></p><p>这下准没错了，于是开始编写<code>oj_killer</code>函数</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>最初仅考虑64位情况的<code>oj_killer</code>函数代码如下</p><pre><code>#include &lt;stdlib.h&gt;void* oj_killer(){        void* randptr = (void *)rand;        //获得rand函数的地址        return (void*)(randptr + 0x8c60);        //加上libc中rand到system的偏移量，返回system函数的地址}</code></pre><p>编译运行后能够成功输出<code>Hello World</code></p><p><img src="/2018/11/06/lab2-report/hello64.png"></p><h2 id="兼容32位"><a href="#兼容32位" class="headerlink" title="兼容32位"></a>兼容32位</h2><p>接下来考虑32位的情况</p><p>如果将上述程序直接编译为32位，会得到<code>Illegal instruction</code>的错误</p><p><img src="/2018/11/06/lab2-report/illegal.png"></p><p>对<code>a.c</code>加上<code>-m32</code>选项进行编译后查看其调用的动态链接库，可以发现调用的是32位的库，和64位的库是不一样的（当然了</p><pre><code>$gcc a.c -m32 -o a32.out$file a32.outa32.out: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically link│ed, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=b3e591a0858f18│2549e63239c338f5fd30496ce2, not stripped $ldd a32.out                                              linux-gate.so.1 (0xf77ac000)                                                      libc.so.6 =&gt; /lib32/libc.so.6 (0xf75d1000)                                        /lib/ld-linux.so.2 (0xf77ae000)$file -L /lib32/libc.so.6                             /lib32/libc.so.6: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=84bb53910470c7ceb2a0963044117fdf8a2bb975, for GNU/Linux 2.6.32, stripped  </code></pre><p>使用同样的方法进行反汇编后</p><pre><code>$objdump -d /lib32/libc.so.6 &gt; libc32</code></pre><p>分别得到<code>rand</code>和<code>system</code>在<code>libc</code>内的地址</p><p><img src="/2018/11/06/lab2-report/rand32.png"></p><p><img src="/2018/11/06/lab2-report/system32.png"></p><p>于是可以按照同样的思路编写代码</p><h2 id="真·代码解释"><a href="#真·代码解释" class="headerlink" title="真·代码解释"></a>真·代码解释</h2><pre><code>void* oj_killer(){    int type = sizeof(void*);    void* randptr = (void *)rand;    //获得rand函数的地址    if(type == 8)     //判断当前环境是否为64-bit        return (void*)(randptr + 0x8c60);    //加上64位时libc中的偏移量    else return (void*)(randptr - 0x2f6f0 + 0x3a850);         //加上32位时libc的偏移量}</code></pre><p>为了保证代码的可移植性，特意将变量<code>randptr</code>声明为<code>void*</code>类型，而非<code>int</code>或<code>long long</code>。<br>判断当前环境为32/64位则依靠对<code>void*</code>长度的判断。 <s>暴露了不太会用<code>#if</code>预编译指令的事实</s></p><p>分别按32位和64位编译后，可以得到<code>Hello World</code>的输出：</p><p><img src="/2018/11/06/lab2-report/success.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验过程&quot;&gt;&lt;a href=&quot;#实验过程&quot; class=&quot;headerlink&quot; title=&quot;实验过程&quot;&gt;&lt;/a&gt;实验过程&lt;/h2&gt;&lt;p&gt;按照实验讲义的提示，首先找到了libc库所在的位置，输出基本与讲义中给出的一致，不作赘述。&lt;/p&gt;
&lt;p&gt;编写的测试文件a.
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
  <entry>
    <title>PA2实验报告</title>
    <link href="https://mengzelev.github.io/2018/11/06/PA2-report/"/>
    <id>https://mengzelev.github.io/2018/11/06/PA2-report/</id>
    <published>2018-11-06T01:33:26.000Z</published>
    <updated>2018-11-06T01:34:50.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验进度描述"><a href="#实验进度描述" class="headerlink" title="实验进度描述"></a>实验进度描述</h1><p><strong>2018/10/04</strong><br>RTF实验讲义，RTFSC，我是谁，我在哪儿，我要干什么</p><p><strong>2018/10/05</strong><br>经历了两天的RTFSC后终于看懂了框架代码是干嘛的，RTFM实现了<code>sub</code>,<code>push</code>,<code>ret</code>,<code>call</code>等指令，在nemu中运行了第一个程序<code>dummy</code></p><p><strong>2018/10/21</strong><br>听了同学们的建议，先实现了<code>diff-test</code>，结果发现PA2.1的指令实现有bug。修复了这些bug并温故框架代码的构成</p><p><strong>2018/10/22</strong><br>花了一整天对照着FM实现了exec目录下大部分指令，填写<code>opcode_table</code>巨表，然而有海量bug等待发现</p><p><strong>2018/10/27</strong><br>开<code>diff-test</code>跑完了cputest中所有的测试，修复了能发现的PA2.2中的bug。<code>bash runall</code>后看到了绿油油的full-combo，心情舒畅。<s>然而并不知道2.3的时候还有海量bug等着自己</s></p><p><strong>2018/10/28</strong><br>实现了<code>string.c</code>中所有的库函数和<code>sprintf</code>，先在nemu外单独手动测试，然后放入klib中，成功运行<code>string.c</code>和<code>hell-str.c</code>，PA2.2基本完成，<code>make submit</code></p><p><strong>2018/11/2</strong><br>实现了<code>in/out</code>指令，成功运行<code>hello</code>。与同学出去吃火锅，讨论发现自己的<code>diff-test</code>歪打正着可以正常运行。</p><p><strong>2018/11/3</strong><br>实现了<code>printf</code>，测试时钟时陷入莫名其妙的Segmentation Fault，在指令中加入大量Log测试，无果；找到大腿进行文件替换，无果；把指令实现和库函数又给了大腿二号进行替换，发现一切运行正常。心态爆炸，怀疑人生，git滚回到2.2完成的状态，从2开始的PA2.3。修仙实现了时钟、键盘和vga，并通过了相关测试，成功运行打字游戏（虽然慢的一笔）。跑分测试时还是出现了bug，遂开启<code>diff-test</code>后滚去睡觉</p><p><strong>2018/11/4</strong><br>起来看到结果发现是<code>neg</code>指令写错了，修复bug后成功运行了三个跑分测试。看到超级无敌慢动作马里奥，差点笑死，<s>录成视频发到qq空间被jyy点赞了</s>。复习链接相关知识，自学Makefile语法，编写硬核实验报告。</p><h1 id="必答题"><a href="#必答题" class="headerlink" title="必答题"></a>必答题</h1><blockquote><p>只有聪明的人才看得见</p></blockquote><h1 id="我遇到的那些bug"><a href="#我遇到的那些bug" class="headerlink" title="我遇到的那些bug"></a>我遇到的那些bug</h1><p>以后实验报告新增这一环节，希望可以帮到其他人</p><ul><li>有些指令不是RTL完了就完事的，还需要<code>operand_write</code>写入到相应位置</li><li>test指令手册表意不清，虽然写了<code>DEST := LeftSRC AND RightSRC</code>，但是两个操作数并不需要改变，不需要进行<code>operand_write</code></li><li>框架里已经为你准备了丰富多彩的译码函数，有些指令有自己特殊的译码函数，赶紧到<code>decode.h</code>里去康康吧！</li><li><code>ret</code>指令需要跳转到返回地址的，没有好好RTFM的后果</li><li><code>sar</code>是需要符号扩展的</li><li>译码函数的立即数读入也是需要符号扩展的</li><li>编译<code>timetest</code>的时候链接出错：<code>undefined reference to</code>，其实是因为<code>stdio.c</code>没有加上重要的头文件</li><li>运行跑分测试<code>coremark</code>时出现内存地址越界，发现是<code>opcode_table</code>中的<code>imul</code>指令的译码函数写错了</li><li><code>neg</code>指令只需要直接取反加一</li><li>不知道时钟怎么写，可以参考一下<code>_putc</code>的代码，里面有提示</li><li><code>native</code>的输入输出实现里有不少提示可供参考</li><li><strong>框架代码中没有rol指令，不知道是可爱PA作者的疏忽还是故意让我们练手的</strong></li></ul><h1 id="蓝框思考题"><a href="#蓝框思考题" class="headerlink" title="蓝框思考题"></a>蓝框思考题</h1><p>临近期中考试，时间不是很充裕，写得很少，但愿今后有机会二周目思考吧</p><ul><li><p>Q:AT&amp;T格式反汇编结果中的少量指令, 与i386手册中列出的指令名称不符, 如cltd. 除了STFW之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?<br>A:先STFW试图搞清楚这个指令是干什么的，然后翻手册的目录寻找描述差不多的指令。比如<code>cltd</code>是Convert longword to doubleword的意思，翻手册的目录能找到意思差不多的Convert word to double word。运气好的话可能在STFW的时候就能找到对应的i386的指令名称了。</p></li><li><p>Q：你或许会感到疑惑, 代码优化不是一件好事情吗? 为什么会有volatile这种奇葩的存在? 思考一下, 如果代码中p指向的地址最终被映射到一个设备寄存器, 去掉volatile可能会带来什么问题?<br>  A：因为编译器基本是根据输入输出状态进行的代码优化，而我们有些时候是care中间过程的，例如lab01中的性能测试。如果代码中<code>p</code>指向的地址最终被映射到一个设备寄存器，可能会发生设备状态的跳变，比如显示器某块地方应该是由蓝变绿再变红，会直接从蓝色变成红色。</p></li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>未测试的代码永远是错的，测试过的代码也不会是对的！隐藏bug无处不在。【PA2.2full-combo的大家几乎都在2.3里发现了cputests没能暴露的bug，以此类推PA3的时候可能还会发现PA2的bug</li><li>要及时坚定滚回去从头再来的决心，试过了力所能及的所有方法都找不出来的bug就不要找了，肯定是在一些玄学的地方犯了玄学的错误，干脆从头重新写一遍</li><li>am相关的概念还不是非常清楚，目前还不影响做实验，但还是想进一步了解</li><li>Copy-paste是坏文明</li><li>github private远程库保命是真的很重要，安心多了</li><li>跑分结果堪忧，但是本着先写对，再完美的宗旨，<s>不管了</s>还是值得开心一下的</li><li>bug死活找不出的时候容易心态血崩，但是这时候只要实现一个小的功能就能瞬间高兴回来</li><li>敲代码真**开心</li></ul><h1 id="Appreciation"><a href="#Appreciation" class="headerlink" title="Appreciation"></a>Appreciation</h1><ul><li>感谢“™写™PA真™开心”群的群友们，一起修仙，一起写bug，一起交流bug，帮忙debug，<s>还在心态快崩的时候一起出去约了顿火锅</s></li><li>感谢xy同学，提供了可供替换的大腿，做得太快了，还给我剧透了不少，让我少踩了不少坑</li><li>感谢ldw同学，用我的代码替换到了他的代码上证明我的指令集和库函数并没有大问题，给了我滚回去重做的决心（</li><li>感谢某位还是不愿意透露姓名的nb学长，通过千里眼，帮忙发现了不少bug</li></ul><p>本实验报告同样会将去掉必答题的版本同步上传至<a href="https://mengzelev.github.io/">个人blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验进度描述&quot;&gt;&lt;a href=&quot;#实验进度描述&quot; class=&quot;headerlink&quot; title=&quot;实验进度描述&quot;&gt;&lt;/a&gt;实验进度描述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;2018/10/04&lt;/strong&gt;&lt;br&gt;RTF实验讲义，RTFSC，我是谁，我在哪儿，
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-单源最短路径</title>
    <link href="https://mengzelev.github.io/2018/10/30/clrs-24Single-Source-Shortest-Path/"/>
    <id>https://mengzelev.github.io/2018/10/30/clrs-24Single-Source-Shortest-Path/</id>
    <published>2018-10-30T14:29:50.000Z</published>
    <updated>2018-11-07T08:18:49.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前备概念"><a href="#前备概念" class="headerlink" title="前备概念"></a>前备概念</h1><h2 id="环路"><a href="#环路" class="headerlink" title="环路"></a>环路</h2><p>如果有<strong>负权重环路</strong>，问题比较大，因为你在环路里往死里转路径要多短有多短，这时候定义最短路径长度为负无穷。$\delta(u,v)=-\infty$</p><p>如果有<strong>正权重环路</strong>，那最短路径肯定不会走这个环路，所以不影响</p><p>如果有<strong>0权重环路</strong>，那这个环路等于没有，也不影响</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>$v.d$：最短路径估计</p><p>使用下面运行时间为$\Theta(V)$的算法来对最短路径估计和前驱结点进行初始化：</p><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/initialize.png"></p><p>初始化操作的时间复杂度为$\Theta(V)$</p><h2 id="松弛操作"><a href="#松弛操作" class="headerlink" title="松弛操作"></a>松弛操作</h2><p>松弛过程：试图改善从$s$到$v$的最短路径。<br>可能降低最短路径的估计值$v.d$并更新$v$的前驱属性$v.\pi$</p><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/relax.png"></p><p>松弛是<strong>唯一</strong>导致最短路径估计和前驱结点发生变化的操作</p><p>本章讨论的所有算法之间的不同之处是对每条边进行松弛的次数和松弛边的次序有所不同</p><h2 id="最短路径和松弛操作的性质"><a href="#最短路径和松弛操作的性质" class="headerlink" title="最短路径和松弛操作的性质"></a>最短路径和松弛操作的性质</h2><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/properties.png"><br>这几条最好要背下来的，我觉得考试很容易考</p><p>为了方便记忆，po主尝试着<s>用人话</s>复述一遍：</p><ul><li><strong>三角不等式性质：</strong>图里任意两个点和源点$s$构成一个三角形（可以退化为直线），有两边之和大于等于第三边</li><li><strong>上界性质：</strong>$v.d$撑死就是$\delta(s,v)$，不能再小了</li><li><strong>非路径性质：</strong>原话已经很人话了</li><li><strong>收敛性质：</strong>松弛前边的起点已求得最短路径，松弛后边的终点也将获得最短路径buff</li><li><strong>路径松弛性质：</strong>只要一条最短路径上的点是按松弛的，那么估计值就等于最短路径</li><li><strong>前驱子图性质：</strong>最短路径算完了，前驱子图是一颗根结点为$s$的最短路径树</li></ul><h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h2><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><ul><li>先将结点进行初始化</li><li>对每条边进行$|V|-1$次松弛操作</li><li>当存在负权重环路时会返回FALSE</li><li>如果不存在负权重环路，则返回TRUE，每个结点的$v.d$即为源点$s$到该点的最短路径长度</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/BF-alg.png"></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(VE)$</p><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>用到了三角不等式 + 非路径性质 + 前驱子图性质 </p><h1 id="有向无环图（DAG）中的单源最短路径问题"><a href="#有向无环图（DAG）中的单源最短路径问题" class="headerlink" title="有向无环图（DAG）中的单源最短路径问题"></a>有向无环图（DAG）中的单源最短路径问题</h1><p>无环，因此没有负权重的环，对于任何结点，最短路径都是存在的</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>先对DAG进行拓扑排序，按照拓扑排序的顺序对每个结点进行松弛操作</p><h2 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/dag-alg.png"></p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>拓扑排序(1)： $\Theta(V+E)$</li><li>初始化(2)：$\Theta(V)$</li><li>3~5行的循环（聚合分析）：$\Theta(V)$<br>总时间复杂度：$\Theta(V+E)$</li></ul><h2 id="正确性证明-1"><a href="#正确性证明-1" class="headerlink" title="正确性证明"></a>正确性证明</h2><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/24-5.png"><br>精髓还是在于神奇的路径松弛性质，只要保证每条最短路径上边的松弛次序，就能得出算法终止时$v_i.d=\delta(s,v_i)$</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>PERT图</p><h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><ul><li>解决带权重的有向图上的单源最短路径问题</li><li>要求所有边的权重都为<strong>非负值</strong></li><li>维护一组结点结合$S$，从源点$s$到该集合中每个结点之间的最短路径已经被找到</li><li>使用贪心策略，每次都从结点集$V-S$中选择最短路径估计最小的结点$u$，然后更新与$u$相连的结点的最短路径估计值</li></ul><h2 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2018/10/30/clrs-24Single-Source-Shortest-Path/dijkstra-alg.png"></p><h2 id="正确性证明-2"><a href="#正确性证明-2" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>循环不变式：在算法第4~8行的<code>while</code>语句的每次循环开始前，对于每个结点$v\in S$，有$v.d=\delta(s,v)$</p><p>证明使用了反证法+最小数原理<br>关键步用到了收敛性质和权重非负的假设</p><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>依赖于最小优先队列的实现</p><ul><li>数组遍历： $O(V^2)$</li><li>二叉堆：$O(E\lg V)$</li><li>斐波那契堆:$O(V\lg V+E)$</li></ul><h1 id="最短路径性质的证明"><a href="#最短路径性质的证明" class="headerlink" title="最短路径性质的证明"></a>最短路径性质的证明</h1><h2 id="三角不等式"><a href="#三角不等式" class="headerlink" title="三角不等式"></a>三角不等式</h2><p>根据最短路径的定义即可得证</p><h2 id="最短路径树性质"><a href="#最短路径树性质" class="headerlink" title="最短路径树性质"></a>最短路径树性质</h2><p>最短路径树的三条性质：</p><ul><li>$v’$是图$G$中从源结点$s$可以到达的所有结点的集合</li><li>$G’$形成一棵根结点为$s$的树</li><li>对于所有的结点$v\in V’$，图$G’$中从结点$s$到结点$v$的唯一简单路径是图$G$中从结点$s$到结点$v$的一条最短路径</li></ul><p><u>未完待不会续</u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前备概念&quot;&gt;&lt;a href=&quot;#前备概念&quot; class=&quot;headerlink&quot; title=&quot;前备概念&quot;&gt;&lt;/a&gt;前备概念&lt;/h1&gt;&lt;h2 id=&quot;环路&quot;&gt;&lt;a href=&quot;#环路&quot; class=&quot;headerlink&quot; title=&quot;环路&quot;&gt;&lt;/a&gt;环路&lt;/h
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Single Source Shortest Path" scheme="https://mengzelev.github.io/tags/Single-Source-Shortest-Path/"/>
    
      <category term="Bellman-Ford" scheme="https://mengzelev.github.io/tags/Bellman-Ford/"/>
    
      <category term="Dijkstra" scheme="https://mengzelev.github.io/tags/Dijkstra/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-基本图论算法</title>
    <link href="https://mengzelev.github.io/2018/10/24/clrs-22graphic-algs/"/>
    <id>https://mengzelev.github.io/2018/10/24/clrs-22graphic-algs/</id>
    <published>2018-10-24T06:20:35.000Z</published>
    <updated>2018-10-30T15:04:07.416Z</updated>
    
    <content type="html"><![CDATA[<p><u>辣鸡po主只挖坑不填坑</u><br>因为作业实在太多了！！！</p><p>试一下<code>Mathjax</code>有没有配置成功！</p><h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><h2 id="邻接链表-Adjacency-list"><a href="#邻接链表-Adjacency-list" class="headerlink" title="邻接链表(Adjacency-list)"></a>邻接链表(Adjacency-list)</h2><ul><li>由一个包含$|V|$条链表的数组<code>Adj</code>所构成，<code>Adj[u]</code>包含所有与结点u之间有右边相连的结点v</li><li>存储空间需求：$\Theta(V+E)$</li><li>鲁棒性高，稍加修改可以支持许多图的变种（如：有权图）</li><li>缺陷：无法快速判断一条边是否在图中</li></ul><h2 id="邻接矩阵-Adjacency-matrix"><a href="#邻接矩阵-Adjacency-matrix" class="headerlink" title="邻接矩阵(Adjacency-matrix)"></a>邻接矩阵(Adjacency-matrix)</h2><ul><li>用矩阵来存储连通信息</li><li>存储空间需求：<code>\Theta(V^2)</code> 与边数|E|无关</li><li>简单，图规模较小时优先使用</li></ul><h1 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>从一个源结点s开始，每次从已发现的结点向未发现的结点扩展</li><li>算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点</li><li>用三种颜色标记结点的访问状态：<ul><li>白色：未被发现</li><li>黑色：本身被发现且所有与之相连的结点都已经被发现</li><li>灰色：本身被发现且与之相连的结点中存在未被发现的</li></ul></li><li>结果可能以来</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><center><br><img src="/2018/10/24/clrs-22graphic-algs/bfs-alg.png"><br></center><ul><li>使用队列存储所有灰色结点</li><li><code>while</code>循环的循环不变式：队列Q中包含的是灰色结点的集合</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>结点信息初始化： O(V)</li><li>队列操作总时间： O(V) （每个结点都要进出各一次）</li><li>扫描邻接链表： O(E)</li></ul><p><strong>总时间复杂度：</strong> O(V+E)<br>是图G的邻接链表大小的一个线性函数</p><h2 id="最短路径正确性证明"><a href="#最短路径正确性证明" class="headerlink" title="最短路径正确性证明"></a>最短路径正确性证明</h2><p>一堆定理和证明</p><h2 id="广度优先树"><a href="#广度优先树" class="headerlink" title="广度优先树"></a>广度优先树</h2><h1 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h1><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>大胆地往前走，走到底再回头（雾</li><li>深度优先搜索的前驱子图可能有多棵树组成，即<strong>深度优先森林</strong>因为搜索可能从多个源结点重复进行</li><li>对结点进行黑白灰染色，可以保证每个结点仅在一棵深度优先树中出现，保证所有的深度优先树是不相交的</li><li>时间戳： 每个结点v有两个时间戳<ul><li>第一个时间戳<code>v.d</code>记录结点v第一次被发现的时间（染上灰色的时候）</li><li>第二个时间戳<code>v.f</code>记录搜索完成对v的邻接链表扫描的时间（图上黑色的时候）</li><li>时间戳都是处于1和2|V|之间的整数</li><li><code>u.d</code> &lt; <code>u.f</code></li></ul></li><li>非树边：<ul><li>前向边F：从祖先指向后代</li><li>后向边B：从后代指向祖先（包括有向图中的自循环）</li><li>横向边C：两端点无血缘关系</li></ul></li></ul><h2 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h2><center><br><img src="/2018/10/24/clrs-22graphic-algs/dfs-alg.png"><br></center><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>结点信息初始化： O(V)</li><li><code>DFS-VISIT</code>： O(E)</li></ul><p><strong>总运行时间： </strong>O(V+E)</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>能提供关于图结构的价值很高的信息</p><h2 id="括号化结构"><a href="#括号化结构" class="headerlink" title="括号化结构"></a>括号化结构</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;辣鸡po主只挖坑不填坑&lt;/u&gt;&lt;br&gt;因为作业实在太多了！！！&lt;/p&gt;
&lt;p&gt;试一下&lt;code&gt;Mathjax&lt;/code&gt;有没有配置成功！&lt;/p&gt;
&lt;h1 id=&quot;图的表示&quot;&gt;&lt;a href=&quot;#图的表示&quot; class=&quot;headerlink&quot; title=&quot;图的表
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Single Source Shortest Path" scheme="https://mengzelev.github.io/tags/Single-Source-Shortest-Path/"/>
    
      <category term="Bellman-Ford" scheme="https://mengzelev.github.io/tags/Bellman-Ford/"/>
    
      <category term="Dijkstra" scheme="https://mengzelev.github.io/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-树</title>
    <link href="https://mengzelev.github.io/2018/10/14/tree/"/>
    <id>https://mengzelev.github.io/2018/10/14/tree/</id>
    <published>2018-10-14T08:00:05.000Z</published>
    <updated>2018-10-15T01:17:40.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本章可用结论整理"><a href="#本章可用结论整理" class="headerlink" title="本章可用结论整理"></a>本章可用结论整理</h1><ul><li>定理4.1：e是图G的桥当且仅当e不在G的任何一个cycle上</li><li>定理4.2：图G是树当且仅当G的任意两个顶点只有唯一的path相连</li><li>定理4.3：每一棵非简单树都有至少两个端点(end-vertice)</li><li>定理4.4：每棵有n个顶点的树都有n-1条边</li><li>推论4.6：每棵有k个component的森林都有n-k条边</li><li>定理4.7：每一个有n个顶点的连通图至少有n-1条边</li><li>定理4.8：有n个顶点、m条边的图G，若满足以下3条性质中的2条：(1)连通 (2)无环 (3)m = n - 1，则G是树</li><li>定理4.9：设T是一棵有k个顶点的树。如果图G中最小的度数不小于k-1，那么T与G的某个子图同构</li><li>定理4.10：每个连通图都包含了一棵生成树</li><li>定理4.15(Tree Formula): 有n个不相同的顶点的树的个数为$n^{n-2}$</li><li>定理4.16(Matrix Tree Theorem):<br><img src="/2018/10/14/tree/theorem4-16.png"></li></ul><h1 id="桥-Bridges"><a href="#桥-Bridges" class="headerlink" title="桥(Bridges)"></a>桥(Bridges)</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>如果$e=uv$是连通图$G$的一条边，且$G-e$不连通，则$e$称为连通图$G$的<strong>桥</strong>.</p><p>如果$G$是非连通图，那么<strong>桥</strong>$e$是G一个部分(component)的桥。</p><p>考虑componnet的数目，边$e$是图$G$的桥当且仅当$k(G-e)=k(G)+1$</p><h2 id="定理4-1"><a href="#定理4-1" class="headerlink" title="定理4.1"></a>定理4.1</h2><p>$e$是图$G$的桥当且仅当$e$不在$G$的任何一个cycle上。</p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树即<strong>无环的连通图</strong>。<br>树<strong>所有</strong>的边都是桥。<br>树也是所有边都是桥的连通图。</p><p><strong>双星(double star)</strong>:包含了恰好两个非端点的树（这两个端点必然相邻）</p><p><strong>毛虫树(caterpillar)</strong>:定点数大于等于3、除去端点后得到的是path的树。<br>除去端点后得到的path叫作毛虫树的<strong>脊椎(spine)</strong>；<br>顶点数不小于3的path，star，double star都是毛虫树<br><s>端点其实就是毛毛虫的脚脚</s></p><p><strong>森林(Forests)</strong>:无环图。森林的每个component的都是树。(过于形象<br>森林不一定要是连通的，但是树必须是。</p><h2 id="定理4-2"><a href="#定理4-2" class="headerlink" title="定理4.2"></a>定理4.2</h2><p>图$G$是树当且仅当$G$的任意两个顶点只有唯一的path相连</p><p>这个证明嘛，只有唯一的path不是和无环是等价的吗(流汗.jpg</p><h2 id="定理4-3"><a href="#定理4-3" class="headerlink" title="定理4.3"></a>定理4.3</h2><p>每一棵非简单树都有至少两个端点(end-vertice)</p><p>证明取了最长路径的两个端点，利用了最长路径上的端点都不与非路径上点相邻的性质，证得最长路径的两个端点都是end-vertice</p><p>这条性质非常有用，可以成为对树结构使用<strong>数学归纳法</strong>的依据，划掉一个端点就会使order-1<br>使用数学归纳法证明图相关结论的关键在于<strong>找到一个end-vertice</strong></p><h2 id="定理4-4"><a href="#定理4-4" class="headerlink" title="定理4.4"></a>定理4.4</h2><p>每棵有n个顶点的树都有n-1条边</p><p>证明使用了基于定理4.3的数学归纳法，很直观</p><h2 id="推论4-6"><a href="#推论4-6" class="headerlink" title="推论4.6"></a>推论4.6</h2><p>每棵有k个component的森林都有n-k条边</p><p>简单的边数计算就能证明</p><h2 id="定理4-7"><a href="#定理4-7" class="headerlink" title="定理4.7"></a>定理4.7</h2><p>每一个有n个顶点的连通图至少有n-1条边。</p><p>证明用到了最小数原理，假设存在一个顶点最少的图少于n-1条边，然后证明此时至少会有一个端点(end vertex)，这时就可以把那一个端点去掉得到一个更小的满足条件的图，从而与假设矛盾。</p><h2 id="定理4-8"><a href="#定理4-8" class="headerlink" title="定理4.8"></a>定理4.8</h2><p>有n个顶点、m条边的图G，若满足以下3条性质中的2条：</p><ul><li>连通</li><li>无环</li><li>m = n - 1<br>则G是树</li></ul><p>证明非常直观，活用了上面的定理</p><h2 id="定理4-9"><a href="#定理4-9" class="headerlink" title="定理4.9"></a>定理4.9</h2><p>设T是一棵有k个顶点的树。如果图G中最小的度数不小于k-1，那么T与G的某个子图同构</p><h1 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h1><p>实际中存在村庄造路的问题，即造一些路使得所有村庄都连通，并保证造这些路的开销最小<br>这样的问题可以归结为最小生成树问题，求解一个有权图中权值最小的生成树</p><h2 id="Kruskal’s-Algorithm"><a href="#Kruskal’s-Algorithm" class="headerlink" title="Kruskal’s Algorithm"></a>Kruskal’s Algorithm</h2><p>算法描述：先取权最小的两条边，从第三次开始，每次都取不与取过的边构成cycle的、权最小的边，直到取满n-1条边为止。类似于贪心算法。</p><p>正确性证明也类似于证明贪心用到的<strong>替换法</strong>，取最优解中与算法解重叠最大的解，进行替换，导出矛盾。</p><h2 id="Prim’s-Algorithm"><a href="#Prim’s-Algorithm" class="headerlink" title="Prim’s Algorithm"></a>Prim’s Algorithm</h2><p>算法描述：先取权最小的一条边，之后每次都选择连接了未连接的点和已连接的点的边中权最小的一条，知道选择了n-1条边为止。类似于动态规划。</p><p>证明思路类似于<strong>剪切-粘贴法</strong>。难以概括……</p><h1 id="生成树的个数"><a href="#生成树的个数" class="headerlink" title="生成树的个数"></a>生成树的个数</h1><p>书上这部分完全就是在讲故事啊(╯°Д°)╯︵┻━┻</p><h1 id="图论证明特点"><a href="#图论证明特点" class="headerlink" title="图论证明特点"></a>图论证明特点</h1><p><s>自己xjb总结的，仅供参考</s></p><ul><li>多用反证法</li><li>…….我再想想</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本章可用结论整理&quot;&gt;&lt;a href=&quot;#本章可用结论整理&quot; class=&quot;headerlink&quot; title=&quot;本章可用结论整理&quot;&gt;&lt;/a&gt;本章可用结论整理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;定理4.1：e是图G的桥当且仅当e不在G的任何一个cycle上&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph" scheme="https://mengzelev.github.io/tags/Graph/"/>
    
      <category term="Tree" scheme="https://mengzelev.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Lab1-乘法 实验报告</title>
    <link href="https://mengzelev.github.io/2018/10/12/lab1-report/"/>
    <id>https://mengzelev.github.io/2018/10/12/lab1-report/</id>
    <published>2018-10-12T09:17:47.000Z</published>
    <updated>2018-10-15T01:25:08.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务1：实现multimod"><a href="#任务1：实现multimod" class="headerlink" title="任务1：实现multimod"></a>任务1：实现<code>multimod</code></h1><p>使用了高精度数乘法计算<code>a*b</code>，然后模拟手算除法的形式写了高精度除法（取模）。代码见文件<code>p1.c</code>.</p><h2 id="正确性-伪-证明"><a href="#正确性-伪-证明" class="headerlink" title="正确性(伪)证明"></a>正确性(伪)证明</h2><p>使用python随机生成生成了1000000组a、b、m，0~9223372036854775807(int64_t的最大值)并计算对应答案，与p1.c的计算结果进行对比。</p><p>python随机数生成代码如下：</p><pre><code>import randomMAX = 9223372036854775807for i in range(1,1000000)：    a = random.randint(0,MAX)    b = random.randint(0,MAX)    m = random.randint(1,MAX)    ans = (a * b) % m    print (a,b,m,ans)</code></pre><p>测试结果一百万组全对（从零开始计数的）<br><img src="/2018/10/12/lab1-report/1.png"></p><h1 id="任务2：性能优化"><a href="#任务2：性能优化" class="headerlink" title="任务2：性能优化"></a>任务2：性能优化</h1><p>由于是先听的课再做的lab，出于惰性直接按照jyy课上讲的方法做了<s>（我去面壁）</s>就不多解释了，代码见p2.c</p><h2 id="时间测试思路"><a href="#时间测试思路" class="headerlink" title="时间测试思路"></a>时间测试思路</h2><p>STFW找到了计算使用<code>time.h</code>库函数计算运行时间的方法，也有计算时钟周期的方法，但是后者使用了汇编代码，在对未知事物的恐惧(这样真的不好)的驱使下还是选择了比较好理解、比较好控制的前者。为了防止计算步骤被优化，又不能让多于的操作占用过多的时间，就使程序计算了正确的case的个数并输出。所以得到的时间应该比实际运行时间长一些。</p><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p><img src="/2018/10/12/lab1-report/time.png"><br>注：其中<code>p1.c</code>为任务一中的高精度实现，<code>p2.c</code>为任务二中的优化算法，<code>p3.c</code>为任务三中的神奇代码</p><h2 id="运行时间分析"><a href="#运行时间分析" class="headerlink" title="运行时间分析"></a>运行时间分析</h2><p>记<code>a,b,m</code>的位数为n<br>高精度除法需要做<code>O(n)</code>次减法和比较，每次减法和比较的时间复杂度也都为<code>O(n)</code>，因此总时间复杂度是<code>O(n^2)</code><br>任务二中优化过的时间需要循环次数是<code>O(n)</code>的，每次循环的操作都能在常数时间<code>O(1)</code>内完成，因此总时间复杂度为<code>O(n)</code><br>而神奇代码对任何输入消耗的时间都是相同的，时间复杂度为<code>O(1)</code><br>从运行时间上来看的确是<code>t(p1)&gt;t(p2)&gt;t(p3)</code>，符合预期<br>一个神奇的现象是，随着优化等级的升高，运行时间不一定缩短。尤其是p2.c的运行情况，O1和O2反而不如O0（虽然也只差了0.001ms），于是我反汇编对比了一下，发现<code>multimod</code>、<code>testcases</code>和<code>main</code>几个函数的汇编代码几乎一模一样，但对应行的行数不同，可能是调用了不同的系统库函数。对优化的原理不太了解，暂时无法想到合理的解释。可能是因为这个程序的优化空间不是太大？但是编译器肯定比我智能多了，我想不到优化方法不能看不起编译器啊。</p><h1 id="任务3：解析神秘代码"><a href="#任务3：解析神秘代码" class="headerlink" title="任务3：解析神秘代码"></a>任务3：解析神秘代码</h1><p><strong>结论</strong>：<code>ab</code>乘积不超过<code>2^53</code>次方，<code>m</code>在<code>int64_t</code>范围内任意取值，可以保证<code>multimod_fast</code>总是能返回正确的数值</p><p>过程非常曲折，以下都是流水账碎碎念，老师嫌长可以不看，自己写着好玩，回头上传个人Blog</p><p>刚拿到手先试了一大堆随机数据，发现一百万组测试样例总只能过1w+组，正确率非常低。后来和同学讨论了一下，听说<code>m</code>比较小的时候结果最容易出错，我就把<code>m</code>的随机范围改成了<code>1~3</code>，果然错误率高了很多。大概是因为神秘代码中<code>(int64_t)((double)a * b / m + 1e-8)</code>强制类型转换后要除以<code>m</code>，如果<code>m</code>偏小，那么<code>a*b</code>的误差就很容易保存下来，引起答案出错。</p><p>保持<code>m</code>1~3的范围，我又试了几组大数。发现是在<code>ab</code>乘积为<code>10^19</code>左右的时候（a和b在算法找中地位是等价的，所以只需要关注<code>ab</code>的乘积的范围）会出现计算错误，于是在这个范围附近取了一些数，绝了，这个使结果正确的区间并不是连续的！然后理智烧却瞎测了几组数据，不太能发现规律，决定先冷静下来，从理论上思考一下算法。<s>毕竟这次是关于数据表示形式的Lab嘛</s></p><p>这个神奇代码大概是把ab乘积转换为<code>double</code>类型。<code>double</code>类型能表示的范围是大于<code>int64_t</code>的，但是精度不够，尾数部分只有52位的精度（加上前面的1一共是53位），所以应该是只能保证这53位的精度，于是我打开<code>python</code>计算器计算了一下<code>2^26.5 =</code>，大概是94900000，于是我把任务一中随机数的生成范围改为了<code>(0,94900000)</code>，测试了5次，每次一百万组，都是全对的。</p><p><img src="/2018/10/12/lab1-report/double.png"></p><p>到这里我就很想吐槽了，这范围怎么还能算<code>int64_t</code>的，保证结果正确的<code>a</code>和<code>b</code>的范围<code>int</code>都达不到，如果能保证输入在这个范围之内，还不如直接用<code>int64_t</code>算呢，<code>ab</code>相乘肯定不会溢出的。但是如果<code>a</code>和<code>b</code>乘积位表示下末尾零比较多，还是有可能正确的。所以这根本就是一份拼人品的神奇代码吗…..</p><p>目前尚未想通的问题：</p><ul><li>为什么要<code>+1e-8</code>？</li><li>为什么返回时需要判断<code>t</code>的正负并做相应修正？</li></ul><p>最后，这个神奇代码毕竟是<code>O(1)</code>的，凭我的算法功底实在没办法优化到<code>O(n)</code>以下，所以神奇代码虽然正确率不高，但是效率还是很感人的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;任务1：实现multimod&quot;&gt;&lt;a href=&quot;#任务1：实现multimod&quot; class=&quot;headerlink&quot; title=&quot;任务1：实现multimod&quot;&gt;&lt;/a&gt;任务1：实现&lt;code&gt;multimod&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;使用了高精度数乘法
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-用于不相交集合的数据结构</title>
    <link href="https://mengzelev.github.io/2018/10/06/clrs-21DisjointSets/"/>
    <id>https://mengzelev.github.io/2018/10/06/clrs-21DisjointSets/</id>
    <published>2018-10-06T08:05:58.000Z</published>
    <updated>2018-10-07T07:33:25.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不相交集合的操作"><a href="#不相交集合的操作" class="headerlink" title="不相交集合的操作"></a>不相交集合的操作</h1><p>一个<strong>不相交集合数据结构</strong>维护了一个不相交动态集的集合<br>每个集合都有一个<strong>代表</strong>标识，它是该集合的某个成员</p><p>我们希望集合支持以下三个操作：</p><p><img src="/2018/10/06/clrs-21DisjointSets/operations.png"></p><h2 id="应用：确定无向图的连通分量"><a href="#应用：确定无向图的连通分量" class="headerlink" title="应用：确定无向图的连通分量"></a>应用：确定无向图的连通分量</h2><center><br><img src="/2018/10/06/clrs-21DisjointSets/g21-1.png"><br><img src="/2018/10/06/clrs-21DisjointSets/alg1.png"><br></center><p>算法就是将连通的顶点全部合并到同一个集合中。</p><h1 id="不相交集合的链表表示"><a href="#不相交集合的链表表示" class="headerlink" title="不相交集合的链表表示"></a>不相交集合的链表表示</h1><p>每个集合可以用一个自己的链表来表示<br>链表中对象可以以任意次序出现</p><p>每个链表组成为：</p><ul><li><code>head</code>– 指向表的第一个对象（代表元）</li><li><code>tail</code>– 指向表的最后一个对象</li></ul><p>链表中每个对象的组成为：</p><ul><li>关键字<code>key</code></li><li>指向<code>head</code>的指针<code>prev</code></li><li>指向后一个对象的指针<code>next</code></li></ul><p>时间复杂度：<br><code>MAKE-SET</code>  O(1)<br><code>FIND-SET</code>  O(1)<br><code>UNION</code>（简单实现） $\Theta(n^2)$  【摊还分析】</p><h2 id="简单加权合并启发式策略"><a href="#简单加权合并启发式策略" class="headerlink" title="简单加权合并启发式策略"></a>简单加权合并启发式策略</h2><p>策略是，每次合并时都将较小的链表挂到较大的链表上，需要多维护一个链表长度的属性。</p><p><img src="/2018/10/06/clrs-21DisjointSets/21.1.png"></p><p>证明的核心在于每个对象的指针在所有的<code>UNION</code>操作中最多被更新$\lceil\lg n\rceil$次，因此所有<code>UNION</code>操作中被更新的对象的指针总数为$O(n\lg n)$。加上<code>MAKE-SET</code>和<code>FIND-SEt</code>的O(m)。 </p><h1 id="不相交集合森林"><a href="#不相交集合森林" class="headerlink" title="不相交集合森林"></a>不相交集合森林</h1><p>使用有根树来表示集合。<br>每棵树表示一个集合，树的根结点是该集合的代表元。<br>执行<code>UNION</code>操作时将两棵树的树根合并。<br>实现时可以用到两种改进运行时间的启发式策略。</p><h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>类似链表的加权合并启发式策略<br>为了易于分析，对于每个结点，维护一个<strong>秩</strong>，表示该结点高度的一个上界。<br>秩<code>x.rank</code>代表x的高度的一个上界，高度即<u>从x到某一后代叶结点的最长简单路径上边的数目</u>。<br><code>UNION</code>操作中</p><ul><li>如果根的秩不同，则让较大秩的根成为较小秩的根的父结点，但秩本身保持不变</li><li>如果根的秩相同，则任意选择两个中的一个作为父结点，并使它的秩+1</li></ul><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>在<code>FIND-SET</code>操作中是查找路径中的每个结点直接指向根，不改变任何结点的秩。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><center><br><img src="/2018/10/06/clrs-21DisjointSets/makeset.png"><br><img src="/2018/10/06/clrs-21DisjointSets/union.png"><br><img src="/2018/10/06/clrs-21DisjointSets/findset.png"><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;不相交集合的操作&quot;&gt;&lt;a href=&quot;#不相交集合的操作&quot; class=&quot;headerlink&quot; title=&quot;不相交集合的操作&quot;&gt;&lt;/a&gt;不相交集合的操作&lt;/h1&gt;&lt;p&gt;一个&lt;strong&gt;不相交集合数据结构&lt;/strong&gt;维护了一个不相交动态集的集合&lt;br&gt;
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Disjoint Sets" scheme="https://mengzelev.github.io/tags/Disjoint-Sets/"/>
    
      <category term="Data Structure" scheme="https://mengzelev.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>做pa的时候可能会用到的操作</title>
    <link href="https://mengzelev.github.io/2018/10/04/pa-inspirations/"/>
    <id>https://mengzelev.github.io/2018/10/04/pa-inspirations/</id>
    <published>2018-10-04T09:18:29.000Z</published>
    <updated>2018-10-04T09:21:25.581Z</updated>
    
    <content type="html"><![CDATA[<p>当做笔记随便写写的，希望能帮到一些人吧。毕竟作为一名优秀的bug maker，别人遇到的问题我基本都能遇到的。</p><p>vim和tmux另外写了教程：</p><p><a href="https://mengzelev.github.io/2018/09/06/vim/">vim初探</a></p><p><a href="https://mengzelev.github.io/2018/09/12/tmux/">使用tmux变身炫酷程序猿(x</a></p><p><u>持续更新中</u><br>最后更新:</p><blockquote><p>2018/10/04 17:18:29 新增PA2时运行dummy出错的解决方式</p></blockquote><h1 id="语言规范"><a href="#语言规范" class="headerlink" title="语言规范"></a>语言规范</h1><hr><p>这名字很中二…但其实就是个人写文章的时候一点习惯用的表示，和别人的可能不一样，很可能非常不标准，注意区分就好</p><ul><li>[]方括号表示需要自定义的内容，括起来的只是你应该输入的东西的名字</li><li>$开头的表示在命令行中键入的代码，否则为文件中的代码</li></ul><h1 id="在整个目录下查找代码"><a href="#在整个目录下查找代码" class="headerlink" title="在整个目录下查找代码"></a>在整个目录下查找代码</h1><hr><p>在某个文件里看到某个函数或者宏或者变量的定义的时候经常会好奇在哪里、怎么使用过，除了用<code>/+(搜索内容)</code>靠vim的功能在文件内搜索外，还可以</p><pre><code>$ grep &quot;搜索内容&quot; -r &lt;目录&gt;</code></pre><p>e.g.</p><pre><code>$ grep &quot;CPU_state&quot; -r .</code></pre><p>其中-r表示递归搜索，可以搜索整个目录下所有的文件</p><h1 id="一键跳转定义处"><a href="#一键跳转定义处" class="headerlink" title="一键跳转定义处"></a>一键跳转定义处</h1><hr><p>创建接口的时候经常需要查看某些函数、宏、结构体的定义，于是被某位nb的学长安利了ctags神器，可以一键跳转至定义处并一键调回，先贴上自己查到的教程</p><p>首先需要<strong>安装</strong>ctags，一般来说直接apt就好了，但是莫名不行，可能是镜像源的问题</p><pre><code>$ sudo apt install ctags</code></pre><p>于是我选择了从<a href="http://ctags.sourceforge.net/" target="_blank" rel="noopener">ctags官网</a>手动下载<code>ctags-5.8.tar.gz</code></p><p>如果是在host里下载的，下载后通过自己的共享方式扔到虚拟机里面，进行<strong>解压缩</strong></p><pre><code>$ cd [压缩包所在目录]$ tar jxvf [文件名].tar.bz</code></pre><p>解压后<strong>手动安装</strong></p><pre><code>$ cd ctags-5.8$ ./configure$ make$ make install</code></pre><p>安装完成后<strong>测试</strong>一下是否安装成功</p><pre><code>$ whereis ctags</code></pre><p>你应该能看到让你觉得成功的提示信息。</p><p>安装成功后，为源码<strong>生成tags文件</strong>，在需要使用ctags的目录下(所有子目录都可以享受到)运行</p><pre><code>$ ctags -R</code></pre><p>为了使得字段补全有效，在生成tags时需要一些额外的参数，推荐的c语言（c处可以替换成其他语言）参数主要是：</p><pre><code>$ ctags -R --c-kinds=+px --fields=+iaS --extra=+q</code></pre><p>其中，fileds 用于指定每条标记的扩展字段域，extra 选项用于增加额外的条目，f表示每个文件增加一个条目，q为每个类增加一个条目</p><p>之后<strong>配置vim</strong>，就不用每次都手动设置</p><pre><code>$ vim ~/.vimrc</code></pre><p>在.vimrc 中加入如下内容</p><pre><code>set tags=[path]/tagsset tags=./tags,tags;$HOME</code></pre><p>第二行我暂时也不知道是干什么的，但是不加上去好像用不起来（小声</p><p>然后用vim编辑你需要的代码文件，当光标落到你想查询定义的函数上时使用<code>Ctrl + ]</code>跳转到定义处<s>（其实明明是两键跳转对不对）</s>，然后<code>Ctrl + o</code>或者<code>Ctrl + t</code>返回跳转前的位置。</p><p><a href="https://www.cnblogs.com/zl-graduate/p/5777711.html" target="_blank" rel="noopener">参考教程原地址</a></p><h1 id="编译dummy时出错"><a href="#编译dummy时出错" class="headerlink" title="编译dummy时出错"></a>编译dummy时出错</h1><p>进行到<strong>PA2</strong>开始时，试图编译dummy会产生如下的报错：</p><center><br><img src="/2018/10/04/pa-inspirations/cdefs.png"><br></center><p>这时候如果STFW得到的答案应该是安装<code>libc6-dev-i386</code></p><pre><code>$ sudo apt-get install libc6-dev-i386</code></pre><p>然而我装了之后还是报错，到stackoverflow上稍微刨了一下发现可能还需要安装<code>gcc-multilib</code></p><pre><code>$ sudo apt-get install gcc-multilib</code></pre><p>然后可以开始愉快的PA2了</p><center><br><img src="/2018/10/04/pa-inspirations/dummy.png"><br></center><p><a href="https://askubuntu.com/questions/470796/fatal-error-sys-cdefs-h-no-such-file-or-directory" target="_blank" rel="noopener">stackoverflow原回答地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当做笔记随便写写的，希望能帮到一些人吧。毕竟作为一名优秀的bug maker，别人遇到的问题我基本都能遇到的。&lt;/p&gt;
&lt;p&gt;vim和tmux另外写了教程：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mengzelev.github.io/2018/09/06/vim
      
    
    </summary>
    
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
      <category term="Linux" scheme="https://mengzelev.github.io/tags/Linux/"/>
    
      <category term="vim" scheme="https://mengzelev.github.io/tags/vim/"/>
    
  </entry>
  
</feed>
