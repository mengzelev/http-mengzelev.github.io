<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengzelev&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mengzelev.github.io/"/>
  <updated>2019-03-10T07:40:08.172Z</updated>
  <id>https://mengzelev.github.io/</id>
  
  <author>
    <name>Mengzelev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>问求学习笔记-置换群与拉格朗日定理</title>
    <link href="https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/"/>
    <id>https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/</id>
    <published>2019-03-09T09:15:13.000Z</published>
    <updated>2019-03-10T07:40:08.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="置换群-Permutation-Group"><a href="#置换群-Permutation-Group" class="headerlink" title="置换群(Permutation Group)"></a>置换群(Permutation Group)</h1><p><strong>定理5.1</strong>:The symmetric group on $n$ letters, $S_n$, is a group with $n!$ elements, where<br>the binary operation is the composition of maps.</p><p>置换群(permutation group):所有排列的集合$S_n$的一个子集</p><h2 id="Cycle-Notation"><a href="#Cycle-Notation" class="headerlink" title="Cycle Notation"></a>Cycle Notation</h2><p>A permutation $\sigma\in S_X$ is a <strong>cycle of length</strong> $k$ if there exite elements $a_1,a_2,…a_k\in X$ such that</p><script type="math/tex; mode=display">\sigma(a_1) = a_2</script><script type="math/tex; mode=display">\sigma(a_2) = a_3</script><script type="math/tex; mode=display">...</script><script type="math/tex; mode=display">\sigma(a_k) = a_1</script><p>and $\sigma(x)=x$ for all other elements $x\in X$. </p><p>We write $(a_1,a_2,…a_k)$ to denote the cycle $\sigma$.</p><p>Cycles are the building blocks of all permutations.循环是所有排列的基石。</p><p>Two cycles in $S_X$, $\sigma=(a_1,a-2,…a_k)$, $\tau=(b_1,b_2,…b_l)$, are <strong>disjoint</strong> if $a_i\neq b_j$ for all $i$ and $j$</p><p><strong>命题5.8</strong>: Let $\sigma$ and $\tau$ be 2 disjoint cycles in $S_X$. Then $\sigma\tau=\tau\sigma$.</p><p><strong>定理5.9</strong>: $S_n$中的所有排列都可以被写成不相交循环的乘积的形式。</p><p><strong>Transpositions</strong>: a cycle of length 2 (任意两个数交换位置)</p><p><strong>命题5.12</strong>: 任意至少含有两个元素的有限集的排列都可以写成transposition乘积的形式<br>e.g. (253)=(23)(25)</p><p><strong>引理5.14</strong>: identity(恒等变换)只能写成<strong>偶数个</strong>transposition的乘积的形式</p><p><strong>定理5.15</strong>: 如果一个排列能被写成偶数个置换乘积的形式，那么另一个与之等价的排列也一定拥有偶数项置换乘积。奇数同理。<br>据此定理可以将排列分为奇偶两类</p><h3 id="交替组-The-Alternating-Groups"><a href="#交替组-The-Alternating-Groups" class="headerlink" title="交替组(The Alternating Groups)"></a>交替组(The Alternating Groups)</h3><p>交替组$A_n$是所有偶排列的集合</p><p><strong>定理5.16</strong>: 集合$A_n$是$S_n$的子群</p><p><strong>命题5.17</strong>: $S_n$中奇排列和欧排列的数目相等，都为$n!/2$</p><h1 id="反组-Dihedral-Groups"><a href="#反组-Dihedral-Groups" class="headerlink" title="反组(Dihedral Groups)"></a>反组(Dihedral Groups)</h1><p>the <strong>nth dihedral group</strong>($D_n$): the group of rigid motions of a regular n-gon(正多边形的刚性运动=转动+反射)</p><p><strong>定理5.20</strong>: $D_n$ is a subgroup of $S_n$ of order $2n$</p><p><strong>定理5.23</strong>: The group $D_n$, $n\ge 3$, consists of all products of the two elements $r$ and $s$, satisfying the relations</p><script type="math/tex; mode=display">r^n=1</script><script type="math/tex; mode=display">s^2=1</script><script type="math/tex; mode=display">srs=r^{-1}</script><p>($r,s$分别为转动和反射)</p><script type="math/tex; mode=display">D_n=\{1,r,r^2,..,r^{n-1},s,sr,sr^2,...,sr^{n-1}\}</script><h2 id="立方体的运动"><a href="#立方体的运动" class="headerlink" title="立方体的运动"></a>立方体的运动</h2><p><strong>命题5.27</strong>: The group of rigid motions of a cube contains 24 elements.</p><p><strong>命题5.28</strong>: The group of rigid motions of a cube is $S_4$.(看体对角线)</p><h1 id="陪集-Coset"><a href="#陪集-Coset" class="headerlink" title="陪集(Coset)"></a>陪集(Coset)</h1><p>$G$为群，$H$为$G$的子群，定义<br><strong>左陪集(left coset)</strong>: $gH=\{gh:~h\in H\}$<br><strong>右陪集(left coset)</strong>: $Hg=\{hg:~h\in H\}$ <s>(这真的不是汞吗)</s><br>其中$g\in G$称为<strong>代表元(representative)</strong></p><p>在交换群中，左陪集与右陪集是相同的。</p><p><strong>引理6.3</strong>: $g_1,g_2\in G$，以下条件等价:<br>$1. g_1H=g_2H$;<br>$2. Hg_1^{-1}=Hg_2^{-1}$;<br>$3. g_1H\subset g_2H$;<br>$4. g_2\in g_1H$;<br>$5. g_1^{-1}g_2\in H$;</p><p><strong>定理6.4</strong>: $H$为$G$的子群。$H$的左陪集分割(partition)了$G$,即$G$是$H$的左陪集的disjoint union. (右陪集同理)</p><p><strong>index</strong> of $H$: the number of left cosets of $H$ in $G$. 表示为$[G:H]$</p><p><strong>定理6.8</strong>: $H$在$G$中的左陪集与右陪集的个数相等。</p><h1 id="拉格朗日定理"><a href="#拉格朗日定理" class="headerlink" title="拉格朗日定理"></a>拉格朗日定理</h1><p><strong>命题6.9</strong>: 定义映射$H\to gH$ by $\phi(h)=gh$. 该映射是双射，$H$中元素的个数等于$gH$中元素的个数。</p><p><strong>定理6.10(拉格朗日定理)</strong>: Let $G$ be a finite group and let $H$ be a subgroup of $G$. Then $|G|/|H|=[G:H]$ is the number of distinct left cosets of $H$ in $G$. In particular, the number of elements in $H$ must divide the number of elements in $G$.</p><script type="math/tex; mode=display">|G|=[G:H]|H|</script><p><strong>推论6.11</strong>: Suppose that $G$ is a finite group and $g\in G$. Then the order of $g$ must divide the number of elements in $G$.</p><p><strong>推论6.12</strong>: Let $|G|=p$ with $p$ a prime number. Then $G$ is cyclic and any $g\in G$ such that $g\neq e$ is a generator. 含有质数个元素的群为循环群且任何非单位元的元素都是生成元。</p><p><strong>推论6.13</strong>: Let $H$ and $K$ be subgroups of a finite group $G$ such that $G\supset H\supset K$. Then $[G:K]=[G:H][H:K]$.</p><p><strong>拉格朗日定理的逆命题是不成立的</strong></p><p><strong>命题6.15</strong>: The group $A_4$ has no subgroup of order 6.</p><p><strong>定理6.16</strong>: Two cycles $\tau$ and $\mu$ in $S_n$ have the same length if and only if there exists a $\sigma\in S_n$ such that $\mu=\sigma\tau\sigma^{-1}$.</p><h1 id="费马与欧拉定理"><a href="#费马与欧拉定理" class="headerlink" title="费马与欧拉定理"></a>费马与欧拉定理</h1><p>欧拉函数$\phi(n)$表示$n$以内与$n$互质的数的个数<br>对任意质数$p$, $\phi(p)=p-1$</p><p><strong>定理6.17</strong>: Let $U(n)$ be the group of units in $\mathbb{Z}_n$. Then $|U(n)|=\phi(n)$</p><p><s>怎么又是欧拉</s><br><strong>定理6.18(欧拉定理)</strong>: Let $a$ and $n$ be integers such that $n&gt;0$ and $gcd(a,n)=1$. Then $a^{\phi(n)}\equiv 1(\mod~n)$</p><p><strong>定理6.19(费马小定理)</strong>: Let $p$ be ant prime number and suppose that $p\nmid a$($p$ does not divide $a$). Then $a^{p-1}\equiv 1(\mod p)$.<br>Furthermore, for any integer $b$, $b^p\equiv b(\mod p)$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;置换群-Permutation-Group&quot;&gt;&lt;a href=&quot;#置换群-Permutation-Group&quot; class=&quot;headerlink&quot; title=&quot;置换群(Permutation Group)&quot;&gt;&lt;/a&gt;置换群(Permutation Group)
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-群论初步</title>
    <link href="https://mengzelev.github.io/2019/03/02/ps-4-2-group/"/>
    <id>https://mengzelev.github.io/2019/03/02/ps-4-2-group/</id>
    <published>2019-03-02T06:03:29.000Z</published>
    <updated>2019-03-09T09:16:30.471Z</updated>
    
    <content type="html"><![CDATA[<p>由于接下来的书没有中文版了，因此笔记中英文都<u>看心情</u></p><h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><h2 id="整数等价类"><a href="#整数等价类" class="headerlink" title="整数等价类"></a>整数等价类</h2><p><strong>命题3.4</strong>：模运算下的整数等价类具有以下性质：</p><ol><li>加法和乘法交换律</li><li>加法和乘法结合律</li><li>加法(0)与乘法(1)恒等式</li><li>乘法分配律</li><li>任意元素都存在加法逆元</li><li>$a$为非零整数，$gcd(a,n)=1$当且仅当$a$存在乘法逆元，即存在非零整数$b$，使得$ab\equiv 1(mod n)$</li></ol><p>(虽然我觉得这玩意儿记了应该没什么卵用)</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>二元运算(binary operation)或合成律(law of composition):a function $G\times G\to G$ that assigns to each pair $(a,b)\in G\times G$ a unique element $a\circ b$, or $ab$ in $G$, called the composition of $a$ and $b$</li><li>群(group): a set $G$ together with a law of composition $(a,b)\mapsto a\circ b$ that satisfies the following axioms:<ol><li>合成律满足<strong>结合律</strong>(asscociative)</li><li>存在<strong>单位元(identity element)</strong>$e\in G$，满足$e\circ a = a\circ e = a$</li><li>对于每个$a\in G$，都存在<em>逆元</em>$a^{-1}$，使得$a\circ a^{-1}=a^{-1}\circ a=e$</li></ol></li><li>群 = 运算封闭+结合律+单位元+逆元</li><li>阿贝尔群(Abelian)或交换群(commutative):满足$a\circ b=b\circ a$的群，反之为nonabelian或noncommutative</li><li>凯莱表(Cayley table):用加法或乘法描述群的表格</li><li>可逆元素群(group of units): 拥有逆元的元素组成的群</li><li>一般线性群(general linear group)</li><li>四元群(quaternion group)</li><li>群是<strong>有限的(finite)</strong>，或者说有<strong>有限序数(has finite order)</strong>，当它具有有限个元素，否则是无限的(infinite)或有无限序数(infinite order)</li></ul><h2 id="群的基本性质"><a href="#群的基本性质" class="headerlink" title="群的基本性质"></a>群的基本性质</h2><p><strong>命题3.17</strong>: 群中的单位元是唯一的<br><strong>命题3.18</strong>: 逆元是唯一的<br><strong>命题3.19</strong>: $G$是群，$a,b\in G$，则$(ab)^{-1}=b^{-1}a^{-1}$<br><strong>命题3.20</strong>: $(a^{-1})^{-1}=a$<br><strong>命题3.21</strong>: $ax=b$和$xa=b$在$G$中有唯一解<br><strong>命题3.22</strong>(左右消去律right and left cancellation law): $ba=ca$ implies $b=c$ and $ab=ac$ implies $b=c$</p><p>对群中的元素，可以定义乘方</p><p><strong>定理3.23</strong>: 在群中，一般指数的运算律成立</p><h2 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h2><ul><li>子群(subgroup):仿照子空间的定义<ul><li>平凡子群(trivial subgroup):$H=\{e\}$</li><li>真子群(proper subgroup)</li></ul></li><li>子群必须继承群的二元运算</li></ul><h3 id="子群相关的定理"><a href="#子群相关的定理" class="headerlink" title="子群相关的定理"></a>子群相关的定理</h3><p><strong>命题3.30</strong>: $G$的子集$H$是子群当且仅当</p><ol><li>$G$的单位元$e\in H$</li><li>$H$对$G$的运算封闭：If $h_1,h_2\in H$, then $h_1h_2\in H$</li><li>If $h\in H$, then $h^{-1}\in H$</li></ol><p><strong>命题3.31</strong>: $H$是$G$的子群当且仅当$H\neq\emptyset$ and whenever $g,h\in H$ then $gh^{-1}$ is in $H$</p><h1 id="循环子群-Cyclic-Subgroups"><a href="#循环子群-Cyclic-Subgroups" class="headerlink" title="循环子群(Cyclic Subgroups)"></a>循环子群(Cyclic Subgroups)</h1><p><strong>定理4.3</strong>: Let $G$ be a group and $a$ be any element in $G$. Then the set $\left⟨a\right⟩=\{a^k:k\in\mathbb{Z}\}$is a subgroup of $G$. Furthermore, $⟨a⟩$ is the <strong>smallest</strong> subgroup of $G$ that contains $a$.</p><p><strong>循环子群(Cyclic Subgroup)</strong>:$⟨a⟩$<br><strong>循环群(Cyclic group)</strong>: 包含了某个元素$a$，使得$G=⟨a⟩$.此时$⟨a⟩$是$G$的<strong>生成器(generator)</strong>.<br>The <strong>order</strong> of $a$: 最小的整数$n$满足$a^n=e$，表示为$|a|=n$。如果不存在满足要求的$n$，则称$a$是<strong>无穷的(infinite)</strong>，表示为$|a|=\infty$<br>e.g. $\mathbb{Z}$和$\mathbb{Z}_n$都是循环群，1和-1是$\mathbb{Z}$的生成器，1是$\mathbb{Z}_n$的生成器但不一定是唯一的。</p><p><strong>定理4.9</strong>: 所有循环群都是可交换的。(Every cyclic group is abelian).</p><p><strong>定理4.10</strong>: 循环群的子群都是循环子群。(Every subgroup of a cyclic group is cyclic.)</p><p><strong>引理4.11</strong>: The subgroups of $\mathbb{Z}$ are exactly $n\mathbb{Z}$ for $n=0,1,2…$</p><p><strong>命题4.12</strong>: Let $G$ be a cyclic group of order $n$ and suppose that $a$ is a generator<br>for $G$. Then $a^k = e$ if and only if $n$ divides $k$.($n$能整除$k$,$k$能被$n$整除)</p><p><strong>定理4.13</strong>: Let $G$ be a cyclic group of order $n$ and suppose that $a\in G$ is a generator<br>of the group. If $b = a^k$, then the order of $b$ is $n/d$, where $d = gcd(k, n)$.</p><p><strong>引理4.14</strong>: The generators of $\mathbb{Z}_n$ are the integers $r$ such that $1\le r&lt; n$ and<br>$gcd(r,n) = 1$. $\mathbb{Z}_n$的生成器与$n$互质。</p><h2 id="复数乘法群-Multiplicative-Group-of-Complex-Numbers"><a href="#复数乘法群-Multiplicative-Group-of-Complex-Numbers" class="headerlink" title="复数乘法群(Multiplicative Group of Complex Numbers)"></a>复数乘法群(Multiplicative Group of Complex Numbers)</h2><p>一堆复数的基础知识…….</p><p>$r(\cos\theta+i\sin\theta)$ 会被简写为 $r~cis\theta$</p><p><strong>命题4.20</strong>: $z=r~cis\theta$ and $w=s~cis\phi$. Then $zw=rs~cis(\theta+\phi)$</p><h3 id="圆群-The-circle-group"><a href="#圆群-The-circle-group" class="headerlink" title="圆群(The circle group)"></a>圆群(The circle group)</h3><p>定义: <script type="math/tex">\mathbb{T}=\{z\in\mathbb{C}: |z|=1\}</script></p><p><strong>命题4.24</strong>: 圆群是$\mathbb{C}^*$的子群</p><p><strong>定理4.25</strong>: If $z^n=1$, then the nth roots of unity are <script type="math/tex">z=cis(\frac{2k\pi}{n})</script><br>where $k-0,1,…n-1$. Furthermore, the nth roors of unity form a cyclic subgroup of $\mathbb{T}$ of order $n$.</p><p>A generator for the group of the nth roots of unity is called a <strong>primitive nth root of<br>unity</strong>.</p><h2 id="重复平方法-The-Method-of-Repeated-Squares"><a href="#重复平方法-The-Method-of-Repeated-Squares" class="headerlink" title="重复平方法(The Method of Repeated Squares)"></a>重复平方法(The Method of Repeated Squares)</h2><p>其实就是快速幂</p><p>理论基础: If $b\equiv a^x (\mod n)$ and $c\equiv a^y (\mod n)$, then $bc\equiv a^{x+y}(\mod n)$<br>$(a^{2n})^2\equiv a^{2\cdot 2n}\equiv a^{2^{n+1}}(\mod n)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于接下来的书没有中文版了，因此笔记中英文都&lt;u&gt;看心情&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&quot;群&quot;&gt;&lt;a href=&quot;#群&quot; class=&quot;headerlink&quot; title=&quot;群&quot;&gt;&lt;/a&gt;群&lt;/h1&gt;&lt;h2 id=&quot;整数等价类&quot;&gt;&lt;a href=&quot;#整数等价类&quot; class
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
  <entry>
    <title>2019年寒假计划(flags)</title>
    <link href="https://mengzelev.github.io/2019/02/18/2019-winter-flags/"/>
    <id>https://mengzelev.github.io/2019/02/18/2019-winter-flags/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-01-31T10:11:55.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美赛准备"><a href="#美赛准备" class="headerlink" title="美赛准备"></a>美赛准备</h1><ul><li>MATLAB入门《MATLAB数学工具软件实例简明教程》</li><li>《MATLAB在数学建模中的应用》</li><li>研读优秀论文，总结模板</li></ul><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul><li>学习Python</li><li>分析minilab的git log中的CE数据</li></ul><h1 id="HK学术竞赛"><a href="#HK学术竞赛" class="headerlink" title="HK学术竞赛"></a>HK学术竞赛</h1><ul><li>等打完美赛再来研究</li></ul><h1 id="番剧"><a href="#番剧" class="headerlink" title="番剧"></a>番剧</h1><h2 id="追番"><a href="#追番" class="headerlink" title="追番"></a>追番</h2><ul><li>多罗罗</li><li>灵能百分百第二季</li><li>关于我转生成为史莱姆的这档事</li><li>强风吹拂</li><li>不吉波普不笑</li><li>约定的梦幻岛 </li></ul><h2 id="补番"><a href="#补番" class="headerlink" title="补番"></a>补番</h2><ul><li>战栗杀机</li><li>小林家的龙女仆</li></ul><h1 id="吉他"><a href="#吉他" class="headerlink" title="吉他"></a>吉他</h1><ul><li>看B站教学视频</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;美赛准备&quot;&gt;&lt;a href=&quot;#美赛准备&quot; class=&quot;headerlink&quot; title=&quot;美赛准备&quot;&gt;&lt;/a&gt;美赛准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MATLAB入门《MATLAB数学工具软件实例简明教程》&lt;/li&gt;
&lt;li&gt;《MATLAB在数学建模中的应用》&lt;
      
    
    </summary>
    
      <category term="Flags" scheme="https://mengzelev.github.io/categories/Flags/"/>
    
    
      <category term="Flags" scheme="https://mengzelev.github.io/tags/Flags/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-线性规划</title>
    <link href="https://mengzelev.github.io/2019/02/13/clrs-29Linear-Programming/"/>
    <id>https://mengzelev.github.io/2019/02/13/clrs-29Linear-Programming/</id>
    <published>2019-02-13T12:28:03.000Z</published>
    <updated>2019-02-27T06:24:13.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识背景"><a href="#知识背景" class="headerlink" title="知识背景"></a>知识背景</h1><ul><li>一个<strong>线性规划问题</strong>是一个线性函数最小化或最大化的问题，该线性函数服从一组有限个线性约束，分为最小化线性规划和最大化线性规划</li><li><strong>可行解</strong>：所有满足约束条件的自变量的取值</li><li><strong>可行区域</strong>：所有可行解在二维空间中构成的凸区域</li><li><strong>目标函数</strong>：希望最大化的函数</li><li><strong>目标值</strong>：目标函数在一个特定点上的值</li><li><strong>最优解</strong>：所有目标值中最大的一个，其目标值为<strong>最优目标值</strong></li><li><strong>不可行的</strong>：一个线性规划没有可行解</li><li><strong>无界的</strong>：一个线性规划有可行解但没有有限的最优目标值</li></ul><h1 id="标准型和松弛型"><a href="#标准型和松弛型" class="headerlink" title="标准型和松弛型"></a>标准型和松弛型</h1><h2 id="标准型"><a href="#标准型" class="headerlink" title="标准型"></a>标准型</h2><ul><li>所有的约束都是不等式</li><li>标准型=目标函数+约束+非负约束</li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/std.png"></p><ul><li>重写为向量与矩阵的形式，可以用一个元组$(A,b,c)$来表示一个标准型的线性规划</li></ul><p>最大化<script type="math/tex">c^Tx</script><br>满足约束<script type="math/tex">Ax\le b</script></p><script type="math/tex; mode=display">x\ge 0</script><ul><li><strong>线性规划的等价</strong>：对两个最大化线性规划$L$和$L’$，如果对$L$的每个目标值为$z$的可行解$\overline{x}$，都存在一个对应的$L’$的目标值为$z$的可行解的$\overline{x}’$；(反过来同理)，则称$L$和$L’$是等价的。<ul><li>最小化线性规划和目标函数取负后得到的最大化线性规划是等价的</li></ul></li></ul><h3 id="非标准型的标准化"><a href="#非标准型的标准化" class="headerlink" title="非标准型的标准化"></a>非标准型的标准化</h3><ul><li>目标函数是最小化：取负</li><li>某些变量不具有非负约束：假设$x<em>j$无线性约束，则将所有出现的$x_j$替换为$x</em>{j}’-x<em>{j}’’$，并令$x</em>{j}’\ge 0, x_{j}’’\ge 0$</li><li>存在等式约束：$\ge + \le$</li><li>存在大于等于约束：取负</li></ul><h2 id="松弛型"><a href="#松弛型" class="headerlink" title="松弛型"></a>松弛型</h2><ul><li>松弛变量$s=b<em>i-\sum\limits</em>{j=1}^{n}a_{ij}x_i,s\ge 0$</li><li>只有非负约束是不等式，其余都是等式</li><li><p>当从标准型转换到松弛型时，我们将使用$x<em>{n+i}$表示与第$i$个不等式相关的松弛变量$$x</em>{n+i}=b<em>i-\sum\limits</em>{j=1}^{n}a<em>{ij}x_i,x</em>{n+i}\ge 0$$</p><p><img src="/2019/02/13/clrs-29Linear-Programming/slack.png"></p></li><li><p><strong>基本变量</strong>：等式左边的变量</p></li><li><strong>非基本变量</strong>：等式右边的变量</li><li>有时描述时会省略词语“最大化”和“满足约束”以及明显的非负约束要求</li><li>简洁记号<ul><li>$N$:非基本变量下标的集合</li><li>$B$:基本变量下标的集合</li><li>$N\cup B=\{1,2,…,n+m\}$</li><li>用一个元组$(N,B,A,b,c,v)$来表示松弛型</li><li>这里的$a_{ij}$是“出现”在松弛型中的 负数</li><li>$A,b,c$的小标不必是连续整数的集合，依赖于索引集合$B$和$N$</li></ul></li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/slack2.png"></p><h1 id="将问题表达为线性规划"><a href="#将问题表达为线性规划" class="headerlink" title="将问题表达为线性规划"></a>将问题表达为线性规划</h1><h2 id="单对最短路径"><a href="#单对最短路径" class="headerlink" title="单对最短路径"></a>单对最短路径</h2><p>如下的线性规划可以计算从$s$到$t$的最短路径权值<br><img src="/2019/02/13/clrs-29Linear-Programming/sssp.png"></p><p>之所以是<strong>最大化目标函数</strong>，是因为最短路径问题的一个最优解把每一个$\overline{d}_v$设置成所有$\overline{d}_u+w(u,v)$的最小值，使得$\overline{d}_v$是小于等于集合$\{\overline{d}_u+w(u,v)\}$所有值的最大值；而最小化目标函数会使所有$\overline{d}_v=0$，这个解显然没有意义</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>最大流问题表示为一个线性规划<br><img src="/2019/02/13/clrs-29Linear-Programming/maxflow.png"></p><p>这个线性规划可以重写为有$O(V+E)$个约束的表示，这样计算起来会更高效</p><h2 id="最小费用流"><a href="#最小费用流" class="headerlink" title="最小费用流"></a>最小费用流</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>最大流的推广</li><li>每条边除了容量还有费用值$a(u,v)$。如果通过边$(u,v)$传送了$f<em>{uv}$个单位的流，那么产生了一个费用$a(u,v)f</em>{uv}$。</li><li>求从$s$到$t$发送$d$个单位的流(流目标)，使得流上发生的总费用$\sum\limits<em>{(u,v)\in E}a(u,v)f</em>{uv}$最小</li></ul><p>最小费用流有专门设计的多项式时间算法，但算导上没有涉及到</p><h3 id="线性规划建模"><a href="#线性规划建模" class="headerlink" title="线性规划建模"></a>线性规划建模</h3><p><img src="/2019/02/13/clrs-29Linear-Programming/mincost.png"></p><p><s>这不是很直观吗</s></p><h2 id="多商品流"><a href="#多商品流" class="headerlink" title="多商品流"></a>多商品流</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>在最小费用流问题的基础上，有$k$种不同的商品$K_1,K_2,…,K_k$，其中用三元组$K_i=(s_i,t_i,d_i)$来详细说明商品的源点、汇点和需求</li><li>定义商品$i$的流$f<em>i$，汇聚流为各种商品流的总和$f</em>{uv}=\sum\limits<em>{i=1}^{k}f</em>{iuv}$</li><li>不用最小化任何目标函数，只需要确定是否存在这样的一个流</li></ul><h3 id="线性规划建模-1"><a href="#线性规划建模-1" class="headerlink" title="线性规划建模"></a>线性规划建模</h3><p><img src="/2019/02/13/clrs-29Linear-Programming/multi.png"></p><h1 id="单纯性算法"><a href="#单纯性算法" class="headerlink" title="单纯性算法"></a>单纯性算法</h1><ul><li>求解线性规划的经典方法</li><li>在最坏情况下执行时间非多项式</li><li>在实际中次算法通常相当快速</li><li>可以看成不等式上的<strong>高斯消元法</strong></li></ul><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><ul><li>每轮迭代都关联一个“基本解”<ul><li>从松弛型中得到“基本解”</li><li>将每个非基本变量设为0，并从等式约束中计算基本变量的值</li></ul></li><li>每轮迭代把一个松弛型转换成一个等价的松弛型 </li><li>如果一个<strong>非基本变量</strong>从0开始增加时目标值也增加(目标函数中系数为正)，则增加该非基本变量直到某<strong>基本变量</strong>为0</li><li>重写松弛型，<strong>交换</strong>此基本变量和选定的非基本变量，这个操作称为<strong>转动</strong><ul><li>一个转动选取一个非基本变量$x_e$(替入变量)和一个基本变量$x_l$(替出变量)</li></ul></li></ul><p>单纯型算法执行了两个操作</p><ol><li>重写等式使得变量再等式的左边与右边之间移动</li><li>替换一个等式为另一个等式</li></ol><p>这两个操作都建立了等价的问题</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在目标函数中选一个<strong>最大正系数非基本变量</strong>$x_1$，尝试增大$x_1$，使得$z$增大(增大时必须满足约束条件)</li><li>找到最紧的约，解出$x_1$</li><li>将$x_1$代入系统中其他约束和目标函数【转动】</li><li>找到新系统的基本解</li></ol><h2 id="转动"><a href="#转动" class="headerlink" title="转动"></a>转动</h2><ul><li>输入：元组$(N,B,A,b,c,v)$，替出变量$x_l$的下标$l$(从左边调到右边),以及替入变量$x_e$的下标$e$(从右边调到左边)<strong>出入是相对非基本变量集合$N$而言的</strong></li><li>输出：新松弛的元组$(\hat{N},\hat{B},\hat{A},\hat{b},\hat{c},\hat{v})$</li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/pivot.png"></p><h2 id="正式的单纯性算法"><a href="#正式的单纯性算法" class="headerlink" title="正式的单纯性算法"></a>正式的单纯性算法</h2><p>SIMPLEX</p><ul><li>输入：一个标准型的线性规划</li><li>输出：一个$n$维向量，表示该线性规划的一个最优解</li><li>假设INITIALIZE-SIMPLEX过程返回一个初始基本解可行的松弛型或不可解信息</li><li>3~12行：算法主体<ul><li>如果都是目标函数所有系数为负，则while循环终止，否则第4行选择替入变量$x_e$</li><li>5~9行检查每个约束，然后挑出一个最严格限制$x_e$增加幅度的约束相关联的基本变量$x_l$，如果没有约束能够限制替入变量增加的幅度，则在第11行返回<strong>“无界”</strong></li><li>调用PIVOT交换替入变量和替出变量</li><li>13~16行吧所有非基本变量设为0，把基本变量$\overline{x_i}$设为$b_i$</li><li>17行返回这些值</li></ul></li></ul><p><img src="/2019/02/13/clrs-29Linear-Programming/simplex.png"></p><h3 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h3><p>while循环每次迭代开始：</p><ul><li>此松弛型等价于调用INITIALIZE-SIMPLEX返回的松弛型</li><li>对每个$i\in B$，有$b_i\ge 0$(保证新系统的基本解可行)</li><li>此松弛型相关的基本解是可行的</li></ul><p>需要保证while循环终止，可以通过第4行和第9行总是选择具有最小下标的变量来打破目标值不变的局面</p><p>假设INITIALIZE-SIMPLEX返回一个基本解可行的松弛型，那么SIMPLEX要么报告一个线性规划是无界的，要么以一个可行解结束，且至多$(^{m+n}_{m})$次循环内终止</p><h1 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h1><p>对偶性：给定一个最大化问题，我们定义一个相关的最小化问题，使得这两个问题具有同样的最优目标值(e.g.最大流最小割)</p><p>给定一个标准型的原式线性规划，我们定义其对偶线性规划为(将最大化改为最小化，交换右边系数与目标函数的系数)<br><img src="/2019/02/13/clrs-29Linear-Programming/duality.png"></p><p>弱对偶性：原式线性规划的任意可行解的值不大于此对偶线性规划的任意可行解的对应值</p><p><strong>引理 29.8</strong>：线性规划对偶性</p><p><img src="/2019/02/13/clrs-29Linear-Programming/29-10.png"></p><p>证明涉及大量数学推导</p><p>对偶问题都可以像最大流最小割一样，用来转移火力，找到一个等价的问题来求解原来的问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;知识背景&quot;&gt;&lt;a href=&quot;#知识背景&quot; class=&quot;headerlink&quot; title=&quot;知识背景&quot;&gt;&lt;/a&gt;知识背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个&lt;strong&gt;线性规划问题&lt;/strong&gt;是一个线性函数最小化或最大化的问题，该线性函数服从一组有限个线
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>SVM的临时抱佛脚for HK</title>
    <link href="https://mengzelev.github.io/2019/02/12/SVM-getstart/"/>
    <id>https://mengzelev.github.io/2019/02/12/SVM-getstart/</id>
    <published>2019-02-12T06:28:39.000Z</published>
    <updated>2019-03-02T02:32:09.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/av9912938/?p=76" target="_blank" rel="noopener">B站 机器学习（Machine Learning）- 吴恩达（Andrew Ng）</a></p><h1 id="关于调参"><a href="#关于调参" class="headerlink" title="关于调参"></a>关于调参</h1><p>使用SVM需要指定的参数</p><ul><li>参数$C$<ul><li>$C$较大：小偏差，大方差</li><li>$C$较小：大偏差，小方差</li></ul></li><li>核函数(kernel)的选择<ul><li>线性核函数(Linear Kernel/No Kernel)</li><li>高斯核函数(Gaussian Kernel)</li><li>以上是两个最常用的核函数</li><li>多项式核函数</li><li>字符串核函数</li><li>卡方核函数</li><li>….</li></ul></li></ul><p>$n=$number of features, $m=$number of training examples</p><ul><li>If $n$ is large(relative to $m$),e.g.$n\ge m$, use logistic regression or SVM without a kernel</li><li>If $n$ is small, $m$ is intermediate, use SVM with Gaussian kernel</li><li>If $n$ is is small, $m$ is large, create/add more features, then use logistic regression or SVM without a kernel</li></ul><h2 id="线性核函数"><a href="#线性核函数" class="headerlink" title="线性核函数"></a>线性核函数</h2><p>特征数较多，样本数较少时选择</p><h2 id="高斯核函数"><a href="#高斯核函数" class="headerlink" title="高斯核函数"></a>高斯核函数</h2><script type="math/tex; mode=display">f_i=exp(-\frac{\Vert{x-l^{(i)}}^2}{2\sigma^2}),\text{where} l^{(i)}=x^{(i)}</script><p>选择高斯核的情况：特征数较少，样本较多</p><p>$\sigma$的选取：</p><ul><li>大$\sigma$: high bias, low variance</li><li>小$\sigma$: low bias, high variance</li></ul><p>Note:在使用高斯核之前记得<strong>特征归一化</strong>(feature scaling)</p><h2 id="多项式核函数"><a href="#多项式核函数" class="headerlink" title="多项式核函数"></a>多项式核函数</h2><script type="math/tex; mode=display">(x^Tl + C)^d</script><ul><li>当$x$和$l$都是严格的非负数时才会使用</li><li>用得不多</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av9912938/?p=76&quot; targe
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Machine Learning" scheme="https://mengzelev.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>HKUST项目讨论内容</title>
    <link href="https://mengzelev.github.io/2019/02/11/HKUST-discussion/"/>
    <id>https://mengzelev.github.io/2019/02/11/HKUST-discussion/</id>
    <published>2019-02-11T07:12:48.000Z</published>
    <updated>2019-02-19T07:05:47.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题理解"><a href="#问题理解" class="headerlink" title="问题理解"></a>问题理解</h1><h2 id="原文【来自有道机翻】"><a href="#原文【来自有道机翻】" class="headerlink" title="原文【来自有道机翻】"></a>原文【来自有道机翻】</h2><h3 id="预测Sklearn程序的运行时间"><a href="#预测Sklearn程序的运行时间" class="headerlink" title="预测Sklearn程序的运行时间"></a>预测Sklearn程序的运行时间</h3><p>在共享基础设施上高效运行分布式应用程序具有挑战性。过去的研究表明，选择合适的硬件配置可以显著提高性能和降低成本。为了选择最佳配置，需要准确地预测不同应用程序的性能。</p><p>我们考虑这个挑战的一个简化版本:<strong>预测单个服务器上机器学习程序的性能</strong>。Scikit-learn (sklearn)是一个用于python的机器学习库。提供的数据集描述了在sklearn中运行SGDClassifier的几个示例。数据集的特征描述了SGDClassifier以及用于生成综合训练数据的特征。待分析数据为SGDClassifier的训练时间。</p><p>在这个文件夹中，您可以找到一个样例训练数据集(“sample_train.csv”)。“Time”是模型的训练时间。具体来说，“n_samples”、“n_features”描述了如何使用<code>sklearn.dataset.make_classification</code>生成训练合成数据集。在生成数据集之后，即使用SGDClassifier进行分类。‘l1_ratio’，‘alpha’，‘max_iter’描述了<code>sklearn.linear.model.SGDClassifier</code>的设置。所有特性名称都遵循sklearn文档中的定义。</p><p>本项目的目标是<strong>最小化预测运行时间的误差</strong>，即您应该预测接近真实运行时间的测试集的运行时间。使用的评价指标是<strong>均方误差</strong>。您可以找到“sample_test.csv”和“sample_submission”，用于测试集和解决方案提交格式。</p><p>项目分为两个阶段:</p><ul><li>阶段1：在访问HKUST前，你可浏览样本数据集及草拟解决方案。建议您提前处理数据集并准备模型。</li><li>阶段2:在您访问期间，我们将为您提供一个更大的数据集，包含更多的示例和特性。然后，您可以使用扩展的数据集处理您的解决方案。请注意，我们在阶段1中提供的数据只是一个示例，在示例数据集上建立一个准确的模型并不一定意味着在这个阶段在真实数据集上具有良好的性能。</li></ul><p>项目的其他信息和要求:</p><ul><li>所有的训练和测试数据集都在同一个服务器上生成。</li><li>不受编程语言或机器学习技术的限制。但是，您不允许运行sklearn程序来扩展训练集或预测测试集。</li><li>你需要在你自己的笔记本电脑上编程和训练你的模型。</li></ul><p>任何查询欢迎发送邮件至jxiaab @ust.hk与Jiacheng Xia联络</p><h2 id="相关名词说明"><a href="#相关名词说明" class="headerlink" title="相关名词说明"></a>相关名词说明</h2><ul><li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_classification.html" target="_blank" rel="noopener">make_classification</a></li><li><a href="https://scikit-learn.org/stable/modules/sgd.html" target="_blank" rel="noopener">sklearn.linear_model.SGDclassifier</a></li></ul><h2 id="任务概括"><a href="#任务概括" class="headerlink" title="任务概括"></a>任务概括</h2><ul><li>得到一个时间关于<code>l1_ratio</code>, <code>alpha</code>, <code>max_iter</code>, <code>n_samples</code>, <code>n_features</code>这5个参数的回归方程</li><li>将以上5个参数重新命名一下，即求$T(x_1,x_2,x_3,x_4,x_5)$</li></ul><h2 id="任务理解"><a href="#任务理解" class="headerlink" title="任务理解"></a>任务理解</h2><p>看到这个问题，有以下两种思路</p><ol><li>把SGDclassifier当成黑盒处理，不管SGD分类器算法的内部运作，用现有的算法作回归分析，拟合回归方程</li><li>根据SGD分类器具体运行的原理，自己确定一个时间函数</li></ol><p>后者需要的数学知识过多，几乎是不可能做到的，而且到时候还会有一个更大、feature更多的数据集，所以采用前者</p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><h3 id="SGD分类器模型相关"><a href="#SGD分类器模型相关" class="headerlink" title="SGD分类器模型相关"></a>SGD分类器模型相关</h3><ul><li><code>penalty</code>:惩罚函数的选择</li><li><code>l1_ratio</code>:混合惩罚函数中l1和l2方法的比例</li><li><code>alpha</code>:乘以正则项的常数</li><li><code>max_iter</code>:最大迭代次数</li><li><code>random_state</code>:随机数种子</li><li><code>n_jobs</code>:运算使用的CPU个数，’-1’表示使用了所有的CPU</li></ul><h3 id="数据生成相关"><a href="#数据生成相关" class="headerlink" title="数据生成相关"></a>数据生成相关</h3><ul><li><code>n_samples</code>:样本个数</li><li><code>n_features</code>:feature个数</li><li><code>n_classes</code>:类别的个数</li><li><code>n_clusters</code>: 每一个分类中的团簇个数</li><li><code>n_informative</code>:看不懂orz</li><li><code>flip_y</code>:随机交换所属类别，越大噪声越多</li><li><code>scale</code>:对每个值乘以一个数</li></ul><h1 id="演讲思路"><a href="#演讲思路" class="headerlink" title="演讲思路"></a>演讲思路</h1><ul><li>问题分析(如果已经有人讲过可以简单带过<ul><li>简述问题【提取关键字</li><li>简要介绍一下SGDclassifier</li><li>拉出我们参考的一篇论文，仿照论文决定训练模型计算</li></ul></li><li>我们尝试了诸多算法，决策树表现得比较好【数据可视化列举各种算法的表现情况</li><li>介绍决策树</li><li>对决策树进行改进【决策树，随机森林</li><li>总结结果</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题理解&quot;&gt;&lt;a href=&quot;#问题理解&quot; class=&quot;headerlink&quot; title=&quot;问题理解&quot;&gt;&lt;/a&gt;问题理解&lt;/h1&gt;&lt;h2 id=&quot;原文【来自有道机翻】&quot;&gt;&lt;a href=&quot;#原文【来自有道机翻】&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019美赛经历</title>
    <link href="https://mengzelev.github.io/2019/01/30/ICM-feelings/"/>
    <id>https://mengzelev.github.io/2019/01/30/ICM-feelings/</id>
    <published>2019-01-30T09:45:38.000Z</published>
    <updated>2019-01-31T10:09:50.651Z</updated>
    
    <content type="html"><![CDATA[<p>在经过了一夜的通宵之后终于把论文交上去惹，然后睡了一天，摸了一天，终于想起来要写这篇blog了。</p><h1 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h1><ul><li>学习MATLAB基本语法，笔记见<a href="https://mengzelev.github.io/2019/01/16/matlab-getstart/">MATLAB临时抱佛脚</a></li><li>学习数模基本算法，资料见<a href="https://github.com/NJUBroccoli/Material-of-MCM-ICM" target="_blank" rel="noopener">NJUBroccoli的github仓库</a></li><li>抄写常用算法模板，如：规划问题、AHP、灰色系统、灰色预测、主成分分析、方差分析等</li><li>阅读往年赛题和O奖论文，摸清套路</li><li><s>和朋友出去看电影</s></li><li>和队友做迫真模拟</li><li><s>补番</s></li></ul><h1 id="团队配置"><a href="#团队配置" class="headerlink" title="团队配置"></a>团队配置</h1><ul><li>po主：cs大二狗，会C/C++，LaTeX，以及Java和Verilog的皮毛，MATLAB是比赛前速成的。建模、计算、写论文、校对多面打杂，兼职美工和排版工人。</li><li>队友A：数学系大二小姐姐。建模扛把子。</li><li>队友B：大气科学大二小哥哥。负责给建模提供灵感，负责抱大气老师教授大腿，负责询问环科同学、商科同学…<s>这么写会不会被打死</s></li></ul><h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><ul><li>模型是一起讨论建的</li><li>数据是一起找的(虽然后来没怎么用上)</li><li>编程队友B不会所以我和队友A小姐姐一起负责</li><li>论文是每个人挑几个部分一起写的</li><li>翻译是交给有道姬完成的，由我和队友A校对<s>因为队友B校对的质量堪忧</s></li><li>排版由原po一人完成</li></ul><h1 id="比赛过程"><a href="#比赛过程" class="headerlink" title="比赛过程"></a>比赛过程</h1><h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><p>之前和队友商量好了选E或F题，因为MCM比较有难度，<s>D题需要排队论和马氏链不想看</s>。比赛当天题目公布的时候，看到F题需要不少硬核经济学知识果断放弃了，然后果断就上了E题这条贼船。MCM碰都没碰所以错过了养龙的机会，<s>我想养康娜酱啊呜呜呜</s></p><p>今年赛题内容大致为</p><ul><li>A题：养龙</li><li>B题：救救难民</li><li>C题：美国总统五大洲四日游</li><li>D题：逃离卢浮宫</li><li>E题：生态服务成本估价</li><li>F题：电子货币</li></ul><p>(只有E题是认真看过的，如有偏差欢迎指出)</p><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>E题按照惯例是环境问题，今年是要求对生态系统服务(ecological services)进行估价。生态系统服务是指生态系统提供的诸如净化空气、水体自净、保持水土等功能。要求大概有以下几点</p><ul><li>建立生态系统估价模型(ecological services valuation model)</li><li>对不同规模的土地开发利用项目进行成本效益分析(CBA)，评估这些项目的真实经济成本</li><li>决策者和管理者提出建议(implication)</li><li>随着时间推移模型如何修改</li></ul><p>本来是抱着AHP+GRA+PCA的觉悟来选的E题，结果一看这tm难道不是$\sum$单价$\times$数量的小学生模型吗，只要我找到每吨废水处理的价格，每吨垃圾回收的价格etc.<br>然后标准结局出现了：找不到！！！<br>比如污水处理费，中国大陆，HK和法国是按吨收的，美国英国是每年交固定的类似于下水道保护费一样的费用。<br>而且题干里都说了“现在的土地利用项目一般不考虑环境成本”，所以根本就找不到工程前后环境相关的数据。几篇类似的论文都是有自己的监测站的啊！！！！我们上哪找去啊！！！<br>环境经济学的书查了一堆啊！！！直接说环境估价是一个尚未解决的难题啊！！！！【废话要是解决了还会出成赛题吗<br>如此绝望了一天半之后，我们决定，死马当活马医：gtnd，上AHP！<br>然后就开始了玄学AHP玄学建模玄学论文解释<br>由于只是个心路历程记录，所以就不详细解释了</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>我们的玄学模型只有CBA那一块有一丢丢计算量，直接上MATLAB<br>甚至把图调得更好看花的时间还多一些【丢人</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p>是大家一起写的中文稿，然后扔给有道姬翻成英文，再手动修改</p><h2 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h2><p>DAY1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选题</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    讨论模;</span><br><span class="line">    找论文;</span><br><span class="line">    找数据;</span><br><span class="line">    推翻模型;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAY2：</p><ul><li>找数据</li><li>推翻模型</li><li>玄学建模开始</li><li>玄学AHP</li><li>玄学CBA</li><li>玄学编程</li><li>队友B开始玄学扯淡写论文</li></ul><p>DAY3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    论文扯淡;</span><br><span class="line">    发现模型有问题;</span><br><span class="line">    打补丁;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAY4(通宵)：</p><ul><li>写论文</li><li>继续给模型打补丁</li><li>翻译并校对</li><li>排版</li><li>提交</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><ul><li>美赛是<strong>真的很累</strong>！！！【不过也有些队伍早早就做完提交了根本没有通宵</li><li>前面不知道做些什么，所以每天都睡足了8小时，事情都积到最后一天做了，所以不得不通宵，所幸还是赶上了的</li><li>没有养龙好遗憾啊，反正哪题都不会做，不如养龙爽一把，非要吊死在E题上</li><li>美赛过于昂贵。3人平分100美元的报名费不说，因为作死没有留在学校里打，导致只能去市图书馆讨论，花费大量金钱在吃饭上，最后一天为了通宵还开了个房</li><li>这次的E题感觉还是挺坑的，涉及到不少环境经济学的知识，外行人慎选。<s>其实哪道题都是坑</s></li><li>我们的模型后来算出来西气东输是个失败的工程，感觉小命不保了</li><li>33.33美元，体验通宵的感觉，参赛一次，受益一生【棒读】</li></ul><blockquote><p>MCM/ICM真是一个骗钱又坑爹的比赛啊</p></blockquote><p><img src="/2019/01/30/ICM-feelings/trump.jpeg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在经过了一夜的通宵之后终于把论文交上去惹，然后睡了一天，摸了一天，终于想起来要写这篇blog了。&lt;/p&gt;
&lt;h1 id=&quot;赛前准备&quot;&gt;&lt;a href=&quot;#赛前准备&quot; class=&quot;headerlink&quot; title=&quot;赛前准备&quot;&gt;&lt;/a&gt;赛前准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Diary" scheme="https://mengzelev.github.io/categories/Diary/"/>
    
    
      <category term="Math Modeling" scheme="https://mengzelev.github.io/tags/Math-Modeling/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记</title>
    <link href="https://mengzelev.github.io/2019/01/23/python-getstart/"/>
    <id>https://mengzelev.github.io/2019/01/23/python-getstart/</id>
    <published>2019-01-23T07:37:50.000Z</published>
    <updated>2019-03-13T03:42:01.600Z</updated>
    
    <content type="html"><![CDATA[<p><u>持续更新中</u><br>参考：</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰的Python3教程</a></li><li>《Python编程：从入门到实践》</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Python是动态语言，即变量本身类型不固定，不需要提前声明变量类型的<br>Python有三大数据类型：整数、浮点数、字符串</p><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>整数可以是任意大小的</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数可以是任意精度的【但是运算也会出现误差】</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>字符串用单引号或双引号括起来</li><li>会涉及到转义符的问题</li><li>在字符串前加<code>r</code>表示让所有的转义符都不转</li><li>字符串拼接：<code>+</code>号</li></ul><h3 id="几个骚方法"><a href="#几个骚方法" class="headerlink" title="几个骚方法"></a>几个骚方法</h3><ul><li><code>title()</code>首字母大写</li><li><code>upper()</code>全部大写</li><li><code>lower()</code>全部小写</li><li><p><code>rstrip()</code>暂时删除字符串右端的空白</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'python '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rstrip()</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'python '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = rstrip() <span class="comment">#永久删除右端空格</span></span><br></pre></td></tr></table></figure></li><li><p><code>lstrip()</code>暂时删除字符串左端的空白</p></li><li><code>strip()</code>同时暂时删除字符串两端空白</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>Python中使用<code>#</code>注释掉一整行</li><li>PyCharm中可以使用<code>Ctrl+/</code></li></ul><h2 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h2><ul><li><code>int(x)</code>把<code>x</code>转化为整数</li><li><code>float(x)</code>把<code>x</code>转化为浮点数</li><li><code>str(x)</code>把<code>x</code>转化为字符串</li></ul><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><blockquote><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p></blockquote><ul><li>Python 3的字符串是以Unicode编码的</li><li><code>ord()</code>获取字符的整数表示，<code>chr()</code>把编码转换为对应的字符</li><li>字符串类型是<code>str</code>，加前缀<code>b&#39;</code>可以转换为<code>bytes</code>类型</li><li><p>Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为<code>bytes</code>类型，反过来<code>bytes</code>类型可以通过<code>decode()</code>方法解码为<code>str</code>类型</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">b'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'中文'</span></span><br></pre></td></tr></table></figure></li><li><p>len()函数返回字符串长度或<code>bytes</code>字节数</p></li><li>始终坚持使用UTF-8对<code>str</code>和<code>bytes</code>进行转换</li><li><p>开头通常需要加上</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure></li><li><p>格式化字符串<code>%</code>，用法同C的<code>printf</code></p></li></ul><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><ul><li>值为<code>True</code>或<code>False</code></li><li>运算<code>and</code>、<code>or</code>、<code>not</code></li></ul><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><ul><li><code>None</code>，是一个特殊变量</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul><li>习惯用全部大写的变量名表示常量</li><li>然而并不能保证该变量不会改变，不像C有<code>const</code></li></ul><h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h2><ul><li>[]表示list</li><li>[]为下标索引，从0开始，同C</li><li>[-1]表示最后一个元素,负号索引-n就表示倒数第n个<s>这也太nb了吧</s></li><li>list里的数据类型可以不同</li><li>list可以嵌套</li></ul><h3 id="list方法"><a href="#list方法" class="headerlink" title="list方法"></a>list方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">len(mylist) <span class="comment">#获得list元素的个数 </span></span><br><span class="line">mylist.append(<span class="string">'a'</span>) <span class="comment"># 往list中追加元素到末尾</span></span><br><span class="line">mylist.insert(<span class="number">1</span>, <span class="string">'a'</span>) <span class="comment"># 把元素插入到指定位置</span></span><br><span class="line">mylist.pop() <span class="comment"># 删除list末尾的元素</span></span><br><span class="line">mylist.pop(<span class="number">1</span>) <span class="comment"># 删除指定位置的元素</span></span><br><span class="line"><span class="comment">#pop返回值为被删除的元素</span></span><br><span class="line"><span class="keyword">del</span> mylist[<span class="number">1</span>] <span class="comment">#使用del可以删除任何位置的列表元素，条件是知道索引</span></span><br><span class="line">mylist.remove() <span class="comment">#按值删除元素，只删除第一个指定的值</span></span><br><span class="line"><span class="comment"># `pop和`del`的选择：删除后是否还要使用该元素</span></span><br><span class="line">mylist.sort() <span class="comment">#永久排序</span></span><br><span class="line">mylist.sort(reverse = <span class="keyword">True</span>) <span class="comment">#倒序排序</span></span><br><span class="line">sorted(mylist) <span class="comment">#暂时排序，也可以加入倒序参数</span></span><br><span class="line">mylist.reverse() <span class="comment">#永久倒置</span></span><br><span class="line">mylist[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#list切片，同MATLAB，首尾可缺省</span></span><br><span class="line">copy_list = mylist[:] <span class="comment">#通过切片赋值list</span></span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L[head : tail :step]</span><br><span class="line">L[:<span class="number">3</span>] <span class="comment">#取出从第0个到第3个元素</span></span><br><span class="line">L[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#取出从第1个到第3个元素</span></span><br><span class="line">L[:<span class="number">10</span>:<span class="number">2</span>] <span class="comment">#前10个数，每2个取一个</span></span><br><span class="line">L[::<span class="number">5</span>] <span class="comment">#所有数，每5个取一个</span></span><br><span class="line">L[:] <span class="comment">#原样复制一个list</span></span><br><span class="line"><span class="string">'ABCDEFG'</span>[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#字符串也可以看成List</span></span><br></pre></td></tr></table></figure><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squares = [value ** <span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">squares = [value ** <span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> value % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>] <span class="comment">#两两组合双重循环</span></span><br><span class="line">[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L] <span class="comment">#将一个list中所有字符串变成小写</span></span><br></pre></td></tr></table></figure><p>上述代码等价于对<code>squares</code>这个list执行了一个<code>for</code>循环，每个元素都平方(<code>**</code>是乘方的意思)<br><s>自然语言编程指日可待</s></p><h3 id="生成器generator"><a href="#生成器generator" class="headerlink" title="生成器generator"></a>生成器generator</h3><ul><li>lits保存的是数据，generator保存的是算法</li><li>使用<code>next()</code>函数可以获得generator的下一返回值</li><li>generator也是可迭代对象</li><li>定义generator<ul><li>把list的[]变成()</li><li>使用<code>yield</code>关键字把函数变成generator</li></ul></li><li>变成generator的函数，每次调用<code>next()</code>时执行，遇到<code>yield</code>语句返回，再次执行时</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)) <span class="comment">#把list的[]变成()就可以得到生成器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(n &lt; max):</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        <span class="comment">#相当于(a,b) = (b, a+b)</span></span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> fib:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#杨辉三角生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangles</span><span class="params">()</span>:</span></span><br><span class="line">    L = [<span class="number">1</span>,]</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> L</span><br><span class="line">        L = [<span class="number">1</span>,] + [L[i<span class="number">-1</span>] + L[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(L))] + [<span class="number">1</span>,]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> triangles():</span><br><span class="line">    print(t)</span><br><span class="line">    results.append(t)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h2><ul><li>与list类似，但是一旦初始化就<strong>不能修改</strong>，类似于C的<code>enum</code></li><li>不可变的tuple使代码更安全</li><li>注：定义一个元素的tuple时需要加一个逗号<code>,</code></li><li><code>tuple</code>的不变是<strong>指向不变</strong>，即给元组变量赋值是合法的</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = () <span class="comment">#定义空tuple</span></span><br><span class="line">t = (<span class="number">1</span>,) <span class="comment">#定义单元素tuple</span></span><br><span class="line">dim = (<span class="number">200</span>, <span class="number">5</span>)</span><br><span class="line">dim = (<span class="number">400</span>, <span class="number">10</span>) <span class="comment">#合法，相当于重新定义了整个元组</span></span><br></pre></td></tr></table></figure><h1 id="分支语句if"><a href="#分支语句if" class="headerlink" title="分支语句if"></a>分支语句if</h1><ul><li>除了不要括号、冒号换行、缩进代替大括号外，其他都和C语言一样</li><li><code>else if</code>可以缩写为<code>elif</code></li><li><code>if mylist</code> 可以检验列表是否非空</li><li><code>if a in mylist</code>你以为我是自然语言编程其实我只是检查某个元素在不在列表里哒</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">s = input(<span class="string">'birth:'</span>)</span><br><span class="line">birth = int(s) //将字符串输入转化为数字类型</span><br><span class="line"><span class="keyword">if</span> birth &gt;= <span class="number">2000</span>:</span><br><span class="line">    print(<span class="string">'00后'</span>)</span><br><span class="line"><span class="keyword">elif</span> birth &lt; <span class="number">1960</span>:</span><br><span class="line">    print(<span class="string">'60前'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'00前'</span>)</span><br></pre></td></tr></table></figure><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>python有2种循环</p><ul><li><code>for x in ...</code>循环，依次把list或者tuple中的每个元素迭代出来</li><li><code>range(m,n,step)</code>函数生成从m开始到n的整数序列，步长为step，<code>m</code>缺省为0，<code>step</code>缺省为1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>): <span class="comment">#行尾要有冒号</span></span><br><span class="line">    print(value) <span class="comment">#别忘了缩进对齐</span></span><br><span class="line">numbers = list(range(<span class="number">1</span>,<span class="number">11</span>,<span class="number">2</span>)) <span class="comment">#list()函数将参数转换为列表</span></span><br></pre></td></tr></table></figure><h3 id="类似C语言的循环"><a href="#类似C语言的循环" class="headerlink" title="类似C语言的循环"></a>类似C语言的循环</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]):</span><br><span class="line">    print(i, value)</span><br><span class="line"><span class="comment"># enumerate可以将list变成索引-元素对，相当于数组</span></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">9</span>)]:</span><br><span class="line">    print(x,y)</span><br><span class="line"><span class="comment">#同时对两个变量进行迭代</span></span><br></pre></td></tr></table></figure><h3 id="迭代对象"><a href="#迭代对象" class="headerlink" title="迭代对象"></a>迭代对象</h3><p><code>for</code>可以作用于所有可迭代对象</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以通过isinstance()函数判断一个对象是否为Iterable(可迭代对象)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">100</span>, Iterable)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li>可以被next()调用并不断返回下一个值的对象成为<strong>迭代器</strong><code>Iterator</code></li><li><code>Iterator</code>对象表示的是一个数据流</li><li>生成器都是<code>Iterator</code>对象</li><li><code>Iterable</code>可迭代对象不一定是<code>Iterator</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">n = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    ans += n</span><br><span class="line">    n -= <span class="number">2</span> <span class="comment"># 没有n--这种语法糖了</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><p><code>break</code>和<code>continue</code>都可以像以前一样用</p><h1 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h1><ul><li><code>dict</code>就相当于C++里的<code>map</code>，功能类似于Hash Table</li><li>是关键字-值对(key-value),key和value只是名字，并不规定类型</li><li>dict相比于list，是在用<strong>空间换时间</strong></li><li>dict的key必须是<strong>不可变对象</strong></li></ul><h2 id="创建dict"><a href="#创建dict" class="headerlink" title="创建dict"></a>创建dict</h2><p>注意dict的初始化使用的<code>{}</code>花括号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'Michael'</span>:<span class="number">95</span>, <span class="string">'Bob'</span>:<span class="number">75</span>, <span class="string">'Tracy'</span>:<span class="number">85</span>&#125; <span class="comment">#将名字和成绩对应起来，项比较多的时候可以加上换行</span></span><br><span class="line">d[<span class="string">'Adam'</span>] = <span class="number">67</span> <span class="comment">#直接通过关键字索引放入数据</span></span><br></pre></td></tr></table></figure><ul><li>多次对一个关键字放入数据，后面的值会把前面的冲掉</li><li>访问了不存在的关键字时会报错</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Thomas'</span> <span class="keyword">in</span> d <span class="comment">#返回布尔值，判断某关键字是否在该字典中</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">'Bob'</span>] <span class="comment">#删除指定关键字</span></span><br></pre></td></tr></table></figure><h2 id="dict方法"><a href="#dict方法" class="headerlink" title="dict方法"></a>dict方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.get(<span class="string">'Thomas'</span>,<span class="number">-1</span>) <span class="comment">#寻找某个关键字的值，-1是规定的不存在时的返回值，缺省时返回None，Python交互环境不显示结果</span></span><br><span class="line">d.pop(<span class="string">'Bob'</span>) <span class="comment">#删除一个关键字</span></span><br></pre></td></tr></table></figure><h2 id="遍历dict"><a href="#遍历dict" class="headerlink" title="遍历dict"></a>遍历dict</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> d.items(): <span class="comment"># 使用items()方法可以访问所有条目</span></span><br><span class="line">    print(key + <span class="string">":"</span> + value)</span><br><span class="line"><span class="comment"># 需要声明两个变量，命名任意</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d.keys(): <span class="comment"># 使用keys()方法可以访问所有的关键字</span></span><br><span class="line">    print(key.title())</span><br><span class="line"><span class="comment">#遍历字典时默认遍历所有key</span></span><br><span class="line"><span class="comment">#同理有values()方法</span></span><br></pre></td></tr></table></figure><h1 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h1><ul><li>无序、无重复元素的集合</li><li>不能放入可变对象</li></ul><h2 id="创建set"><a href="#创建set" class="headerlink" title="创建set"></a>创建set</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#需要提供一个list作为输入，重复元素自动过滤</span></span><br></pre></td></tr></table></figure><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">4</span>) <span class="comment">#添加元素</span></span><br><span class="line">s.remove(<span class="number">4</span>) <span class="comment">#删除元素</span></span><br></pre></td></tr></table></figure><h2 id="set操作"><a href="#set操作" class="headerlink" title="set操作"></a>set操作</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 &amp; s2 <span class="comment">#交集</span></span><br><span class="line">s1 | s2 <span class="comment">#并集</span></span><br></pre></td></tr></table></figure><h2 id="可变对象与不可变对象"><a href="#可变对象与不可变对象" class="headerlink" title="可变对象与不可变对象"></a>可变对象与不可变对象</h2><p>不可变对象：调用对象自身的方法不会改变该对象自身的内容，而是会创建新的对象并返回，如str<br>可变对象：恰恰相反，如list</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>函数名可以像变量一样赋值【太骚了</li></ul><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span> <span class="comment">#行尾加个冒号</span></span><br><span class="line">    <span class="keyword">if</span> x = <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure><h3 id="空操作"><a href="#空操作" class="headerlink" title="空操作"></a>空操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># pass可以用作占位符，没想好写什么但函数可以先运行起来</span></span><br></pre></td></tr></table></figure><h3 id="参数类型检查"><a href="#参数类型检查" class="headerlink" title="参数类型检查"></a>参数类型检查</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x,(int, float)): <span class="comment">#数据类型检查</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>) <span class="comment">#异常处理(后续会提到)</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure><h3 id="返回多值"><a href="#返回多值" class="headerlink" title="返回多值"></a>返回多值</h3><p>这也太骚了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle=<span class="number">0</span>)</span>:</span></span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br></pre></td></tr></table></figure><p>事实上返回的是一个tuple</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>位置参数：普通意义上的参数</li><li>默认参数：有缺省值的参数，如<code>def power(x,n=2)</code><ul><li>必选参数在前，默认参数在后</li><li>多个默认参数时，可以按顺序调用，也可以将需要修改的参数值的名称写好，不写的使用默认值，如<code>enroll(&#39;Adam&#39;, &#39;M&#39;,city=&#39;Tianjin&#39;)</code></li><li>默认参数必须指向<strong>不变对象</strong>，例如默认参数为list时用<code>None</code>代替<code>[]</code></li></ul></li><li><p>可变参数：参数个数不确定时，可以使用list或tuple传参，带<code>*</code>表示可变参数</p><ul><li>参数在函数调用时自动组装为tuple<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(*numbers)</span>:</span> <span class="comment">#加*表示可变参数</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        ans += n * n</span><br><span class="line">    <span class="keyword">return</span> ans   </span><br><span class="line"><span class="comment">#传参</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cal(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#传递变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cal(*number) <span class="comment">#传递list和tuple</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>关键字参数：允许传入0个或任意个含参数名的参数</p><ul><li>参数在内部自动组装为dict<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span> <span class="comment">#表示接受关键字参数`kw`</span></span><br><span class="line">        print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br><span class="line">    <span class="comment">#调用</span></span><br><span class="line">    &gt;&gt;&gt; person(<span class="string">'Michael'</span>, <span class="number">30</span>) <span class="comment">#可以只传入必选参数</span></span><br><span class="line">    &gt;&gt;&gt; person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">    &gt;&gt;&gt; person(<span class="string">'Adam'</span>, <span class="number">45</span>, **extra) <span class="comment">#将现成的dict作为参数</span></span><br><span class="line">+ 命名关键字参数：在函数内部检查传入了哪些参数</span><br><span class="line">  + 为了限制调用者可以传入的参数名，同时可以提供默认值。</span><br><span class="line">  + 必须传入参数名，否则调用将报错</span><br><span class="line">  + 命名关键字参数可以有缺省值</span><br><span class="line">  + 使用时，如果没有可变参数，必须加一个`*`作为分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数</span><br><span class="line">    ```py</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'city'</span> <span class="keyword">in</span> kw: <span class="comment">#有city参数</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'job'</span> <span class="keyword">in</span> kw: <span class="comment">#有job参数</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span> </span><br><span class="line">    <span class="comment">#限制关键字参数的名字，分隔符*后的参数被视为命名关键字参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *args, city, job)</span>:</span></span><br><span class="line">    <span class="comment">#有可变参数时后面的命名关键字参数不再需要分隔符*</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>参数定义顺序：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</p></li><li>对于任何函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用</li></ul><p>P.S.</p><ul><li>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code></li><li>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code></li><li><code>*args</code>和<code>**kw</code>是习惯写法</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><ul><li>函数名也是变量</li><li>有点C里面函数指针的感觉</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = abs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul><li>接收函数作为参数的函数叫做<strong>高阶函数</strong></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li><code>map(f,L)</code>，<code>f</code>为函数，<code>L</code>为一个list，表示将<code>f</code>作用于<code>L</code>的每一个元素上</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><ul><li><code>reduce(f,L)</code>，把结果继续和序列的下一个元素做累计计算</li><li><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></li><li>使用时需要加上<code>from functools import reduce</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="comment">#求和运算可以直接用sum()函数</span></span><br></pre></td></tr></table></figure><p><code>map()</code>与<code>reduce()</code>结合使用可以用很少的代码写出<code>str2int</code>函数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num = &#123;<span class="string">'0'</span>:<span class="number">0</span>, <span class="string">'1'</span>:<span class="number">1</span>, <span class="string">'2'</span>:<span class="number">2</span>, <span class="string">'3'</span>:<span class="number">3</span>, <span class="string">'4'</span>:<span class="number">4</span>, <span class="string">'5'</span>:<span class="number">5</span>, <span class="string">'6'</span>:<span class="number">6</span>, <span class="string">'7'</span>:<span class="number">7</span>, <span class="string">'8'</span>:<span class="number">8</span>, <span class="string">'9'</span>:<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2num</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> num[s]</span><br><span class="line">    <span class="keyword">return</span> reduce(fn, map(char2num, s))</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul><li>用于过滤list</li><li>把传入的函数依次作用于某个元素，根据返回值是True还是False决定保留还是丢弃该元素</li><li>返回的是一个惰性序列，需要用<code>list()</code>函数将所有结果组织为list</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#筛选回文数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(n)</span>:</span></span><br><span class="line">    s = str(n)</span><br><span class="line">    rev = s[::<span class="number">-1</span>] <span class="comment">#使用切片倒转字符串</span></span><br><span class="line">    <span class="keyword">return</span> s == rev</span><br><span class="line"></span><br><span class="line">output = filter(is_palindrome, range(<span class="number">1</span>, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><ul><li>可以直接对全是数据的list排序，<code>sort(L)</code>返回升序排序的<code>L</code></li><li>可以接受一个<code>key</code>函数来实现自定义的排序，<code>sort(L,key)</code><ul><li><code>key</code>指定的函数将作用于list的每一个元素上，并根据<code>key</code>函数返回的结果进行排序</li><li>然后<code>sorted()</code>函数按照keys进行排序，并按对应关系返回<strong>原list</strong>的相应元素</li><li>要进行反向排序可以传入第三个参数<code>reverse=True</code></li></ul></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">by_name</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> t[<span class="number">0</span>] <span class="comment">#按姓名字母顺序排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">by_score</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> -t[<span class="number">1</span>] <span class="comment">#按分数降序排序</span></span><br><span class="line"></span><br><span class="line">L = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</span><br><span class="line">L1 = sorted(L, key=by_name)</span><br><span class="line">L2 = sorted(L, key=by_score)</span><br><span class="line">print(L1)</span><br><span class="line">print(L2)</span><br></pre></td></tr></table></figure><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><ul><li>函数作为返回值的函数</li><li>“闭包”程序结构：相关参数和变量都包含在返回的函数中</li><li>返回的函数不会被立刻执行，而是直到调用了才执行</li><li><strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong></li><li>有啥卵用：保存当前的运行环境。被引用的自由变量与函数同在，即使离开了创造它的环境也不例外</li><li>将外部函数的变量与内部函数绑定</li></ul><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul><li><p>关键字<code>lambda</code>表示匿名函数，冒号前的<code>x</code>表示函数参数</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x : x * x</span><br><span class="line"><span class="comment">#相当于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure></li><li><p>只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果</p></li><li>好处：没有名字，不用担心和其他函数名冲突</li><li>匿名函数也是函数对象，可以把匿名函数赋值给一个变量，再利用变量来调用该函数【有毒吗，不能直接def吗</li><li>匿名函数也可以作为返回值返回</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = list(filter((<span class="keyword">lambda</span> x : x%<span class="number">2</span>==<span class="number">1</span>), range(<span class="number">1</span>,<span class="number">20</span>)))</span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>函数对象有个<code>__name__</code>属性，可以获得函数的名字</li><li>在代码运行期间动态增加函数的功能的方式成为<strong>装饰器(decorator)</strong></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func) # 把原始函数的属性复制到wrapper()函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__) <span class="comment"># 先打印日志</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw) <span class="comment"># 再调用原函数</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log # @语法，相当于执行now=log(now)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"2019-2-6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2019</span><span class="number">-2</span><span class="number">-6</span></span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><ul><li>把一个函数的某些参数固定住(设置一个参数的默认值)，返回一个新的函数，可以直接调用这个新的函数</li><li><code>functools.partial(f,*args,**kw)</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int2 = functools.partial(int, base=<span class="number">2</span>) </span><br><span class="line"><span class="comment">#固定转化为二进制的函数</span></span><br></pre></td></tr></table></figure><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><ul><li>一个.py文件就是一个模块</li><li>可以避免函数名和变量名冲突</li><li>包下的是模块，包中必包含<strong>init</strong>.py模块</li><li>注意模块命名不要与python原有模块冲突</li><li>模块名为<code>包名.模块名</code></li><li>类似于C的库</li></ul><h2 id="标准模块文件"><a href="#标准模块文件" class="headerlink" title="标准模块文件"></a>标准模块文件</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">' a test module '</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Michael Liao'</span></span><br></pre></td></tr></table></figure><ul><li>第一行：标准注释，表示该文件可以直接在Unix/Linux/Mac上运行</li><li>第二行：标准注释，表示该文件本身使用标准UTF-8编码</li><li>第四行：模块文档注释，任何模块代码的第一个字符串都被视为模块的文档注释</li><li>第六行：作者标注，使用<code>__author__</code>变量把作者写进去</li></ul><h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><ul><li>导入模块：<code>import 模块名</code></li></ul><h2 id="函数和变量的作用域"><a href="#函数和变量的作用域" class="headerlink" title="函数和变量的作用域"></a>函数和变量的作用域</h2><ul><li>正常的函数和变量名是公开的(public)，可以直接被引用</li><li>类似<code>__xxx__</code>的变量是特殊变量，可以被直接引用，但一般不建议这么做<ul><li>例如，如果调用<code>len()</code>试图获取一个对象的长度，会自动调用该类的<code>__len__</code>方法</li></ul></li><li>类似<code>_xxx</code>和<code>__xxx</code>的函数或变量是非公开的(private)，不应该被引用，但是Python不能完全限制它们的引用</li><li>外部不需要引用的函数和变量全部定义为private，只有外部需要引用的函数才定义为public</li></ul><h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install [模块名]</span><br></pre></td></tr></table></figure><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="comment"># Student是类名</span></span><br></pre></td></tr></table></figure><ul><li>类名一般首字母大写</li><li>括号中标明了从哪个类继承下来，所有类最终都继承自<code>object</code>(同Java)</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>创建实例：类名+()，如<code>bart = Student()</code></li><li>可以自由地给一个实例变量绑定属性</li><li><p>实例的初始化可以使用<code>__init__</code>函数</p><ul><li>将一些必须绑定的属性写上去</li><li><code>__init__</code>方法的第一个参数永远是<code>self</code>，需要声明但无需传递(类似于C的<code>this</code>)</li><li>不就是构造函数吗<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">bart = Student(<span class="string">'Bart Simpson'</span>,<span class="number">59</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>定义方法除了第一个参数是<code>self</code>外，与定义函数无异</p></li></ul><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><ul><li>私有变量：名称前加两个下划线<code>__xxx</code>，外部无法访问(其实只是Python解释器把它解释为了另一个名字)</li><li>单下划线实例变量名:“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”</li></ul><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><ul><li>基本类似Java的继承</li><li>子类继承父类的方法</li><li>子类和父类可以有相同的方法，但子类的方法会覆盖父类的方法</li><li>“鸭子类型”：一个对象只要“看起来像鸭子，走起路来像鸭子”，就可以被看成鸭子<ul><li>不要求严格的继承体系，调用方法时只要保证对象有这样的方法</li></ul></li></ul><h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><ul><li><p><code>type()</code>函数：判断对象、函数类型，返回对应的Class类型，可以用<code>if</code>语句比较两个变量的类型是否相同</p><ul><li>判断基本数据类型可以直接写<code>int</code>，<code>str</code>等</li><li>判断一个对象是否是函数可以使用<code>types</code>模块中定义的常量<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">123</span>) == int</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(fn) == types.FunctionType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(abs) == types.BuiltinFunctionType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="keyword">lambda</span> x : x) == types.LambdaType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))) == types.GeneratorType</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>isinstance()</code>可以用来判断继承关系</p><ul><li>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断</li><li>优先使用<code>isinstance()</code></li></ul></li><li><p><code>dir()</code>可以获得一个对象的所有属性和方法，返回一个包含字符串的list</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(<span class="string">'ABC'</span>)</span><br><span class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>,..., <span class="string">'__subclasshook__'</span>, <span class="string">'capitalize'</span>, <span class="string">'casefold'</span>,..., <span class="string">'zfill'</span>]</span><br></pre></td></tr></table></figure><ul><li><p>配合<code>getattr()</code>，<code>setattr()</code>和<code>hasattr()</code>可以直接操作一个对象的状态</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'x'</span>) <span class="comment"># 有属性'x'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性'y'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'y'</span>) <span class="comment"># 获取属性'y'</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.y <span class="comment"># 获取属性'y'</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'power'</span>) <span class="comment"># 有属性'power'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn = getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'并赋值到变量fn</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure><ul><li>只有在不知道对象具体信息时，才会去获取对象的信息<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#正确用法</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">readImage</span><span class="params">(fp)</span>:</span></span><br><span class="line"><span class="keyword">if</span> hasattr(fp, <span class="string">'read'</span>):</span><br><span class="line">    <span class="keyword">return</span> readData(fp)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"><span class="comment"># 假设我们希望从文件流fp中读取图像</span></span><br><span class="line"><span class="comment"># 我们首先要判断该fp对象是否存在read方法</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><ul><li>给实例绑定属性：通过实例变量或self变量</li><li>类本身需要绑定属性：直接在class中定义<ul><li>类的所有实例都可以访问类属性<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        Student.count += <span class="number">1</span> <span class="comment"># 类的属性增加一，而非实例的属性self.countA</span></span><br><span class="line"></span><br><span class="line">bart = Student(<span class="string">'Bart'</span>)</span><br><span class="line">print(Student.count)</span><br><span class="line">lisa = Student(<span class="string">'Lisa'</span>)</span><br><span class="line">print(Student.count)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h2><ul><li><p>实例可以绑定属性和方法</p><ul><li><p>绑定方法需要使用到types<code>模块中的</code>MethodType`方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></li><li><p>以上方法绑定的方法对其他的实例是不起作用的</p></li></ul></li><li><p>给类绑定方法可以给所有实例绑定方法，是一种动态绑定，绑定后所有实例均可调用</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line"><span class="meta">... </span>    self.score = score</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</span><br></pre></td></tr></table></figure></li><li><p>使用<code>__slots__</code>可以限制实例的属性</p><ul><li>仅对当前类的实例起作用，对继承的子类是不起作用的</li><li>如果在子类中也定义<code>__slots__</code>，则子类实例允许定义的属性 = 自身的<code>__slots__</code> + 父类的<code>__slots__</code></li></ul></li></ul><h2 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h2><ul><li><p><code>@property</code>是装饰器，负责把一个<code>setter</code>方法变成属性赋值</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class">    @<span class="title">property</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score <span class="comment"># getter属性</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span> <span class="comment"># setter属性</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 and 100'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><ul><li><code>@property</code>使得对实例属性操作时，通过getter和setter方法来实现</li><li>是定义getter方法就相当于定义了一个只读属性</li></ul></li></ul><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><ul><li><p>一个子类可以同时获得多个父类的所有功能</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, Runnable)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>MixIn:除主线之外的继承关系</p><ul><li>为了更好地看出继承关系，可以把主线外的继承类命名为<code>xxxMixIn</code>，如<code>RunnableMixIn</code></li><li>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类</li><li>Java是只允许单一继承的，不允许MixIn的继承</li></ul></li></ul><h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p>上文提到的 <code>__len__</code>方法能让class作用于<code>len()</code>函数，就是一种定制类的方法</p><h3 id="str"><a href="#str" class="headerlink" title="str"></a><strong>str</strong></h3><ul><li><p><code>__str__</code>方法可以改变类的实例的打印方式，类似于Java的<code>toString</code></p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Student object (name: %s)'</span> % self.name</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</span><br><span class="line">Student object (name: Michael)</span><br></pre></td></tr></table></figure></li></ul><h3 id="repr"><a href="#repr" class="headerlink" title="repr"></a><strong>repr</strong></h3><ul><li><code>__repr__</code>方法 直接显示变量调用(在交互模式下敲出变量名)<ul><li><code>__str__()</code>方法返回用户看到的字符串，<code>__repr__()</code>返回程序开发者看到的字符串，为调试服务</li><li>通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，有个偷懒的写法</li></ul></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line">__repr__ = __str__</span><br></pre></td></tr></table></figure><h3 id="iter"><a href="#iter" class="headerlink" title="iter"></a><strong>iter</strong></h3><ul><li><p><code>__iter__</code>方法返回一个迭代对象，让类可以被用用于<code>for ... in</code>循环</p><ul><li><p>配合<code>__next__</code>方法，for循环会不断调用该迭代对象的<code>__next__()</code>方法得到循环的下一个值，直到遇到<code>StopIteration</code>错误退出循环</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a,self.b = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a,self.b = self.b, self.a+self.b</span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopInteration()</span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line">            print(n)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">46368</span></span><br><span class="line">    <span class="number">75025</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="getitem"><a href="#getitem" class="headerlink" title="getitem"></a><strong>getitem</strong></h3><ul><li><p><code>__getitem__</code>方法使类可以像list那样根据下标取出元素</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(isinstance(n, int)): <span class="comment"># n是索引</span></span><br><span class="line">            a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                a,b = b,a+b</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">if</span>(isinstance(n, slice)): <span class="comment"># n是切片</span></span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.start</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span>  <span class="keyword">None</span>:</span><br><span class="line">                start = <span class="number">0</span></span><br><span class="line">            a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">            L = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(stop):</span><br><span class="line">                <span class="keyword">if</span> x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a,b = b,a+b</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fib()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">100</span>]</span><br><span class="line"><span class="number">573147844013817084101</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><ul><li>以上<code>__getitem__()</code>方法没有对步长和负数做处理，因此要正确实现一个<code>__getitem__()</code>还是有很多工作要做的</li><li>如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如<code>str</code>，与之对应的还有<code>__setitem__</code>和<code>__delitem__</code></li></ul></li></ul><h3 id="getattr"><a href="#getattr" class="headerlink" title="getattr"></a><strong>getattr</strong></h3><ul><li><p><code>__getattr__</code>方法能够动态返回一个属性，当调用不存在的属性时，会试图调用<code>__getattr__(self,属性)</code>来尝试获得属性</p><ul><li><p>只有在没有找到属性的情况下才会调用<code>__getattr__</code>，已有的属性是直接获取的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> attr==<span class="string">'age'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">'\'Student\' object has no attribute \'%s\''</span> % attr)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h3><ul><li><code>__call__</code>使实例自身能被当作函数调用</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'My name is %s.'</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s()</span><br><span class="line">My name <span class="keyword">is</span> Michael</span><br></pre></td></tr></table></figure><ul><li>通过<code>callable</code>函数可以判断一个对象是否能被调用</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(Student())</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(max)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(<span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(<span class="string">'str'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="枚举类Enum"><a href="#枚举类Enum" class="headerlink" title="枚举类Enum"></a>枚举类Enum</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>))</span><br></pre></td></tr></table></figure><ul><li>这样就得到了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量</li><li><p>也可以枚举该类的所有成员</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> name,member <span class="keyword">in</span> Month.__members.items()</span><br><span class="line">    print(name, <span class="string">'=&gt;'</span>, member, <span class="string">','</span>, member.value)</span><br></pre></td></tr></table></figure></li><li><p><code>value</code>属性是自动赋给<code>int</code>常量，默认<strong>从1开始</strong>计数(居然不是从0开始)</p></li><li>从<code>Enum</code>派生自定义类可以精确控制枚举类型  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique #装饰器，帮忙检查有无重复值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span><span class="params">(Enum)</span>:</span> <span class="comment"># Enum的子类</span></span><br><span class="line">    Sun = <span class="number">0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">Weekday.Mon</span><br><span class="line">Weekday[<span class="string">'Tue'</span>]</span><br><span class="line">Weekday(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="type-函数"><a href="#type-函数" class="headerlink" title="type()函数"></a>type()函数</h2><ul><li>动态语言的函数和类不是编译时定义的，而是运行时动态创建的</li><li><code>type()</code>函数可以查看一个类型或变量的类型</li><li><p><code>type()</code>函数可以创建出新的类型，而无需通过class定义</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(self, name=<span class="string">'world'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'Hello, %s.'</span> % name)</span><br><span class="line">Hello = type(<span class="string">'Hello'</span>, (object,), dict(hello=fn)) <span class="comment">#创建Hello类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = Hello()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.hello()</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure></li><li><p><code>type()</code>函数需依次传入3个参数</p><ul><li>class的名称</li><li>继承的父类的集合，<strong>注意单元素tuple的写法</strong></li><li>class的方法名称与函数绑定</li></ul></li></ul><h2 id="metaclass-函数"><a href="#metaclass-函数" class="headerlink" title="metaclass()函数"></a>metaclass()函数</h2><ul><li>先定义metaclass(元类)，就可以创建类，然后创建实例</li><li>可以把类看成metaclass创建出来的实例</li><li>metaclass正常情况下不会用到所以看不懂也没关系</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># metaclass是类的模板，所以必须从`type`类型派生：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        attrs[<span class="string">'add'</span>] = <span class="keyword">lambda</span> self, value: self.append(value)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用metaclass定制类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list, metaclass=ListMetaclass)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>创建Mylist时，通过<code>ListMetaclass.__new__()</code>来创建</li><li>可以用来修改类的定义，例如加上新的方法(样例中在<code>MyList</code>类中增加了<code>add</code>方法)</li><li><code>__new__()</code>方法接收的参数依次是<ul><li>当前准备创建的类的对象</li><li>类的名字</li><li>类继承的父类的集合</li><li>类的方法的集合</li></ul></li><li>应用上与SQL相结合的较多，等用到的时候再看了</li></ul><h1 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h1><h2 id="try"><a href="#try" class="headerlink" title="try"></a>try</h2><ul><li>当我们认为某些代码可能会出错时，可以用<code>try</code>来运行这段代码</li><li><p>如果出错，后续代码不会继续执行，而是直接跳转至错误处理代码</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    print(<span class="string">'result:'</span>, r)</span><br><span class="line"><span class="comment"># 错误处理代码</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:  <span class="comment"># 可以有多个except</span></span><br><span class="line">    print(<span class="string">'except:'</span>, e)</span><br><span class="line"><span class="keyword">finally</span>: <span class="comment"># finally无论如何都会被执行，表示执行结束</span></span><br><span class="line">    print(<span class="string">'finally...'</span>)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>except</code>后可加<code>else</code>语句块，当没有错误发生时会执行<code>else</code>语句块</p></li><li><code>try...except</code>可以跨越多层调用，被调用者出错，调用者也能捕捉到</li><li>Python的错误也是类，所有错误类型都继承自<code>BaseException</code></li><li><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">常见的错误类型和继承类型</a></li></ul><h2 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h2><ul><li>python有内置的<code>logging</code>模块，可以记录错误信息</li><li>程序打印完错误信息后会继续执行并正常退出</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">      bar(<span class="string">'0'</span>)</span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">      logging.exception(e)</span><br></pre></td></tr></table></figure><h2 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h2><ul><li>根据需要，可以定义一个错误的类，选择好继承关系，用<code>raise</code>语句抛出一个错误的实例</li><li>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型，尽量使用Python内置的错误类型</li><li>当前函数不知道如何处理该错误时，还可以在打印错误后再往上抛，让顶层调用者去处理<ul><li><code>raise</code>语句如果不带参数，就会将当前错误原样抛出</li><li>在<code>except</code>中<code>raise</code>一个Error，可以将错误转化成另一种类型</li></ul></li></ul><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><ul><li><code>print</code>调试法</li><li><p><code>assert</code>调试法</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> n != <span class="number">0</span>, <span class="string">'n is zero!'</span></span><br><span class="line"><span class="comment"># 表达式应该为True，否则输出AssertionError+后接的字符串</span></span><br></pre></td></tr></table></figure><ul><li>启动python解释器时可以用<code>-O</code>参数来关闭assert</li></ul></li><li><p><code>log</code>调试法(Python管这叫logging)</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO) <span class="comment"># 配置</span></span><br><span class="line">logging.info(<span class="string">'n = %d'</span> % n) </span><br><span class="line"><span class="comment"># logging.info: 输出信息</span></span><br></pre></td></tr></table></figure><ul><li>可以指定<code>DEBUG</code>&gt;<code>INFO</code>&gt;<code>WARNING</code>&gt;<code>ERROR</code>几个不同级别(level)的信息，级别越高越先被屏蔽，e.g.<code>level=INFO</code>时<code>DEBUG</code>的logging就不起作用了</li></ul></li><li>pdb调试法(命令同gdb)<ul><li><code>l</code>: 查看代码</li><li><code>n</code>: 单步执行</li><li><code>p 变量名</code>: 打印变量</li><li><code>c</code>: 继续执行</li></ul></li><li><p><code>pdb.set_trace()</code>在程序中设置断点，运行时程序会自动暂停并进入pdb</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">s = <span class="string">'0'</span></span><br><span class="line">n = int(s)</span><br><span class="line">pdb.set_trace() <span class="comment"># 运行到这里会自动暂停</span></span><br><span class="line">print(<span class="number">10</span> / n)</span><br></pre></td></tr></table></figure></li><li><p>PyCharm调试法</p></li></ul><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="comment"># 失败时会返回IOError</span></span><br><span class="line">f.read() <span class="comment">#一次性读取全部内容到内存，用一个str对象表示</span></span><br><span class="line">f.close() <span class="comment">#关闭文件，回收资源</span></span><br></pre></td></tr></table></figure><p>为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>嫌长可以简化为<code>with</code>语句<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="comment">#隐式调用了f.close()</span></span><br></pre></td></tr></table></figure></p><p>不想一次读取所有文件</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.read(size) <span class="comment"># 读取一定size个字节的内容</span></span><br><span class="line">f.readline() <span class="comment"># 一次读取一行</span></span><br><span class="line">f.readlines() <span class="comment"># 一次读取所有行并返回list</span></span><br></pre></td></tr></table></figure><p>还可以有效防止内存爆炸</p><p>内存的字节流，网络流，自定义流等等都是<strong>file-like Object</strong>，只需要写个<code>read()</code>方法就能用</p><p>二进制文件需要用<code>&#39;rb&#39;</code>模式打开</p><p>读取默认使用<strong>UTF-8</strong>编码，需要编码转换的时候要给<code>open()</code>传入<code>encoding</code>参数,<code>errors</code>参数表示出现错误后怎么处理，一般选择忽略</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/Users/michael/gbk.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'gbk'</span>,errors=<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>和读一样，把<code>r</code>改成<code>w</code>(跟C也差不多)</p><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>在内存中读写str</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO() <span class="comment"># 创建StringIO对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hello'</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">' '</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'world!'</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue()) <span class="comment">#getvalue()用于获得写入后的str</span></span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>可以用一个str初始化StringIO，然后，像读文件一样读取</p><h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>操作内存中的二进制数据</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87</span></span><br></pre></td></tr></table></figure><h3 id="操作系统命令"><a href="#操作系统命令" class="headerlink" title="操作系统命令"></a>操作系统命令</h3><p>Python内置的os模块可以直接调用操作系统提供的接口函数</p><p>文件名操作只对字符串进行，并不要求文件真实存在</p><p><code>shutil</code>中可以找到很多对<code>os</code>的补充</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.name <span class="comment">#查看操作系统名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ <span class="comment"># 查看操作系统中所有的环境变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ.get(<span class="string">'key'</span>) <span class="comment"># 获取某个环境变量的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">'.'</span>) <span class="comment"># 查看当前目录的绝对路径:</span></span><br><span class="line"><span class="string">'/Users/michael'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">'/Users/michael'</span>, <span class="string">'testdir'</span>)</span><br><span class="line"><span class="comment"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span></span><br><span class="line"><span class="string">'/Users/michael/testdir'</span></span><br><span class="line"><span class="comment"># 然后创建一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">'/Users/michael/testdir'</span>)</span><br><span class="line"><span class="comment"># 删掉一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">'/Users/michael/testdir'</span>)</span><br><span class="line"><span class="comment"># 拆分路径，把当前文件名与目录分开</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">'/Users/michael/testdir/file.txt'</span>)</span><br><span class="line">(<span class="string">'/Users/michael/testdir'</span>, <span class="string">'file.txt'</span>)</span><br><span class="line"><span class="comment"># 拆分文件扩展名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="string">'/path/to/file.txt'</span>)</span><br><span class="line">(<span class="string">'/path/to/file'</span>, <span class="string">'.txt'</span>)</span><br><span class="line"><span class="comment"># 对文件重命名:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">'test.txt'</span>, <span class="string">'test.py'</span>)</span><br><span class="line"><span class="comment"># 删掉文件:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.remove(<span class="string">'test.py'</span>)</span><br></pre></td></tr></table></figure><p>过滤文件<br><s>不都是一行命令行就能搞定的吗</s></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>) <span class="keyword">if</span> os.path.isdir(x)]</span><br><span class="line">[<span class="string">'.lein'</span>, <span class="string">'.local'</span>, <span class="string">'.m2'</span>, <span class="string">'.npm'</span>, <span class="string">'.ssh'</span>, <span class="string">'.Trash'</span>, <span class="string">'.vim'</span>, <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, ...]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>) <span class="keyword">if</span> os.path.isfile(x) <span class="keyword">and</span> os.path.splitext(x)[<span class="number">1</span>]==<span class="string">'.py'</span>]`</span><br><span class="line">[<span class="string">'apis.py'</span>, <span class="string">'config.py'</span>, <span class="string">'models.py'</span>, <span class="string">'pymonitor.py'</span>, <span class="string">'test_db.py'</span>, <span class="string">'urls.py'</span>, <span class="string">'wsgiapp.py'</span>]</span><br></pre></td></tr></table></figure><p>还有<code>psutil</code>模块提供了对cpu信息、内存和磁盘使用信息的访问</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><blockquote><p>把变量从内存中变成可存储或传输的过程叫作序列化(picking).序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p></blockquote><p>用到了再看吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;持续更新中&lt;/u&gt;&lt;br&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="Self-learning" scheme="https://mengzelev.github.io/categories/Self-learning/"/>
    
    
      <category term="Python" scheme="https://mengzelev.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数学建模几种常用算法</title>
    <link href="https://mengzelev.github.io/2019/01/19/matlab-usage/"/>
    <id>https://mengzelev.github.io/2019/01/19/matlab-usage/</id>
    <published>2019-01-19T08:41:45.000Z</published>
    <updated>2019-01-24T13:22:25.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据拟合"><a href="#数据拟合" class="headerlink" title="数据拟合"></a>数据拟合</h1><h2 id="多项式拟合"><a href="#多项式拟合" class="headerlink" title="多项式拟合"></a>多项式拟合</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [...];</span><br><span class="line">y = [...];</span><br><span class="line">P = polyfit(x,y,n); <span class="comment">% n是多项式的次数</span></span><br><span class="line">xi = <span class="number">0</span>: <span class="number">.2</span> :<span class="number">10</span>;</span><br><span class="line">yi = polyval(P, xi);</span><br><span class="line">plot(xi, yi, x, y, <span class="string">'r*'</span>);</span><br></pre></td></tr></table></figure><h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><p>标准型<script type="math/tex">\min~c^Tx s.t. Ax\le b</script></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = linprog(c, -a, -b, [], [], <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = fmincon(fun, x0, A, B, Aeq, Beq, LB, UB, [c,ceq], OPTIONS)</span><br><span class="line"><span class="comment">% fun:目标函数</span></span><br><span class="line"><span class="comment">% x0:x的初始条件</span></span><br><span class="line"><span class="comment">% A,B,Aeq,Beq:线性约束条件</span></span><br><span class="line"><span class="comment">% LB,UB:上下界</span></span><br><span class="line"><span class="comment">% [c,ceq]:.m文件定义的非线性约束条件,分别为不等式与等式约束</span></span><br></pre></td></tr></table></figure><h2 id="二次规划"><a href="#二次规划" class="headerlink" title="二次规划"></a>二次规划</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, fval] = quadprog(H, f, A, b, Aeq, Beq, LB, UB, X0, OPTIONS)</span><br></pre></td></tr></table></figure><h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><ul><li>隐枚举法</li><li>随机算法(蒙特卡洛)</li><li>分枝定界法</li></ul><h2 id="其他求解约束最优化问题的函数"><a href="#其他求解约束最优化问题的函数" class="headerlink" title="其他求解约束最优化问题的函数"></a>其他求解约束最优化问题的函数</h2><ul><li><code>fminbnd</code>:单变量非线性函数在区间上的极小值</li><li><code>fseminf</code></li><li><code>fminimax</code>:函数族的极大极小值</li></ul><h1 id="灰色预测"><a href="#灰色预测" class="headerlink" title="灰色预测"></a>灰色预测</h1><p>GM(1,1)模型适用于具有较强指数规律的序列，只能描述单调的变化过程，而Verhulst模型则适用于非单调的摆动发展序列或具有饱和状态的S形序列。<br>原始数列$x^{(0)}$，AGO累加生成数列$x^{(1)}$，加权均值数列$z^{(0)}$</p><h2 id="关联分析和优势分析"><a href="#关联分析和优势分析" class="headerlink" title="关联分析和优势分析"></a>关联分析和优势分析</h2><ul><li>根据bigger is better和smaller is better标准将数据分类进行初始化</li><li>根据公式算关联系数</li><li>根据关联系数计算关联度</li></ul><h2 id="灰色预测步骤"><a href="#灰色预测步骤" class="headerlink" title="灰色预测步骤"></a>灰色预测步骤</h2><ul><li>数据的检验与处理：计算级比，视情况进行必要的变换处理，使其落入可容覆盖内</li><li>建立模型 $x^{(1)}=…$可以得到预测值</li><li>残差检验</li><li>级比偏差检验</li><li>预测预报</li><li>另：灾变预测可以构造灾变数列</li></ul><h1 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h1><ul><li>求解多约束复杂非线性规划问题</li><li>直接调库吧，不可能看懂的</li></ul><h1 id="层次分析法-Analytic-Hierarchy-Process"><a href="#层次分析法-Analytic-Hierarchy-Process" class="headerlink" title="层次分析法(Analytic Hierarchy Process)"></a>层次分析法(Analytic Hierarchy Process)</h1><ul><li>用于解决较为复杂、模糊、难于定量分析的问题</li><li>当影响决策的因素较多且较主观时</li><li>分层、构造矩阵、检验一致性</li></ul><p>因为基本上做E或F题都会用到，所以详细展开一下</p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul><li>建立递阶层次结构模型；</li><li>构造出各层次中的所有判断矩阵；</li><li>层次单排序及一致性检验；</li><li>层次总排序及一致性检验。</li></ul><h2 id="层次结构的建立"><a href="#层次结构的建立" class="headerlink" title="层次结构的建立"></a>层次结构的建立</h2><p><img src="/2019/01/19/matlab-usage/1.png"></p><h2 id="构造判断矩阵"><a href="#构造判断矩阵" class="headerlink" title="构造判断矩阵"></a>构造判断矩阵</h2><p><img src="/2019/01/19/matlab-usage/2.png"></p><h2 id="层次单排序一致性检验"><a href="#层次单排序一致性检验" class="headerlink" title="层次单排序一致性检验"></a>层次单排序一致性检验</h2><ul><li>判断矩阵$A$对应于最大特征值$\lambda_{max}$的特征向量$W$ ，经归一化后即为同一层次相应因素对于上一层次某因素相对重要性的排序权值，这一过程称为层次单排序</li><li>如果比较结果是前后完全一致的，则矩阵$A$的元素还应当满足$a<em>{ij}a</em>{jk}=a_{ik}$，此时矩阵$A$成为一致矩阵</li><li>$n$阶正互反矩阵$A$为一致矩阵当且仅当其最大特征根$\lambda<em>{max}=n$，且当正互反矩阵$A$非一致时，必有$\lambda</em>{max}&gt;n$</li><li>一致性检验步骤<ul><li>计算一致性指标$CI=\frac{\lambda_{max}-n}{n-1}$</li><li>查找相应的平均随机一致性指标$RI$</li><li>计算一致性比例$CR=\frac{CR}{CI}$</li><li>$CR&lt;0.10$时，认为判断矩阵的一致性是可以接受的，否则应对判断矩阵作适当修正</li></ul></li></ul><h2 id="层次总排序一致性检验"><a href="#层次总排序一致性检验" class="headerlink" title="层次总排序一致性检验"></a>层次总排序一致性检验</h2><p>设A层(上一层次)包含$A<em>1,…A_m$共$m$个因素，层次总排序权重分别为$a_1,…a_m$，又设其后的下一层次B层包含$n$个因素$B_1,…B_n$，它们关于$A_j$的层次单排序权重分别为$b</em>{1j},…b<em>{nj}$(当$B_i$与$A_j$无关时，$b</em>{ij}=0$)。现求$B$层中各因素关于总目标的权重，即求$B$层个因素的层次总排序权重$b<em>1,…,b_n$。<br>$B$层各因素的层次总排序权重$b_i=\sum\limits</em>{j=1}^{m}b<em>{ij}a</em>{j}$<br>B层总排序随机一致性比例<script type="math/tex">CR=\frac{\sum\limits_{j=1}^{m}CI(j)a_j}{\sum\limits_{j=1}^{m}RI(j)a_j}</script><br>$CR&lt;0.10$时认为层次总排序具有较满意的一致性并接受该分析结果</p><h1 id="方差分析-ANOVA"><a href="#方差分析-ANOVA" class="headerlink" title="方差分析(ANOVA)"></a>方差分析(ANOVA)</h1><ul><li>又称F检验</li><li>用数理统计分析试验结果、鉴别各因素对结果影响程度的方法</li></ul><h2 id="单因素方差分析"><a href="#单因素方差分析" class="headerlink" title="单因素方差分析"></a>单因素方差分析</h2><ul><li>任务：从试验结果推断某因素对指标有无显著影响</li><li>单因素方差分析表</li><li>方差分析命令<code>anoval</code>，<code>p = anoval(x,group)</code>将算得的概率<code>p</code>与<code>\alpha</code>进行比较</li></ul><h2 id="双因素方差分析"><a href="#双因素方差分析" class="headerlink" title="双因素方差分析"></a>双因素方差分析</h2><ul><li><code>p = anova2(x,reps)</code></li></ul><h2 id="多因素方差分析"><a href="#多因素方差分析" class="headerlink" title="多因素方差分析"></a>多因素方差分析</h2><ul><li><code>anovan</code></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y = [<span class="number">31</span> <span class="number">54</span> <span class="number">38</span> <span class="number">53</span> <span class="number">49</span> <span class="number">42</span> <span class="number">57</span> <span class="number">62</span> <span class="number">64</span>]; <span class="comment">%试验结果</span></span><br><span class="line">g1 = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]; <span class="comment">%正交表第一列</span></span><br><span class="line">g2 = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span>];</span><br><span class="line">g3 = [<span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>];</span><br><span class="line">[p,t,st] = anovan(y,&#123;g1,g2,g3&#125;)</span><br></pre></td></tr></table></figure><h1 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h1><ul><li><p>用来检验拟合函数的准确度</p></li><li><p>残差：实际观察值，估计值(拟合值)之间的差</p></li><li>$R^2$判定系数：可解释的变异占总变异的百分比</li></ul><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[b,bint,r,rint,stats] = regress(y,x,alpha);</span><br><span class="line"><span class="comment">% b为回归系数估计值</span></span><br><span class="line"><span class="comment">% bint为置信区间 </span></span><br><span class="line"><span class="comment">% r为残差，rint为残差的置信区间</span></span><br><span class="line"><span class="comment">% stats是用于检验回归模型的统计量[R^2,F,p,s^2]</span></span><br><span class="line"><span class="comment">% alpha显著性水平，缺省时为0.05</span></span><br></pre></td></tr></table></figure><h2 id="一元多项式回归"><a href="#一元多项式回归" class="headerlink" title="一元多项式回归"></a>一元多项式回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[p,s] =  polyfit(x0, y0, <span class="number">2</span>);</span><br><span class="line"><span class="comment">% s为用于计算函数值的数据结构，如</span></span><br><span class="line">[y,delta] = polyconf(p,x0,s);y</span><br><span class="line"><span class="comment">%可以得到y的拟合值、置信区间半径delta</span></span><br></pre></td></tr></table></figure><h2 id="多元二项式回归"><a href="#多元二项式回归" class="headerlink" title="多元二项式回归"></a>多元二项式回归</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rstool(x,y,model,alpha)</span><br><span class="line"><span class="comment">% x:n×m维矩阵</span></span><br><span class="line"><span class="comment">% y:n维向量</span></span><br><span class="line"><span class="comment">%model:线性、纯二次、交叉、完全二次四选一</span></span><br></pre></td></tr></table></figure><h1 id="主成成分分析"><a href="#主成成分分析" class="headerlink" title="主成成分分析"></a>主成成分分析</h1><ul><li>用较少的变量去解释原来资料中的大部分变异</li><li>选出比原始变量个数少、能解释大部分资料中的变异的几个新变量</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>对原始数据进行标准化处理</li><li>计算相关系数矩阵$R$</li><li>计算特征值和特征向量</li><li>选择$p$个主成分，计算综合评价值</li><li>计算综合得分</li></ul><h1 id="排队论"><a href="#排队论" class="headerlink" title="排队论"></a>排队论</h1><ul><li>有很多公式，用的时候再查吧</li><li>优化：最优服务率，最优服务台数</li></ul><h1 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h1><ul><li>当模型的数据中有一个或几个发生变化时，最优解会有什么变化</li><li>这些数据在什么范围内变化时，已求解的最优解不变</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据拟合&quot;&gt;&lt;a href=&quot;#数据拟合&quot; class=&quot;headerlink&quot; title=&quot;数据拟合&quot;&gt;&lt;/a&gt;数据拟合&lt;/h1&gt;&lt;h2 id=&quot;多项式拟合&quot;&gt;&lt;a href=&quot;#多项式拟合&quot; class=&quot;headerlink&quot; title=&quot;多项式拟合&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MATLAB临时抱佛脚</title>
    <link href="https://mengzelev.github.io/2019/01/16/matlab-getstart/"/>
    <id>https://mengzelev.github.io/2019/01/16/matlab-getstart/</id>
    <published>2019-01-16T09:04:59.000Z</published>
    <updated>2019-01-20T03:49:08.093Z</updated>
    
    <content type="html"><![CDATA[<p>来源：王正盛 《MATLAB数学工具软件实例简明教程》</p><h1 id="入门技能"><a href="#入门技能" class="headerlink" title="入门技能"></a>入门技能</h1><h2 id="命令行命令"><a href="#命令行命令" class="headerlink" title="命令行命令"></a>命令行命令</h2><p>matlab基本可以看成一个有自己语法的命令行终端使用<br>下面列举一些我觉得自己将来可能会用到的</p><ul><li><code>clc</code>:擦除当前工作窗中所有显示内容</li><li><code>dir</code>:相当于<code>ls</code></li><li><code>cd</code>:你懂的</li><li><code>who</code>:检查内存变量</li><li><code>whos</code>:检查驻留变量的详细情况</li><li><code>help</code>:召唤FM</li><li><code>lookfor</code>:对<code>man</code>进行<code>grep</code></li></ul><p>MATLAB也是有当前工作路径的，同Linux的bash</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量基本以矩阵形式存在<br>还有一些预定义的变量</p><ul><li><code>eps</code>:计算机表示的最小正数</li><li><code>pi</code>:圆周率</li><li><code>inf</code>或<code>Inf</code></li><li><code>NaN</code></li><li><code>i,j</code></li><li><code>flops</code>:浮点运算次数，用于统计计算量</li></ul><h2 id="显示格式"><a href="#显示格式" class="headerlink" title="显示格式"></a>显示格式</h2><ul><li><code>short</code></li><li><code>long</code></li><li><code>short/long e</code> 科学计数法显示</li><li><code>bank</code> 银行格式</li><li><code>hex</code> 十六进制格式</li><li><code>+</code>用于大矩阵的紧凑格式 </li></ul><h1 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h1><h2 id="矩阵创建"><a href="#矩阵创建" class="headerlink" title="矩阵创建"></a>矩阵创建</h2><ul><li>直接输入法</li><li><code>reshape</code>把长行向量拆成$n\times m$的矩阵</li><li><code>diag</code>可以实现向量和对角阵之间的互相转化</li><li><code>.m</code>和<code>.mat</code>文件</li></ul><h2 id="矩阵运算与数组运算"><a href="#矩阵运算与数组运算" class="headerlink" title="矩阵运算与数组运算"></a>矩阵运算与数组运算</h2><ul><li>矩阵运算：按矩阵法则进行的运算</li><li>数组运算：对元素逐个进行</li><li>可以将数组直接作为参数传入函数中，而不用写循环，不同于C<br><img src="/2019/01/16/matlab-getstart/sign.png"></li><li>MATLAB推荐：尽量使用除运算，少用逆运算</li></ul><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><ul><li>系数行向量表示：$p=[a_0,a_1,…a_n]$</li><li>指令<code>p=poly(AR)</code>产生多项式<ul><li>若<code>AR</code>是方阵，则产生特征多项式</li><li>若<code>AR</code>是向量，则<code>AR</code>中每个数是该多项式=0的解</li></ul></li></ul><h3 id="多项式运算"><a href="#多项式运算" class="headerlink" title="多项式运算"></a>多项式运算</h3><ul><li><code>R = roots(p)</code>：求根</li><li><code>PA = polyval(p,S)</code>:按数组运算规则计算多项式的值</li><li><code>PA = polyvalm(p,S)</code>:按矩阵运算规则计算多项式的值</li><li><code>P = polyfit(x,y,n)</code>:用$n$阶多项式拟合$x,y$给定的数据</li></ul><h2 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h2><ul><li><code>S = quad(&#39;fname&#39;, a, b, tol, trace)</code> 自适用Simpson数值积分法</li><li><code>S = quad8(&#39;fname&#39;, a, b, tol, trace)</code>自适用Newton-Cotes数值积分法</li><li><code>quad8</code>比<code>quad</code>性能和精度更好</li></ul><h2 id="非线性方程"><a href="#非线性方程" class="headerlink" title="非线性方程"></a>非线性方程</h2><ul><li><code>r = roots(p)</code> 多项式非线性函数求根</li><li><code>z = fzero(&#39;fname&#39;, x0, tol, trace)</code> 单变量函数求零点，只给出离<code>x0</code>最近的根</li></ul><h2 id="微分方程的数值解"><a href="#微分方程的数值解" class="headerlink" title="微分方程的数值解"></a>微分方程的数值解</h2><ul><li><code>[t,x] = ode23/45(&#39;xprime&#39;, [t0,tf], x0, tol, trace)</code></li></ul><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul><li><code>cd, type, delete, dir</code>，和bash用起来差不多</li><li><code>!</code>可用于执行外部程序</li></ul><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><ul><li><p><code>fopen</code>打开二进制文件</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fid = fopen(<span class="string">'a.dat'</span>, <span class="string">'r'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>fread</code>将数据装入变量</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = fread(fid);</span><br><span class="line">a = fread(fid, <span class="number">100</span>);</span><br><span class="line">a = fread(fid, [<span class="number">10</span>,<span class="number">10</span>]);</span><br></pre></td></tr></table></figure></li><li><p><code>fwrite</code>按照指定的书精度将矩阵中的元素写入文件</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt = fwrite(fid, <span class="built_in">magic</span>(<span class="number">5</span>), <span class="string">'integer * 4'</span>);</span><br><span class="line"><span class="comment">%返回写入数据的个数</span></span><br><span class="line">status = fclose(fid);</span><br></pre></td></tr></table></figure></li><li><p><code>save</code>命令及<code>-ascii</code>选项</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">rand</span>(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">save a.dat a -ascii</span><br></pre></td></tr></table></figure></li></ul><h1 id="符号计算"><a href="#符号计算" class="headerlink" title="符号计算"></a>符号计算</h1><h2 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h2><ul><li><p><code>sym</code>定义符号或表达式</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sym(<span class="string">'x'</span>)</span><br><span class="line">sym(`<span class="number">1</span> + x / <span class="number">2</span>`)</span><br><span class="line">syms a b c d </span><br><span class="line"><span class="comment">%syms可以定义多个符号</span></span><br></pre></td></tr></table></figure></li><li><p><code>findsym</code>确认符号表达式中的符号</p></li></ul><h2 id="微积分运算"><a href="#微积分运算" class="headerlink" title="微积分运算"></a>微积分运算</h2><h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><ul><li><code>diff(f,t,n)</code>函数<code>f</code>对变量<code>t</code>求<code>n</code>阶导，<code>t</code>缺省时对<code>x</code>求导，<code>n</code>缺省为1</li><li>参数为矩阵时，作用于每个元素</li></ul><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><ul><li><code>int(f,t)</code> 函数<code>f</code>对变量<code>t</code>求不定积分</li><li><code>int(f,t,a,b)</code> 函数<code>f</code>对符号变量求从<code>a</code>到<code>b</code>的定积分</li></ul><h3 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h3><ul><li><code>limita(f,t,a)</code>当符号变量<code>t-&gt;a</code>时，函数<code>f</code>的极限，<code>t</code>缺省<code>x</code>，<code>a</code>缺省为0</li></ul><h3 id="级数和"><a href="#级数和" class="headerlink" title="级数和"></a>级数和</h3><ul><li><code>symsum(s,t,a,b)``s</code>中的符号变量<code>t</code>从<code>a</code>到<code>b</code>的级数和</li></ul><h3 id="Taylor展开"><a href="#Taylor展开" class="headerlink" title="Taylor展开"></a>Taylor展开</h3><ul><li><code>taylor(f,n,a)</code>函数<code>f</code>对符号变量<code>x</code>或最接近字母<code>x</code>的符号变量在<code>a</code>点的<code>n-1</code>阶泰勒多项式,<code>n</code>缺省时值为6,<code>a</code>缺省值为0</li></ul><h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><ul><li><code>solve(f,t)</code>对<code>f</code>中的符号标量<code>t</code>解方程<code>f=0</code></li><li><code>solve(&#39;fname&#39;,t)</code> 求解形如<code>f(x)=g(x)</code>的方程</li><li><code>dsolve(&#39;S&#39;,&#39;s1&#39;,...&#39;x&#39;)</code> </li></ul><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><ul><li>用，都可以用</li></ul><h2 id="化简和代换"><a href="#化简和代换" class="headerlink" title="化简和代换"></a>化简和代换</h2><ul><li><code>collect</code>合并同类项</li><li><code>expand</code>将乘积展开为和式</li><li><code>factor</code>将和式展开为乘积</li><li><code>horner</code>嵌套多项式</li><li><code>simplify</code>利用各种</li></ul><h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><ul><li><code>plot(x,y)</code>其中<code>x</code>和<code>y</code>为坐标向量</li><li><p>在<code>plot</code>指令中增加一些参数，可以绘制出不同颜色与不同线性的图形，e.g.</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(x, y1, <span class="string">'k:'</span>, x, y2, <span class="string">'b-'</span>)</span><br></pre></td></tr></table></figure></li><li><p>每条曲线的线型和颜色由字符串<code>&#39;cs&#39;</code>指定，其中<code>&#39;c&#39;</code>表示颜色，<code>&#39;s&#39;</code>表示线型<br>  <img src="/2019/01/16/matlab-getstart/cs.png"></p></li><li>图形标记指令<code>title</code>,<code>xlabel</code>,<code>ylabel</code>,<code>text</code>,<code>legend</code></li><li><code>axis([xmin, xmax, ymin, ymax])</code>设定坐标轴</li><li><code>hold on</code>保持已有图形绘制新的图形</li><li><code>fplot(fname, lims, tol)</code>为函数提供自适应采样</li><li><code>loglog(x,y)</code>双对数坐标</li><li><code>semilogx,semilogy</code> 单对数坐标</li><li><code>polar(theat, rho)</code> 极坐标</li></ul><p><img src="/2019/01/16/matlab-getstart/plot.png"></p><h2 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h2><ul><li><code>plot3</code>用法同<code>plot</code></li><li><code>mesh(x,y,z,c)</code>绘制三维网格图</li><li><code>surf(x,y,z,c)</code>三维曲面图</li><li><code>view</code>指定视点</li><li><code>contour3</code>等高线图</li></ul><h1 id="MATLAB程序设计"><a href="#MATLAB程序设计" class="headerlink" title="MATLAB程序设计"></a>MATLAB程序设计</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul><li><p><code>input</code>函数</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = input(<span class="string">'Enter matrix A=&gt;'</span>)</span><br><span class="line"><span class="comment">%这样可以在执行该语句时首先给出提示，再接收键盘输入</span></span><br></pre></td></tr></table></figure></li><li><p><code>pause(延迟秒数)</code></p></li><li><code>Disp()</code>输出函数， 输出项可以为矩阵或字符串</li></ul><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><ul><li>结尾需要加<code>end</code></li><li><code>else</code>和<code>if</code>可以连起来写成<code>elseif</code></li></ul><h3 id="swith语句"><a href="#swith语句" class="headerlink" title="swith语句"></a>swith语句</h3><p>与C相比：</p><ul><li><code>default</code>改为<code>otherwise</code></li><li>结尾加<code>end</code></li></ul><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><ul><li>for 初始条件:步长(缺省为1):终值</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">2</span> : <span class="number">2</span>*n<span class="number">-1</span></span><br><span class="line">    <span class="comment">%循环体</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>for 循环变量=矩阵表达式，使循环变量取遍矩阵里每个数的值(以行为周期)</li></ul><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><ul><li>结尾加<code>end</code>，用法同C</li></ul><h2 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h2><ul><li>一般格式为</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 输出形参表 = 函数名<span class="params">(输入形参表)</span></span></span><br><span class="line">    <span class="comment">%注释说明部分</span></span><br><span class="line">    <span class="comment">%函数体</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>当输出形参多于1个时，用方括号括起来</li><li>函数调用<code>[输出参数表]=函数名(输入参数表)</code>，支持嵌套调用和递归</li><li>参数个数可变：通过变量<code>nargin</code>和<code>nargout</code>实现</li><li>函数内部申明的变量都是局部变量</li><li>全局变量前缀<code>global</code>，所有函数都可以对其进行存取和修改</li></ul><h1 id="关于括号"><a href="#关于括号" class="headerlink" title="关于括号"></a>关于括号</h1><h2 id="圆括号"><a href="#圆括号" class="headerlink" title="() 圆括号"></a>() 圆括号</h2><p>引用数组中的元素</p><h2 id="方括号"><a href="#方括号" class="headerlink" title="[] 方括号"></a>[] 方括号</h2><p>表示向量或矩阵</p><h2 id="花括号"><a href="#花括号" class="headerlink" title="{} 花括号"></a>{} 花括号</h2><p>用于元胞(cell)数组的分配和引用<br>元胞与矩阵的区别是能放任何类似的元素，而矩阵只能放数值型数据</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D=&#123;[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>],<span class="string">'abc'</span>,&#123;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>&#125;，[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>;<span class="number">11</span> <span class="number">22</span> <span class="number">33</span>]&#125;</span><br><span class="line"></span><br><span class="line">D&#123;<span class="number">1</span>&#125; <span class="comment">%表示D中第一个元素        显示为 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">D&#123;<span class="number">1</span>&#125;(<span class="number">2</span>) <span class="comment">%表示D中第一个元素中第二个元素        显示为 2</span></span><br><span class="line">D&#123;<span class="number">3</span>&#125;&#123;<span class="number">1</span>&#125; <span class="comment">%表示第三个元素中第一个元素        显示为 7</span></span><br><span class="line"></span><br><span class="line">D&#123;<span class="number">3</span>&#125;(<span class="number">1</span>) <span class="comment">%表示第三个元素中第一个元素        显示为&#123;[7]&#125;</span></span><br><span class="line"></span><br><span class="line">D&#123;[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]&#125; <span class="comment">%表示前三个元素        显示为1 2 3 4 ;    ‘abc’  ;&#123;[7]&#125;  &#123;[8]&#125;  &#123;[9]&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：王正盛 《MATLAB数学工具软件实例简明教程》&lt;/p&gt;
&lt;h1 id=&quot;入门技能&quot;&gt;&lt;a href=&quot;#入门技能&quot; class=&quot;headerlink&quot; title=&quot;入门技能&quot;&gt;&lt;/a&gt;入门技能&lt;/h1&gt;&lt;h2 id=&quot;命令行命令&quot;&gt;&lt;a href=&quot;#命令行命令
      
    
    </summary>
    
      <category term="Self-learning" scheme="https://mengzelev.github.io/categories/Self-learning/"/>
    
    
      <category term="MATLAB" scheme="https://mengzelev.github.io/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>问题求解3-总复习</title>
    <link href="https://mengzelev.github.io/2019/01/07/Problem-Solving-3/"/>
    <id>https://mengzelev.github.io/2019/01/07/Problem-Solving-3/</id>
    <published>2019-01-07T11:21:20.000Z</published>
    <updated>2019-01-08T15:40:21.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><ul><li>问题的最优解由相关子问题的最优解组合而成，这些子问题可以独立求解</li><li>使用“剪切-粘贴”技术证明：假设原问题取得最优解时，子问题没有取最优解，那么可以将子结构从整体删除替换为最优解，这与原问题取得最优解的前提矛盾</li><li>子问题间互相独立</li><li>运行时间：子问题总数*每个问题要考察的选择数</li></ul><p>求解时先找出最优子结构，列出递推式</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>自顶向下的备忘算法（带备忘的递归）</li><li>自底向上的动态规划算法（难写，但是快）</li><li>并没有板子</li></ul><h2 id="能解决的问题"><a href="#能解决的问题" class="headerlink" title="能解决的问题"></a>能解决的问题</h2><ul><li>矩阵乘法问题</li><li>最长公共子序列</li><li>最长上升子序列</li></ul><p><s>&gt;主要就是一个列递推式的问题但是就是列不出来</s></p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h2><ul><li>进行选择时，直接做出当前问题中看来最优的选择，而不必考虑子问题的解</li><li>贪心不太方便时可以进行预处理</li><li>证明：替换法<ul><li>贪心算法得到一个解S，假设存在一个抽象的最优解S’，证明S’可以通过若干步满足要求的替换变成S</li><li>也可以证明S优于S(e.g.S的代价$\le$S’的代价)，加上S’优于S的天然条件，可知S与S’都是最优解</li></ul></li></ul><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ul><li>教室安排问题</li><li>Huffman编码树【可以等价为叶结点的带权路径长度之和最小问题</li><li>区间选点问题<ul><li>数轴上有n个闭区间$[a_i,b_i]$。取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以是同一个）</li><li>将区间按右端点升序排序，优先处理小区间</li></ul></li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul><li>这个完全就是因题而异的了啊【哭了</li></ul><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="三个基本操作"><a href="#三个基本操作" class="headerlink" title="三个基本操作"></a>三个基本操作</h2><ul><li>MAKE-SET($x$)</li><li>UNION($x,y$)</li><li>FIND-SET($x$)：返回$x$所在集合的代表元</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>时间复杂度make和find是$O(1)$，UNION$O(n\lg n)$</li><li>简单加权合并式启发策略（小的并到大的上</li></ul><h2 id="不相交集合森林"><a href="#不相交集合森林" class="headerlink" title="不相交集合森林"></a>不相交集合森林</h2><ul><li>按秩合并，路径压缩</li><li>make和find$O(1)$，UNION$O(m_{\alpha}(n))$</li></ul><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = i;            </span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*递归版*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[i] == i ? i : f[i] = find(f[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*非递归版*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = f[x];</span><br><span class="line">    <span class="keyword">while</span>(root != f[root]) root = f[root];</span><br><span class="line">    <span class="keyword">int</span> y = f[x];</span><br><span class="line">    <span class="keyword">while</span>(x != root) &#123;</span><br><span class="line">        y = f[x];</span><br><span class="line">        f[x] = root;</span><br><span class="line">        x = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(a);</span><br><span class="line">    <span class="keyword">int</span> fb = find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa != fb) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rank[a] &lt; rank[b]) f[a] = fb;</span><br><span class="line">        <span class="keyword">else</span> f[b] = fa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h2><ul><li>带权并查集</li><li>分类并查集</li></ul><p><s>&gt;考到自求多福</s></p><h2 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h2><ul><li>无向图连通分量个数</li></ul><h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><p>参考了ytr的整理</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>诱导子图</li><li>链walk，迹trail，路path</li><li>回路circuit，圈cycle</li><li>连通性，连通分支</li><li>距离，测地线(长度为$u-v$距离的$u-v$路)，直径</li><li>环(loop)，你 连 你 自 己</li><li>平行边：重边</li><li>度数deg，最小度数$\delta(G)$，最大度数$\Delta(G)$</li><li>度序列，可图的</li></ul><h2 id="几种图"><a href="#几种图" class="headerlink" title="几种图"></a>几种图</h2><ul><li>完全图$K_n$</li><li>补图</li><li>二部图，完全二部图($K<em>{s,t}$)，星图star($K</em>{1,s}$)</li><li>多部图，完全多部图(K_{s,s,s})</li><li>$G+H$：$G$和$H$放一起，顶点两两连起来</li><li>$G\times H$：$G$的每个点都替换成一个$H$</li><li>n方体cube($Q<em>n=Q</em>{n-1}\times K_2$)</li><li>$r-$正则图：每个点度数都为$r$</li></ul><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><ul><li>设$G$是一个阶至少为3的图，则$G$是连通的当且仅当$G$包含两个不同的顶点$u$和$v$,使得$G-u$和$G-v$都是连<br>通的</li><li>非平凡图$G$是二部的当且仅当$G$不含奇圈</li><li><strong>图论第一定理</strong>：度数和=边数*2</li><li>每一个图都有偶数个奇点</li><li>设$G$为$n$阶图,若对于$G$中任意两个不邻接的顶点$u$和$v$, 都满足<script type="math/tex">deg~u+deg~v\geq n-1</script>，则$G$是连通的且$diam(G)\leq$2</li><li>设$r$和$n$为满足$0\leq r\leq n-1$的整数． 则存在n阶的r正则图当且仅当$r$和$n$中至少有一个为偶数</li><li>度序列可图的充要条件(删掉一个点依然可图)</li></ul><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>割边</li><li>树，森林</li></ul><h2 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h2><ul><li>某条边是割边当且仅当该边不在任何一个cycle上</li><li>每一棵非平凡树都至少有两个端点(最长路径的两个端点)<ul><li><strong>【可以成为数学归纳法的依据】</strong></li><li>使用数学归纳法证明图论问题的关键在于找到一个端点</li></ul></li><li>有$k$个连通分量的森林有$n-k$条边，树就有$n-1$条边</li><li>每一个有$n$个顶点的连通图至少有$n-1$条边【证明：最小数原理】</li><li>任意两条可得树：连通、无环、$m=n-1$</li><li>每个连通图都包含一棵生成树</li><li>Matrix Tree Theorem：连通图$G$的生成树个数可以用行列式求得</li><li>$T$是唯一最小生成树当且仅当$\forall e\in G\setminus T: w(e)&gt;w(\text{every other edge on the cycle in $T+e$})$<ul><li>推论：distinct weights $\Leftarrow$ unique MST</li><li>推论：Maximum-weight edge in any cycle is unique $\Leftarrow$ unique MST </li></ul></li><li>若每个点度数大于等于2，则该图有cycle</li><li>$e$是割边当且仅当$e$存在于$G$的某一棵生成树上</li></ul><h2 id="最小生成树性质"><a href="#最小生成树性质" class="headerlink" title="最小生成树性质"></a>最小生成树性质</h2><ul><li>Cut Property <ul><li>VER I:$X$是某棵最小生成树的一部分，$(S,V\setminus S)$是一个$X$没有横跨的切割，$e$为横跨$(S,V\setminus)$的一条最轻的边，则$X\cup \{e\}$是某棵最小生成树$T_2$的一部分。</li><li>VER II:$e$为横跨$(S,V\setminus)$的一条最轻的边，则$e$属于某棵最小生成树</li><li>贪心选择性质，可由替换法证明</li></ul></li><li>Cycle Property<ul><li>若$e$为任意一个cycle上权重最大的一条边，则存在一棵最小生成树$T$，使$e\notin T$</li></ul></li></ul><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><ul><li>$O(E\lg~V)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(edge, edge + m, cmp);<span class="comment">//将边按权重从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;<span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edge[i].u;</span><br><span class="line">        <span class="keyword">int</span> b = edge[i].v;</span><br><span class="line">        <span class="keyword">int</span> fa = find(a), fb = find(b);</span><br><span class="line">        <span class="keyword">if</span>(fa != fb) &#123;</span><br><span class="line">            f[fa] = fb;</span><br><span class="line">            ans += edge[i].w;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><ul><li>$O(E\lg V)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        mincost[i] = INF;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; (v == <span class="number">-1</span> || mincost[i] &lt; mincost[v])) v = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">        ans += mincost[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            mincost[i] = min(mincost[i], <span class="built_in">map</span>[v][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图的计算机表示及其遍历"><a href="#图的计算机表示及其遍历" class="headerlink" title="图的计算机表示及其遍历"></a>图的计算机表示及其遍历</h1><h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><ul><li>邻接链表</li><li>邻接矩阵</li></ul><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ul><li>维护一个队列</li><li>时间复杂度$O(V+E)$</li><li>搜完了会得到广度优先树</li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ul><li>前驱子图：深度优先森林</li><li>边的类型<ul><li>树边</li><li>前向边F：祖宗指向儿子</li><li>后向边B：儿子指向祖宗</li><li>横向边C：没有亲缘关系</li></ul></li><li>复杂度$O(V+E)$</li><li>每个结点有两个时间戳<ul><li>$v.d$：记录该结点第一次被发现的时间</li><li>$v.f$：记录搜索完成对$v$的邻接链表的扫描的时间</li><li>$v.d&lt;v.f$</li></ul></li></ul><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul><li>根据DFS后的$v.f$时间戳降序排序，即拓扑序最前的最晚结束访问</li><li>若$(u,v)\in G$，则$v.f&lt;u.f$</li><li>只有DAG才有拓扑排序</li></ul><h2 id="SCC"><a href="#SCC" class="headerlink" title="SCC"></a>SCC</h2><p>算法描述</p><ul><li>DFS($G$)</li><li>DFS($G^{T})$，在主循环根据$v.f$的大小降序访问其邻接点，得到的每棵树都是一个强连通分量</li></ul><h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><ul><li><strong>松弛操作</strong>是<strong>唯一</strong>导致最短路径估计和前驱结点发生变化的操作</li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>三角不等式性质：$s,u,v$</li><li>上界性质：$v.d$撑死就是$\delta(s,v)$</li><li>非路径性质：$s-v$之间没路则$\delta(s,v)=+\infty$</li><li>收敛性质：松弛前是最短路径，松弛后也是最短路径</li><li>路径松弛性质：一条最短路径上的点按先后顺序松弛，则终点的估计值等于最短路径长度</li><li>前驱子图性质：$v.d=\delta(s,v)$，则前驱子图是一棵根结点为$s$的最短路径树</li></ul><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><ul><li>对每条边进行$|V|-1$次relax</li><li>可以识别负权重环</li><li>$O(VE)$</li><li>本质上是DP</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[e[j].u &lt; INF &amp;&amp; dist[e[j].v] &gt; dist[e[j].u] + e[j].w) &#123;</span><br><span class="line">                dist[e[j].v] = dist[e[j].u] + e[j].w;</span><br><span class="line">                pre[e[j].v] = e[j].u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        <span class="keyword">if</span>(dist[e[j].v] &gt; dist[e[j].u] + e[j].w) flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h2><ul><li>按拓扑序松弛结点（路径松弛性质保证）</li><li>$\Theta(V+E)$</li></ul><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><ul><li>所有权重都非负</li><li>二叉堆实现$O(E\lg V)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prority_queue &lt;node&gt; q;</span><br><span class="line">    ver[<span class="number">0</span>].d = <span class="number">0</span>;</span><br><span class="line">    q.push(ver[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> vid = son[u.id][i];</span><br><span class="line">            <span class="keyword">if</span>(ver[vid].d &lt; u.d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(ver[vid].d &gt; u.d + <span class="built_in">map</span>[u.id][vid]) &#123;</span><br><span class="line">                ver[vid].d = u.d + <span class="built_in">map</span>[u.id][vid];</span><br><span class="line">                q.push(ver[vid]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><ul><li>差分图：若$x_j-x_i\le b_k$，则$w(v_i,v_j)=b_k$</li><li>Bellman-Ford可以求解</li></ul><h1 id="所有结点对最短路"><a href="#所有结点对最短路" class="headerlink" title="所有结点对最短路"></a>所有结点对最短路</h1><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><ul><li>我不想管了！！</li><li>是$n$维的Bellman-Ford</li></ul><h2 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h2><ul><li>本质DP，枚举最短路径上的中间结点</li><li>不允许负权重环，但是能报错（看对角元是否有负数）</li><li>$\Theta(n^3)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(); <span class="comment">//记得将所有map[i][i]置零</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) </span><br><span class="line">                <span class="built_in">map</span>[i][j] = min(<span class="built_in">map</span>[i][j], <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Johnson算法"><a href="#Johnson算法" class="headerlink" title="Johnson算法"></a>Johnson算法</h2><ul><li>用于稀疏图</li><li>重新赋值<ul><li>新增源点$s$，该点与各点有权重为0的边</li><li>先跑一次Bellman-Ford，没有负权重环就重新赋值为$\hat{w}(u,v)=w(u,v)+\delta(s,u)-\delta(s,v)$</li><li>对每个点Dijkstra</li><li>恢复权重并返回</li></ul></li><li>$O(VE\lg E)$</li></ul><h1 id="连通度"><a href="#连通度" class="headerlink" title="连通度"></a>连通度</h1><h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><ul><li>$v$与割边相连，则$v$是割点当且仅当$deg~v\ge 2$</li><li>对于至少有3个顶点的连通图，只要有割边，就一定有割点</li><li>$v$是连通图$G$的割点，当且仅当存在两个不同的顶点$u$和$w$，使得$v$位于$u-w$的任意一条路径上</li><li>非平凡连通图中，距离某个点最远的点不是割点</li><li>任意非平凡连通图至少包含两个非割点的顶点</li><li>不可分图：没有割点的非平凡连通图</li></ul><h2 id="块"><a href="#块" class="headerlink" title="块"></a>块</h2><ul><li>图的一个最大不可分子图【类比连通分量</li><li>任意两个不同块的性质<ul><li>不相交</li><li>至多一个公共点</li><li>如果有公共点，则该公共点为割点</li></ul></li></ul><h2 id="连通度-1"><a href="#连通度-1" class="headerlink" title="连通度"></a>连通度</h2><ul><li>$\kappa(G)$点连通度=最小顶点割基数</li><li>$\lambda(G)$边连通度=最小边割基数</li><li>点连通度$\le$边连通度$\le$最小度数    <ul><li>$\kappa(G)\le \lfloor\frac{2m}{n}\rfloor$</li></ul></li></ul><h2 id="Menger定理"><a href="#Menger定理" class="headerlink" title="Menger定理"></a>Menger定理</h2><ul><li>设$u$和$v$是$G$中两个不邻接的顶点，则$u-v$的最小分离集的顶点个数等于内部不相交$u-v$路的最大个数</li><li><p>类似的有边定理：分离$u-v$的边的最小个数等于边不相交$u-v$路的最大个数</p></li><li><p>$k$连通当且仅当任意两个顶点至少有$k$条内部不相交路</p></li><li>$k$连通图中任意$k$个顶点均位于某一个圈上</li></ul><h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*无向图tarjan*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">    dfs_clock ++;</span><br><span class="line">    dfn[u] = low[u] = dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;<span class="comment">//(u,v)是树边</span></span><br><span class="line">            tarjan(v,u);</span><br><span class="line">            child ++;</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>((u == <span class="number">1</span> &amp;&amp; child &gt; <span class="number">1</span>) || (u != <span class="number">1</span> &amp;&amp; dfn[u] &lt;= low[v])) &#123;</span><br><span class="line">                cut_node.push_back(u);</span><br><span class="line">            &#125;<span class="comment">//割点判定：根结点有多个子树，或非根结点的访问序数小于等于能回溯的最大祖先</span></span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u]) bridge.push_back(&#123;min(u,v), max(u,v)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v !=  pre) low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="旅行问题"><a href="#旅行问题" class="headerlink" title="旅行问题"></a>旅行问题</h1><h2 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h2><ul><li>欧拉回路【闭合】/欧拉迹</li><li>有欧拉回路才算欧拉图</li><li>一个非平凡连通图是Euler的 当且仅当它的每个顶点的度都为偶数</li><li>有欧拉迹当且仅当只有两个奇度点</li></ul><h2 id="哈密尔顿图"><a href="#哈密尔顿图" class="headerlink" title="哈密尔顿图"></a>哈密尔顿图</h2><ul><li>哈密尔顿圈/哈密尔顿路</li><li>性质<ul><li>$G$的任一非空子集$S$，都有$k(G-S)\ge |S|$（$G$是哈密尔顿图，$k(G)$指图$G$的连通分支数）</li></ul></li><li>充分条件<ul><li>(Ore定理)对于不少于3个顶点的图，任意两个不邻接的顶点度数之和大于等于$n$，则$G$是哈密尔顿的。</li><li>推论：每个点的度数大于等于$n/2$</li><li>$u$和$v$是不邻接的两个顶点，且度数之和大于等于$n$，则$G+uv$是哈密尔顿的当且仅当$G$是哈密尔顿的</li><li>一个图是哈密尔顿的当且仅当它的闭包是哈密尔顿的</li><li>对于每个整数$j(1\le j\le n/2)$，$G$中度数至多为$j$的顶点数小于$j$，则$G$是哈密尔顿的</li></ul></li></ul><h1 id="匹配与覆盖"><a href="#匹配与覆盖" class="headerlink" title="匹配与覆盖"></a>匹配与覆盖</h1><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><ul><li>Hall条件：$\forall X\subseteq U, |N(X)\ge |X|$</li><li>婚姻定理：$r$个女人，$s$个男人，可能出现$r$对婚姻当且仅当对任意$k$，任意$k$个女人共认识至少$k$个男人。</li><li>最大匹配</li><li>完美匹配：阶为$2k$的图存在一个基数为$k$的匹配</li><li>任意$r$正则二部图均有一个完美匹配</li></ul><h2 id="独立性参数"><a href="#独立性参数" class="headerlink" title="独立性参数"></a>独立性参数</h2><ul><li>最大边独立数$\alpha’(G)$</li><li>最下边覆盖数$\beta’(G)$</li><li>最大点独立数$\alpha’(G)$</li><li>最小点覆盖数$\beta(G)$</li><li>Gallai恒等式<ul><li>点独立数+点覆盖数=$n$</li><li>边独立数+边覆盖数=$n$</li></ul></li><li>一般独立集比覆盖集好求</li></ul><h2 id="因子分解"><a href="#因子分解" class="headerlink" title="因子分解"></a>因子分解</h2><ul><li>$r-$因子：图$G$的$r-$正则生成图</li><li>完美匹配产生1-因子</li><li>图$G$包含1-因子当且仅当对于$V(G)$的任意真子集$S$,$k_O(G-S)\le |S|$。($k_O(G)$表示$G$的奇连通分支个数)</li><li>Petersen定理：所有无割边的3-正则图包含1-因子</li><li>任一至多有两条割边的3-正则图包含1-因子</li><li>可因子分解：能划分成多个因子</li><li>Petersen图不可1-因子分解</li></ul><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">0</span> || find(match[i])) &#123;</span><br><span class="line">                match[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span> ,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(find(i)) ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li>$f:V\times V\to\mathbb{R}$</li><li><strong>容量限制</strong>：$0\le f(u,v)\le c(u,v)$</li><li><strong>流量守恒</strong>：$\forall u\in V-s,t, \sum\limits<em>{v\in V}f(u,v)=\sum</em>\limits_{v\in V}f(v,u)$【流入=流出】</li><li>流的值$|f|=\sum\limits<em>{v\in V}f(s,v)-\sum\limits</em>{v\in V}f(v,s)$(从源结点流出的总流量-流入源结点的总流量)</li></ul><h2 id="几种特殊处理"><a href="#几种特殊处理" class="headerlink" title="几种特殊处理"></a>几种特殊处理</h2><ul><li>反平行边：拆其中一条边为两条边</li><li>多源多汇</li></ul><h2 id="残存网络"><a href="#残存网络" class="headerlink" title="残存网络"></a>残存网络</h2><p>残存容量</p><script type="math/tex; mode=display">c_f=(u,v)=\begin{cases}c(u,v)-f(u,v) & (u,v)\in E \\f(v,u) & (v,u)\in E\\0 & o.w.</script><h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><ul><li>把$V$划分为$S$和$T$两个集合，其中$s\in S, t\in T$</li><li>横跨该切割的净流量：$f(S,T)=\sum\limits<em>{u\in S}\sum\limits</em>{v\in T}f(u,v)-\sum\limits<em>{u\in S}\sum\limits</em>{v\in T}f(v,u)$【所有结点对的流量之和</li><li>切割的容量：$c(S,T)=\sum\limits<em>{v\in S}\sum\limits</em>{v\in T}c(u,v)$【只考虑$S$出发进入$T$的容量</li><li>最小切割：容量最小的切割</li><li>最大流最小割定理</li></ul><h2 id="网络流解决最大匹配"><a href="#网络流解决最大匹配" class="headerlink" title="网络流解决最大匹配"></a>网络流解决最大匹配</h2><ul><li>一个集合连$s$，一个集合连$t$，两个集合间两两连，每条边都是单位容量</li><li>$O(VE)$</li></ul><h1 id="图论证明方法"><a href="#图论证明方法" class="headerlink" title="图论证明方法"></a>图论证明方法</h1><p>解题时可能会用到一个或多个</p><ul><li>反证法</li><li>构造法</li><li>临界法(最小/最大的满足条件的一个图)</li><li>归纳法</li><li>算两次</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;最优子结构&quot;&gt;&lt;a href=&quot;#最优子结构&quot; class=&quot;headerlink&quot; title=&quot;最优子结构&quot;&gt;
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
  </entry>
  
  <entry>
    <title>Lab4 实验报告</title>
    <link href="https://mengzelev.github.io/2018/12/29/lab4-report/"/>
    <id>https://mengzelev.github.io/2018/12/29/lab4-report/</id>
    <published>2018-12-29T09:22:55.000Z</published>
    <updated>2019-01-07T11:15:17.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验进度描述"><a href="#实验进度描述" class="headerlink" title="实验进度描述"></a>实验进度描述</h1><p>我已完成所有内容。</p><p>以下是可以忽略的碎碎念：</p><ul><li>实验开始一小时：写代码；实验开始两小时推翻前一个小时写的代码；实验开始四小时：推翻前两小时写的代码……</li><li>会发生上面的情况其实是因为写<code>cache_read</code>的时候觉得调入调出可以封装为函数，写到<code>cache_write</code>的时候觉得<code>cache_read</code>里的寻找比对、缺失处理都可以封装成函数。在写PA的时候深受Copy-paste其害，所以想把能共享的代码都尽量封装成函数，减轻debug的痛苦</li><li>测试的时候曾经出现过写过的地址从cache调出之后回写到内存不成功。加了回写检查函数<code>check_write_back()</code>依然没有定位错误。出去吹了冷风突然意识到可能是回写的内存地址算错了。回去一看发现是cache装入的时候tag没有更新。结论：吹冷风调试法真有用</li><li>一开始在虚拟机里用vim写的时候，为了区分变量，都取了超长的名字，打起来很累，后来无奈先在windows里用CLion打开写了基本框架再放到Linux里进行调试(因为虚拟机里开CLion会卡爆)。CLion写代码真的是体验极佳，下学期OSLab双系统走起了</li><li>我个**！！！第一遍做完数据没用给定的trace！第二遍做的数据被我一个手抖永久删除了！！！excel还没办法脚本导入！！！一个数据做了3遍！！！</li></ul><h1 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h1><p>为了提高代码的复用率、降低debug负担，我封装了很多API。</p><ul><li>为了模拟cache结构定义了如下结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CacheLine</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid; <span class="comment">//有效位</span></span><br><span class="line">    <span class="keyword">bool</span> dirty; <span class="comment">//脏位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag; <span class="comment">//标记位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> data[<span class="number">16</span>]; <span class="comment">//一行64B数据</span></span><br><span class="line">&#125;line[<span class="number">1024</span>];</span><br></pre></td></tr></table></figure><ul><li>定义了如下全局变量来记录cache的相关信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* cache info */</span></span><br><span class="line"><span class="keyword">int</span> ass_width; <span class="comment">//关联宽度</span></span><br><span class="line"><span class="keyword">int</span> total_width; <span class="comment">//总宽度</span></span><br><span class="line"><span class="keyword">int</span> group_width; <span class="comment">//组宽度(指cache组号在主存地址中的位数)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_ASS exp2(ass_width) <span class="comment">//宏定义，组内行数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET  0x3f <span class="comment">//与操作后可以取出块内偏移量</span></span></span><br></pre></td></tr></table></figure><p>将以下功能封装为了API。因为宏定义会涉及到加括号等问题，怕出现奇奇怪怪的bug，所以并没有使用宏定义，而是直接用函数代替</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> get_tag(<span class="keyword">uintptr_t</span> addr) &#123;</span><br><span class="line"><span class="comment">//获得一个内存地址的tag字段</span></span><br><span class="line">    <span class="keyword">return</span> (addr &gt;&gt; (group_width + BLOCK_WIDTH));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> get_group(<span class="keyword">uintptr_t</span> addr) &#123;</span><br><span class="line">    <span class="comment">//获得一个内存地址的cache组号字段</span></span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; BLOCK_WIDTH) &amp; mask_with_len(group_width));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_in</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">int</span> line_num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将主存中某一块调入cache中</span></span><br><span class="line">assert(line[line_num].valid == <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">uint32_t</span> block_num = addr &gt;&gt; BLOCK_WIDTH;</span><br><span class="line">mem_read(block_num, (<span class="keyword">uint8_t</span>*)(line[line_num].data));</span><br><span class="line">line[line_num].valid = <span class="literal">true</span>;</span><br><span class="line">line[line_num].dirty = <span class="literal">false</span>;</span><br><span class="line">line[line_num].tag = get_tag(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_out</span><span class="params">(<span class="keyword">int</span> group_num, <span class="keyword">int</span> line_num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将cache的某一行调回到主存中，同时判断dirty bit并写回</span></span><br><span class="line">assert(line[line_num].valid == <span class="literal">true</span>);</span><br><span class="line">assert(line_num &lt; <span class="number">1024</span>);</span><br><span class="line">line[line_num].valid = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(line[line_num].dirty) &#123;</span><br><span class="line"><span class="keyword">uintptr_t</span> block_num = (line[line_num].tag &lt;&lt; group_width) + group_num;</span><br><span class="line"></span><br><span class="line">mem_write(block_num, (<span class="keyword">uint8_t</span>*)line[line_num].data);</span><br><span class="line">line[line_num].dirty = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//write back</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_in_group</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">int</span> group_num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//在某一组寻找找某主存地址对应的行，返回其所在行号，缺失则返回-1</span></span><br><span class="line"><span class="keyword">int</span> group_start = group_num * NR_ASS;</span><br><span class="line"><span class="keyword">int</span> group_end = group_start + NR_ASS;</span><br><span class="line"><span class="keyword">uint32_t</span> tag = get_tag(addr);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = group_start; i &lt; group_end; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(line[i].valid &amp;&amp; line[i].tag == tag) &#123;</span><br><span class="line">cycle_increase(<span class="number">1</span>);</span><br><span class="line">hit_visit ++;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">replace_in_group</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">int</span> group_num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将主存地址对应的主存块调入cache中</span></span><br><span class="line">miss_visit ++;</span><br><span class="line"><span class="keyword">int</span> group_start = group_num * NR_ASS;</span><br><span class="line"><span class="keyword">int</span> group_end = group_start + NR_ASS;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = group_start; i &lt; group_end; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(!line[i].valid) &#123;</span><br><span class="line">move_in(addr, i);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果组内有空行，则直接放入空行中</span></span><br><span class="line"><span class="keyword">int</span> line_out = group_start + choose(NR_ASS);</span><br><span class="line">assert(line_out &lt; group_end);</span><br><span class="line"></span><br><span class="line">move_out(group_num, line_out);</span><br><span class="line">move_in(addr, line_out);</span><br><span class="line"><span class="comment">//否则随机替换一行</span></span><br><span class="line"><span class="keyword">return</span> line_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_in_line</span><span class="params">(<span class="keyword">int</span> line_num, <span class="keyword">int</span> index, <span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> wmask)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将数据写入cache某一行的某个index中</span></span><br><span class="line">line[line_num].dirty = <span class="literal">true</span>;</span><br><span class="line">line[line_num].data[index] &amp;= (~wmask);</span><br><span class="line">line[line_num].data[index] |= (data &amp; wmask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样一来需要实现的3个函数只需要调用以上API即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">(<span class="keyword">int</span> total_size_width, <span class="keyword">int</span> associativity_width)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*设置cache的一系列参数*/</span></span><br><span class="line">total_width = total_size_width;</span><br><span class="line">assert(total_width &lt;= <span class="number">14</span>);</span><br><span class="line">ass_width = associativity_width;</span><br><span class="line">group_width = total_width - ass_width - BLOCK_WIDTH;</span><br><span class="line"><span class="comment">/*初始化用于统计的变量*/</span></span><br><span class="line">cycle_cnt = <span class="number">0</span>;</span><br><span class="line">total_visit = hit_visit = miss_visit = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* set all the valid bits and dirty bits to invalid */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NR_LINE; ++i) line[i].valid = line[i].dirty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> cache_read(<span class="keyword">uintptr_t</span> addr) &#123;</span><br><span class="line">total_visit ++;</span><br><span class="line"><span class="keyword">uint32_t</span> group_num = get_group(addr);</span><br><span class="line"><span class="keyword">uint32_t</span> index = (addr &amp; OFFSET) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">//index in group</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line_num = find_in_group(addr, group_num);</span><br><span class="line"><span class="keyword">if</span>(line_num &gt;= <span class="number">0</span>) <span class="keyword">return</span> line[line_num].data[index];</span><br><span class="line"><span class="comment">//hit则直接读出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line_out = replace_in_group(addr, group_num);</span><br><span class="line"><span class="keyword">return</span> line[line_out].data[index];</span><br><span class="line"><span class="comment">//否则从主存调入cache</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_write</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> wmask)</span> </span>&#123;</span><br><span class="line">total_visit++;</span><br><span class="line"><span class="keyword">uint32_t</span> group_num = get_group(addr);</span><br><span class="line"><span class="keyword">uint32_t</span> index = (addr &amp; OFFSET) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">//index in group</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> line_num = find_in_group(addr, group_num);</span><br><span class="line"><span class="keyword">if</span>(line_num &gt;= <span class="number">0</span>) </span><br><span class="line">write_in_line(line_num, index, data, wmask);</span><br><span class="line"><span class="comment">//hit则直接写入</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> line_out = replace_in_group(addr, group_num);</span><br><span class="line">write_in_line(line_out, index, data, wmask);</span><br><span class="line">&#125;<span class="comment">//否则写分配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="cache性能测试"><a href="#cache性能测试" class="headerlink" title="cache性能测试"></a>cache性能测试</h1><h1 id="运行时间测算"><a href="#运行时间测算" class="headerlink" title="运行时间测算"></a>运行时间测算</h1><ul><li>框架代码已经给内存的读写赋好了相应的时钟周期数，所以我很自然地想到通过统计<strong>时钟周期数</strong>来统计运行的时间</li><li>关于怎么对cache读写操作的时钟周期测算，讲义说可以建立关于关联度的带参数的模型，但是我回想起来课本上讲过，组相联组内是用了很多比较器进行<strong>并行</strong>比较的。所以我认为读写的时钟周期数应该和关联度以及cache容量关系不大，所以将读写的时钟周期都设置为1。<s>&gt;可能也有想省事的惰性成分在里面</s></li><li>除时钟周期数外，还衡量一个缺失率。由于主存读写比cache读写慢得多，读写命中率也能表征cache的性能</li></ul><p>声明了一些用于统计的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* statistics */</span></span><br><span class="line"><span class="keyword">uint64_t</span> total_visit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> hit_visit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> miss_visit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>测算方法：控制变量法，控制组相联度或cache总宽度其中一个量不变，改变另外一个量。每种配置测量3次后取平均。根据结果使用excel作图，得到如下结果。【数据已经放在打包上传的.xlsx文件中】</li></ul><center><img src="/2018/12/29/lab4-report/miss-width.png"><img src="/2018/12/29/lab4-report/clk-width.png"><img src="/2018/12/29/lab4-report/miss-ass.png"><img src="/2018/12/29/lab4-report/clk-ass.png"></center><p>从以上数据和图表中可以看出：</p><ul><li>cache容量越大，缺失率越低，花费的总时钟周期数也越少。这是因为cache容量大了以后，能装入更多的主存块，缺失率就会相应地降低，需要进行替换的次数也会变少。但是cache大就意味着高昂的造价，而且SDRAM的材质(?)决定了cache不可能做到很大。而且由图中可以看出，当cache容量增大到一定大小时，其性能增长就很不明显了，因此一般会选择比较中等的大小。</li><li><p>缺失率与组相联度似乎并不是呈单调关系。原理上分析，组相联度越大，同一组内发生冲突的概率就越低，需要调出的次数也会越低。但有可能microbench-test中的访存顺序会导致某些经常访问的块，在相联度较小时被放到了不同的组中，而相联度较大时被放到了同一组中，导致发生冲突的次数增加。而且越高的组相联度，意味着越多的比较器，意味着更大的体积和更高的造价。</p></li><li><p>综上，对于microbench-test下的workload，我认为最佳的组相联宽度是2(4路组相联)。如果有钱任性，cache容量越大越好；如果要省钱经济，12或13的容量宽度(4KB或8KB的容量)是比较理想的。</p></li></ul><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h1 id="数据对齐和存储层次结构"><a href="#数据对齐和存储层次结构" class="headerlink" title="数据对齐和存储层次结构"></a>数据对齐和存储层次结构</h1><ul><li>如果没有对齐，同一个数据可能会被分配再两个主存块的交界处，读取这个数据的时候发生cache miss的概率更大，cache miss后可能需要调入两个主存块，代价更大，运行速度会大大降低。</li></ul><h1 id="不知道cache的复杂性对频率的影响"><a href="#不知道cache的复杂性对频率的影响" class="headerlink" title="不知道cache的复杂性对频率的影响?"></a>不知道cache的复杂性对频率的影响?</h1><ul><li>我不是很看得懂这里的建模的意思。我认为$ak^2+b$中%a,b$只是两个参数，考察它们对cache性能的影响是没有意义的，而是应该固定$a,b$，考察组相联度和cache容量对cache性能的影响。但是我已经在上文提到了我并没有把这两者与cache的读写速度关联起来。所以我没有建立带参数的模型。</li></ul><h1 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h1><ul><li>感谢不水的正经学习群的朋友们当我的小黄鸭，帮我调试</li><li>感谢<em>*的自己，因为一系列\</em>*行为，成功锻炼了心理承受能力</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验进度描述&quot;&gt;&lt;a href=&quot;#实验进度描述&quot; class=&quot;headerlink&quot; title=&quot;实验进度描述&quot;&gt;&lt;/a&gt;实验进度描述&lt;/h1&gt;&lt;p&gt;我已完成所有内容。&lt;/p&gt;
&lt;p&gt;以下是可以忽略的碎碎念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实验开始一小时：写代码
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
  <entry>
    <title>PA4实验报告</title>
    <link href="https://mengzelev.github.io/2018/12/28/PA4-report/"/>
    <id>https://mengzelev.github.io/2018/12/28/PA4-report/</id>
    <published>2018-12-28T08:00:32.000Z</published>
    <updated>2019-01-07T11:13:04.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h2><p>我已完成全部实验内容。</p><p>2018/12/15:<br>完成PA4.1。不少自认为关键的地方竟然怎么改都是对的，有点慌</p><p>2018/12/16:<br>PA4.2第一个任务完成，再不开始做数电大实验就要死了，只能封印PA</p><p>2018/12/23：<br>被数电大实验折磨完，PA4.2完成。仙剑跑得慢到感人。</p><p>2018/12/24：<br>平安夜，发现4.2最后一个task忘了跑了，定位了半天bug发现是<code>context_kload</code>忘了改成<code>context_uload</code>，心情简单。开始做4.3，但是由于前几天睡眠不足连着写了好几个沙雕bug，于是决定先放弃。</p><p>2018/12/25：<br>圣诞节，继续写PA4.3，花了一个小时解决了平安夜昏睡状态下写出的沙雕bug，花了4个小时解决了当天写出的沙雕bug，也就是PA最后一个bug。PA通关!</p><h2 id="蓝框思考题"><a href="#蓝框思考题" class="headerlink" title="蓝框思考题"></a>蓝框思考题</h2><p>迫于作业和复习考试压力，这次也一道都没做……</p><h2 id="我遇到的bug"><a href="#我遇到的bug" class="headerlink" title="我遇到的bug"></a>我遇到的bug</h2><ul><li>没看到讲义上要求把<code>loader</code>把文件映射到物理页的要求，映射到虚拟页上，结果一直出发<code>pte.present==0</code>的assert。仔细一想<code>loader</code>的确有义务把程序搬到合适的实际位置</li><li>即使是一个简单的dummy程序，其内容也有两页多。而且不能直接用文件大小/PGSIZE，否则余数部分会被丢弃</li><li><code>make run</code>的时候可能会碰到一大堆链接报错，原因不明，目前解决方案是在所有目录下都来一遍<code>clean(-update)-run</code>全家桶。<s>这时候调试公理1是不是被打破了呢？</s></li><li><code>_switch</code>是用来切换到下一个进程的，因此传入参数肯定为<code>next</code>而非<code>tf</code>【这不是我遇到的bug，是我不少同学都遇到的bug，所以也记下来了</li><li>增加时钟中断时需要填写idt表，太久没碰系统调用这个都忘了</li><li>4.3最后测试进程切换的时候千万不要因为嫌仙剑跑得太慢换成<code>bmptest</code>，这玩意儿是根本block了<code>events_read()</code>的，导致我debug了4个小时才发现</li></ul><h2 id="实验中的发现"><a href="#实验中的发现" class="headerlink" title="实验中的发现"></a>实验中的发现</h2><ul><li>与<code>cr3</code>和<code>cr0</code>有关的指令的译码函数其实可以使用框架代码提供的现成的译码函数,只不过需要研究一下怎么使用</li><li>在写<code>_map</code>函数时，我思考了很久，为什么当页目录的present位无效时，要用回调函数申请一个新的物理页。觉得应该是把这一页作为了存放页表的物理页</li><li>一些头文件里有不少讲义没提到的、可以方便coding的宏定义，例如<code>x86.h</code>和<code>mmu.h</code>,论RTFSC的重要性</li></ul><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ul><li>一定要好好读讲义</li><li>和同学交流了一下，发现不一定要全部理解了再开始写代码。可以把框架代码中提供的东西输出一下，根据输出的值来猜测这个变量的含义，或者这个函数的功能。做实验和理解理论是相辅相成的</li><li>每次开机，看着一行行初始化Log，就会想到这只是一个比我刚刚造完的<s>(其实大部分都是yzh写的)</s>的东西复杂一点<s>(这个一点有点多)</s>的家伙，就觉得五味杂陈</li><li>迫于时间压力不少挑战极限的选做题都没做</li><li>这学期做PA还是依赖了不少人的帮助，寒假想要二周目并完成PA5，希望也能把不少选做题都做一下</li></ul><h1 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h1><ul><li>感谢某人提供的探路和盯着写bug服务</li><li>感谢不水的正经学习群的群友们互帮互助的debug氛围</li></ul><p>本实验报告同样会将去掉必答题的版本同步上传至<a href="https://mengzelev.github.io/">个人blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验进度&quot;&gt;&lt;a href=&quot;#实验进度&quot; class=&quot;headerlink&quot; title=&quot;实验进度&quot;&gt;&lt;/a&gt;实验进度&lt;/h2&gt;&lt;p&gt;我已完成全部实验内容。&lt;/p&gt;
&lt;p&gt;2018/12/15:&lt;br&gt;完成PA4.1。不少自认为关键的地方竟然怎么改都是对的，
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
      <category term="ICS" scheme="https://mengzelev.github.io/tags/ICS/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-矩阵运算</title>
    <link href="https://mengzelev.github.io/2018/12/18/clrs28Matrix-Operation/"/>
    <id>https://mengzelev.github.io/2018/12/18/clrs28Matrix-Operation/</id>
    <published>2018-12-18T01:50:18.000Z</published>
    <updated>2019-01-07T11:16:02.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h1><script type="math/tex; mode=display">Ax=b</script><p><strong>欠定的(underdetermined)</strong>：方程的数目少于未知变量数目$n$，则该线性方程组为欠定的<br><strong>超定的(overdetermined)</strong>:方程数目超过未知变量数目$n$<br><strong>非奇异矩阵</strong>：$A$的秩等于未知变量的个数$n$</p><h2 id="LUP分解"><a href="#LUP分解" class="headerlink" title="LUP分解"></a>LUP分解</h2><p>思想：找出3个$n\times n$矩阵$L,U,P$，满足$PA=LU$,其中<br>$L$是一个单位下三角矩阵<br>$U$是一个上三角矩阵<br>$P$是一个置换矩阵<br>每一个非奇异矩阵$A$都会有这样一种分解</p><script type="math/tex; mode=display">Ax=b</script><script type="math/tex; mode=display">PAx=Pb</script><script type="math/tex; mode=display">LUx=Pbx</script><p>求解两个三角线性系统<br>下三角系统$Ly=Pb$<br>上三角系统$Ux=y$</p><h2 id="正向替换与方向替换"><a href="#正向替换与方向替换" class="headerlink" title="正向替换与方向替换"></a>正向替换与方向替换</h2><p>可在$\Theta(n^2)$时间内求解下三角系统</p><p>置换阵$P$可以用数组$\pi[1..n]$表示</p><script type="math/tex; mode=display">P_{i,j}=\begin{cases}1 & (j == \pi[i])\\0 & (j\neq\pi[i])\end{cases}</script><p>从第一个式子开始正向替换，可以得到</p><script type="math/tex; mode=display">y_i=b_{\pi[i]}-\sum\limits_{j=1}^{i-1}l_{ij}y_i</script><p>反向替换同理，最终可以得到</p><script type="math/tex; mode=display">x_i=(y_i-\sum\limits_{j=i+1}^{n}u_{ij}x_j)/u_{ii}</script><p><img src="/2018/12/18/clrs28Matrix-Operation/LUP-SOLVE.png"></p><h2 id="LU分解计算"><a href="#LU分解计算" class="headerlink" title="LU分解计算"></a>LU分解计算</h2><p>Gauss消元法：</p><ul><li>行消元得到的行梯阵即$U$</li><li>$L$由消去变量所用的行的乘数组成</li></ul><p><img src="/2018/12/18/clrs28Matrix-Operation/1.png"><br><img src="/2018/12/18/clrs28Matrix-Operation/2.png"></p><p><img src="/2018/12/18/clrs28Matrix-Operation/LU-DE.png"></p><p>可以看成<script type="math/tex">a_{ij}=a_{ij}-\frac{a_{ik}a_{kj}}{a_{kk}}</script></p><p>运行时间$\Theta(n^3)$</p><h2 id="LUP分解计算"><a href="#LUP分解计算" class="headerlink" title="LUP分解计算"></a>LUP分解计算</h2><p>在LU分解的基础上，为了保证除数不为0和减少数值不稳定，每次选择该列中具有最大绝对值的元素，交换到对角元的位置</p><p><img src="/2018/12/18/clrs28Matrix-Operation/LUP-DE.png"></p><p>运行时间$\Theta(n^3)$</p><h1 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h1><p>LUP分解可以用于计算逆矩阵(废话，高斯消元可以，LUP当然可以)<script type="math/tex">AX_{i}=e_i</script></p><p>矩阵乘法和矩阵求逆具有相同的时间复杂度</p><p>证明时间复杂度相同：两个问题都能在O(另一个问题算法的时间复杂度)时间内解决</p><ul><li>证明的时候可能会用到分块阵的思想来转化问题</li></ul><h1 id="对称正定阵"><a href="#对称正定阵" class="headerlink" title="对称正定阵"></a>对称正定阵</h1><p><strong>引理28.3</strong>：任何对称正定矩阵都是非奇异矩阵<br>任何对称正定矩阵都有逆矩阵。</p><p><strong>引理28.4</strong>：如果$A$是一个对称正定矩阵，那么$A$的每一个主子矩阵都是对称正定的。</p><p><strong>舒尔补</strong>：矩阵$A$关于主子矩阵$A_k$的舒尔补为$S=C-B{A_k}^{-1}B^T$。其中，$A$为对称正定阵且</p><script type="math/tex; mode=display">A=\left[     \begin{matrix}    A_k & B^T \\    B & C    \end{matrix}    \right]</script><p><strong>舒尔补定理</strong>：如果$A$是一个对称正定矩阵，$A_k$是$A$的$k\times k$主子矩阵，那么$A$关于$A_k$的舒尔补是对称正定的。</p><p><strong>推论28.6</strong>：一个对称正定矩阵的LU分解永远不会出现除数为0的情形</p><h1 id="最小二乘逼近"><a href="#最小二乘逼近" class="headerlink" title="最小二乘逼近"></a>最小二乘逼近</h1><p>就是看上去很厉害实际上真的很厉害的曲线拟合</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求解线性方程组&quot;&gt;&lt;a href=&quot;#求解线性方程组&quot; class=&quot;headerlink&quot; title=&quot;求解线性方程组&quot;&gt;&lt;/a&gt;求解线性方程组&lt;/h1&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;Ax=b&lt;/script&gt;&lt;p
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-平面图与着色</title>
    <link href="https://mengzelev.github.io/2018/12/13/planar-graph-and-coloring/"/>
    <id>https://mengzelev.github.io/2018/12/13/planar-graph-and-coloring/</id>
    <published>2018-12-13T06:30:30.000Z</published>
    <updated>2018-12-15T03:40:57.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h1><p><strong>平面图(planar graph)：</strong>如果$G$能够被画在一个平面上而使得任何两条边都不会交叉</p><p><strong>平图(plane graph)</strong>：如果$G$是平面图且$G$的任何两条边都不交叉</p><p>平面图的例子：cycle, path, star, tree</p><p><strong>区域(regions)</strong>：一个平图把平面分成一些连通片<br><strong>外区域(exterior region)</strong>：每个平图中总有的一个无界的区域<br><strong>边界(boundary)</strong>：在一个平图中，顶点和边斗鱼某个给定区域$R$关联的子图称为是$R$的边界</p><p>割边总是恰好在一个区域的边界上<br>非割边一定位于两个区域的边界上</p><p>如果$G$是一个至少含有三条边的连通平图，则$G$的而每个区域的边界至少含有三条边</p><p><strong>定理9.1(Euler恒等式)</strong>：如果$G$是一个阶为$n$，边数为$m$且含有$r$个区域的连通平图，则$n-m+r=2$</p><p><strong>定理9.2</strong>：如果$G$是一个阶为$n\ge 3$且边数为$m$的平面图，则$m\le 3n-6$。(平面图的必要条件，非平面图的充分条件)<br>逆否命题：设$G$阶为$n$，若$m&gt;3n-6$，则$G$是非平面图。<br>注：满足$m\le 3n-6$的不一定是平面图</p><p><strong>推论9.3</strong>：每个平面图含有一个度小于或等于5的顶点。</p><p><strong>推论9.4</strong>：完全图$K_5$是非平面的。</p><p><strong>极大平面的(maximal planar)</strong>：若$G$是平面的，且在$G$的任意两个不邻接的顶点之间添加一条边即可产生一个非平面图。<br>另一种表述：$G$是平面的，但$G$不是任何一个平面图的生成子图<br>极大平面图满足$m=3n-6$</p><p><strong>定理9.5</strong>：图$K_{3,3}$是非平面的</p><p><strong>细分(subdivision)</strong>： 如果有一个或多个度为2的顶点被插入到$G$的一条或多条边中，则称图$G’$是图$G$的一个细分</p><p><strong>定理9.7(Kuratowski定理)</strong>：一个图$G$是平面图当且仅当$G$不含$K<em>5$，$K</em>{3,3}$，或者$K<em>5$或$K</em>{3,3}$的一个细分作为子图。</p><p>如果一个图$G$含有(1)至多4个度大于或等于4的顶点(2)至多5个度大于或等于3的顶点，则$G$必定是平面的。</p><h1 id="顶点染色"><a href="#顶点染色" class="headerlink" title="顶点染色"></a>顶点染色</h1><p><strong>对偶(dual)</strong>：每张地图都有一个与之关联的图$G$，称为该地图的对偶，其中$G$的顶点即为地图的区域，$G$的两个顶点是邻接的当且仅当它们所对应的区域是相邻的<br>每张地图的对偶图都是平面图，每个连通的平面图都是某个地图的对偶。</p><p><strong>真染色(proper coloring)</strong>：给$G$的顶点分配一些颜色(来自于某个颜色集合)，是的每个顶点都能分配到一种颜色，且邻接的顶点被染成不同的颜色，简称为<strong>染色(coloring)</strong></p><p><strong>色数(chromatic number)$\chi(G)$</strong>：在$G$的所有染色中，所用的最少颜色数</p><p><strong>$k$可染色的(k-colorable)</strong>：如果能用一个含有$k$种颜色的集合给$G$的顶点染色，则称$G$是$k$<strong>可染色的(k-colorable)</strong>，应用$k$种颜色的染色称为是<strong>$k$染色(k-coloring)</strong>。</p><p>若$\chi(G)=k$，则$G$也称为是<strong>$k$色的(k-chromatic)</strong>，并且$G$的每个$k$染色都是$G$的<strong>最小染色(minimum coloring)</strong></p><p><strong>定理10.1(四色定理)</strong>：每个平面图的色数至多是4</p><p><strong>色类(color classes)</strong>：若$G$是一个$k$色图，则可以把$V(G)$划分成$k$个独立集$V_1,V_2,…,V_k$，此时这些顶点集称为色类。</p><p><strong>定理10.2</strong>：图$G$的色数是2当且仅当$G$是一个非空的二部图。</p><p>(复习：<strong>定理1.12</strong>：图$G$是二部的当且仅当其不含奇圈)<br>若$G$含有奇圈，则$\chi(G)\ge 3$</p><p>$n$阶图$G$的色数为$n$当且仅当$G=K_n$</p><p>证明$\chi(G)=k$，必须证明：</p><ul><li>至少需要$k$种颜色来为$G$染色(不能用$k-1$种颜色为$G$染色)</li><li>存在$G$的一个$k$染色</li></ul><p>若$H$为$G$的一个子图，则$\chi(H)\le\chi(G)$</p><p><strong>团(clique)</strong>：$G$的一个完全子图<br><strong>团数(clique number)\omega(G)</strong>：图$G$中最大团的阶数<br>$\alpha(G)=k$当且仅当$\omega(G)=k$</p><p><strong>定理10.5</strong>：对每个$n$阶图$G$：<script type="math/tex">\chi(G)\ge\omega(G), \chi(G)\ge\frac{n}{\alpha(G)}</script><br>(给出了图$G$的色数的下限)</p><p>图$G$的染色可以看成是$V(G)\to\mathbb{N}$的一个函数$c:V(G)\to\mathbb{N}$，使得当$uv\in E(G)$时，$c(u)\neq c(v)$</p><p><strong>定理10.7</strong>：对于每个图$G$，$\chi(G)\le 1+\Delta(G)$。($\Delta(G)$为$G$的最大度)</p><p><strong>定理10.8(Brooks定理)</strong>：对每个非奇圈也非完全的连通图$G$，$\chi(G)\le\Delta(G)$</p><p><strong>定理10.9</strong>：对于每个图$G$,$\chi(G)\le 1+\max\{\delta(H)\}$，其中$\max$取遍$G$的所有诱导子图$H$。</p><p><strong>影子图(shadow graph)$S(G)$</strong>:通过在$G$中，对其每个顶点$v$，增加一个新的顶点$v’$，称之为$v$的<strong>影子顶点(shadow vertex)</strong></p><p><img src="/2018/12/13/planar-graph-and-coloring/shadow.png"></p><p><strong>定理10.10</strong>：对于每个整数$k\ge 3$，都存在一个色数为$k$的无三角的图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平面图&quot;&gt;&lt;a href=&quot;#平面图&quot; class=&quot;headerlink&quot; title=&quot;平面图&quot;&gt;&lt;/a&gt;平面图&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;平面图(planar graph)：&lt;/strong&gt;如果$G$能够被画在一个平面上而使得任何两条边都不会交叉&lt;/p
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>卫宫家今天的饭</title>
    <link href="https://mengzelev.github.io/2018/12/10/Dinner/"/>
    <id>https://mengzelev.github.io/2018/12/10/Dinner/</id>
    <published>2018-12-10T08:22:19.000Z</published>
    <updated>2018-12-10T09:43:06.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题源"><a href="#题源" class="headerlink" title="题源"></a>题源</h1><p>POJ 3281 Dining<br><a href="http://bailian.openjudge.cn/practice/3479/" target="_blank" rel="noopener">openjudge传送门</a><br><s>饱受OJ折磨的我决定以德报怨给大家出道水题</s></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>基本只是把原题搬到了月球上</p><ul><li>N位客人，F种食物，D种饮料</li><li>每位客人有多种喜欢的事物和饮料</li><li>每位客人只吃一种食物、只喝一种饮料</li><li>每种食物，每种饮料只能被一位客人吃/喝</li></ul><p>可以看成两个二分图最大匹配问题</p><h1 id="构建流网络"><a href="#构建流网络" class="headerlink" title="构建流网络"></a>构建流网络</h1><ul><li>先尝试：食物-客人-饮料 <ul><li>会出现一位客人对应多份食物或饮料的情况</li><li>客人结点需要加上结点容量</li><li>将每个客人结点拆分为两个</li></ul></li><li>源点s-食物-客人1-客人2-饮料-汇点</li></ul><h1 id="最大流算法"><a href="#最大流算法" class="headerlink" title="最大流算法"></a>最大流算法</h1><ul><li>数据规模[1,100]</li><li>EK完全OK</li><li>没有刻意生成卡任何算法的数据，也许可以尝试暴力</li><li>板子写起来有丶难度</li><li>代码虽然我贴了，但是务必自己写一遍！</li></ul><h1 id="EK板子"><a href="#EK板子" class="headerlink" title="EK板子"></a>EK板子</h1><p><img src="/2018/12/10/Dinner/ff.png"></p><ul><li><s>容量c[N][N]，流量f[N][N]</s></li><li>只需要一个记录当前残存容量的数组map[N][N]</li><li>随便搜一下就能找到</li></ul><h2 id="板子代码"><a href="#板子代码" class="headerlink" title="板子代码"></a>板子代码</h2><pre><code>int edmonds_karp() {    int ans = 0;    int minc;    while((minc = bfs()) != -1) { //bfs找到一条增广路径        ans += minc;    //加上这条增广路径的流量        int tt = t,pt;          while(tt != s) {            pt = pre[tt];            map[pt][tt] -= minc;            map[tt][pt] += minc;            tt = pt;        }   //修改这条增广路径上的边的残存容量    }    return ans;}</code></pre><h2 id="bfs寻找增广路径"><a href="#bfs寻找增广路径" class="headerlink" title="bfs寻找增广路径"></a>bfs寻找增广路径</h2><pre><code>int bfs(){    memset(pre, -1, sizeof(pre));    int minc = 1e9;    queue &lt;int&gt; q;    q.push(s);    while(!q.empty()){        int u = q.front();        q.pop();        if(u == t) break;        for(int i = 1; i &lt;= t; ++i) {            if(pre[i] == -1 &amp;&amp; map[u][i]) {                minc = min(minc, map[u][i]);                //更新当前路径的最小残存容量                q.push(i);                pre[i] = u;                 //pre数组用于记录bfs找到的增广路径            }        }    }    if(pre[t] == -1) return -1;    else return minc;}</code></pre><h2 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h2><p>代码不贴惹，自己写吧:)</p><p>Tips:<br>为了将各种不同类型的所有点都囊括在一个数组里的同时，增强代码的可读性，可以使用宏定义</p><pre><code>#define FOOD(x) **我**#define GUEST1(x) **是**#define GUEST2(x) **马**#define DRINK(x) **赛**#define s **克**#define t **!**</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题源&quot;&gt;&lt;a href=&quot;#题源&quot; class=&quot;headerlink&quot; title=&quot;题源&quot;&gt;&lt;/a&gt;题源&lt;/h1&gt;&lt;p&gt;POJ 3281 Dining&lt;br&gt;&lt;a href=&quot;http://bailian.openjudge.cn/practice/3479/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PA3实验报告</title>
    <link href="https://mengzelev.github.io/2018/12/08/PA3-report/"/>
    <id>https://mengzelev.github.io/2018/12/08/PA3-report/</id>
    <published>2018-12-08T08:00:32.000Z</published>
    <updated>2019-01-07T11:11:41.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h1><p>我已完成所有内容。<br>好，下面是惯例碎碎念。</p><p>2018/11/18<br>心态爆炸的一天！先是因为脑子短路完全没有想到<code>idt</code>的地址就在<code>lidt</code>译码过后的<code>id_dest</code>里。然后还因为惯性思维从<code>id_dest-&gt;val</code>里读地址，疯狂出错才发现应该在<code>id_dest-&gt;addr</code>里（因为是地址）。组织Context的时候思考了半天，最后问了大腿才知道怎么判断上下文的组织结构。感觉还是课本知识学得不够扎实的恶果。今日不宜PA，关机睡觉。</p><p>2018/11/19<br>PA3.1完成。感觉测试手段都不太给力，不知道有没有埋下隐藏bug</p><p>2018/11/24<br>PA3.2完成。感觉莫名顺利，可能是3.3要自闭的征兆</p><p>2018/12/1<br>开始自闭PA3.3，实现了文件读写操作，死活看不到PASS!!!，文件读写时对长度超过文件大小的情况的处理有一些麻烦，调了半天，最后发现是PA3.2时就好了的SYS_write没有加上刚刚写的<code>fs_write</code>，喷了。开始编写设备文件操作，看不懂vga那块到底是要干啥，机房关门了，回去睡觉。</p><p>2018/12/2<br>继续自闭PA3.3。为了看懂VGA那块的架构直接翻出了bmptest的源码，然后一路摸到NDL库的源码，花了大概一个下去终于显示出了ProjectN的Logo。实现<code>events_read()</code>时还把事件的格式搞错了debug了半天，终于可以开始跑仙剑了。小心翼翼地开始游戏，没有注释掉<code>Log</code>因此看到了瀑布般的<code>Log</code>信息，然后50min才播放完片头对话，所幸无事。然后注释掉了所有<code>Log</code>，又胆战心惊地开始尝试所有存档点，尝试了穿墙和穿人，全部失败，确认了没有肉眼可见的bug。长舒一口气，然后加急写完了批处理系统，机房关门，走人。难以置信我居然跑出了仙剑，亢奋。</p><h1 id="必答题"><a href="#必答题" class="headerlink" title="必答题"></a>必答题</h1><p><s>其实我写PA的时候都在系统调用过程梳理里做好笔记了</s></p><h2 id="游戏的存档"><a href="#游戏的存档" class="headerlink" title="游戏的存档"></a>游戏的存档</h2><ul><li>仙剑奇侠传中调用C标准I/O库函数<code>fread()</code></li><li>库函数<code>fread()</code>会调用libos中的系统调用的封装函数<code>_read()</code></li><li>libos中的<code>_read()</code>函数通过调用<code>_syscall_()</code>，直接使用内联汇编语句编译出<code>int 0x81</code>的系统调用内陷指令，并将相应的参数放入约定的寄存器中(<code>%eax</code>,<code>%ebx</code>，<code>%ecx</code>，<code>%edx</code>)</li><li>nemu执行指令时遇到了<code>int 0x81</code>指令，译码后执行<code>raise_intr()</code>，将EFLAGS，CS，EIP的值压入栈中，并到am中的中断门描述符表<code>idt</code>中查询0x81对应的跳转目标的偏移量offset，为<code>vectrap()</code></li><li><code>vectrap()</code>直接通过汇编指令将错误码<code>irq</code>压栈，然后跳转到<code>asm_jmp</code>函数执行（nexus-am/am/arch/x86-nemu/src/trap.S中定义）</li><li>在<code>asm_trap</code>中通过<code>pusha</code>指令让nemu将所有寄存器压栈，然后执行<code>irq_handle()</code>函数（在nexus-am/am/arch/x86-nemu/src/cte.c中）</li><li><code>irq_handle()</code>把执行流切换的原因打包成事件，然后调用在<code>_cte_init()</code> 中注册的事件处理回调函数, 将事件交给Nanos-lite来处理</li><li>Nanos-lite中的<code>do_event()</code>函数根据nemu打包传过来的时间决定系统调用类型，此处是<code>_EVENT_SYSCALL</code>类型的，就调用<code>do_syscall()</code>函数来处理这个系统调用</li><li><code>do_syscall()</code>根据上下文中寄存器<code>%eax</code>保存的参数确定系统调用的类型，此时为<code>SYS_read</code>类型，就调用文件系统中的<code>fs_read()</code>并将相应的参数传入</li><li><code>fs_read()</code>根据传入的文件名（存档信息文件的名称）读取需要的长度到指定的位置，恢复成存档前的状态，就可以从存档点继续游戏</li><li><code>fs_read()</code>执行完成后，一路返回到<code>asm_trap</code>中，恢复之前压入栈中保存的寄存器，然后执行<code>iret</code>指令</li><li>nemu执行<code>iret</code>指令，恢复EFLAGS，CS，EIP，跳转到EIP所指向的地方继续执行之后的指令</li></ul><p>至此，一次读取存档的系统调用全部完成</p><h2 id="更新屏幕"><a href="#更新屏幕" class="headerlink" title="更新屏幕"></a>更新屏幕</h2><ul><li>仙剑奇侠传中调用libndl中的库函数<code>NDL_DrawRect()</code></li><li><code>NDL_DrawRect()</code>会调用C标准I/O库函数<code>fwrite()</code>，将当前的像素信息写入<code>stdout</code>中，这里的<code>stdout</code>不是终端里的标准输出，而是应用程序的标准输出<code>_REENT-&gt;stdout</code></li><li>系统调用过程同上，此处不再赘述。进入Nanos-lite的文件系统后，由于是对显示设备抽象成的文件<code>/dev/fb</code>进行读取，<code>fs_write()</code>调用的是<code>fb_write()</code></li><li><code>fb_write()</code>调用了am的klib中提供的<code>screen_width()</code>和<code>draw_rect()</code></li><li>am中的<code>draw_rect()</code>调用了vga设备的写函数<code>video_write()</code>，把相应的像素信息写入到映射到<code>vga_memory</code>的物理内存中</li><li>当nemu访问到从0x4000开始的一段被映射到I/O空间的物理地址时，就会通过<code>mmio_write</code>来修改I/O空间的数据</li><li>I/O空间的数据被修改后调用了<code>update_screen()</code>，由nemu把更新后的屏幕显示信息显示了出来</li><li>进行系统调用的返回操作，同样不再赘述</li></ul><p>至此，一次更新屏幕的系统调用完成</p><h1 id="蓝框思考题"><a href="#蓝框思考题" class="headerlink" title="蓝框思考题"></a>蓝框思考题</h1><p>最近太忙了一题都没写…<br>想写的时候讲义又挂了…<br>二周目的时候再思考吧orz</p><h1 id="实验中的发现"><a href="#实验中的发现" class="headerlink" title="实验中的发现"></a>实验中的发现</h1><h2 id="关于nanos-lite和nemu是怎么通讯的"><a href="#关于nanos-lite和nemu是怎么通讯的" class="headerlink" title="关于nanos-lite和nemu是怎么通讯的"></a>关于nanos-lite和nemu是怎么通讯的</h2><p>在写PA3.1中的<code>lidt</code>指令的时候，我有个很大的疑惑，<code>idt</code>是在nanos-lite里被定义的，nemu要怎么获取它的地址呢？<code>_cte_init</code>中有一步调用了<code>set_idt</code>函数，将idt的地址和大小用内联汇编语句写入了指令集。因此当nanos编译成nemu可执行的指令后，idt的地址就可以通过相应的译码函数写入<code>id_dest</code>中。<br>问了一位nb的学长后，学长给出了如下理解</p><blockquote><p>不在system.c里的指令，一般靠编译c文件成机器码就可以给nemu做事，所以pa2很顺利；而system.c的东西依赖于系统（比如中断），只靠编译c文件做不到int、lidt这些东西，所以要内联汇编</p></blockquote><h2 id="关于如何判断-Context结构的组织顺序"><a href="#关于如何判断-Context结构的组织顺序" class="headerlink" title="关于如何判断_Context结构的组织顺序"></a>关于如何判断<code>_Context</code>结构的组织顺序</h2><p><code>_Context</code>是在函数<code>irq_handle</code>里作为参数的类型被传入的，然而<code>irq_handle</code>是通过汇编代码直接调用的，因此没有显式的参数传递语句，实际的参数是存放在栈中<code>%ebp-8</code>的位置开始的位置，观察<code>call irq_handle</code>之前所有的<code>push</code>相关语句就可以得知寄存器的顺序。而<code>eip</code>,<code>eflags</code>和<code>eip</code>是硬件保存的，因此需要观察<code>int</code>指令中的入栈顺序才能知道这三者的顺序。</p><h2 id="系统调用过程梳理"><a href="#系统调用过程梳理" class="headerlink" title="系统调用过程梳理"></a>系统调用过程梳理</h2><ol><li>用户层navy-apps在相应的系统调用函数（如<code>_exit()</code>）中调用系统调用接口函数<code>_syscall_()</code></li><li><code>_syscall_</code>用内联汇编语句将<code>int 0x80</code>和相应的系统调用参数传给nemu</li><li>nemu执行<code>int</code>指令，叫出nanos-lite</li><li><code>irq_handler</code>通过<code>int</code>指令传入的参数识别出这是一次系统调用的event，打包传给<code>do_event</code></li><li><code>irq.c</code>中的<code>do_event()</code>函数调用<code>do_syscall()</code>执行系统调用事件</li><li><code>syscall.c</code>中的<code>do_syscall()</code>函数根据传入的参数（在上下文的相应寄存器中）执行相应的系统调用操作，设置返回值并返回</li></ol><h1 id="我遇到的bug"><a href="#我遇到的bug" class="headerlink" title="我遇到的bug"></a>我遇到的bug</h1><ul><li>堆区管理的时候声明的用于记录program break的变量<code>pbrk</code>没有初始化【所以说初始化真的是个好文明</li><li>写了<code>fs_write</code>却忘了修改相应的系统调用<code>SYS_write</code>找了一个下午</li><li>所有关于文件读写的系统操作都需要控制<code>open_offset</code>，不能超过当前文件的size，但是<code>serial_write</code>和<code>dispinfo_read</code>等不同文件的读写又不能一概而论，写bug和debug的时候要特别注意</li><li><code>fs_lseek</code>最后要控制当前的<code>open_offset</code>，不然可能会导致<code>fs_read</code>和<code>fs_write</code>的功能无法正常使用</li><li><code>fs_read</code>和<code>fs_write</code>需要对<code>open_offset</code>做出修改</li><li>函数指针的调用就跟函数一样用就行了</li><li><code>fb_write</code>里的<code>offset</code>怎么用，怎么给<code>draw_rect</code>传参，可能要一直摸到<code>libnbl</code>才能搞清楚</li><li>字符串不能x**初始化，会由于某些我搞不懂的原因编译出<code>STOS</code>指令，导致看到亲切的i386 Logo</li><li><code>if((keytemp &amp; 0x8000) == 1)</code>和<code>if(keytemp &amp; 0x8000)</code>是不一样的！！！！！！[你是沙雕吗.jpg]</li></ul><h1 id="对讲义的一些建议（你们选择性反馈给yzh）"><a href="#对讲义的一些建议（你们选择性反馈给yzh）" class="headerlink" title="对讲义的一些建议（你们选择性反馈给yzh）"></a>对讲义的一些建议（你们选择性反馈给yzh）</h1><ul><li>建议把能看到<code>PASS!!!</code>信息的放在<code>serial_write()</code>之后，不少同学都在实现完<code>SYS_write</code>之后没看到PASS！！！感到困惑（当然仔细想一下还是能想通）</li><li>堆区管理那一块太考验阅读理解水平了，而且大部分人会忘掉PA2还接触过AM里一个叫<code>heap</code>的结构体，就稍微提醒一下下呗（</li><li>让dummy实现<code>_syscall_</code>时，最好能提醒一下如果按照之前加系统调用一下加入<code>do_event</code>中会触发死循环，或者干脆把下面的必做部分并到一起写，减少困惑</li></ul><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ul><li>RTFSC是很难的，不要一下子看不出来就自闭，<s>不然会出事情的</s></li><li>要成为一名优秀的程序猿，首先你要学好语文</li><li>出bug不可怕，如果能通过debug的过程对框架代码和计算机系统的原理有更深刻的理解，其实是一件很赚的事情。听了助教讲课之后我深刻感受到，一出bug就问大腿“怎么写才是对的”，实在太亏了，应该搞清楚哪里写错了，为什么写的fault这个出现这样的failure。</li></ul><h1 id="Appreciation"><a href="#Appreciation" class="headerlink" title="Appreciation"></a>Appreciation</h1><ul><li>感谢某人提供的探路和debug服务，我觉得有点保护过度了再这样下去我要不会自己写代码了【捂脸</li><li>感谢名字一直在换的学习群的群友们互帮互助的debug氛围</li></ul><p>本实验报告同样会将去掉必答题的版本同步上传至<a href="https://mengzelev.github.io/">个人blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验进度&quot;&gt;&lt;a href=&quot;#实验进度&quot; class=&quot;headerlink&quot; title=&quot;实验进度&quot;&gt;&lt;/a&gt;实验进度&lt;/h1&gt;&lt;p&gt;我已完成所有内容。&lt;br&gt;好，下面是惯例碎碎念。&lt;/p&gt;
&lt;p&gt;2018/11/18&lt;br&gt;心态爆炸的一天！先是因为脑子短路
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="pa" scheme="https://mengzelev.github.io/tags/pa/"/>
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-最大流</title>
    <link href="https://mengzelev.github.io/2018/12/05/clrs-26Maximum-Flow/"/>
    <id>https://mengzelev.github.io/2018/12/05/clrs-26Maximum-Flow/</id>
    <published>2018-12-05T07:03:20.000Z</published>
    <updated>2019-01-17T12:08:51.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流网络"><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h1><h2 id="流网络-1"><a href="#流网络-1" class="headerlink" title="流网络"></a>流网络</h2><ul><li>有向图$G=(V,E)$</li><li>图中中每条边$(u,v)\in E$有一个非负的<strong>容量值</strong>$c(u,v)\ge 0$</li><li>如果$(u,v)\notin E$，定义$c(u,v)=0$</li><li>如果边集合$E$包含一条边$(u,v)$，则图中不存在反方向的边$(v,u)$</li><li>有<strong>源结点$s$</strong>和<strong>汇点$t$</strong></li><li>流网络图是连通的</li><li>除源结点外的每个结点都至少有一条进入的边，$|E|\ge |V|-1$</li></ul><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>设$G=(V,E)$为一个流网络，其容量函数为$c$。设$s$为网络的源结点，$t$为汇点。$G$中的流是一个实值函数$f: V\times V \to \mathbb{R}$，满足下面两条性质：</p><ul><li><strong>容量限制</strong>：对于所有的结点$u,v\in V$，要求$0\le f(u,v)\le c(u,v)$</li><li><strong>流量守恒</strong>：对于所有的结点$u\in V-\{s,t\}$，要求<script type="math/tex">\sum\limits f(v,u)=\sum\limits f(u,v)</script>当$(u,v)\notin E$时，从结点$u$到结点$v$之间没有流，因此$f(u,v)=0$</li></ul><p>称非负数值$f(u,v)$为从结点$u$到结点$v$的流。（流入=流出）</p><p>一个流$f$的<strong>值</strong>$|f|=\sum\limits<em>{v\in V}f(s,v)-\sum\limits</em>{v\in V}f(v,s)$ （从源结点流出的总流量减去流入源结点的总流量）</p><p><strong>最大流问题</strong>：给定一个流网络$G$、一个源结点$s$、一个汇点$t$，找到值最大的一个流</p><h2 id="反平行边"><a href="#反平行边" class="headerlink" title="反平行边 "></a><strong>反平行边</strong> </h2><p>如果要使用反平行边来模拟一个流问题，就选择两条反平行边中的一条，加入一个新结点来将其分解为两段，并以新的结点到原来边的结点的两条路替换所选边，同时将两条新设立的边的容量设置为与原来的边的容量相同。</p><p><img src="/2018/12/05/clrs-26Maximum-Flow/antiparallel.png"></p><h2 id="具有多个源结点和多个汇点的网络"><a href="#具有多个源结点和多个汇点的网络" class="headerlink" title="具有多个源结点和多个汇点的网络"></a>具有多个源结点和多个汇点的网络</h2><p>加入一个<strong>超级源结点$s$</strong>和一个<strong>超级汇点$t$</strong></p><p><img src="/2018/12/05/clrs-26Maximum-Flow/multi.png"></p><h1 id="Ford-Fulkerson方法"><a href="#Ford-Fulkerson方法" class="headerlink" title="Ford-Fulkerson方法"></a>Ford-Fulkerson方法</h1><p><img src="/2018/12/05/clrs-26Maximum-Flow/ffm.png"></p><h2 id="残存网络"><a href="#残存网络" class="headerlink" title="残存网络"></a>残存网络</h2><p>给定流网络$G$和流量$f$，残存网络$G_f$由那些仍有空间对流量进行调整的边构成。</p><p>残存容量为$c_f(u,c)=c(u,v)-f(u,v)$</p><p>对正流量的<strong>缩减</strong>：将边$(v,u)$加入到图$G_f$中，并将其残存容量设置为$c_f(v,u)=f(u,v)$</p><p><strong>残存容量</strong>的形式化定义如下：<br><img src="/2018/12/05/clrs-26Maximum-Flow/residual_capacity.png"></p><p>给定一个流网络$G=(V,E)$和一个流$f$，则有$f$所诱导的图$G$的残存网络为$G_f=(V,E_f)$，其中$E_f=\{(u,v)\in V\times V: c_f(u,v)&gt;0\}$，有$|E_f|\le 2|E|$</p><p><strong>递增</strong>：如果$f$是$G$的一个流，$f’$是对应的残存网络$G_f$的中的一个流，定义<script type="math/tex">f'\uparrow f':V\times V\to\mathbb{R}</script>为流$f’$对流$f$的<strong>递增</strong></p><p><img src="/2018/12/05/clrs-26Maximum-Flow/augmentation.png"></p><p><strong>抵消操作</strong>：在残存网络中将流量推送回去</p><p><strong>引理26.1</strong>：<script type="math/tex">|f\uparrow f'|=|f|+|f'|</script></p><h2 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h2><p><strong>增广路径</strong>$p$：残存网络$G_f$中一条从源结点$s$到汇点$t$的简单路径</p><p><strong>残存容量</strong>：在一条增广路径$p$上能够为每条边增加的流量的最大值<script type="math/tex">c_f(p)=\min\{c_f(u,v): (u,v)\in p\}</script></p><p><img src="/2018/12/05/clrs-26Maximum-Flow/Lemma26-2.png"><br><img src="/2018/12/05/clrs-26Maximum-Flow/Lemma26-3.png"></p><h2 id="流网络的切割"><a href="#流网络的切割" class="headerlink" title="流网络的切割"></a>流网络的切割</h2><p><strong>流网络的切割</strong>：将结点集合$V$划分为$S$和$T=V-S$两个集合，使得$s\in S, t\in T$</p><p>横跨切割的$(S,T)$的<strong>净流量</strong>$f(S,T)$：<script type="math/tex">f(S,T)=\sum\limits_{u\in S}\sum\limits_{v\in T}f(u,v)-\sum\limits_{u\in S}\sum\limits_{v\in T}f(v,u)</script></p><p>切割$(S,T)$的<strong>容量</strong>：<script type="math/tex">c(S,T)=\sum\limits_{v\in S}\sum\limits_{v\in T}c(u,v)</script><br><strong>最小切割</strong>：整个网络中容量最小的切割</p><ul><li>对于容量，只计算从集合$S$发出进入集合$T$的边的容量，而忽略反方向边上的容量</li><li>对于流，考虑从$S$到$T$的流量减去从$T$到$S$的反方向的流量</li></ul><p><strong>引理26.4</strong>：整个流网络的流量与横跨某一个切割的流量相等<script type="math/tex">f(S,T)=|f|</script></p><p><strong>推论26.5</strong>：$|f|\ge c(S,T)$</p><p><strong>定理26.6(最大流最小割定理)</strong><br><img src="/2018/12/05/clrs-26Maximum-Flow/Theorem26-6.png"></p><h2 id="基本的Ford-Fulkerson算法"><a href="#基本的Ford-Fulkerson算法" class="headerlink" title="基本的Ford-Fulkerson算法"></a>基本的Ford-Fulkerson算法</h2><p><img src="/2018/12/05/clrs-26Maximum-Flow/ff.png"></p><p>粗糙的时间复杂度上界：$O(E|f<em>|)$（$f</em>$为将有理数流网络转换成整数流网络后，网络中的一个最大流）</p><h2 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h2><p>在Ford-Fulkerson算法的第三行使用<strong>广度优先搜索</strong>来寻找增广路径。<br>每次在残存网络中选择的增广路径是一条从源结点$s$到汇点$t$的最短路径，其中每条边的权重为单位距离。</p><p>时间复杂度：$O(VE^2)$</p><p><strong>引理26.7</strong>：使用Edmonds-Karp算法，对于除源结点和汇点外的所有结点$v$，残存网络$G_f$中的最短路径距离$\delta_f(s,v)$随着每次流量的递增而单调递增。</p><p><strong>定理26.8</strong>：Edmonds-Karp算法所执行的流量递增操作的总次数为$O(VE)$</p><p><strong>关键边</strong>：在残存网络中，一条路径$p$的残存容量是该条路径上边$(u,v)$的残存容量，即$c_f(p)=c_f(u,v)$<br>对于$E$的每条边来说，其成为关键边的次数最多为$|V|/2$次。</p><h1 id="最大二分匹配"><a href="#最大二分匹配" class="headerlink" title="最大二分匹配"></a>最大二分匹配</h1><p>在一个二分图中，结点集合可以划分为$V=L\cup R$，其中$L$和$R$是不相交的，并且边集合$E$中所有的边都横跨$L$和$R$。</p><p>构造一个流网络$G=(V’,E’)$，其中<script type="math/tex">V'=V\cup\{s,t\}$$$$E=\{(s,u):u\in L, u\in L\}\cup \{(u,v):(u,v)\in E\}\cup \{(v,t):v\in\mathbb{R}\}</script><br>给$E’$中的每条边赋单位容量</p><p><img src="/2018/12/05/clrs-26Maximum-Flow/26-9.png"></p><p>流$f$是<strong>整数值</strong>的：对于所有的边$(u,v)\in V\times V$，$f(u,v)$都是整数值。</p><p><strong>定理26.10（完整性定理Integrality theorem）</strong>：如果容量函数$c$只能取整数值，则$Ford-Fulkerson$方法所生成的最大流$f$满足$|f|$是整数值的性质。而且，对于所有的结点$u$和$v$，$f(u,v)$都是整数。</p><p><strong>推论26.11</strong>：二分图$G$中的一个最大匹配$M$的基数等于其对应的流网络$G’$中某一最大流$f$的值。</p><p>时间复杂度：$O(VE)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;流网络&quot;&gt;&lt;a href=&quot;#流网络&quot; class=&quot;headerlink&quot; title=&quot;流网络&quot;&gt;&lt;/a&gt;流网络&lt;/h1&gt;&lt;h2 id=&quot;流网络-1&quot;&gt;&lt;a href=&quot;#流网络-1&quot; class=&quot;headerlink&quot; title=&quot;流网络&quot;&gt;&lt;/a&gt;流网
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Graph Algorithms" scheme="https://mengzelev.github.io/tags/Graph-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>图论学习笔记-图中的匹配与覆盖</title>
    <link href="https://mengzelev.github.io/2018/11/28/matchings/"/>
    <id>https://mengzelev.github.io/2018/11/28/matchings/</id>
    <published>2018-11-28T06:59:39.000Z</published>
    <updated>2018-12-01T02:14:22.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><h2 id="匹配的定义"><a href="#匹配的定义" class="headerlink" title="匹配的定义"></a>匹配的定义</h2><p><strong>独立</strong>：若图的边集中任意两条边不邻接，则称该集合是独立的</p><p><strong>匹配</strong>：图$G$中的边的一个独立集<br>$G$的<strong>匹配</strong>是一个边的集合$M={e_1,e_2,…,e_k}$，其中$e_i=u_iw_i(1\le i\le k)$，使得$u_1,u_2,…,u_k$是$U$中$k$个不同的顶点，$w_1,w_2,…,w_k$是$W$中$k$个不同的顶点。</p><h2 id="匹配存在的条件"><a href="#匹配存在的条件" class="headerlink" title="匹配存在的条件"></a>匹配存在的条件</h2><p><strong>邻域(neighbourhood)</strong>$N(X)$：设$G$为二部图，其部集为$U$和$W$，且$|U|\le |W|$，对于$U$的非空子集$X$，$X$中所有顶点的邻域的并。</p><p><strong>Hall’s condition/友好的(neighborly)</strong>：对于$U$的任意非空子集$X$，均有$|N(X)|\ge |X|$。</p><p><strong>定理8.3</strong>：设$G$为二部图，其部集为$U$和$W$，且$r=|U|\le |W|$。则$G$包含一个基数为$r$的匹配当且仅当$U$是<strong>友好的</strong>。 </p><p><strong>定理8.4</strong>：非空有限集族$\{S_1,S_2,…,S_n\}$有一个互异代表元系(system of distinct representative) 当且仅当 对于任一整数$k(1\le k\le n)$，集族中任意$k$个集合的并至少包含$k$个元素。</p><p><strong>定理8.5(婚姻定理)</strong>:在一个由$r$个女人和$s$个男人构成的人群中，$1\le r\le s$，在熟识的男女之间可能出现$r$对婚姻当且仅当对每个整数$k(1\le k\le r)$，任意$k$个女人共认识至少$k$个男人。</p><p><strong>最大匹配(maximum matching)</strong>：具有最大基数的匹配</p><p><strong>完美匹配(perfect matching)</strong>：阶为$2k$的图$G$存在一个基数为$k$的匹配$M$，则称该匹配$M$为完美匹配</p><p><strong>定理8.6</strong>：任意$r$正则二部图$(r\ge 1)$均有一个完美匹配。</p><h2 id="边的独立性参数"><a href="#边的独立性参数" class="headerlink" title="边的独立性参数"></a>边的独立性参数</h2><p><strong>边独立数(edge independence number)</strong>$\alpha ‘(G)$：最大边独立集的基数</p><p><strong>覆盖</strong>：一个顶点和与其相连的一条边</p><p><strong>边覆盖数(edge covering number)</strong>$\beta ‘(G)$：$G$中所有边覆盖的最小基数</p><p><strong>最小边覆盖集(minimum edge cover)</strong>：具有最小基数的边覆盖集</p><p><strong>定理8.7</strong>：对于任意不包含孤立点的$n$阶图$G$，<script type="math/tex">\alpha'(G)+\beta'(G)=n</script></p><h2 id="顶点的独立性参数"><a href="#顶点的独立性参数" class="headerlink" title="顶点的独立性参数"></a>顶点的独立性参数</h2><p>如果图中的一个顶点集合中任意两顶点都不邻接，则称该顶点的集合是<strong>独立</strong>的</p><p><strong>点独立数(vertex independence number)</strong>$\alpha(G)$:$G$中点独立集的最大基数，又称<strong>独立数</strong></p><p><strong>最大独立集(maximum independence set)</strong>：图$G$中基数为$\alpha(G)$的独立集</p><p><strong>点覆盖(vertex cover)</strong>：图$G$的某个顶点子集可以覆盖$G$的所有边</p><p><strong>点覆盖数(vertex covering number)</strong>$\beta(G)$：$G$的所有点覆盖的最小基数</p><p><strong>最小点覆盖(minimum vertex cover)</strong>：基数为$\beta(G)$的点覆盖</p><p><strong>定理8.8</strong>:对于任意不包含孤立点的$n$阶图，<script type="math/tex">\alpha(G)+\beta(G)=n</script></p><p><strong>定理8.7</strong>与<strong>定理8.8</strong>合称为<strong>Gallai恒等式</strong></p><p>一般独立集比覆盖集好求</p><h1 id="因子分解"><a href="#因子分解" class="headerlink" title="因子分解"></a>因子分解</h1><h2 id="1因子"><a href="#1因子" class="headerlink" title="1因子"></a>1因子</h2><p><strong>1因子(1-factor)</strong>：图$G$的1正则生成子图。<br>$n$阶图$G$的完美匹配$M$的诱导的子图$F[M]$是$G$的1因子。<br>图$G$有1因子当且仅当$G$有完美匹配。</p><p>连通分支的<strong>奇偶性</strong>就是该连通分支的阶的<strong>奇偶性</strong>。<br>$k_O(G)$表示图$G$的<strong>奇连通分支</strong>的个数。</p><p><strong>定理8.10</strong>：图$G$包含1因子当且仅当对于$V(G)$的任意真子集$S$，$k_O(G-S)\le |S|$。</p><p><strong>定理8.11(Petersen定理)</strong>：所有无割边的3正则图包含1因子。</p><p><strong>定理8.12</strong>：任一至多含有两条割边的3正则图包含1因子。</p><h2 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h2><p><strong>可因子分解的(1-factorable)</strong>：若$G$有1因子$F_1,F_2,…,F_r$，使得$\{E(F_1),E(F_2),…,E(F_r)\}$是$E(G)$的一个划分，此时我们称$G$被<strong>因子分解(factored)</strong>成1因子$F_1,F_2,…,F_r$；这些1因子构成了$G$的<strong>1因子分解(1-factorization)</strong></p><p>任一可1因子分解的图是正则的，反之不真，反例：Peterson图</p><p><strong>定理8.13</strong>：Petersen图是不可1因子分解的。</p><p><strong>定理8.14</strong>：对于任意正整数$k$，完全图$K_{2k}$是可1因子分解的。</p><p><strong>循环因子分解(cyclic factorization)</strong>：如图所示，所有因子分解可以由某一个因子分解旋转一定角度得到</p><p><img src="/2018/11/28/matchings/cyclic.png"></p><p><strong>定理8.15</strong>：任意$r$正则的二部图$(r\ge 1)$是可1因子分解的。</p><h2 id="2因子"><a href="#2因子" class="headerlink" title="2因子"></a>2因子</h2><p><strong>2因子(2-factor)</strong>：图$G$的二正则生成子图</p><p>2因子的任一连通分支是一个圈。</p><p><strong>可2因子分解的(2-factorable)</strong>：定义类似1因子</p><p><strong>定理8.16</strong>：图$G$是可2因子分解的当且仅当存在某个正偶数$r$，是的$G$是$r$正则的。</p><p><strong>*Hamilton因子分解(Hamilton factorization)</strong>：$G$的一个2因子分解，满足该分解中所有2因子均是Hamilton圈</p><p><strong>定理8.17</strong>：对于任一整数$k\ge 1$，完全图$K_{2k+1}$是可Hamilton分解的。<br>证明：构造法（如图）</p><p><img src="/2018/11/28/matchings/K9.png"></p><h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p><strong>因子(factor)</strong>：图$G$不含有孤立点的生成子图</p><p><strong>可因子分解(factorable)</strong>：因子$F_1,F_2,…,F_r$，满足$\{E(F_1),E(F_2),…,E(F_r)\}$是$E(G)$的一个划分。</p><p><strong>可F-因子分解的(F-factorable)</strong>：若存在某个图$F$，是的每个因子$F_i\cong F$</p><h2 id="Kirkman三元系"><a href="#Kirkman三元系" class="headerlink" title="Kirkman三元系"></a>Kirkman三元系</h2><p><strong>n阶的Kirkman三元系(Kirkman triple system)</strong>：有一个基数为$n$的集合$S$，和$S$的三元子集（称为<strong>三元组(triple)</strong>）族$T$，以及$T$的一个划分$\mathcal{P}$构成，且满足如下性质：</p><ol><li>$S$中任意两个不同的元素属于$T$中唯一的三元组</li><li>$S$中任一元素属于划分$\mathcal{P}$的每一元素的唯一的三元组</li></ol><p>存在一个$6k+3$阶Kirkman三元系当且仅当存在一个$K_{6k+3}$的$(2k+1)K_3$因子分解</p><p><strong>定理8.19</strong>：$n(n\ge 3)$阶的Kirkman三元系存在当且仅当$n\equiv 3(mod 6)$，即$n=6k+3$</p><p><strong>定理8.20</strong>：对于每个整数$k\ge 1$，完全图$K_{2k}$可因子分解为$k-1$个Hamilton圈和一个1因子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;匹配&quot;&gt;&lt;a href=&quot;#匹配&quot; class=&quot;headerlink&quot; title=&quot;匹配&quot;&gt;&lt;/a&gt;匹配&lt;/h1&gt;&lt;h2 id=&quot;匹配的定义&quot;&gt;&lt;a href=&quot;#匹配的定义&quot; class=&quot;headerlink&quot; title=&quot;匹配的定义&quot;&gt;&lt;/a&gt;匹配的定
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="Graph Theory" scheme="https://mengzelev.github.io/tags/Graph-Theory/"/>
    
      <category term="Matchings" scheme="https://mengzelev.github.io/tags/Matchings/"/>
    
      <category term="Factorization" scheme="https://mengzelev.github.io/tags/Factorization/"/>
    
  </entry>
  
  <entry>
    <title>Lab3：链接与加载（2）实验报告</title>
    <link href="https://mengzelev.github.io/2018/11/24/lab3-report/"/>
    <id>https://mengzelev.github.io/2018/11/24/lab3-report/</id>
    <published>2018-11-24T09:17:47.000Z</published>
    <updated>2018-11-30T14:18:07.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现描述"><a href="#实现描述" class="headerlink" title="实现描述"></a>实现描述</h1><h2 id="寻找正确的入口地址"><a href="#寻找正确的入口地址" class="headerlink" title="寻找正确的入口地址"></a>寻找正确的入口地址</h2><p>在框架代码抽取出的<code>symtab</code>中主项寻找，如果该项的<code>Type</code>属性为<code>STT_FUNC</code>，就根据其<code>st_name</code>属性去字符串表<code>strtab</code>里寻找该函数的<code>Name</code>属性，并与<code>main</code>进行对比，就能找到<code>main</code>函数对应的表项，此时该表项的<code>st_value</code>属性即 我们需要的入口地址。</p><h2 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h2><p><code>loader()</code>函数的实现需要程序头表，模仿<code>load_elf_table()</code>函数的写法可将程序头表抽取到结构体<code>Elf32_phdr</code>中，找到<code>p_type</code>为<code>PT_LOAD</code>的表项，读取其<code>p_offset</code>，<code>p_vaddr</code>，<code>p_filesz</code>，<code>p_memsz</code>属性，按照讲义的描述，使用<code>fread</code>函数将可执行文件中相对文件偏移<code>p_offset</code>的内容读取<code>p_filedz</code>到内存地址为<code>[p_addr, p_addr + p_filesz</code>的地方，并用<code>memset</code>函数将<code>[p_vaddr + p_filesz, p_vaddr + p_memsiz)</code>对应的物理区间清零。</p><h2 id="打印栈帧链"><a href="#打印栈帧链" class="headerlink" title="打印栈帧链"></a>打印栈帧链</h2><p>第一次打印<code>eip</code>的值作为当前地址，之后每次都取内存中<code>ebp-4</code>的地址存放的返回地址作为函数调用的地址。函数的名字通过去<code>symtab</code>中寻找对应表项并从<code>strtab</code>中提取而得。仿照gdb的<code>bt</code>命令输出打印出来。对<code>ebp</code>的值解引用能得到上一个函数的<code>ebp</code>的值。如此循环直到<code>ebp</code>的信息为0为止。</p><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p>留着以后当笑话看的碎碎念</p><h2 id="寻找正确的入口地址-1"><a href="#寻找正确的入口地址-1" class="headerlink" title="寻找正确的入口地址"></a>寻找正确的入口地址</h2><p>我本来以为这个只要做好RTFSC就不会花太多时间的，<code>man 5 elf</code>之后理所当然地写了如下代码：</p><pre><code>if(symtab[i].st_info == STT_FUNC)</code></pre><p>发现怎么都找不到<code>main</code>，各种调试了一个多小时之后，问了同学才意识到，<code>st_info</code>不是直接的<code>type</code>值，<code>type</code>只占了低四位，高四位为绑定属性<code>bind</code>，把FM继续往下翻可以看到</p><pre><code>ELF32_ST_BIND(info), ELF64_ST_BIND(info)                                                                    Extract a binding from an st_info value. </code></pre><p><s>泪，可以流下来吗</s><br>论耐心RTFM的重要性</p><h2 id="加载程序-1"><a href="#加载程序-1" class="headerlink" title="加载程序"></a>加载程序</h2><p>这部分基本是照抄框架代码抽取<code>El32_Shdr</code>的方法抽取了<code>Elf32_Phdr</code>，让我自己写大概还是写不出来的吧[自卑.jpg]</p><h2 id="打印栈帧连"><a href="#打印栈帧连" class="headerlink" title="打印栈帧连"></a>打印栈帧连</h2><p>先用gdb调试了给的<code>segmentfault.c</code>，摸索了一下<code>bt</code>命令的打印格式，确认了打印的栈帧链中的地址为函数调用时压入栈中的返回地址。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="堆和栈在哪里？"><a href="#堆和栈在哪里？" class="headerlink" title="堆和栈在哪里？"></a>堆和栈在哪里？</h2><p>经过PA3.2的调教，可以知道堆是程序运行时调用<code>malloc</code>动态向高地址申请空间维护的。堆区的开始位置就是数据段的结束位置。当调用<code>malloc</code>函数时，会触发系统调用<code>sbrk</code>查询并调整堆区的结束位置，即program break，以调整堆区的大小。<br>栈区是从内核虚存区开始向低地址方向生长的，栈顶的地址保存在寄存器<code>esp</code>中。通过<code>push</code>和<code>pop</code>等指令来调整栈区大小。<br>堆和栈的内容不放入可执行文件，我猜想一方面因为这些部分是动态生成的，程序执行过程中它们的大小时刻变化着，因此不能放入静态的可执行文件中。另一方面，栈区会有一个随机化操作来防止恶意攻击，不便于放入可读的可执行文件中。</p><h2 id="如何识别不同格式的可执行文件？"><a href="#如何识别不同格式的可执行文件？" class="headerlink" title="如何识别不同格式的可执行文件？"></a>如何识别不同格式的可执行文件？</h2><p>ELF可执行目标文件有ELF头，根据ELF可执行文件的各种规范书写。Windows生成的可执行文件应该也有自己的文件头的格式，在GNU/Linux下执行时，系统按照ELF头的格式解析该文件的文件头出现了错误，例如没有读到“魔数”，就会报告“格式错误”。</p><h2 id="消失的符号"><a href="#消失的符号" class="headerlink" title="消失的符号"></a>消失的符号</h2><p>因为这些符号只在本模块内被使用，其被动态分配在栈中，链接器并不需要这些符号的信息，因此不会出现在符号表中。符号是指参与链接的变量名和函数名。</p><h2 id="寻找”Hello-World-”"><a href="#寻找”Hello-World-”" class="headerlink" title="寻找”Hello World!”"></a>寻找”Hello World!”</h2><p>用上述方法找到<code>hello</code>程序的字符串表，会发现“Hello World!”字符串…它…根本不在字符串表中，而是在<code>.rodata</code>节中。</p><p><img src="/2018/11/24/lab3-report/HelloWorld.png"></p><p>因为<code>printf</code>中的格式化字符串是一个只读的字符串，所以编译时会被放入只读数据节<code>.rodata</code>节中。</p><h2 id="冗余的符号表"><a href="#冗余的符号表" class="headerlink" title="冗余的符号表"></a>冗余的符号表</h2><p>编译单独的hello程序没有问题，但是尝试对hello.o进行链接时就会链接报错（忘了截图了）。因为符号表用于链接中的符号解析，单独运行程序时没有符号表，单有指令就也没有问题。</p><h2 id="冗余的属性？"><a href="#冗余的属性？" class="headerlink" title="冗余的属性？"></a>冗余的属性？</h2><p>起初我猜测是.bss节的数据没有在<code>Filesz</code>中被计算，而是计算在了<code>Memsz</code>中。但是我把.bss节的大小加上<code>Filesz</code>后还是比<code>Memsz</code>小一些，STFW发现stackoverflow上有人问了类似的问题，欣喜地点进去发现并没有人回答….我再思考一下说不定就有stackoverflow首答了…</p><h2 id="为什么要清零？"><a href="#为什么要清零？" class="headerlink" title="为什么要清零？"></a>为什么要清零？</h2><p>数电和问求还没写完，溜了…….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实现描述&quot;&gt;&lt;a href=&quot;#实现描述&quot; class=&quot;headerlink&quot; title=&quot;实现描述&quot;&gt;&lt;/a&gt;实现描述&lt;/h1&gt;&lt;h2 id=&quot;寻找正确的入口地址&quot;&gt;&lt;a href=&quot;#寻找正确的入口地址&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://mengzelev.github.io/tags/Notes/"/>
    
      <category term="Lab" scheme="https://mengzelev.github.io/tags/Lab/"/>
    
      <category term="Ics" scheme="https://mengzelev.github.io/tags/Ics/"/>
    
  </entry>
  
</feed>
