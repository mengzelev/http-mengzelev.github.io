<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengzelev&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mengzelev.github.io/"/>
  <updated>2019-11-03T07:07:09.895Z</updated>
  <id>https://mengzelev.github.io/</id>
  
  <author>
    <name>Mengzelev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>托福首考日记</title>
    <link href="https://mengzelev.github.io/2019/11/03/tofel-1st-exp/"/>
    <id>https://mengzelev.github.io/2019/11/03/tofel-1st-exp/</id>
    <published>2019-11-03T03:38:49.000Z</published>
    <updated>2019-11-03T07:07:09.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="考场情况"><a href="#考场情况" class="headerlink" title="考场情况"></a>考场情况</h1><p>听别人安利选了<strong>南京大学鼓楼校区C考场</strong><br>就在天津路校门口，地铁出去最近的一个小门进去就是计算中心<br>虽然楼在外面看上去挺破的，但是里面还行<br>C考场里面是一人一个小隔间这样子，感觉挺安心的，虽然戴上耳机还是能听到其他人的听力和口语声音，但是音量调到最大我个人感觉就完全没有影响了<br>总体觉得考场还不错</p><h1 id="考试流程"><a href="#考试流程" class="headerlink" title="考试流程"></a>考试流程</h1><h2 id="上路"><a href="#上路" class="headerlink" title="上路"></a>上路</h2><p>六点起床，七点出发<br>从南大仙林校区叫了辆出租车，三个人拼车打了82大洋，还行吧，至少比考场房便宜很多了</p><h2 id="进场"><a href="#进场" class="headerlink" title="进场"></a>进场</h2><p>进场前有个工作人员在发一张纸让你填个人信息，声称是“学校要填的”，但那张单子非常随便，而且ETS已经有我的全部报名信息了，很显然是像把我们的个人信息卖给什么留学机构的，所以我就拒绝了，她也没有纠缠<br>不过被“忽悠”了填的同学真的很多诶，大家对自己个人信息的保护意识也太差了吧www</p><p>八点不到就开始放人进去了，在一楼门口就要把身上的东西掏得只剩<strong>吃的、喝的、身份证</strong>，女孩子的话<strong>卫生巾</strong>也是可以带的，餐巾纸和药（我当天带了止痛药）是不让带的。</p><p>剩下的东西都要装到一个标有序号的大麻袋(x)里面去，大麻袋的钥匙可以（而且必须）带走</p><p>然后就是搜身，要把口袋里东西都掏出来全身金属探测器一下。我穿的衣服上金属饰品太多了让工作人员很无语hhhh姨妈巾拿多了还被勒令最多带一个，求了一下情才能带俩进去（中场休息换一个不是合情合理吗）。工作人员还让我把扎头发的大蝴蝶结摘下来（我觉得也不是很大啊），这也太严格了…..</p><p>搜完身之后就要填一个保密协议单，桌子上有模板，照着填就行了（我一开始还没注意到模板的存在</p><p>填完之后带着单子上三楼。水杯和吃的都要放在一张大桌子上（姨妈巾也要），要上厕所的话赶紧现在去上一个。之后就要去排队等拍照，拍完照就不能碰吃的喝的，也不能上厕所了，直接进考场坐下</p><p>以上就是南大鼓楼考场的进场流程了，我8点10分进的楼，中间出了不少小意外，等拍照的时候前面也正好人有点多，所以是8点40左右才进的考场，索性不影响考试</p><h2 id="开考前"><a href="#开考前" class="headerlink" title="开考前"></a>开考前</h2><p>开考前，考场里的监考老师会说一堆注意事项，我虽然都听了，但是考试时候还是没有全记起来，大概有以下几点：</p><ul><li>草稿纸和两只铅笔用完了要换，但是要保证桌上只有3张草稿纸。草稿纸要两面都用完了才给换</li><li>有事举手的时候举高一点，因为没人一个隔间老师可能会看不见</li><li>中场休息一定要看见倒计时了再出去</li><li>中场休息只有十分钟，女厕所坑位比较少，所以一定要先去上厕所，最好提早一点回来，因为还要拍照什么的</li><li>中场休息倒计时还剩二三十秒的时候就要叫监考老师来输入密码开锁，不然可能会自动生成缺考报告（我就忘了，多亏老师发现orz</li><li>阅读instruction的时间有时候也算在考试时间里面的，基本模考时候都看过了就不要管了(x)</li><li>休息走的时候要把门带上，因为每个人结束上半场的时间不一样</li><li>P.S.在考场里脱衣服的话老师会过来把你的衣服收走，你冷了还得举手要，所以不是特别热就尽量自己忍忍吧(那我怀疑夏天去考觉得空调冷了还要举手问老师要外套)</li></ul><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>老师输完密码解锁后第一项就是阅读</p><p>我这次考试的阅读难度感觉有个别（3道左右）比较难，对应原文读不太懂，也可能是因为上考场有点简单。TPO里的阅读题还是偏简单的。</p><p>还有我最后一大题真的很薄弱orz选的三项里都至少有一项很不确定</p><p>还有考试环境里竟然都不能鼠标选中高亮，不像在网页上模考那样，经常看看题目就忘了自己考到哪了。这阅读考试也太反人类了，更别说高考那套记号系统完全废了。</p><p>我的时间分配大概是19+18+16+1min检查，因为第一篇还没进入状态，比较紧张，读起来很慢。不过可能也是依赖于二三难度比一低一点，不然可能要时间地狱了www</p><p>索性阅读没被加试</p><h2 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h2><p>这次听力总体来说感觉好难，刷TPO我基本能控制到最多2题没印象，但是这次没印象的题比例特别高，感觉是不是出题点出现偏移了，导致我留意的没考到，考到的没留意orz(给自己菜找借口ing)</p><p>我听力被加试了，1对话+1授课，11min</p><p>听力时候由于每个section是紧连着的，我草稿纸写完了，点了下一题下一篇听力直接开始了，结果忘了举手换草稿纸了，唉…最后一题真的是插空式到处搜刮空间记笔记，记得七零八落的，下次一定要记得</p><p>我听到答案的题基本都是秒选，不确定的题最多纠结1分钟，时间还是比较充裕的。大家安排时间的时候最好把找老师换纸的时间算进去呀</p><h2 id="中场休息"><a href="#中场休息" class="headerlink" title="中场休息"></a>中场休息</h2><p>要把身份证带走，一会儿还要拍照<br>女厕果然排队<br>我上个厕所回来喝了两口水吃了点东西再拍照回去，就已经只剩40s了，时间还是有点局促的呀<br>sb如我忘了在计时器还剩几十秒的时候叫老师解锁了，幸好老师发现了</p><h2 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h2><p>本来对这部分就没什么信心…</p><p>Task1独立口语问的是….我忘了orz<br>Task2是想让学生和老师的食堂合并起来。这里有个奇怪的地方是，main speaker第一个理由是赞同的，觉得这样可以腾出空间缓解拥挤，因为老师不怎么吃食堂；第二个理由却说学生会在吃饭时被老师问学习，老师可能也不想和学生聊天，反而有点反对的意思了<br>Task3大概是生态大坝，很常规的题目。可惜我没控制好时间，没说完（自卑<br>Task4也很典型，没什么印象了….</p><p>总的来说感觉自己一旦专注于内容就顾及不了语音语调了，还是缺乏练习，二刷之前要专攻口语了</p><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>综合写作也很常规，关于天然气，阅读说它不好，听力说好，没太大问题</p><p>综合写作这次的题目我佛了<br>考前准备了很多个人与社会方面的常用论点，身体健康、社会平等什么的，结果这次给我来了一个<strong>名人该不该表明自己的政治观点</strong><br>我怎么觉得这个好针对啊，<s>N*A的事情才刚刚过去</s>，好吧其实国外也是这样的<br>透露着出题组满满的恶意……<br>我是写了不应该，一个是会煽动无知群众，一个是会造成表达政治立场蹭热度的风气（这个好难写），不可否认的是对宣传好的主张有帮助。然后，突然想不起来主张怎么说(自裁)<br>时间还是紧，有一段没写完草草收尾了，也没来得及检查拼写(再次自裁)</p><p>写作也是下次来之前要恶补的项目了……</p><h2 id="考完"><a href="#考完" class="headerlink" title="考完"></a>考完</h2><p>我是十二点多出考场的，考试时间缩短还是好（嘿嘿<br>出考场才意识到自己有点饿了，要是跟原来一样考到一点估计要饿瘫了<br>在新街口浪了一整天（其实只有大半天</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之感觉就是<strong>非常严格</strong>，高考都相形见绌，看来天朝还是比老美相信自己人的(雾)<br>考场里不让喝水real难受，思考很消耗水分的啊kora<br>本来有把握的阅读听力没发挥好，口语写作又不出所料的烂，这次就权当体验生活了，上交2k大洋下次再来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;考场情况&quot;&gt;&lt;a href=&quot;#考场情况&quot; class=&quot;headerlink&quot; title=&quot;考场情况&quot;&gt;&lt;/a&gt;考场情况&lt;/h1&gt;&lt;p&gt;听别人安利选了&lt;strong&gt;南京大学鼓楼校区C考场&lt;/strong&gt;&lt;br&gt;就在天津路校门口，地铁出去最近的一个小门进去就
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络-课程笔记</title>
    <link href="https://mengzelev.github.io/2019/10/12/network-notes/"/>
    <id>https://mengzelev.github.io/2019/10/12/network-notes/</id>
    <published>2019-10-12T03:25:20.000Z</published>
    <updated>2019-10-25T03:45:22.820Z</updated>
    
    <content type="html"><![CDATA[<p><u>【工事中】</u></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li>ISP：因特网服务提供商</li><li>协议：定义了两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接受一条报文或其他事件所采取的动作</li><li>主机=端系统</li><li>以太网：以太网交换机-机构路由器-ISP</li><li>WiFi:接入点-企业网-有限因特网</li></ul><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><ul><li>分组交换机：路由器/链路交换机</li><li>存储转发传输：交换机能够开始向输出链路传输该分组的第一个比特钱，必须接收到整个分组<ul><li>时延：$2L/R$，不存储是$L/R$</li><li>通过$N$条速率均为$R$的链路组成的路径，端到端时延$d_{\text{端到端}}=N\frac{L}{R}$</li></ul></li><li>输出缓存/输出队列：链路上进入交换机前分组等待的地方</li><li>排队时延，丢包</li><li>转发表：将目的地址（或一部分）映射为输出链路</li><li>路由选择协议：自动设置转发表</li></ul><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><ul><li>预留资源，按需使用</li><li>频分复用FDM，时分复用TDM</li><li>带宽：频分复用的宽度</li></ul><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><ul><li>处理时延$d_{proc}$：检查分组首部决定讲该分组导向何处所需要的时间<ul><li>也包括检查比特级别的差错需要的时间</li><li>微秒或更低数量级</li></ul></li><li>排队时延$d_{queue}$：在队列中，分组在链路上等待传输的时间<ul><li>取决于先期到达的正在排队等待向链路传输的分组数量</li><li>到达分组期望发现的分组数量是到达该队列的流量的强度和性质的函数</li><li>毫秒到微秒量级</li></ul></li><li>传输时延$d_{trans}$：将所有分组的比特推向链路所需要的时间<ul><li>毫秒到微秒量级</li></ul></li><li>传播时延$d_{prop}$：一个比特从该链路的起点到路由器B的传播所需要的时间<ul><li>不需要等推完了再上路，有一个比特传一个比特</li><li>两台路由器之间的距离/传播速率</li><li>毫秒量级</li></ul></li><li>节点总时延$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$</li><li>时延成分所起的作用可能会有很大不同</li></ul><h2 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h2><ul><li>$a$:分组的到达队列的平均速率(pkt/s)</li><li>流量强度=$La/R$<ul><li>$La/R&gt;1$：到达得比传输得快，队列无限增加，排队时延趋向无穷大</li></ul></li><li>流量强度越大，丢包的比例越大</li><li>假设没有排队时延的端到端时延：$d_{end-to-end}=N(d_{proc}+d_{trans}+d_{prop})$</li></ul><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><ul><li>瓶颈链路</li><li><p>吞吐量取决于数据流过的链路的传输速率</p></li><li><p>吞吐量：每秒能够传送的数据量</p></li></ul><h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>服务模型：向上一层提供的服务<br>协议栈：各层的所有协议、</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul><li>网络应用程序及它们的应用层协议存留的地方</li><li>一个端系统的应用程序与另一个端系统中的应用程序交换信息分组</li><li>HTTP,SMTP,FTP,DNS</li><li>报文(message)</li></ul><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><ul><li>在应用程序端点之间传送应用层报文</li><li>TCP, UDP</li><li>报文段(segment)</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>将数据报从一台主机移动到另一台主机</li><li>数据报(datagram)</li><li>网际协议IP</li></ul><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><ul><li>将分组从一个节点(主机或路由器)移动到路径上的下一个节点</li><li>以太网、WiFi、电缆接入网DOCSIS、PPP</li><li>帧(frame)</li></ul><p>###　物理层</p><ul><li>将帧中的一个个比特从一个节点移动到下一个节点</li><li>协议是链路相关的，并进一步与实际传输媒体相关</li></ul><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>运输层和应用层之间多了表示层和会话层</p><ul><li>表示层：使通信的应用程序能够解释交换数据的含义<ul><li>数据压缩、数据加密、数据描述</li></ul></li><li>会话层：数据交换的定界和同步功能<ul><li>建立检查点和恢复方案</li></ul></li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>链路交换机只实现链路层和物理层</li><li>路由器只实现网络层、链路层和物理层</li><li>路由器能实现IP协议，链路交换机不行</li><li>分组=首部字段+有效载荷字</li></ul><h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><ul><li>恶意软件：进入设备干坏事</li><li>僵尸网络：受害设备网络</li><li>病毒：需要某种形式的用户交互来感染用户设备的恶意软件</li><li>蠕虫：无须任何明显用户交互就能进入设备的恶意软件</li><li>DoS：拒绝服务攻击<ul><li>弱点攻击、带宽洪泛、连接洪泛</li><li>分布式Dos:DDoS</li></ul></li><li>嗅探分组：分组嗅探器（被动接收机</li><li>IP哄骗：将具有虚假源地址的分组注入因特网</li></ul><h1 id="链路层-1"><a href="#链路层-1" class="headerlink" title="链路层"></a>链路层</h1><p>节点：运行链路层协议的任何设备<br>链路：沿着相邻结点的通信信道</p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><ul><li>成帧：把网络层数据报封装成链路层帧</li><li>链路接入：媒体访问控制(MAC)协议</li><li>可靠交付：确认和重传</li><li>差错检测和纠正</li></ul><p>实现：网络适配器（网络接口卡），硬件实现</p><h2 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h2><p>EDC：差错检测和纠正比特</p><p>###　奇偶校验</p><ul><li>二位奇偶校验：可以纠正单比特错，可检测但不能纠正两个比特错</li><li>前向纠错FEC:接收方检测和纠正差错的能力</li></ul><h3 id="Internet-checksum"><a href="#Internet-checksum" class="headerlink" title="Internet checksum"></a>Internet checksum</h3><ul><li>将数据的字节作为16比特的整数对待并求和:进位加法，最高位进位需要加到末尾</li><li>相对弱的差错保护</li></ul><h3 id="循环冗余检测CRC"><a href="#循环冗余检测CRC" class="headerlink" title="循环冗余检测CRC"></a>循环冗余检测CRC</h3><ul><li>又称多项式编码：将发送的比特串看成多项式系数</li></ul><p>$D\cdot 2^r \text{ XOR } R = nG$<br>$D\cdot 2^r=nG \text{ XOR }  R$<br>$R=\text{remainder}\frac{D\cdot 2^r}{G}$</p><p>转自阿姨博客的表示方法：<br>$$\frac{X^{n-k}D(X)}{P(X)}=Q(X)+\frac{R(X)}{P(X)}$$<br>$$T(X)=X^{n-k}D(X)+R(X)$$<br>其中，$X$是二进制串对应的多项式，如$P=11001, P(X)=X^4+X^3+1$<br>接收方用$T/P$，如果不能整除，说明存在差错。</p><ul><li>$P\to G$</li><li><p>位数：$P/G: n-k+1, D:k, T:n-k$</p></li><li><p>可以检测小于$r+1$比特的错($r=|R|$)</p></li></ul><h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><ul><li>点对点链路</li><li>广播链路</li><li>碰撞：多个节点同时传输帧导致所有节点同时接到多个帧</li><li>多路访问协议的特性(p294)<ul><li>当仅有一个节点发送数据时，该节点具有$R$ bps的吞吐量</li><li>当有$M$个节点发送数据时，每个节点的吞吐量为$R/M$ bps</li><li>协议是分散的：不会因为某主节点故障而使整个系统崩溃</li><li>协议是简单的，使实现不昂贵</li></ul></li></ul><h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><ul><li>TDM：将时间划分为时间帧，并进一步划分每个时间帧喂$N$个时隙(slot)</li><li>FDM：将$R$ bps信号划分为不同的频段，并把每个频率分给$N$个节点中的一个</li><li>CDMA(码分多址)：对每个节点分配一种不同的编码，不同的节点能够同时传输，并且各自接收方能正确接收</li></ul><h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><ul><li>传输节点总是以信道的全部速率进行发送</li><li>当有碰撞时，涉及碰撞的每个节点反复地重发它的帧</li><li>重发之前等待一个随机时延</li></ul><h4 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h4><ul><li>所有节点要同步传输</li><li>如果有碰撞，该节点以概率$p$在后续的每个时隙中重传它的帧，直到无碰撞地传出去</li><li>时隙多路访问协议的效率：当有大量的活跃节点且每个节点总有大量的帧要发送时，长期运行中成功时隙的份额</li><li>效率：$Np(1-p)^{N-1}$, 最大$1/e$</li></ul><h4 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h4><ul><li>一个给定节点成功传输一次的概率是$p(1-p)^{2(N-1)}$<ul><li>在$[t_0-1,t_0]$和$[t_0, t_0+1]$时间段内都不可以有别的节点传输</li></ul></li><li>最大效率$1/2e$</li></ul><h4 id="CSMA-载波侦听多路访问"><a href="#CSMA-载波侦听多路访问" class="headerlink" title="CSMA(载波侦听多路访问)"></a>CSMA(载波侦听多路访问)</h4><ul><li>载波侦听：说话之前先听，如果其他人正在说话，等到他们说完为止</li><li>碰撞检测：如果与他人同时开始说话，停止说话</li><li>广播信道的端到端信道传播时延在决定性能方面起到关键作用<ul><li>越大，XSMA节点不能侦听到另一个节点已经开始传输的机会越大</li></ul></li></ul><h4 id="CSMA-CD-具有碰撞检测的载波侦听多路访问"><a href="#CSMA-CD-具有碰撞检测的载波侦听多路访问" class="headerlink" title="CSMA/CD(具有碰撞检测的载波侦听多路访问)"></a>CSMA/CD(具有碰撞检测的载波侦听多路访问)</h4><ul><li>如果适配器在传输时检测到来自其他适配器的信号能量，就中止传输，并随机等待一个随机时间量再次传输</li><li>期望：碰撞节点数较少时，时间间隔较短；反之亦然<ul><li>二进制指数后退算法：经历了一连串的$n$次碰撞后，节点随机地从${0,1,2,\cdots,2^n-1}$中选择一个$K$值，$n$最大为10</li></ul></li><li>不考虑近期过去时间内可能已经发生的任何碰撞</li><li>效率$= n\frac{1}{1+5d_{prop}/d_{trans}}$</li></ul><h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><h4 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h4><ul><li>主节点轮询告诉每个节点能够传输的帧的最多数量</li><li>缺点：引入了轮询时延、主节点坏了就全坏了</li></ul><h4 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h4><ul><li>一个称为令牌(token)的小的特殊帧在节点之间以某种固定的次序进行交换</li><li>一个节点收到令牌时，仅当它有一些帧要传输，它才持有这个令牌，否则立即向下一个节点转发该令牌</li><li>有帧要传输时，发送最大数目的帧数，然后把令牌转发给下一个节点</li><li>缺点：一个节点坏了就全坏了，一个节点忘了释放令牌</li></ul><h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><ul><li>链路层地址</li><li>6个字节，$2^48$个可能，每个字节表示为一堆十六进制数</li><li>没有两块适配器具有相同的地址–IEEE管理</li></ul><p>###　地址解析协议ARP</p><ul><li>ARP表：包含IP地址到MAC地址的映射关系</li><li>TTL寿命值：表示从表中删除每个映射的时间</li><li>ARP分组：包含发送和接受IP地址及MAC地址<ul><li>查询分组：询问子网上所有其他主机和路由器，以确定对应于要解析的IP地址的那个MAC地址</li><li>响应分组</li><li>查询分组和响应分组格式相同</li><li>查询 ARP在广播帧中发送，响应ARP在标准帧中发送</li></ul></li><li>ARP即插即用，不需要手动配置</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul><li>发送方向其适配器发送一个ARP查询分组</li><li>适配器在链路层帧中封装这个ARP分组，并讲该帧传输进子网中</li><li>（广播地址）每个适配器把在该帧中的ARP分组向上传递给ARP模块，每个ARP模块检查它的IP地址是否与ARP分组中的目的IP地址相匹配，与之相匹配的一个给查询主机发送回一个带有所希望映射的响应ARP分组</li><li>查询主机更新ARP表，并发送IP数据报</li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li>集线器(hub)：物理层设备，作用于比特，放大收到的比特的能量强度并向其他所有借口传输出去</li><li>广播局域网：无论何时集线器从它的一个接口接收到一个比特，它向所有其他接口发送该比特的副本</li><li>碰撞：某集线器同时从两个不同的接口接收到帧，将出现一次碰撞，生成该帧的节点必须重新传输该帧</li><li>交换机(switch)代替hub</li></ul><h4 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前同步码|目的地址|源地址|类型|数据|CRC</span><br></pre></td></tr></table></figure><ul><li>数据字段：承载IP数据报，最小长度46字节，最大长度1500字节</li><li>目的地址：目的适配器的MAC地址。是自己的地址/广播地址就丢给网络层，否则直接丢弃</li><li>源地址：顾名思义</li><li>类型字段：允许以太网复用多种网络层协议</li><li>CRC</li><li>前同步码<ul><li>前7字节都是10101010，最后一个字节为10101011</li><li>发送方的额定速率会产生漂移，所以前7字节用来同步接收方的时钟</li><li>最后两个字节用于警告接收方重要的东西要 来 了</li></ul></li></ul><p>以太网技术向网络层提供的服务：</p><ul><li>无连接：没有事先握手</li><li>不可靠：接收方不发送确认帧和否定确认帧，只丢弃没通过校验的帧</li></ul><h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><p>交换机的任务：接收入链路层帧并将它们转发到出链路<br>交换机对于子网中的主机和路由器是透明的<br>交换机输出接口设有缓存</p><h4 id="交换机表"><a href="#交换机表" class="headerlink" title="交换机表"></a>交换机表</h4><p>转发和过滤借助于交换机表实现<br>过滤：决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能<br>转发：决定一个帧应该被导向哪个接口，并把该帧移动到哪些接口</p><p>一个表项包括：</p><ul><li>一个MAC地址</li><li>通向该MAC地址的交换机接口</li><li>表项放置在表中的时间</li></ul><p>工作过程</p><ul><li>对于没有目的地址的表项，交换机广播该帧</li><li>存在到达接口与目标地址相联系的表项，丢弃该帧（过滤）</li><li>存在非到达接口与目标地址相联系的表项，交换机将帧放到目标接口的输出缓存完成转发功能</li></ul><h4 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h4><ul><li>交换机表初始为空</li><li>对于每个接口接收到的每个入帧，该交换机在其表中存储</li><li>在一段时间(老化时间)后交换机没有接受到以该地址作为源地址的帧，就在表中删除这个帧</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>即插即用</li><li>消除碰撞<ul><li>绝不会在网段上同时传输多于一个帧</li><li>最大聚合带宽：该交换机所有接口速率之和（交换机间的接口不算</li></ul></li><li>异质链路<ul><li>能够以不同速率运行并且能够在不同的介质上运行</li></ul></li><li>便于管理</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>活跃拓扑限制为一棵生成树</li><li>对于广播风暴不提供保护措施</li></ul><h1 id="CH7-无线网络和移动网络"><a href="#CH7-无线网络和移动网络" class="headerlink" title="CH7 无线网络和移动网络"></a>CH7 无线网络和移动网络</h1><p>无线$\neq$移动</p><ul><li>无线主机：到处都是</li><li>无线链路：主机通过无线通信链路连接到一个基站或者另一台无线主机；<ul><li>覆盖区域和链路速率</li></ul></li><li>基站：负责向与之关联的无线主机发送数据和从主机那里接收数据，协调与之相关联的多个无线主机的传输；e.g.蜂窝网络中的蜂窝塔、无限LAN中的接入点AP</li><li>基础设施模式</li></ul><h2 id="无线链路和网络特征"><a href="#无线链路和网络特征" class="headerlink" title="无线链路和网络特征"></a>无线链路和网络特征</h2><p>有线和无线网络的主要区别在链路层，网络层及以上都是相同的</p><ul><li>递减的信号强度：距离$\uparrow$,信号强度$\downarrow$</li><li>来自其他源的干扰</li><li>多径传播：使得接收方收到的信号变得模糊</li></ul><p>信噪比(SNR)</p><ul><li>单位分贝(dB)</li><li>收到的信号的振幅与噪声的振幅的以10为敌的对数的比值</li><li>较大的SNR是接收方更容易从背景噪声中提取传输的信号</li><li>对于给定的调制方案，SNR越高，BER(比特差错)越低</li></ul><h2 id="CDMA"><a href="#CDMA" class="headerlink" title="CDMA"></a>CDMA</h2><ul><li>码分多址信道划分协议</li><li>要发送的每个比特都通过乘以一个信号(编码)的比特来进行编码，这个信号的变化速率(码片速率)比初始数据比特序列的变化速率快很多</li><li>CDMA工作假设：干扰的传输比特信号是加性的</li><li>划分编码空间</li></ul><h2 id="WiFi-802-11无线LAN"><a href="#WiFi-802-11无线LAN" class="headerlink" title="WiFi: 802.11无线LAN"></a>WiFi: 802.11无线LAN</h2><p>基本服务集(BSS): 802.11体系结构的基本构建模块，包含一个或多个无线站点和一个称为AP的中央基站<br>每个无线站点具有一个6字节的MAC地址</p><h3 id="信道与关联"><a href="#信道与关联" class="headerlink" title="信道与关联"></a>信道与关联</h3><p>网络管理员安装AP时</p><ul><li>为AP分配一个单字或双字的服务及标识符(SSID)</li><li>分配一个信道号</li></ul><p>WiFi丛林：任意一个物理位置，在这里无线站点能从两个或多个AP中收到很强的信号<br>关联：无线站点在自身和AO之间创建一个虚拟线路</p><ul><li>被动扫描<ul><li>每个AP周期性地发送信标帧</li><li>每个信标帧包括该AP的SSID和MAC地址</li><li>无线站点扫描11个信道，找出可能位于该区域的AP所发出的信标帧</li></ul></li><li>主动扫描<ul><li>无线主机向位于其范围内的所有AP广播探测帧</li><li>选定与之关联的AP后，无线主机向AP发送一个关联请求帧，并且该AP以一个关联响应帧进行响应</li><li>需要二次请求/响应握手</li><li>主机通常将通过关联的AP向该子网发送一个DHCP发现报文，以获取在该子网中的一个IP地址</li></ul></li></ul><p>用户名和口令</p><ul><li>AP与一个鉴别服务器进行通信</li><li>一个鉴别服务器可以服务于多个AP</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;【工事中】&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ISP：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数字图像处理课程笔记</title>
    <link href="https://mengzelev.github.io/2019/10/11/dip-notes/"/>
    <id>https://mengzelev.github.io/2019/10/11/dip-notes/</id>
    <published>2019-10-11T12:31:15.000Z</published>
    <updated>2019-10-26T05:43:36.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="空间域图像增强"><a href="#空间域图像增强" class="headerlink" title="空间域图像增强"></a>空间域图像增强</h1><h2 id="像素间的基本关系"><a href="#像素间的基本关系" class="headerlink" title="像素间的基本关系"></a>像素间的基本关系</h2><h3 id="相邻像素"><a href="#相邻像素" class="headerlink" title="相邻像素"></a>相邻像素</h3><ul><li>4邻域$N_4(p)$：送葬人攻击范围<ul><li>边界像素点可能没有4个</li></ul></li><li>4对角邻域$N_D(p)$：没有这样的攻击范围</li><li>8邻域$N_8(p)=N_4(p)+N_D(p)$：空精0攻击范围</li></ul><h3 id="邻接性"><a href="#邻接性" class="headerlink" title="邻接性"></a>邻接性</h3><p>$V$是用于定义邻接性的灰度值集合，把灰度级划分成2个等价类（把灰度图像渲染成二值图像）</p><ul><li>4邻接：$q\in N_4(p)\wedge val(p),val(q)\in V$</li><li>8邻接：$q\in N_8(p)\wedge val(p),val(q)\in V$</li><li>$m$邻接(混合邻接)：$ val(p),val(q)\in V$<ul><li>$q\in N_4(p)$</li><li>$q\in N_D(p)$ and the set $N_4(p)\cap N_4(q)$ has no pixels whose values are from $V$ </li></ul></li></ul><h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><p>  通路：从像素点$p(x,y)$到像素点$q(s,t)$的路，相邻像素点是邻接的</p><ul><li>长度：通路上包括头尾像素点的个数-1</li><li>闭合通路</li><li>4通路，8通路，$m$通路</li></ul><h3 id="连通集"><a href="#连通集" class="headerlink" title="连通集"></a>连通集</h3><ul><li>连通分量：对于$S$中任何像素$p$，$S$中连通到该像素的像素集叫做$S$的连通分量</li><li>如果$S$仅有一个连通分量，则集合$S$叫做连通集</li></ul><h3 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h3><ul><li>区域：图像中是连通集的像素子集</li><li>邻接区域：两个区域的联合形成一个连通集</li><li>前景：$K$个不邻接域的并集</li><li>背景：前景的补集 </li></ul><h1 id="频率域图像处理"><a href="#频率域图像处理" class="headerlink" title="频率域图像处理"></a>频率域图像处理</h1><h2 id="连续傅里叶变换"><a href="#连续傅里叶变换" class="headerlink" title="连续傅里叶变换"></a>连续傅里叶变换</h2><ul><li>傅里叶变换$$F(\mu)=\int_{-\infty}^{\infty}f(t)e^{-j2\pi\mu t}dt$$</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;空间域图像增强&quot;&gt;&lt;a href=&quot;#空间域图像增强&quot; class=&quot;headerlink&quot; title=&quot;空间域图像增强&quot;&gt;&lt;/a&gt;空间域图像增强&lt;/h1&gt;&lt;h2 id=&quot;像素间的基本关系&quot;&gt;&lt;a href=&quot;#像素间的基本关系&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库学习笔记</title>
    <link href="https://mengzelev.github.io/2019/10/09/database/"/>
    <id>https://mengzelev.github.io/2019/10/09/database/</id>
    <published>2019-10-09T11:41:22.000Z</published>
    <updated>2019-11-03T03:38:07.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h1><h2 id="名词术语"><a href="#名词术语" class="headerlink" title="名词术语"></a>名词术语</h2><ul><li>关系–表</li><li>属性–列</li><li>元组–行</li><li>模式(schema)–表头（有名字的列的集合）</li></ul><h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><ul><li>表框架由$n$个命名的属性组成，$n$称为表的元数</li><li>每个属性有一个取值范围，称为值域</li><li>一个表框架可存放$m$个元组，$m$称为表的基数</li></ul><h2 id="二维表必备性质"><a href="#二维表必备性质" class="headerlink" title="二维表必备性质"></a>二维表必备性质</h2><p>略</p><ul><li>关系和关系模型</li></ul><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>关系名、属性名、关系框架</p><h2 id="键Key"><a href="#键Key" class="headerlink" title="键Key"></a>键Key</h2><p>在二维表中能唯一最小标识元组的属性集<br>要根据语义来判断</p><ul><li>候选键</li><li>主键</li><li>超键：包含了键的集合</li><li>外键：如果表A中的属性集F是表B的键，则称该属性集F是表A的外键。<ul><li>表A是引用表，表B是被引用表。</li><li>表A和表B可以是同一张二维表</li></ul></li></ul><h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><ul><li>多张表的数据查询可以先合并为一张表</li></ul><h3 id="基本操作方式"><a href="#基本操作方式" class="headerlink" title="基本操作方式"></a>基本操作方式</h3><ul><li>两个关系的合并</li><li>元组选择</li><li>属性指定</li><li>数据删除（元组）</li><li>数据插入（元组）</li><li>数据修改</li></ul><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><ul><li>主键中不允许出现空值</li><li>需要定义有关空值的运算<ul><li>算术表达式：有空值则结果为空</li><li>逻辑表达式：有空值则结果为假</li><li>计算SUM，AVG，MAX，MIN，COUNT时空值不统计在内</li></ul></li></ul><h2 id="关系操作的表示"><a href="#关系操作的表示" class="headerlink" title="关系操作的表示"></a>关系操作的表示</h2><h3 id="相容表"><a href="#相容表" class="headerlink" title="相容表"></a>相容表</h3><p>有相同表头的表是相容表</p><h3 id="并运算"><a href="#并运算" class="headerlink" title="并运算"></a>并运算</h3><p>两张表行拼起来</p><h3 id="差运算"><a href="#差运算" class="headerlink" title="差运算"></a>差运算</h3><p>去掉一些行</p><h3 id="投影运算"><a href="#投影运算" class="headerlink" title="投影运算"></a>投影运算</h3><ul><li>略去关系中的某些列并重新安排剩余列的排列次序</li><li>$\pi_{B_1,B_2,…, B_m}(R)$</li><li>运算结果还是关系</li><li>注意消除结果中可能出现的重复元组</li><li>不满足交换律</li></ul><h3 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h3><ul><li>$\sigma_F(R)$</li><li>根据给定条件$F$从关系$R$中选出符合条件的元组</li><li>条件：逻辑表达式</li><li><strong>先选择再投影</strong> ，颠倒后的表达式不一定合法</li><li>$\pi_A\sigma_F(R)$默认运算顺序：从右向左</li><li>满足交换律</li></ul><h3 id="笛卡尔乘积"><a href="#笛卡尔乘积" class="headerlink" title="笛卡尔乘积"></a>笛卡尔乘积</h3><ul><li>如果存在相同属性名，必须对其中至少一个进行换名</li></ul><h3 id="交运算"><a href="#交运算" class="headerlink" title="交运算"></a>交运算</h3><ul><li>同类关系</li><li>关系模式不变，由所有既属于关系$R$也属于关系$S$的元组所组成的集合</li></ul><h3 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h3><ul><li>$T=R\div S$: $Head(T)=Head(R)-Head(S)$</li><li>能取遍关系$S$中所有值的$R$中的元组组成的集合（见例子）</li><li>$T\times S\subseteq R$</li></ul><h3 id="联接-join-运算"><a href="#联接-join-运算" class="headerlink" title="联接(join)运算"></a>联接(join)运算</h3><ul><li>$R\underset{F}{\Join}S$: 将关系$R$和关系$S$根据联接条件$F$合并为一个关系</li><li>结果中同名属性需要换名</li><li>自然联接：根据同名属性进行等值联接，同名属性只保留一份</li><li>外联接：允许外的<strong>另一边</strong>的有null</li></ul><h1 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h1><h2 id="关系演算系统"><a href="#关系演算系统" class="headerlink" title="关系演算系统"></a>关系演算系统</h2><ul><li>元组关系演算：公式中每个变元的取值都是一个元组，称为元组变量<ul><li>$n$元关系$R$可用一个谓词$R(t)$表示，$t$是元组变量，$t(i)$表示关系$R$中的第$i$个属性</li></ul></li><li>域关系演算：每个变元的取值是单个的属性值，称为域变量<ul><li>$n$元关系$R$用$n$元谓词$R(x_1,x_2,\cdots x_n)$表示</li></ul></li></ul><h2 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h2><ul><li>元组关系演算：$R={t\mid P(t)}$, 可简写为$P(t)$</li><li>域关系演算：$R={&lt;x_1,x_2,…,x_n&gt;\mid P(x_1,x_2,…,x_n) }$</li></ul><h2 id="关系操作的表示-1"><a href="#关系操作的表示-1" class="headerlink" title="关系操作的表示"></a>关系操作的表示</h2><ul><li>$R\cup S={t\mid R(t)\vee S(t) }$</li><li>$R\setminus S={t\mid R(t)\wedge \neg S(t) }$</li><li>$\sigma_F(R)={t\mid R(t)\wedge F }$</li><li>$\pi_{…} $</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关系代数&quot;&gt;&lt;a href=&quot;#关系代数&quot; class=&quot;headerlink&quot; title=&quot;关系代数&quot;&gt;&lt;/a&gt;关系代数&lt;/h1&gt;&lt;h2 id=&quot;名词术语&quot;&gt;&lt;a href=&quot;#名词术语&quot; class=&quot;headerlink&quot; title=&quot;名词术语&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>论文阅读笔记</title>
    <link href="https://mengzelev.github.io/2019/07/20/paper-reading/"/>
    <id>https://mengzelev.github.io/2019/07/20/paper-reading/</id>
    <published>2019-07-20T08:55:11.000Z</published>
    <updated>2019-08-28T08:36:59.453Z</updated>
    
    <content type="html"><![CDATA[<p>阅读一些论文的收获整理，全是私货(雾)</p><h1 id="A-Large-Scale-Empirical-Study-of-Compile-Errors-in-Continuous-Integration"><a href="#A-Large-Scale-Empirical-Study-of-Compile-Errors-in-Continuous-Integration" class="headerlink" title="A Large-Scale Empirical Study of Compile Errors in Continuous Integration"></a>A Large-Scale Empirical Study of Compile Errors in Continuous Integration</h1><p>这篇论文通过整理并筛选了github上的使用了一个名叫Travis CI的java项目，统计CI历史中出现的CE与各项因素的关系<br>主要遵循了采集数据-分析数据-发现联系-提出解释-给出建议的思路<br>整个项目的build分为多个过程，build的状态有success, error, fail, canceled和started等，maven和gradle的error和fail分别出现在不同的步骤<br>最后对developer,tool,researcher各自提出了自己的建议</p><h2 id="频率分析"><a href="#频率分析" class="headerlink" title="频率分析"></a>频率分析</h2><p>分析了CE频率与项目性质、分支、代码类型(production code or test code)、build state、trgerring events之间的关系</p><h2 id="分布分析"><a href="#分布分析" class="headerlink" title="分布分析"></a>分布分析</h2><p>作者使用了正则表达式匹配统计各种错误类型，并与google的结果进行了比较<br>因素作用关系基本同上</p><h2 id="fix-effort分析"><a href="#fix-effort分析" class="headerlink" title="fix effort分析"></a>fix effort分析</h2><p>通过分析CE出现到消失的时间来衡量fix某个CE所耗费的effort</p><ul><li>排除掉了多错误CE，因为研究难度过大</li><li>排除掉了超过12个小时的fix，因为这可能跟程序员的个人生活安排有关<br>设计到代码架构实现CE比个别地方写错的CE需要更多的时间fix<br>google的平均fix时长短一些，可能是因为google对fix时间有要求，而且还有数据集的区别</li></ul><h2 id="fix-pattern分析"><a href="#fix-pattern分析" class="headerlink" title="fix pattern分析"></a>fix pattern分析</h2><p>人工分析</p><h1 id="Programmers’-Build-Errors-A-Case-Study-at-Google"><a href="#Programmers’-Build-Errors-A-Case-Study-at-Google" class="headerlink" title="Programmers’ Build Errors: A Case Study(at Google)"></a>Programmers’ Build Errors: A Case Study(at Google)</h1><p>这篇论文研究了3个问题：</p><ol><li>编译错误的频率</li><li>编译错误的原因</li><li>修复错误编译的时间</li></ol><p>方法：一个parser，可以将报错分类</p><h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p>数据来源是build的log file<br>计算了以下维度的数据：</p><ul><li>编译次数</li><li>编译失败率：失败次数/总编译次数</li><li>编译错误类型<ul><li>count-all:一次编译中出现的多个同类错误算多个</li><li>count-distinct:….算一个</li><li>但是错误出现的次数权重是不对等的(比如漏写一个声明会报一堆符号错误)，所以采用count-distinct比较合理</li></ul></li><li>解决时间：第一次build fail结束到第一次build success开始之间的时间，同时记录了这期间build fail的次数<ul><li>只考虑单错误的fail building</li><li>只考虑在12个小时内解决的错误</li></ul></li></ul><h2 id="RQ1：错误频率"><a href="#RQ1：错误频率" class="headerlink" title="RQ1：错误频率"></a>RQ1：错误频率</h2><p>把开发者按照经验分类进行了数据分析<br>但是对经验程度的定义可能不够准确</p><h2 id="RQ2：错误原因"><a href="#RQ2：错误原因" class="headerlink" title="RQ2：错误原因"></a>RQ2：错误原因</h2><p>把各种编译错误分成了5个大类：Dependency, Type mismatch, Syntax, Semantic, Other<br>对于C++和Java来说，Dependency-related error都是最常见的错误类型</p><h2 id="RQ3：修复时间"><a href="#RQ3：修复时间" class="headerlink" title="RQ3：修复时间"></a>RQ3：修复时间</h2><p>把研究对象限定为单一类型的错误信息，排除多错误修复时间带来的误差</p><p>进一步分析，还进行了case study<br>首先随机选择了25个Java的cant.resolve类型的编译错误，这些错误都是在下一次build的时候就修复了的，对比了修复前后的文件来观察错误是如何被修复的，并将结果记入表格</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阅读一些论文的收获整理，全是私货(雾)&lt;/p&gt;
&lt;h1 id=&quot;A-Large-Scale-Empirical-Study-of-Compile-Errors-in-Continuous-Integration&quot;&gt;&lt;a href=&quot;#A-Large-Scale-Empiri
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows-Ubuntu双系统重装笔记</title>
    <link href="https://mengzelev.github.io/2019/07/08/system-rebuild-notes/"/>
    <id>https://mengzelev.github.io/2019/07/08/system-rebuild-notes/</id>
    <published>2019-07-08T05:49:57.000Z</published>
    <updated>2019-07-08T07:04:40.002Z</updated>
    
    <content type="html"><![CDATA[<p>之前Linux只给了20个G过于局促，Windows企图装WSL又出现了各种各样的问题，于是就脑子一发热把两个系统备份以后都重装了。期间查了很多教程，就统一汇总在这里了。</p><h1 id="Windows重装"><a href="#Windows重装" class="headerlink" title="Windows重装"></a>Windows重装</h1><ul><li>原来装的是win10家庭版，很多功能被阉割掉了，就决定重装学校买的win10教育版，几种版本的nb程度大概是教育版≈企业版&gt;专业版&gt;家庭版</li><li>如果是同一个版本内的重装，只需要到设置里找”重装windows”就可以了，甚至可以保留个人文件</li><li>下载windows的iso文件到U盘里(U盘不需要格式化)，解压，启动盘就做好了。因为现在的笔记本电脑基本都装有UEFI，可以自己选择启动方式，所以不需要再格式化做引导盘。</li><li>把原先C盘里的重要文件备份一下l电脑品牌的官网上去查找进入方式)，选择装了windows安装程序的U盘进入</li><li>接下来按照指示一步步做就可以了，需要注意的是如果是要重装系统，要选择“自定义安装”，然后选一个位置作为C盘安装windows</li><li>等20分钟左右系统就装好辣</li><li>进入windows后如果发现连不上wifi了/没有声音了，应该是相关驱动在格式化的时候被删掉了，只需要到电脑厂商的官网上下载对应型号的驱动程序就可以了</li><li>ps既然重装了windows，国产流氓软件例如3*0，驱动*灵就不要装了，我之前年少无知装了3*0卸载了几次都把自己给装回来了</li></ul><h1 id="Ubuntu重装与配置"><a href="#Ubuntu重装与配置" class="headerlink" title="Ubuntu重装与配置"></a>Ubuntu重装与配置</h1><p>因为打算以后常驻Ubuntu了，而且可以个性化的内容也比较多，所以这边要配置的东西会相对多一些</p><h2 id="重装"><a href="#重装" class="headerlink" title="重装"></a>重装</h2><p>首先要在磁盘上准备好一定的空间，Ubuntu比较小，往死里压的话20G都能装得下，但是后期使用会经常出现磁盘空间不足的问题（不要问我怎么知道的），所以这次我给了70G（磁盘总大小256G）<br>到windows的“磁盘格式化与压缩”（我忘了是不是叫这个了，欢迎纠正）中选择一个可以压缩的磁盘，右击“压缩卷”，选择需要压缩的大小。如果需要压缩的空间比可压缩空间小还是失败的话应该是当前磁盘的碎片太多，建议备份以后格式化一下。<br><strong>注意</strong>： 双系统重装选手一定要先装Windows再装Ubuntu，不然windows的引导会覆盖掉Ubuntu的引导，产生不必要的麻烦</p><p>然后就只需要重启进入UEFI像重装windows一样操作即可<br>从windows重启可能会出现进不了UEFI的情况，可能是windows快速启动优化导致的，解决方法是重启时按住shift键，会出现蓝色的屏幕，选择高级选项-&gt;进入UEFI</p><p>Ubuntu的安装程序也比较亲民，基本按照指示做点Continue就可以，唯一的稍微有困难的地方是磁盘分区那里，我只提供一下我的分区方案做参考，不保证一定是最好的：</p><ul><li>biosgrub：200M,用于放置引导</li><li>swap：交换分区，我也不清楚这个是做什么的，看到网上不少地方说和内存差不多大就可以了，我的内存是8G，所以我给了10G</li><li>剩下的空间全都给根目录”/“，挂载方式选择ext4文件系统，挂载点选择”/“</li></ul><p>20分钟不到你就可以看到船新的Ubuntu了</p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>拿到新系统第一件事是把基本的软件都装了<br>Linux系统装软件都很方便，直接<code>sudo apt install [软件名]</code>就可以了<br>一般必备的软件有：git, gcc, g++等，其他可以等用到了的时候再装，反正很方便</p><h3 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h3><p>在Ubuntu菜单里面找到”Software &amp; Updates”<br>“Download from”下拉条里面选择”Other…”, 国家找到China，然后选择你要换的网址，我用的是阿里云的镜像<br>确定并关闭之后应该会有更新提示，等就可以了</p><h3 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h3><p>由于我装的是英文系统，上百度搜教程非常不方便，所以第一件事是把中文输入法给装好<br>Ubuntu自带的中文输入法iBus非常反人类，所以建议自己装中文输入法，我装的是搜狗拼音输入法for Linux</p><p><a href="https://blog.csdn.net/fx_yzjy101/article/details/80243710" target="_blank" rel="noopener">解决Ubuntu 18.04中文输入法的问题，安装搜狗拼音</a></p><h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><p>Ubuntu自带的是Firefox浏览器，相比于IE来说也很好用了，但是舍不得chrome的同步功能所以还是决定用chrome</p><p>百度搜索chrome官网，下载.deb文件，完成后直接打开，Ubuntu的软件商店会跳出来，再点Install就可以了</p><h3 id="小飞机"><a href="#小飞机" class="headerlink" title="小飞机"></a>小飞机</h3><p>要想登录google账号肯定需要科学上网</p><p><a href="https://www.cnblogs.com/luzeming/p/10591624.html" target="_blank" rel="noopener">ubuntu配置小飞机</a></p><p>值得补充的是，如果从github上下载的SwitchyOmega的crx文件拖进chrome显示<code>INVALID_CRX_HEADER</code>，就把crx文件后缀直接改成zip，然后解压该zip文件，在chrome插件管理界面中打开开发者模式-&gt;导入(Load Unpacked)，选择一个名叫”SwitchyOmega_xxx”(xxx为版本号)的文件夹即可</p><h3 id="QQ-or-TIM"><a href="#QQ-or-TIM" class="headerlink" title="QQ or TIM"></a>QQ or TIM</h3><p><a href="https://github.com/wszqkzqk/deepin-wine-ubuntu" target="_blank" rel="noopener">wszqkzqk/deepin-wine-ubuntu</a></p><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>用惯了windows的人表示想要一个好康的GUI环境，Ubuntu原生的有点太死板了</p><p>美化桌面环境需要先下载<code>gnome-tweak-tools</code>，不要问，问就是apt</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>到<a href="https://www.opendesktop.org/s/Gnome" target="_blank" rel="noopener">gnome-look.org</a>上找喜欢的主题和icon主题就可以了<br>我装的是排名最高的<a href="https://www.opendesktop.org/s/Gnome/p/1013030/" target="_blank" rel="noopener">Flat Remix GNOME/Ubuntu/GDM theme</a><br>安装方法里面都有写<br>装完以后在菜单里面找Tweaks，在里面改Applications，icons等设置就可以了</p><h3 id="gnome插件"><a href="#gnome插件" class="headerlink" title="gnome插件"></a>gnome插件</h3><p>这次装机突然了解到一个很骚的直接在浏览器里管理gnome的插件的工具<br><a href="http://www.linux-ren.org/portal.php?mod=view&amp;aid=2473" target="_blank" rel="noopener">如何手动或通过浏览器轻松安装 GNOME Shell 扩展？</a></p><p>我装的插件有</p><ul><li>dash to dock(可以把任务栏一样的条拿到下面，还可以设置自动隐藏)</li><li>Hide top bar(设置上面那条东西自动隐藏)</li><li>User themes(让shell可以使用主题同样的风格)</li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Ubuntu本来的字体就还可以，不过我还是最喜欢苹果的monaco</p><p><a href="https://blog.csdn.net/qq_26990831/article/details/51847416" target="_blank" rel="noopener">ubuntu16.04安装monaco字体</a></p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>Ubuntu默认的终端是bash，但是zsh比bash好看，而且插件也很丰富，所以我把默认终端换成zsh了</p><p><a href="https://www.cnblogs.com/EasonJim/p/7863099.html" target="_blank" rel="noopener">Ubuntu 16.04下安装zsh和oh-my-zsh</a></p><p>主题我用的是powerlevel9k<br>值得提醒的是，改.zshrc之前一定要记得备份，我就把自己的zsh玩坏过还回不去orz</p><h3 id="vim和tmux"><a href="#vim和tmux" class="headerlink" title="vim和tmux"></a>vim和tmux</h3><p>我直接用了github上别人的配置文件，安装方法里面都有</p><p><a href="https://github.com/gpakosz/.tmux" target="_blank" rel="noopener">gpakosz/.tmux</a><br><a href="https://github.com/amix/vimrc" target="_blank" rel="noopener">amix/vimrc</a></p><p>说实话我已经用惯了vscode基本不碰vim了(x)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前Linux只给了20个G过于局促，Windows企图装WSL又出现了各种各样的问题，于是就脑子一发热把两个系统备份以后都重装了。期间查了很多教程，就统一汇总在这里了。&lt;/p&gt;
&lt;h1 id=&quot;Windows重装&quot;&gt;&lt;a href=&quot;#Windows重装&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://mengzelev.github.io/2019/07/08/hello-world/"/>
    <id>https://mengzelev.github.io/2019/07/08/hello-world/</id>
    <published>2019-07-08T04:16:31.006Z</published>
    <updated>2017-10-28T00:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统期末复习笔记</title>
    <link href="https://mengzelev.github.io/2019/06/21/os-review/"/>
    <id>https://mengzelev.github.io/2019/06/21/os-review/</id>
    <published>2019-06-21T12:58:41.000Z</published>
    <updated>2019-06-23T03:37:40.845Z</updated>
    
    <content type="html"><![CDATA[<p><s>这其实是jyy课程讲义摘抄</s></p><h1 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h1><p>维度：价格、容量、速度、可靠性</p><p>持久化存储介质统称Non-Volatile Memory</p><h1 id="IO设备与驱动"><a href="#IO设备与驱动" class="headerlink" title="IO设备与驱动"></a>IO设备与驱动</h1><p>设备：三种操作（发送命令、读取状态、传输数据）的集合</p><h2 id="管理IO设备"><a href="#管理IO设备" class="headerlink" title="管理IO设备"></a>管理IO设备</h2><p>查看系统IO设备：<code>lspci,lsblk</code><br>(实现： <code>open(&quot;/sys/bus/pci&quot;)</code>)</p><p>Loop Back Device(回路设备)：把一个文件模拟成一个块设备<br>a pseudo-device that makes a file accessible as a block device in Unix-like operating systems</p><p>IO设备类型众多、访问模式差距很大<br>解决：抽象层——设备驱动<br><strong>设备驱动</strong>：操作系统对设备进行的额外抽象，使得更上层的部分（通常是文件系统）能够以统一的接口访问这些设备，i.e.把文件API翻译成设备命令</p><ul><li>设备驱动层帮助我们屏蔽了底层设备的具体实现细节</li><li>使得创建“虚拟”设备非常容易(<code>/dev/random</code>,<code>/dev/null</code>)</li></ul><p>I/O设备最主要的功能：input/output(read/write)<br>还有一些设备相关设置(<code>ioctl</code>)</p><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>解决中断没能解决的问题<br>一个完成CPU和设备之间数据传输的I/O设备<br>这样CPU可以在传送数据时做别的事</p><h1 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h1><p>存储设备虚拟化<br>虚拟磁盘：一个可以读写的动态字节序列<br>传统理解：文件系统是保存在持久存储上的数据结构(存储格式规范+允许的操作)</p><p>文件系统【以下是我能找到的所有描述】</p><ul><li>存储设备的虚拟化机制</li><li>保存在持久存储上的数据结构</li><li>文件名到虚拟磁盘的映射</li><li>管理操作系统内部对象的中间层</li><li>连接应用程序与设备驱动的桥梁</li><li>管理操作系统中能够抽象成“虚拟磁盘”接口访问的任何数据</li></ul><p>文件系统实现 = 数据结构的查询/修改操作<br>文件：可读写的数据对象，相当于一个虚拟磁盘<br>文件操作</p><ul><li>打开（返回文件描述符），关闭</li><li>文件描述符操作：read,write,lseek,ioctl,mmap…</li></ul><p>目录：文件和目录的集合<br>目录操作</p><ul><li>改变进程工作目录(没有<code>/bin/cd</code>)</li><li>目录解析</li><li>读取目录</li><li>目录操作：link,unlink,rename</li></ul><h2 id="文件系统设计"><a href="#文件系统设计" class="headerlink" title="文件系统设计"></a>文件系统设计</h2><p>文件（扩展）：操作系统中的一个可读/写/控制的对象<br>文件描述符：指向操作系统对象的handle<br>管理操作系统对象的本质：传递数据的需求</p><blockquote><p>为什么<code>/proc</code>不是进程树？-方便根据pid查找进程</p></blockquote><p>虚拟文件系统：把read/write翻译成对操作系统对象(进程线程、文件目录、设备等)的读写</p><h1 id="文件系统API"><a href="#文件系统API" class="headerlink" title="文件系统API"></a>文件系统API</h1><h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><p>挂载：<code>mount -t type device dir</code><br>把一个设备和一个文件系统实现联系起来，在设备上创建一个文件系统实例，并且把创建的文件系统“放置”到文件系统中的一个路径里</p><h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>切换根目录<br>只影响路径解析<br>如果持有外部文件描述符很容易越狱</p><h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p>本质也是文件，只是操作系统在路径解析、目录遍历时对它的数据有特殊的解读</p><h3 id="硬♂链接"><a href="#硬♂链接" class="headerlink" title="硬♂链接"></a>硬♂链接</h3><ul><li>目标只能是文件(不能是目录)</li><li>不能跨越文件系统</li></ul><h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><ul><li>目标可以是任何相对/绝对路径</li><li>只是一个路径解析提示</li></ul><h2 id="文件管理：打开文件"><a href="#文件管理：打开文件" class="headerlink" title="文件管理：打开文件"></a>文件管理：打开文件</h2><p>打开目录：得到一个指向文件系统某个位置的指针</p><h2 id="文件操作：文件描述符"><a href="#文件操作：文件描述符" class="headerlink" title="文件操作：文件描述符"></a>文件操作：文件描述符</h2><ul><li>避免每次操作都要重新打开文件</li><li>帮助我们自动管理文件访问的偏移量</li></ul><h2 id="文件系统的同步"><a href="#文件系统的同步" class="headerlink" title="文件系统的同步"></a>文件系统的同步</h2><p>操作系统做了很多激进地缓存，所以多用<code>sync</code></p><h1 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h1><p>实现文件系统需要考虑以下因素</p><ul><li>虚拟磁盘的数据结构（链表，树…）</li><li>目录文件的数据结构</li><li>inode的表示和存储</li><li>balloc/bfree的实现</li></ul><h2 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h2><p>固定大小的block的数组<br>在<code>/sys/block</code>里可以找到<br>块设备API：进程/线程向存储设备提交I/O request, request首先进入设备队列，经过调度器调度后执行设备上的I/O<br>操作系统不管Block I/O调度，只管进程尽可能公平地获得I/O操作和请求优化</p><h2 id="虚拟磁盘"><a href="#虚拟磁盘" class="headerlink" title="虚拟磁盘"></a>虚拟磁盘</h2><p>数据结构：链表/树，提供<code>balloc/bfree</code><br>链表在文件小时表现较好，索引的lseek性能更好<br>block bitmap(联系L3)</p><p>文件应该有</p><ul><li>一个唯一的编号</li><li>元数据信息（类型，大小，权限，访问时间、链接数量、索引）</li></ul><h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><p>目录=文件名$\to$文件id的映射</p><h3 id="Inode的存储"><a href="#Inode的存储" class="headerlink" title="Inode的存储"></a>Inode的存储</h3><table><thead><tr><th style="text-align:left">存储方式</th><th style="text-align:center">好处</th><th style="text-align:center">坏处</th></tr></thead><tbody><tr><td style="text-align:left">在磁盘用单独区域统一存储和管理</td><td style="text-align:center">查找快速（可以快速计算出inode在磁盘中的位置）</td><td style="text-align:center">容易被破坏（备份）；浪费空间</td></tr><tr><td style="text-align:left">存储在目录文件中（如FAT）</td><td style="text-align:center">节约空间</td><td style="text-align:center">不支持硬链接</td></tr><tr><td style="text-align:left">存储在文件头部</td><td style="text-align:center">容错性</td></tr></tbody></table><h3 id="评价文件系统"><a href="#评价文件系统" class="headerlink" title="评价文件系统"></a>评价文件系统</h3><ul><li>性能<ul><li>存在超大文件、超大目录时各个操作的性能表现</li><li>在各种类型workload的读写（顺序/随机，读/写分布）、目录操作比例下的性能表现</li><li>多进程并发时的文件系统表现</li></ul></li><li>可靠性<ul><li>在系统可能意外崩溃时文件系统实现的正确性</li><li>在磁盘可能损坏的前提下文件系统的可靠性</li></ul></li></ul><h1 id="FAT和ext2"><a href="#FAT和ext2" class="headerlink" title="FAT和ext2"></a>FAT和ext2</h1><h2 id="File-Allocationg-Table"><a href="#File-Allocationg-Table" class="headerlink" title="File Allocationg Table"></a>File Allocationg Table</h2><p>链表实现文件，为每个block维护一个next block<br>文件分配表：集中存储next</p><p>PBR(Partition Boot Record)：存储在分区头部</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>读写序列不够连续</li><li>FAT容易被枪毙（一般都有两个备份）</li><li>文件系统可能碎片化（巨大的文件可能散落在磁盘的各个角落）</li><li><s>不支持链接只是因为手册里没写</s></li><li>FAT32最大文件只有4GB（因为是从小磁盘时代过来的）</li></ul><p>磁盘碎片整理：使文件尽可能在磁盘中占有连续的块</p><h2 id="ext2"><a href="#ext2" class="headerlink" title="ext2"></a>ext2</h2><p>索引实现文件：混合多种存储方式<br>inodes单独管理：支持硬链接<br>inodes连续存储：提高文件访问的局部性<br>相比于FAT空间浪费比较多</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li>分配分成了两级(组级、块级)<ul><li>不用管理全局的bitmap</li></ul></li><li>一定程度的性能优化<ul><li>尽量把相近的文件分配在同一个组里</li><li>尽量把同一个文件的数据块分配在同一个组里</li></ul></li><li>使磁盘大小容易动态调整</li></ul><h1 id="持久数据的可靠性"><a href="#持久数据的可靠性" class="headerlink" title="持久数据的可靠性"></a>持久数据的可靠性</h1><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>如何把虚拟磁盘映射到物理磁盘块</p><h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID-0"></a>RAID-0</h3><p>没有冗余</p><ul><li>方案1</li></ul><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>3</td></tr><tr><td>#1</td><td>1</td><td>4</td></tr><tr><td>#2</td><td>2</td><td>5</td></tr></tbody></table><ul><li>方案2</li></ul><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>1</td></tr><tr><td>#1</td><td>2</td><td>3</td></tr><tr><td>#2</td><td>4</td><td>5</td></tr></tbody></table><table><thead><tr><th></th><th>方案一</th><th>方案二</th></tr></thead><tbody><tr><td>顺序读写速度</td><td>1X</td><td>2X</td></tr><tr><td>随机读写速度</td><td>2X</td><td>2X</td></tr></tbody></table><p>实际使用中对目录访问较多（顺序读写），方案2中磁盘2等于没有</p><p>毫无容错</p><h3 id="RAID-1-镜像"><a href="#RAID-1-镜像" class="headerlink" title="RAID-1 镜像"></a>RAID-1 镜像</h3><p>维护两块数据完全一样的磁盘实现容错</p><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>0</td></tr><tr><td>#1</td><td>1</td><td>1</td></tr><tr><td>#2</td><td>2</td><td>2</td></tr><tr><td>#3</td><td>3</td><td>3</td></tr></tbody></table><h3 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID-4"></a>RAID-4</h3><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th><th>磁盘3</th><th>磁盘4</th><th>磁盘P</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>$0\oplus1\oplus2\oplus3$</td></tr><tr><td>#1</td><td>4</td><td>5</td><td>6</td><td>7</td><td>$4\oplus5\oplus6\oplus7$</td></tr><tr><td>#2</td><td>8</td><td>9</td><td>10</td><td>11</td><td>$8\oplus9\oplus10\oplus11$</td></tr><tr><td>#3</td><td>12</td><td>13</td><td>14</td><td>15</td><td>$12\oplus13\oplus14\oplus15$</td></tr></tbody></table><ul><li>顺序读：4X</li><li>顺序写：4X</li><li>随机读：4X</li><li>随机写：X/2(校验盘是性能瓶颈)</li></ul><h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID-5"></a>RAID-5</h3><p>RAID-4升级版</p><table><thead><tr><th>Block</th><th>磁盘1</th><th>磁盘2</th><th>磁盘3</th><th>磁盘4</th><th>磁盘P</th></tr></thead><tbody><tr><td>#0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>P</td></tr><tr><td>#1</td><td>4</td><td>5</td><td>6</td><td>P</td><td>7</td></tr><tr><td>#2</td><td>8</td><td>9</td><td>P</td><td>10</td><td>11</td></tr><tr><td>#3</td><td>12</td><td>P</td><td>13</td><td>14</td><td>15</td></tr></tbody></table><ul><li>随机写可以并发</li></ul><h3 id="带宽分析"><a href="#带宽分析" class="headerlink" title="带宽分析"></a>带宽分析</h3><p>见OSTEP</p><h3 id="RAID硬件"><a href="#RAID硬件" class="headerlink" title="RAID硬件"></a>RAID硬件</h3><ul><li>缓冲&amp;日志</li><li>奇偶校验电池</li><li>保证数据写回</li></ul><h1 id="崩溃恢复与日志"><a href="#崩溃恢复与日志" class="headerlink" title="崩溃恢复与日志"></a>崩溃恢复与日志</h1><h2 id="磁盘上的数据结构"><a href="#磁盘上的数据结构" class="headerlink" title="磁盘上的数据结构"></a>磁盘上的数据结构</h2><p>读磁盘的请求：</p><ul><li>读一个已经写过的块，可以不从磁盘读取</li><li>读一个未被访问过的块，必须从磁盘读取（等待）</li></ul><p>写磁盘的请求：</p><ul><li>原则上可以无限排队，让磁盘的读请求先行</li><li>但同时最终应当被写入磁盘</li></ul><h2 id="原子性的丧失"><a href="#原子性的丧失" class="headerlink" title="原子性的丧失"></a>原子性的丧失</h2><p>崩溃=缓存数据丢失</p><h3 id="简单的workload-追加写"><a href="#简单的workload-追加写" class="headerlink" title="简单的workload: 追加写"></a>简单的workload: 追加写</h3><ol><li>$FAT[b’]\leftarrow EOF$</li><li>$data[b’]\leftarrow$ 数据</li><li>$FAT[f_{end}]\leftarrow b’$</li></ol><p>一下考虑所有可能的崩溃情况</p><ul><li>$FAT[b’]\to$❌ (dead block/leak)</li><li>$data[b’]\to$❌ (random writes, 写到了没办法再读到的地方)</li><li>$FAT[f{end}]\to$❌ (corrupted FAT, inconsistency)</li><li>$data[b’]\to FAT[f_{end}]\to$❌ (random writes + corrupted FAT)</li><li>$FAT[b’]\to data[b’]\to$❌ (dead block * 2)</li><li>$FAT[b’]\to FAT[f_{end}]\to$❌ (corrupted file, incorrect data)</li><li>$FAT[f_end’]\to FAT[b’]\to data[b’]$ ✅</li></ul><p>dead block不是个很大的问题所以$FAT[b’]\to FAT[f_{end}]\to data[b’]$是个相对可以接受的方案，但这只是追加写，一般情形就很困难了</p><h2 id="文件系统一致性"><a href="#文件系统一致性" class="headerlink" title="文件系统一致性"></a>文件系统一致性</h2><p>当磁盘上的数据结构不合法或不满足文件操作的语义，文件系统就处于不一致的状态，e.g.</p><ul><li>链接成环</li><li>FAT指向未被分配数据块</li><li>两个文件的索引共享数据块</li></ul><h2 id="FSCK"><a href="#FSCK" class="headerlink" title="FSCK"></a>FSCK</h2><p>File System Checking<br>在崩溃后扫描磁盘进行补救</p><p>缺陷：</p><ul><li>为了一点小事扫描整个磁盘，太花时间了</li><li>没人能证明这么做一定能回到一个一致的状态</li><li>fsck的时候也会崩溃</li></ul><h2 id="实现崩溃一致性"><a href="#实现崩溃一致性" class="headerlink" title="实现崩溃一致性"></a>实现崩溃一致性</h2><p>Key idea: 使磁盘上的状态能推导出某个过去时刻的文件系统状态<br>借助<code>sync()</code>保证数据写入磁盘后才返回</p><h3 id="日志-Journaling"><a href="#日志-Journaling" class="headerlink" title="日志(Journaling)"></a>日志(Journaling)</h3><p>把操作以append only的方式记下来：写入TXbegin和数据→sync→写入TXEND→sync<br>用一个额外的指针维护journal完成的时刻</p><p>崩溃恢复：从指针开始向后重做journal中记录的操作<br>优化：合并log，只对metadata做journaling(但可能导致应用程序丢失数据)</p><h1 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h1><h2 id="I-O设备模型"><a href="#I-O设备模型" class="headerlink" title="I/O设备模型"></a>I/O设备模型</h2><p>传输数据、发送命令、读取状态这三种操作的集合</p><p>设备驱动：操作系统对设备进行的额外抽象，使得更上层的程序能够以统一的接口访问这些设备</p><h2 id="main函数之前的故事"><a href="#main函数之前的故事" class="headerlink" title="main函数之前的故事"></a>main函数之前的故事</h2><p>hello的第一条指令：<code>ld.so</code>的<code>_start</code></p><p>hello的<code>main</code>函数执行之前</p><ol><li>加载器(<code>ld.so</code>)把hello进程的地址空间加载进来</li><li>加载器的<code>_start</code>加载libc到hello进程的地址空间</li><li>进入hello自己的<code>_start</code>, 调用<code>__libc_start_main</code></li></ol><h2 id="线程安全的printf"><a href="#线程安全的printf" class="headerlink" title="线程安全的printf"></a>线程安全的printf</h2><p>复习条件变量和信号量</p><h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h3><ul><li>维护了（可能不止）一份文件分配表，记录每个文件中每一个block的下一个block的编号，位于文件系统头部、super block之后</li><li>block被称为sector的cluster</li><li>文件的元数据(inode)保存在目录项里，不支持链接，目录项按顺序存储在文件中</li><li>缺陷：<code>lseek</code>困难，FAT块容易被枪毙，文件系统碎片化</li></ul><h3 id="ext2-1"><a href="#ext2-1" class="headerlink" title="ext2"></a>ext2</h3><ul><li>多级索引</li><li>inode单独管理，提高了文件访问的局部性</li><li>目录项顺序存储inode编号、该目录项长度、类型、文件名</li><li>分组：不用管理全局的bitmap，性能优化，简化磁盘大小动态调整</li></ul><h2 id="保护数据不受损害"><a href="#保护数据不受损害" class="headerlink" title="保护数据不受损害"></a>保护数据不受损害</h2><h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID"></a>RAID</h3><table><thead><tr><th style="text-align:center">RAID lv.</th><th style="text-align:center">容量</th><th style="text-align:center">容错</th><th style="text-align:center">顺序读</th><th style="text-align:center">顺序写</th><th style="text-align:center">随机读</th><th style="text-align:center">随机写</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">$n$</td><td style="text-align:center">0</td><td style="text-align:center">$n$</td><td style="text-align:center">$n$</td><td style="text-align:center">$n$</td><td style="text-align:center">$n$</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">$n/2$</td><td style="text-align:center">$1…n/2$</td><td style="text-align:center">$&gt;n/2$</td><td style="text-align:center">$n/2$</td><td style="text-align:center">$n$</td><td style="text-align:center">$n/2$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$n-1$</td><td style="text-align:center">1</td><td style="text-align:center">$n-1$</td><td style="text-align:center">$n-1$</td><td style="text-align:center">$n-1$</td><td style="text-align:center">$1/2$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$n-1$</td><td style="text-align:center">1</td><td style="text-align:center">$n-1$</td><td style="text-align:center">$n-1$</td><td style="text-align:center">$n$</td><td style="text-align:center">$n/4$</td></tr></tbody></table><h3 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h3><p>崩溃之后的补救措施</p><ul><li>扫描inodes里所有数据块，检查bitmap的一致性</li><li>检查inode数据是否看起来合法，否则删除</li><li>检查链接情况，没有链接的inode被移到lost+found目录</li></ul><p>缺陷：没事儿就扫描整个磁盘开销太大；也不一定能把文件系统恢复成一致的状态；fsck的时候崩溃了就完蛋了</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul><li>记录所有操作</li><li>维护一个指针，指向已经完成的checkpoint</li><li>崩溃后从指针处开始重做所有操作，向后恢复</li><li>优化：批处理；metadata journaling</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;s&gt;这其实是jyy课程讲义摘抄&lt;/s&gt;&lt;/p&gt;
&lt;h1 id=&quot;存储介质&quot;&gt;&lt;a href=&quot;#存储介质&quot; class=&quot;headerlink&quot; title=&quot;存储介质&quot;&gt;&lt;/a&gt;存储介质&lt;/h1&gt;&lt;p&gt;维度：价格、容量、速度、可靠性&lt;/p&gt;
&lt;p&gt;持久化存储介质统称No
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OSTEP阅读笔记-持久化部分</title>
    <link href="https://mengzelev.github.io/2019/06/21/OSTEP-persistence/"/>
    <id>https://mengzelev.github.io/2019/06/21/OSTEP-persistence/</id>
    <published>2019-06-21T02:23:27.000Z</published>
    <updated>2019-06-23T02:47:49.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch36-IO设备"><a href="#Ch36-IO设备" class="headerlink" title="Ch36 IO设备"></a>Ch36 IO设备</h1><h2 id="典型设备协议"><a href="#典型设备协议" class="headerlink" title="典型设备协议"></a>典型设备协议</h2><p>设备的两个重要组成部分：硬件接口+内部结构</p><p><img src="/2019/06/21/OSTEP-persistence/device.png"></p><p>OS通过读写状态、命令和数据寄存器来控制设备行为</p><p>协议模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(STATUS == BUSY);</span><br><span class="line">//wait until device is not busy(polling)</span><br><span class="line">write data to DATA reg;</span><br><span class="line">write cmd to cmd reg;</span><br><span class="line">  (Doing so starts the device and executes the cmd)</span><br><span class="line">while(STATUS == BUSY);</span><br><span class="line">//wait until device is done with your request</span><br></pre></td></tr></table></figure><p>缺陷：轮询浪费时间——用中断减少CPU浪费(概括一下：等待设备的时候去做别的事情)</p><p>使用中断还是轮询取决于设备的速度</p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>要传送数据的时候，OS告诉DMA数据在哪里、送多少、要送给谁，然后OS就可以去干别的事了，数据拷贝全部由DMA来完成</p><h2 id="OS与设备的交互"><a href="#OS与设备的交互" class="headerlink" title="OS与设备的交互"></a>OS与设备的交互</h2><h3 id="明确的I-O指令"><a href="#明确的I-O指令" class="headerlink" title="明确的I/O指令"></a>明确的I/O指令</h3><p>古代方法<br>e.g. <code>x86</code>的<code>in</code>,<code>out</code>指令<br>PA你都写过了<br>都是特权指令，只有OS可以使用</p><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>现代方法<br>但古代方法没有被抛弃</p><h2 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h2><p>by传统艺能：抽象<br>设备驱动：OS中的某一块(piece)知道设备的工作细节的软件，封装了所有与设备的交互行为(原话：a piece of software in the OS must know in detail how a device works)<br>但这样会使设备损失特殊功能(e.g SCSI有比ATA和IDE更丰富的error handling机制)<br>OS里70%的代码都是设备驱动程序，而且因为设备驱动主要都是野鸡程序猿(相对于内核代码)写的，所以是贡献内核bug的中坚力量</p><h1 id="Ch37-硬盘驱动"><a href="#Ch37-硬盘驱动" class="headerlink" title="Ch37 硬盘驱动"></a>Ch37 硬盘驱动</h1><p>虽然现代os会一次性往硬盘写很多数据，但是硬盘只保证一个sector(512字节)的写是原子的(要么写了要么没写)</p><h2 id="物理构造"><a href="#物理构造" class="headerlink" title="物理构造"></a>物理构造</h2><p>盘片(platter)的两个面称为盘面(surface)，盘片装在转轴(spindle)上。数据按磁道(track)排列在盘片上，由磁头(disk head)读写。每个盘面都有一个磁头(disk head)。磁头长在磁臂(disk arm)上<br>RPM(rotation per minute)</p><p>缓存(track buffer)</p><p>写判定</p><ul><li>写回(write back): 把数据放入磁盘缓冲就算写完</li><li>直写(write through): 把数据写入磁盘后才算写完</li></ul><p>下面都是磁盘读写调度我不看了啦</p><h1 id="Ch38-RAIDs"><a href="#Ch38-RAIDs" class="headerlink" title="Ch38 RAIDs"></a>Ch38 RAIDs</h1><p>Redundant Arrays of Inexpensive Disks廉价磁盘冗余阵列<br>RAID其实是一个firmware(编程硬件)，有自己的处理器、存储和磁盘</p><p>###评价标准<br>performance, capacity, reliability.<br>其中performance有两个判定尺度：single-request latency(单操作延迟), steady-state throughput(稳态吞吐量, the total bandwidth of many concurrent requests)</p><h2 id="故障模型-Fault-Model"><a href="#故障模型-Fault-Model" class="headerlink" title="故障模型(Fault Model)"></a>故障模型(Fault Model)</h2><h3 id="fail-stop"><a href="#fail-stop" class="headerlink" title="fail-stop"></a>fail-stop</h3><p>磁盘只有两个状态：wording &amp; failed(永远没有了)，不考虑坏了半块这样的情况</p><h2 id="RAID-Level-0-Striping-串列"><a href="#RAID-Level-0-Striping-串列" class="headerlink" title="RAID Level 0: Striping(串列)"></a>RAID Level 0: Striping(串列)</h2><p>毫无冗余，虚假的RAID</p><p>capacity: perfect<br>reliability: any disk failure will lead to data loss<br>performance:  excellent</p><p>【此处省略懒得截图的截图】<br>stripe: 排在同一行的blocks<br>chunk size(组块大小): 连续分布在同一块磁盘上的数据大小<br>chunk size对RAID的performance影响最大<br>小的chunk size能提高连续读的并发性，但是延长了把block分配到不同磁盘的时间<br>大的chunk size只有在读大文件时才能有较好的并发性，但缩短了分配时间<br>chunk size的选择依赖于workload</p><p>workload有两种：sequential和random</p><h2 id="RAID-Level-1-Mirroring"><a href="#RAID-Level-1-Mirroring" class="headerlink" title="RAID Level 1: Mirroring"></a>RAID Level 1: Mirroring</h2><p><img src="/2019/06/21/OSTEP-persistence/raid10.png"></p><p>图上那个又叫RAID-10</p><p>读：随机选一个<br>写：两份都要写（并发）</p><ul><li>capacity: N块磁盘，容量N/2</li><li>reliability: 可以忍受单块磁盘爆炸(只要不是同一块磁盘的两个备份同时爆炸)</li><li>performance: <ul><li>读延迟：速度同读单块磁盘</li><li>写延迟：同时写两份（并发），与同时写单块相同。但写时间由两块中时间长的决定，因此比写单块会慢一丢丢</li><li>连续读：同随机写</li><li>连续写：最大带宽$(\frac{N}{2}\cdot S)$，峰值带宽的一半</li><li>随机读：满带宽$N\cdot R$ MB/s</li><li>随机写：一半</li></ul></li></ul><h3 id="多块磁盘的一致性维护"><a href="#多块磁盘的一致性维护" class="headerlink" title="多块磁盘的一致性维护"></a>多块磁盘的一致性维护</h3><p>刚决定写一块磁盘，另一块磁盘写不写还没确定，就断电了，这时另一块磁盘完全没被写，导致两块磁盘数据不一致。也就是说希望镜像的两块盘的写操作是原子的。<br>解决：write-ahead log<br>大多数磁盘都带有电池供电的小型非易失性RAM</p><h2 id="RAID-Level-4-Saving-Space-With-Parity"><a href="#RAID-Level-4-Saving-Space-With-Parity" class="headerlink" title="RAID Level 4: Saving Space With Parity"></a>RAID Level 4: Saving Space With Parity</h2><p>用时间(performance)换空间(capacity)</p><p><img src="/2019/06/21/OSTEP-persistence/raid4.png"></p><p>给每个stripe加了一个parity check block(XOR)<br>当一块盘坏掉时，我们需要读同一个stripe中其他所有盘的数据才能恢复出这块盘的数据</p><ul><li>capacity： $N-1$</li><li>reliability: 能容忍每个stripe中有一块磁盘爆炸</li><li>performance<ul><li>连续读：只有校验盘没有被占用，$(N-1)\cdot S$ MB/s</li><li>连续写：full-stripe write很高效，因为写完一个stripe正好能写校验盘，$(N-1)\cdot S$ MB/s</li><li>随机读：除了校验盘，$(N-1)\cdot S$ MB/s</li><li>随机写：当修改了一块盘中的数据时，需要同时修改校验盘，这里有两种方法。一是additive parity，把同一个stripe中的块的数据全部读出来再算一遍校验位，然后并发地写入校验盘和数据盘，这种做法在RAID块比较多的时候会很慢；另一种是subtractive parity，从检验位中把原来的数据减去再加上新的数据，这种方法的瓶颈在于校验盘不能并发读写，带宽只有$R/2$ MB/s，即使加磁盘也不会加快。</li><li>读延迟：同读单块磁盘</li><li>写延迟：写单块时需要进行两次读和写(subtractive parity)，但读写都可以并发，因此写延迟为写单块磁盘的两倍（速度是一半）</li></ul></li></ul><h2 id="RAID-Level-5：-Rotating-Parity"><a href="#RAID-Level-5：-Rotating-Parity" class="headerlink" title="RAID Level 5： Rotating Parity"></a>RAID Level 5： Rotating Parity</h2><p><img src="/2019/06/21/OSTEP-persistence/raid5.png"></p><p>为了消除RAID-4校验盘的性能瓶颈</p><p>三围基本和RAID-4相同<br>随机读的performance会好一些，因为所有的磁盘都被占用了<br>随机写性能大大提升，因为写操作之间可以并发了。当有较大的随机写操作序列时，可以保证每块磁盘都能并发工作，但依然有2读2写，带宽是$\frac{N}{4}\cdot R$ MB/s.<br>在市场上已经基本取代了RAID-4</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>一张表格概括本章精髓</p><p><img src="/2019/06/21/OSTEP-persistence/sum.png"></p><p>方案选择取决于实际使用，对reliability、顺序或随机读写的不同需求</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ch36-IO设备&quot;&gt;&lt;a href=&quot;#Ch36-IO设备&quot; class=&quot;headerlink&quot; title=&quot;Ch36 IO设备&quot;&gt;&lt;/a&gt;Ch36 IO设备&lt;/h1&gt;&lt;h2 id=&quot;典型设备协议&quot;&gt;&lt;a href=&quot;#典型设备协议&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>难问题求解学习笔记-随机算法</title>
    <link href="https://mengzelev.github.io/2019/05/25/ps-4-13-Randomized-Algorithms/"/>
    <id>https://mengzelev.github.io/2019/05/25/ps-4-13-Randomized-Algorithms/</id>
    <published>2019-05-25T03:20:40.000Z</published>
    <updated>2019-06-19T12:33:02.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>输出为随机变量的算法称为蒙特卡洛算法(Monte Carlo)<br>输出总是正确的但时间复杂度为随机变量的算法称为拉斯维加斯算法(Las Vegas)</p><p>概率论理论引入了随机算法$A$与确定输入$x$构成的随机试验。试验可以被描述为概率空间$(S_{A,x},Prob)$，其中$S_{A,x}={C\mid C \text{is a computation (radom run) of } A \text{ on } x}$，$Prob$是$S_{A,x}$上的概率分布。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="一种新的复杂度度量"><a href="#一种新的复杂度度量" class="headerlink" title="一种新的复杂度度量"></a>一种新的复杂度度量</h2><p>$Random_A(x)$: 对于所有$A$在$x$上的随机计算中使用的random bits的最大数量<br>$Random_A(n)=\max{Random_A(x)\mid x \text{is a input of size }n}$</p><p>这么衡量的两点原因</p><ul><li>产生真随机数非常困难，且真随机序列越长越困难</li><li>如果一个算法的$Random_A(x)$是对数级的，那就可能可以在多项式时间内追踪它的所有运行的可能情况，做到去随机化(derandomization)</li></ul><p>$Prob_{A,x}(C)$: 某一次$A$对输入$x$的计算$C$, 由相应的随机序列的概率决定<br>$Prob(A(x)=y)$: $A$ outputs $y$ for an input $x$的概率<br>$Time(C)$: the time complexity of the run $C$ of $A$ on $x$</p><p>期望时间复杂度of $A$ on $x$(expected time complexity)<br>$$Exp-Time_A(x)=E[Time]=\sum\limits_{C}Prob_{A,x}(C)\cdot Time(C)$$</p><p>$A$的期望时间复杂度(worst case approach)<br>$$Exp-TIme_A(n)=\max{Exp-Time_A(x)\mid x \text{is an input of size } n}$$</p><p>$$Time_A(x)=\max{Time(C)\mid C \text{ is a run of} A \text{on} x }$$<br>$$Time_A(n)=\max{Time_A(x)\mid x \text{ is an input of size }n}$$</p><p>随机算法不一定会终止，可能会进行无限次计算，在实际情况下可以在某一时间后叫停，算法输出”?”，即无法在给定时间内解决该问题，然后重新开始</p><h1 id="随机算法的分类"><a href="#随机算法的分类" class="headerlink" title="随机算法的分类"></a>随机算法的分类</h1><h2 id="拉斯维加斯算法"><a href="#拉斯维加斯算法" class="headerlink" title="拉斯维加斯算法"></a>拉斯维加斯算法</h2><p>拉斯维加斯算法与其时间复杂度有两种定义方式，适用于不同的场景</p><h3 id="第一种定义"><a href="#第一种定义" class="headerlink" title="第一种定义"></a>第一种定义</h3><p>若对问题$F$的任意输入实例$x$，$Prob(A(x)=F(x))=1$,其中$F(x)$是问题$F$对于输入$x$的解，则称$A$是计算问题$F$的拉斯维加斯算法。这种定义下时间复杂度是$Exp-Time_A(n)$</p><h3 id="第二种定义"><a href="#第二种定义" class="headerlink" title="第二种定义"></a>第二种定义</h3><p>允许”?”输出<br>若对问题$F$的任意输入实例$x$，$Prob(A(x)=F(x))\ge\frac{1}{2}$且$Prob(A(x)=”?”)=1-Prob(A(x)=F(x))\le\frac{1}{2}$.<br>这种定义下时间复杂度采用$Time_A(n)$</p><p>第一种定义一般用于计算函数，第二种一般用于计算decision problem</p><h2 id="单边误差蒙特卡洛算法"><a href="#单边误差蒙特卡洛算法" class="headerlink" title="单边误差蒙特卡洛算法"></a>单边误差蒙特卡洛算法</h2><p>ONE-SIDED-ERROR MONTE CARLO ALGORITHMS</p><p>$L$的单边蒙特卡洛算法满足</p><ul><li>对任意$x\in L, Prob(A(x)=1)\ge 1/2$</li><li>对任意$x\notin L, Prob(A(x)=0)=1$</li></ul><p>重复次数越多，得到正确答案的可能性就越大</p><p>质数定理：集合${1,2,\cdots,m}$中质数的个数大约是$m/\ln m$，且当$m\ge 100$时至少是$m/\ln m$</p><h2 id="双边误差蒙特卡洛算法"><a href="#双边误差蒙特卡洛算法" class="headerlink" title="双边误差蒙特卡洛算法"></a>双边误差蒙特卡洛算法</h2><p>TWO-SIDED-ERROR MONTE CARLO ALGORITHMS</p><p>若存在实数$\varepsilon, 0\le\varepsilon &lt;1/2$，满足对于$F$的任意输入$x, Prob(A(x)=F(x))\ge\frac{1}{2}+\varepsilon$,则称该算法为$F$的双边蒙特卡洛算法</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/at.png"> </p><h2 id="无限制误差蒙特卡洛算法"><a href="#无限制误差蒙特卡洛算法" class="headerlink" title="无限制误差蒙特卡洛算法"></a>无限制误差蒙特卡洛算法</h2><p>UNBOUNDED-ERROR MONTE CARLO ALGORITHMS</p><p>若对于$F$的任意输入$x, Prob(A(x)=F(x))&gt;\frac{1}{2}$，则称这样的算法$A$是无限制蒙特卡洛算法</p><h2 id="随机最优化问题"><a href="#随机最优化问题" class="headerlink" title="随机最优化问题"></a>随机最优化问题</h2><p>判定问题的随机算法是选择出现最多的答案，而最优化问题是选择最接近(根据cost function)的答案</p><h3 id="随机近似算法"><a href="#随机近似算法" class="headerlink" title="随机近似算法"></a>随机近似算法</h3><p>随机算法可以看成是以高概率得到与最优解差别不大的解的近似算法</p><p><strong>定义5.2.2.10</strong>：设$U=$(略)是一个最优化问题。对任意正实数$\delta&gt;1$，随机算法$A$是$U$的<strong>随机$\delta-$近似算法</strong>，若$A$满足以下要求</p><ul><li>$Prob(A(x)=\mathcal{M}(x))=1$且</li><li>$Prob(R_A(x)\le\delta)\ge 1/2$</li></ul><p>对任意$x\in L_I$</p><p>类似可定义<strong>随机$f(n)-$近似算法</strong></p><p>随机多项式近似方案(RPTAS)</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/rptas1.png"></p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/rptas2.png"></p><p>还有随机 完全多项式近似方案(RFPTAS)</p><p>$\delta-$期望近似算法</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/52211.png"></p><p>以上两种定义互不包含</p><h1 id="随机算法设计"><a href="#随机算法设计" class="headerlink" title="随机算法设计"></a>随机算法设计</h1><h2 id="挫败对手"><a href="#挫败对手" class="headerlink" title="挫败对手"></a>挫败对手</h2><p>随机选择一系列算法中的一个，这样就无法特意构造一组最坏输入</p><h2 id="充分取证"><a href="#充分取证" class="headerlink" title="充分取证"></a>充分取证</h2><p>常用于判定问题</p><p>如Example5.2.2.6的取模运算</p><h2 id="指纹"><a href="#指纹" class="headerlink" title="指纹"></a>指纹</h2><p>用于判定等价问题</p><p><img src="/2019/05/25/ps-4-13-Randomized-Algorithms/fp.png"></p><h2 id="随机采样"><a href="#随机采样" class="headerlink" title="随机采样"></a>随机采样</h2><h2 id="松弛与随机舍入"><a href="#松弛与随机舍入" class="headerlink" title="松弛与随机舍入"></a>松弛与随机舍入</h2><p>比如把线性规划的值舍入成整数规划</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;输出为随机变量的算法称为蒙特卡洛算法(Monte Carlo)&lt;br&gt;输出总是正确的但时间复杂度为随机变量的算法称为拉斯维加斯算法(Las 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>难问题求解学习笔记-近似算法</title>
    <link href="https://mengzelev.github.io/2019/05/18/ps-4-12-Approximation-Algorithms/"/>
    <id>https://mengzelev.github.io/2019/05/18/ps-4-12-Approximation-Algorithms/</id>
    <published>2019-05-18T03:03:30.000Z</published>
    <updated>2019-06-19T08:16:41.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>近似算法是能提供最优化问题的可行解的算法，所提供的解的质量不会与最优解相差太多</p><p><strong>形式化定义</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$是一个最优化问题，$A$是$U$的consistent algorithm. 对任意$x\in L_I$, $A$在$x$上的相对误差(relative error)$\varepsilon_A(x)$定义为<br>$$\varepsilon_A(x)=\frac{|cost(A(x))-Opt_U(x)|}{Opt_U(x)}$$<br>对任意$x\in\mathbb{N}$,定义$A$的相对误差$$\varepsilon_A(n)=\max{\varepsilon_A(x)|x\in L_I\cap (\Sigma_I)^n}$$<br>对每个$x\in L_I$,$A$在$x$上的的近似率(approximation ration)$R_A(x)$定义为$$R_A(x)=\max{\frac{cost(A(x))}{Opt_U(x)}, \frac{Opt_U(x)}{cost(A(x))}}$$<br>对任意$n\in\mathbb{N}$,定义$A$的近似率为$$R_A(n)=\max{R_A(x)|x\in L_I\cap (\Sigma_I)^n}$$<br>$R_A$又名最坏情况性能(worst case performance)，近似因子(approximation factor), 性能约束(performance bound)，性能率(performance ratio)，误差率(error ratio)</p><p>若$A$是最小化问题且$R_A(x)=\frac{Opt_U(x)}{cost(A(x))}$,则$R_A(x)=1+\varepsilon_A(x)$</p><p>对于任意正实数$\delta&gt;1$，若$R_A(x)\le\delta$对任意$x\in L_I$恒成立，则称$A$是$U$的$\delta-$近似算法<br>对任意函数$f:\mathbb{N}\to\mathbb{R}^+$,若$R_A(x)\le f(n)$对任意$n\in\mathbb{N}$恒成立，则称$A$是$U$的$f(n)-$近似算法</p><h1 id="近似方案-approximation-scheme"><a href="#近似方案-approximation-scheme" class="headerlink" title="近似方案(approximation scheme)"></a>近似方案(approximation scheme)</h1><p>用户可以指定一个小的相对误差值$\varepsilon$，程序可以提供出一个误差至多为$\varepsilon$的可行解</p><p><strong>定义4.2.1.6</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$是一个最优化问题。若对任意输入对$(x,\varepsilon)\in L_I\times\mathbb{R}^+$, $A$计算出一个相对误差至多为$\epsilon$的可行解$A(x)$, 且$Time_A(x,\varepsilon^{-1})$以某个$|x|$的多项式函数为界，则称$A$是$U$的<strong>多项式时间近似方案(polynomial-time approximation scheme, PTAS)</strong>. 若$Time_A(x,\varepsilon^{-1})$以某个同时是$|x|$和$\varepsilon^{-1}$的多项式的函数为界，则称$A$是$U$的<strong>完全多项式近似方案(fully polynomial-time approximation scheme, FPTAS)</strong></p><p>一般来说$Time_A(x,\varepsilon^{-1})$关于$|x|$和$\varepsilon^{-1}$都单调递增</p><p>好处：用户有权决定要快还是要精度</p><h1 id="最优化问题的分类"><a href="#最优化问题的分类" class="headerlink" title="最优化问题的分类"></a>最优化问题的分类</h1><p>在近似的意义下NPO可以被分为以下五类：</p><ul><li>NPO(I): NPO中所有存在FPTAS的最优化问题(e.g.背包问题)</li><li>NPO(II): NPO中所有存在PTAS的最优化问题(e.g. MS)</li><li>NPO(III): 包含所有$U\in NPO$满足：<ul><li>对某些$\delta&gt;1$存在多项式时间的$\delta-$近似算法</li><li>对某些$d&lt;\delta$不存在多项式时间的的$d-$近似算法</li><li>i.e.$U$没有PTAS</li></ul></li><li>NPO(IV): 包含所有$U\in NPO$满足：<ul><li>对某些$f:\mathbb{N}\to\mathbb{R}^+$,存在多项式时间的$f(n)-$近似算法,其中$f$以某个多项式函数为界</li><li>对任意$\delta\in\mathbb{R}^+$不存在任何多项式时间的$\delta-$近似算法</li><li>e.g.集合覆盖问题</li></ul></li><li>NPO(V): 包含所有$U\in NPO$，满足若存在多项式时间的$f(n)-$近似算法，则$f(n)$不以任何多项式函数为界(e.g. TSP, 最大团问题)</li></ul><p>以上分类都基于合理的假设P$\neq$NP<br>所有集合都是非空的</p><h1 id="近似算法的稳定性"><a href="#近似算法的稳定性" class="headerlink" title="近似算法的稳定性"></a>近似算法的稳定性</h1><p>即使是NPO(V)中的问题，也可能有很大一部分的输入是比较简单的</p><p>稳定性用来衡量问题实例的限定(参数，特性等)对近似率的影响<br>如果对模型的限制影响近似率的程度很低，则可以说我们的算法是稳定的</p><p><strong>定义4.2.3.1</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$, $\overline{U}={\Sigma_I, \Sigma_O, L, L, \mathcal{M}, cost, goal}$是两个最优化问题，$L_I\subseteq L$. $\overline{U}$依据$L_I$的距离函数(distance function for $\overline{U}$ according to $L_I$)是任何满足下列性质的函数$h_L:L\to\mathbb{R}^+\cup{0}$:</p><ul><li>对任意$x\in L_I, h_L(x)=0$</li><li>$h$可以在多项式时间内计算</li></ul><p>定义：对任意$r\in\mathbb{R}^+$,$$Ball_{r,h}(L_I)={w\in L\mid h(w)\le r}$$</p><p>$p$是正实数，若对任意实数$0\le r\le p$, 存在$\delta_{r,\varepsilon}\in\mathbb{R}^{&gt;1}$, $A$是$U_r={\Sigma_I, \Sigma_O, L, Ball_{r,h}, \mathcal{M}, cost, goal}$的$\delta_{r,\varepsilon}-$近似算法，则称$A$是<strong>p-stable</strong> according to $h$</p><p>若对任意$p\in\mathbb{R}^+$，$A$都是p-stable的，则称$A$是stable according to $h$<br>反之，若对任意$p\in\mathbb{R}^+$，$A$都不是p-stable的，则称$A$是unstable according to $h$</p><p>对任意正整数$r$和任意函数$f:\mathbb{N}\to\mathbb{R}^{&gt;1}$,若$A$是$U_r={\Sigma_I, \Sigma_O, L, Ball_{r,h}, \mathcal{M}, cost, goal}$的$f_r(n)-$近似算法，则称$A$是$(r,f_r(n))$-quasistable accroding to $h$</p><p>把PTAS$A$看作一系列多项式时间$(1+\varepsilon)-$近似算法的集合$A_\varepsilon$.若在某个距离度量$h$下对任意$\varepsilon&gt;0$,$A_\varepsilon$都是稳定的，则我们可以得到以下二者之一</p><ul><li>$U_r$的一个PTAS(for every $r\in\mathbb{R}^+$)</li><li>$U_r$的一个$\delta_{r,\varepsilon}$近似算法，但没有PTAS</li></ul><p><strong>定义4.2.3.6</strong>： $U,\overline{U}$定义同上。$h$是$\overline{U}$根据$L_I$的距离函数，$U_r$同上。设$A={A_\varepsilon}<em>{\varepsilon&gt;0}$是$U$的一个PTAS<br>若对任意$r&gt;0$和$\varepsilon&gt;0$,$A</em>\varepsilon$是$\delta_{r,\varepsilon}$-近似算法，则$A$是关于$h$stable的<br>若$\delta_{r,\varepsilon}\le f(\varepsilon)\cdot g(r)$，其中$f$和$g$是某些$\mathbb{R}^{\ge 0}\to\mathbb{R}^+$的函数且$\lim\limits_{\varepsilon\to 0}f(\varepsilon)=0$, 则称$A$关于$h$超稳定(superstable).</p><p>如果$A$对$U$超稳定，则$A$对$U_r$也超稳定</p><h1 id="对偶近似算法"><a href="#对偶近似算法" class="headerlink" title="对偶近似算法"></a>对偶近似算法</h1><p>修改限制条件$\mathcal(M)$来简化计算</p><p><strong>定义4.2.4.1</strong>：$U={\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal}$是一个最优化问题。$U$的<strong>限制距离函数(constraint distance function)</strong>是任何满足下列条件的函数$h:L_I\times\Sigma^*_O\to\mathbb{R}^{\ge 0}$:</p><ul><li>对任意$S\in\mathcal{M}(x), h(x,S)=0$</li><li>对任意$S\notin\mathcal{M}(x), h(x,S)&gt;0$</li><li>$h$是多项式时间内可计算的</li></ul><p>对任意$\varepsilon\in\mathbb{R}^+$,任意$x\in L_I$,$\mathcal{M}_\varepsilon^h(x)={S\in\Sigma_O^*\mid h(x,S)\le\varepsilon}$是$\varepsilon-$ball of $\mathcal{M}(x)$ according to $h$.</p><p><strong>定义4.2.4.2</strong>: $U$是最优化问题，$h$是$U$的限制距离函数. 若对任意$x\in L_1$,有$A(x)\in\mathcal{M}_\varepsilon^h(x)$且$cost(A(x))\ge Opt_U(x)$ if $goal=maximum$且$cost(A(x))\le Opt_U(x)$ if $goal=minimum$, 则称$A$是$U$的$h-$对偶$\varepsilon-$近似算法</p><p><strong>定义4.2.4.3</strong>: 条件同上。若</p><ul><li>对任意输入$(x,\varepsilon)\in L_I\times\mathbb{R}^+, A(x,\varepsilon)\in\mathcal{M}_\varepsilon^h(x)$</li><li>$cost(A(x))\ge Opt_U(x)$ if $goal=maximum$且$cost(A(x))\le Opt_U(x)$ if $goal=minimum$</li><li>$Time_A(x,\varepsilon^{-1})$以某个$|x|$的多项式函数为界</li></ul><p>则称$A$是$U$的$h-dual$PTAS<br>类似的可以定义$U$的$h-dual$FPTAS</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>降低问题难度的方法：</p><ul><li>对输出精度要求降低</li><li>对输入做限制</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;近似算法是能提供最优化问题的可行解的算法，所提供的解的质量不会与最优解相差太多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;形式化定义&lt;/strong&gt;：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自己看得惯的板子整理</title>
    <link href="https://mengzelev.github.io/2019/04/19/oj-templates/"/>
    <id>https://mengzelev.github.io/2019/04/19/oj-templates/</id>
    <published>2019-04-19T08:20:44.000Z</published>
    <updated>2019-04-20T10:55:16.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h2><h3 id="dfs版"><a href="#dfs版" class="headerlink" title="dfs版"></a>dfs版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> rnd, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (status == two[num] - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[i][status] &gt; <span class="number">0</span>) <span class="keyword">return</span> f[i][status];</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = num; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (j != i &amp;&amp; (!(status &amp; temp))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q &gt; dfs(j, rnd + <span class="number">1</span>, status | temp) + a[need[i]][need[j]]) &#123;</span><br><span class="line">                q = dfs(j, rnd + <span class="number">1</span>, status | temp) + a[need[i]][need[j]];</span><br><span class="line">                c[i][status] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[i][status] = q;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bfs版"><a href="#bfs版" class="headerlink" title="bfs版"></a>bfs版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(start);</span><br><span class="line">    vis[start] = <span class="literal">true</span>;</span><br><span class="line">    s[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = u + ok[i];</span><br><span class="line">            <span class="keyword">int</span> v2 = u - ok[i];</span><br><span class="line">            <span class="keyword">if</span> (v1 &lt;= n &amp;&amp; !vis[v1]) &#123;</span><br><span class="line">                Q.push(v1);</span><br><span class="line">                s[v1] = s[u] + <span class="number">1</span>;</span><br><span class="line">                vis[v1] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v2 &gt;= <span class="number">0</span> &amp;&amp; !vis[v2]) &#123;</span><br><span class="line">                Q.push(v2);</span><br><span class="line">                s[v2] = s[u] + <span class="number">1</span>;</span><br><span class="line">                vis[v2] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) e[i] = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">int</span> sn = <span class="number">1</span> &lt;&lt; cnt1; <span class="comment">//状态数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sn; ++i) f[i] = INF;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sn; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &amp; e[j]) ++j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p = j + <span class="number">1</span>; p &lt; cnt1; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(i &amp; e[p]) &amp;&amp; dist[p+<span class="number">1</span>][j+<span class="number">1</span>]) &#123;</span><br><span class="line">            f[i | e[j] | e[p]] = min(f[i | e[j] | e[p]], f[i] + dist[p+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> f[sn<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//别忘了初始化f[i]=i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = f[x];</span><br><span class="line">    <span class="keyword">while</span>(root != f[root]) root = f[root];</span><br><span class="line">    <span class="keyword">int</span> y = f[x];</span><br><span class="line">    <span class="keyword">while</span>(f[x] != root)&#123;</span><br><span class="line">        f[x] = f[y];</span><br><span class="line">        y = f[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(a, b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(a);</span><br><span class="line">    <span class="keyword">int</span> fb = find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa != fb) f[fa] = fb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> temp = f[x];</span><br><span class="line">    f[x] = find(temp);</span><br><span class="line">    rel[x] = (rel[x] + rel[temp]) % <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//rel[x]初始化为全0</span></span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">        f[fy] = fx;</span><br><span class="line">        rel[fy] = (<span class="number">3</span> + d + rel[x] - rel[y]) % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span>) <span class="keyword">return</span> (rel[x] == rel[y]);</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">1</span>) <span class="keyword">return</span> ((<span class="number">3</span> - rel[x] + rel[y]) % <span class="number">3</span> == d); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fu = find(e[i].u);</span><br><span class="line">        <span class="keyword">int</span> fv = find(e[i].v);</span><br><span class="line">        <span class="keyword">if</span> (fu != fv) &#123;</span><br><span class="line">            f[fv] = fu;</span><br><span class="line">            ans += e[i].weight;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">//序号，找边权用</span></span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;y) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &lt; y.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;vertex[MAXN] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue &lt;node&gt; q;</span><br><span class="line">    vertex[<span class="number">0</span>].d = <span class="number">0</span>;</span><br><span class="line">    q.push(vertex[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u.id].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> vid = son[u.id][i];</span><br><span class="line">            <span class="keyword">double</span> weight = w[u.id][i];</span><br><span class="line">            <span class="keyword">if</span>(vertex[vid].d &lt; u.d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vertex[vid].d &gt; u.d + weight)&#123;</span><br><span class="line">                vertex[vid].d = u.d + weight;</span><br><span class="line">                q.push(vertex[vid]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j] &gt; <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j])</span><br><span class="line">                    <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="各种tarjan"><a href="#各种tarjan" class="headerlink" title="各种tarjan"></a>各种tarjan</h1><h2 id="有向图强连通分量数"><a href="#有向图强连通分量数" class="headerlink" title="有向图强连通分量数"></a>有向图强连通分量数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfn[u] u的时间戳</span></span><br><span class="line"><span class="comment">//low[u] u或u的子树能够追溯到的最早栈中节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++cnt;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    stack1[++index] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v]) low[u] = min(low[u], dfn[v]); <span class="comment">//u-v is a back edge</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">        scnum ++; <span class="comment">//强连通分量数</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            belong[stack1[index]] = scnum;</span><br><span class="line">            num[scnum] ++;</span><br><span class="line">            vis[stack1[index]] = <span class="literal">false</span>;</span><br><span class="line">            index --;</span><br><span class="line">        &#125;<span class="keyword">while</span>(u != stack1[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">//     if(!dfn[i]) &#123;</span></span><br><span class="line"><span class="comment">//         cnt = 1;</span></span><br><span class="line"><span class="comment">//         tarjan(i);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="无向图割点与割边"><a href="#无向图割点与割边" class="headerlink" title="无向图割点与割边"></a>无向图割点与割边</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">    dfs_clock ++;</span><br><span class="line">    dfn[u] = low[u] = dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v,u);</span><br><span class="line">            child ++;</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>((u == <span class="number">1</span> &amp;&amp; child &gt; <span class="number">1</span>) || (u != <span class="number">1</span> &amp;&amp; dfn[u] &lt;= low[v])) &#123;</span><br><span class="line">                cut.push_back(u); <span class="comment">//割点判定</span></span><br><span class="line">                <span class="comment">//iscut[u] = true;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u]) </span><br><span class="line">                bridge.push_back(&#123;min(u,v), max(u,v)&#125;); <span class="comment">//割边判定</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v != pre)</span><br><span class="line">                low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tarjan(1,-1);</span></span><br></pre></td></tr></table></figure><h2 id="无向图双连通分量"><a href="#无向图双连通分量" class="headerlink" title="无向图双连通分量"></a>无向图双连通分量</h2><p>点（边）双连通分量：若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥），则称作点（边）双连通图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    dfs_clock ++;</span><br><span class="line">    dfn[u] = low[u] = dfs_clock;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v,u);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &lt; dfn[u] &amp;&amp; v != pre) low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计无向图的边双连通分量，在一个双连通分量中当且仅当low[u] == low[v]</span></span><br></pre></td></tr></table></figure><h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">directed_euler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> moreout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> morein = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ver[i].indeg &gt; ver[i].outdeg) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ver[i].indeg == ver[i].outdeg + <span class="number">1</span>) morein ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ver[i].deg &lt; ver[i].outdeg) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ver[i].outdeg == ver[i].indeg + <span class="number">1</span>) moreout++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("morein = %d, moreout = %d", morein, moreout);</span></span><br><span class="line">    <span class="keyword">if</span>(morein &lt;= <span class="number">1</span> &amp;&amp; moreout &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断连通有向图是否含欧拉迹</span></span><br><span class="line"><span class="comment">//至多一顶点出度=入度+1</span></span><br><span class="line"><span class="comment">//至多一顶点入度=出度+1</span></span><br><span class="line"><span class="comment">//其余顶点：入度=出度</span></span><br></pre></td></tr></table></figure><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">undirected_euler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(ver[i].deg % <span class="number">2</span> == <span class="number">1</span>) odd++;</span><br><span class="line">    <span class="keyword">if</span>(odd == <span class="number">0</span> || odd == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈密尔顿回路"><a href="#哈密尔顿回路" class="headerlink" title="哈密尔顿回路"></a>哈密尔顿回路</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hamilton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    path.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size() - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[path[j]][i] &amp;&amp; <span class="built_in">map</span>[i][path[j + <span class="number">1</span>]])&#123;</span><br><span class="line">                path.insert(path.begin() + j + <span class="number">1</span>, i);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[path.back()][i]) path.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> path.insert(path.begin(), i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h1><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">0</span> || find(match[i]))&#123;</span><br><span class="line">                match[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">if</span>(find(i)) ans ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KM：最小权匹配"><a href="#KM：最小权匹配" class="headerlink" title="KM：最小权匹配"></a>KM：最小权匹配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    S[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!T[j] &amp;&amp; ls[i] + lt[j] == <span class="built_in">map</span>[i][j]) &#123;</span><br><span class="line">            T[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!match[j] || find(match[j])) &#123;</span><br><span class="line">                match[j] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> relax_val = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(n,m); ++i)</span><br><span class="line">        <span class="keyword">if</span>(S[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j)</span><br><span class="line">                <span class="keyword">if</span>(!T[j] &amp;&amp; ls[i] + lt[j] &gt; <span class="built_in">map</span>[i][j]) relax_val = min(relax_val, ls[i] + lt[j] - <span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    assert(relax_val &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i]) ls[i] -= relax_val;</span><br><span class="line">        <span class="keyword">if</span> (T[i]) lt[i] += relax_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match, <span class="number">0</span>, <span class="keyword">sizeof</span>(match));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(m,n); ++i) &#123;</span><br><span class="line">        ls[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; ++j) ls[i] = max(<span class="built_in">map</span>[i][j], ls[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) lt[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(n,m); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(S, <span class="number">0</span>, <span class="keyword">sizeof</span>(S));</span><br><span class="line">            <span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T));</span><br><span class="line">            <span class="keyword">if</span> (find(i)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> relax();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="Dinic-当前弧优化"><a href="#Dinic-当前弧优化" class="headerlink" title="Dinic+当前弧优化"></a>Dinic+当前弧优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0</span> , <span class="keyword">sizeof</span>(depth));</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    depth[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[u][v] &gt; <span class="number">0</span> &amp;&amp; !depth[v]) &#123;</span><br><span class="line">                depth[v] = depth[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth[t] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 寻找当前增广路径上的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> dist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i = cur[u]; i &lt; son[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[u][i];</span><br><span class="line">        <span class="keyword">if</span>(depth[v] == depth[u] + <span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[u][v] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> minc = dfs(v, min(dist, <span class="built_in">map</span>[u][v]));</span><br><span class="line">            <span class="keyword">if</span>(minc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">map</span>[u][v] -= minc;</span><br><span class="line">                <span class="built_in">map</span>[v][u] += minc;</span><br><span class="line">                <span class="keyword">return</span> minc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span> , <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">int</span> minc = dfs(s, INF)) &#123;</span><br><span class="line">            ans += minc;</span><br><span class="line">            <span class="comment">//printf("minc=%d\n",minc);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2row</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) swap(a[x][i], a[y][i]);</span><br><span class="line">    <span class="comment">//printf("**swap row %d with row %d**\n",x,y);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot_one</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> temp = a[x][y];</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i &lt;= n + <span class="number">1</span>; ++i) a[x][i] /= temp;</span><br><span class="line">    <span class="comment">//printf("**pivot one at row %d**\n", x);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul_and_add</span><span class="params">(<span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">double</span> cof)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        a[dst][i] -= a[src][i] * cof;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("**mul row %d with %lf add to row %d**\n", src, cof, dst);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_matrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">printf</span>(<span class="string">"%lf "</span>, a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"| %lf\n"</span>, a[i][n + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">iszero</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(a[row][i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Guass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">1</span>, col = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(row &lt;= n &amp;&amp; col &lt;= n) &#123;</span><br><span class="line">        <span class="comment">//printf("Now row=%d, col=%d\n",row, col);</span></span><br><span class="line">        <span class="keyword">if</span>(a[row][col] == <span class="number">0.0</span>) &#123;</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = row + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                <span class="keyword">if</span>(a[i][col] != <span class="number">0</span>) &#123;</span><br><span class="line">                    swap2row(row, i);</span><br><span class="line">                    ok = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(ok == <span class="literal">false</span>) &#123;col++; <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="comment">//else print_matrix();</span></span><br><span class="line">        &#125;</span><br><span class="line">        pivot_one(row,col);</span><br><span class="line">        <span class="keyword">if</span>(col == n &amp;&amp; row == n &amp;&amp; a[row][col] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//print_matrix();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(i != row &amp;&amp; a[i][col] != <span class="number">0</span>) &#123;</span><br><span class="line">                assert(a[row][col] != <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">double</span> cof = a[i][col] / a[row][col];</span><br><span class="line">                <span class="keyword">if</span>(cof != <span class="number">0</span>) mul_and_add(row, i, cof);</span><br><span class="line">                assert(a[i][col] == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//print_matrix();</span></span><br><span class="line">        row ++; col ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性规划-–-simplex单纯形算法"><a href="#线性规划-–-simplex单纯形算法" class="headerlink" title="线性规划 – simplex单纯形算法"></a>线性规划 – simplex单纯形算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; -EPS) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; EPS ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    swap(id[n + r], id[c]);</span><br><span class="line">    <span class="keyword">double</span> x = -a[r][c];</span><br><span class="line">    a[r][c] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) a[r][i] /= x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sgn(a[i][c]) &amp;&amp; i != r) &#123;</span><br><span class="line">            x = a[i][c];</span><br><span class="line">            a[i][c] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) a[i][j] += x * a[r][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* important: revert symbols of conditions */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            a[i][j] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) id[i] = i;</span><br><span class="line">    <span class="comment">/* initial-simplex */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[i][<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123; x = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[x][i]) &gt; <span class="number">0</span>) &#123; y = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!y) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// infeasible</span></span><br><span class="line">        pivot(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* solve-simplex */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[<span class="number">0</span>][i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        printf("choose x%d, cof=%d\n", x, a[0][x]);</span></span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">break</span>; <span class="comment">// finished</span></span><br><span class="line">        <span class="keyword">double</span> w = <span class="number">0</span>, t = <span class="number">0</span>; <span class="comment">//t是最苛刻的非基本变量能取到的最大值</span></span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sgn(a[i][x]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                t = ((<span class="keyword">double</span>)-a[i][<span class="number">0</span>]) / ((<span class="keyword">double</span>)a[i][x]);</span><br><span class="line"><span class="comment">//                if(x==3) printf("t: -%d / %d = %.lf\n", a[i][0], a[i][x], t);</span></span><br><span class="line">                <span class="keyword">if</span> (f || t &lt; w) &#123;</span><br><span class="line">                    w = t, y = i, f = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="comment">// unbounded</span></span><br><span class="line">        pivot(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) v[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; ++i) v[id[i]] = a[i - n][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">  kmp[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len2; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s2[i] != s2[j + <span class="number">1</span>]) j = kmp[j];</span><br><span class="line">    <span class="keyword">if</span>(s2[j + <span class="number">1</span>] == s2[i]) j ++;</span><br><span class="line">    kmp[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s1[i] != s2[j + <span class="number">1</span>]) j = kmp[j];</span><br><span class="line">    <span class="keyword">if</span>(s1[i] == s2[j + <span class="number">1</span>]) ++j;</span><br><span class="line">    <span class="keyword">if</span>(j == len2 - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - len2 + <span class="number">2</span>);</span><br><span class="line">      j = kmp[j];</span><br><span class="line">      ok = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="comment">/*字典树*/</span></span><br><span class="line">    <span class="keyword">int</span> tot, root;</span><br><span class="line">    <span class="keyword">int</span> nxt[MAXN][<span class="number">26</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">      tot = <span class="number">1</span>;</span><br><span class="line">      root = newNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">memset</span>(nxt[tot], <span class="number">0</span> ,<span class="keyword">sizeof</span>(nxt[tot]));</span><br><span class="line">      <span class="keyword">return</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> cur = root;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(nxt[cur][id] == <span class="number">0</span>) nxt[cur][id] = newNode();</span><br><span class="line">        cur = nxt[cur][id];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">          <span class="keyword">if</span>(nxt[i][j] != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"S.nxt[%d][%c]=%d\n"</span>,i, j+<span class="string">'a'</span>, nxt[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;S;</span><br></pre></td></tr></table></figure><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n, ll mod)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*快速幂*/</span></span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  a %= mod;</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = (ans * a) % mod;</span><br><span class="line">    a = (a * a) % mod;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;状态压缩dp&quot;&gt;&lt;a href=&quot;#状态压缩dp&quot; class=&quot;headerlink&quot; title=&quot;状态压缩d
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>os期中复习</title>
    <link href="https://mengzelev.github.io/2019/04/15/os-midterm/"/>
    <id>https://mengzelev.github.io/2019/04/15/os-midterm/</id>
    <published>2019-04-15T14:17:55.000Z</published>
    <updated>2019-06-22T15:58:43.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用眼中的OS"><a href="#应用眼中的OS" class="headerlink" title="应用眼中的OS"></a>应用眼中的OS</h1><ul><li>操作系统一方面需要提供程序的<strong>执行的环境</strong>和<strong>相应的资源</strong>，还要提供<strong>和操作系统世界中其他对象交互的方法和约定</strong></li></ul><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="共享内存多线程"><a href="#共享内存多线程" class="headerlink" title="共享内存多线程"></a>共享内存多线程</h2><ul><li>并发定义：一个程序、算法或问题的不同部分乱序或偏序执行而不影响最终结果的能力</li><li><p>程序经历了什么？</p><ul><li>编译器优化$\to$顺序丧失</li><li>操作系统中断，多处理器、缓存(硬件)$\to$原子性(all or nothing)丧失</li><li>缓存，乱序（硬件）$\to$可见性丧失</li></ul></li><li><p>顺序丧失：允许源代码中内存访问指令不再按顺序甚至不再出现</p></li><li>原子性的丧失：指令序列可以在任意时刻被中断，然后操作系统切换到其他线程执行</li><li>可见性丧失：缓存&amp;乱序</li></ul><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>评估一把锁的基本准则</p><ul><li>能够完成基本任务：提供互斥性质</li><li>锁的分配是公平的：不会有现成想要上锁却永远得不到它</li><li>锁的高效的：无等待时性能？多线程同时等待时性能？多CPU每个核的线程都要上锁时性能？</li></ul><p>自旋锁的正确性证明：</p><ul><li>建模程序的状态</li><li>证明safety(只有一个线程进入临界区)和liveness(至少有一个线程能进入临界区)</li></ul><h3 id="几种上锁方法"><a href="#几种上锁方法" class="headerlink" title="几种上锁方法"></a>几种上锁方法</h3><ul><li>TestAndSet；相当于<code>atomic_xchg</code></li><li>CompareAndWait</li><li>LL&amp;SC</li><li>FetchAndAdd：彩票锁，保证公平性</li></ul><h2 id="同步-CV"><a href="#同步-CV" class="headerlink" title="同步(CV)"></a>同步(CV)</h2><ul><li><code>wait(&amp;cond)</code>：当前进程进入睡眠状态，等待cond被满足后唤醒</li><li><code>signal(&amp;cond)</code>：唤醒在等待cond条件的某个进程</li><li><code>broadcast(&amp;cond)</code>: 唤醒在等待cond条件的所有进程</li><li>需要配合互斥锁使用：读取状态到<code>wait()</code>之间不能被打断，改变状态到<code>signal</code>之间也不能被打断</li></ul><h3 id="使用条件变量"><a href="#使用条件变量" class="headerlink" title="使用条件变量"></a>使用条件变量</h3><p>记 得 上 锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line">    done[id] = <span class="number">1</span>;</span><br><span class="line">    signal(&amp;joins);</span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nworkers; ++i) create(worker,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nworkers; ++i) &#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(!done[i]) wait(&amp;joins, &amp;mutex);</span><br><span class="line">        mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>互斥锁(二元信号量)和同步都可以使用信号量来实现<br>信号量就相当于有一个管理员manage了一堆资源，进程需要资源时先向管理员请求(<code>semi_wait</code>)，暂时没有资源就等，使用完毕后归还(<code>semi_post</code>)给管理员</p><p>需要配合锁使用<br>注意死锁：lock之后P，其他线程是无法获得lock的</p><p>期中考题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'('</span>: lock(<span class="string">"("</span>); <span class="comment">// assume lock can nest</span></span><br><span class="line">     <span class="built_in">putchar</span>(); V(fill1);</span><br><span class="line"><span class="string">')'</span>: P(fill1); <span class="built_in">putchar</span>();</span><br><span class="line">     unlock(<span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">'['</span>: lock(<span class="string">"("</span>);</span><br><span class="line">     <span class="built_in">putchar</span>();</span><br><span class="line">     V(fill2);</span><br><span class="line">     unlock(<span class="string">"("</span>);</span><br><span class="line"><span class="string">']'</span>: P(fill2);</span><br><span class="line">     lock(<span class="string">"("</span>);</span><br><span class="line">     <span class="built_in">putchar</span>();</span><br><span class="line">     unlock(<span class="string">"("</span>);</span><br></pre></td></tr></table></figure><ul><li>不能上一把大锁（会死锁），所以拆了小锁来保证原子性</li><li>P不能在锁中间进行</li><li>自旋锁是为了保证圆括号和方括号不冲突（互斥），信号量是为了保证左右括号配对（同步）</li><li>之所以用锁而非信号量来处理圆括号和方括号的关系，是因为为了保证原子性本来就要上锁，这样一举两得。用信号量不是不可以，但一样也要上锁，造成了资源浪费。</li></ul><h3 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h3><ul><li><code>sem_wait</code>：信号量-1，表示在等待的线程增加了一个，消耗一个执行名额；如果信号量&lt;0, 表示等待的线程数多于可执行线程数，当前线程进入睡眠</li><li><code>sem_post</code>：信号量+1，表示执行的线程少了一个，可以让出一个执行名额</li></ul><h3 id="哲学家吃饭问题"><a href="#哲学家吃饭问题" class="headerlink" title="哲学家吃饭问题"></a>哲学家吃饭问题</h3><p>One general solution: 让一个人集中管理所有叉子(信号量)</p><h2 id="并发Bugs"><a href="#并发Bugs" class="headerlink" title="并发Bugs"></a>并发Bugs</h2><ul><li>原子性违反(AV) –&gt; 上锁</li><li>顺序违反(OV) –&gt; 同步</li></ul><h3 id="死锁出现的四个条件"><a href="#死锁出现的四个条件" class="headerlink" title="死锁出现的四个条件"></a>死锁出现的四个条件</h3><ul><li>互斥</li><li>请求与保持(同一个进程要同时上多把锁)</li><li>没有抢占(不能强制解锁)</li><li>循环等待</li></ul><h3 id="对付死锁"><a href="#对付死锁" class="headerlink" title="对付死锁"></a>对付死锁</h3><ul><li>避免：规定上锁顺序</li><li>检测：打log</li></ul><h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><p>每个进程都以为自己独占CPU和整个内存空间<br>进程：OS提供的对运行程序的抽象</p><h2 id="进程抽象"><a href="#进程抽象" class="headerlink" title="进程抽象"></a>进程抽象</h2><p>CPU执行指令时假设自己直接占有整个CPU<br>进程分时共享物理CPU</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>Running: 进程正在处理器上执行命令</li><li>Ready：进程准备执行，但由于某些原因OS决定现在不让它运行</li><li>Blocked：进程此前执行了某些操作(e.g. I/O)，让它在其他事件发生前停止执行</li></ul><h3 id="实现进程"><a href="#实现进程" class="headerlink" title="实现进程"></a>实现进程</h3><ul><li>进程=线程+地址空间</li><li>进程就是个结构体<ul><li>名字</li><li>pid</li><li>上下文</li><li>地址空间</li><li>堆栈</li><li>状态</li><li>其他信息（如父进程、文件描述符等）</li></ul></li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul><li>fork</li><li>execve</li><li>exit<ul><li><code>exit()</code>是库函数，<code>_exit()</code>是系统调用</li></ul></li></ul><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>一个指向os内对象的指针<br><code>fork-exec</code>不改变文件描述符<br><code>int dup2(int oldfd, int newfd);</code> - 关闭<code>newfd</code>，并复制<code>oldfd</code>到<code>newfd</code>(<code>dup+close</code>的并发版)</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">assert(pid != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(...);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    close(fd);</span><br><span class="line">    execve(...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pipe(fds) != <span class="number">0</span>) &#123;panic(<span class="string">"pipe error"</span>);&#125;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;<span class="comment">//child</span></span><br><span class="line">    dup2(fds[<span class="number">1</span>], STUOUT_FILENO); <span class="comment">//连接写口，往管道内写数据</span></span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; <span class="comment">//parent</span></span><br><span class="line">    dup2(fds[<span class="number">0</span>], STDIN_FILENO); <span class="comment">//连接读口，从管道内读数据</span></span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>进程组实现</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h3><ul><li>轮转时间(turnaround time): $\sum t_{complete}-t_{arrival}$</li><li>响应时间(response time): $\sum t_{firstrun}-t_{arrival}$</li></ul><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><ul><li>优点：简单易实现</li><li>缺点： 会产生护航效应（有一个<s>不要脸的</s>任务占坑很久）</li></ul><h3 id="SJF-Shortest-Job-First"><a href="#SJF-Shortest-Job-First" class="headerlink" title="SJF(Shortest Job First)"></a>SJF(Shortest Job First)</h3><ul><li>当假设所有任务同时到达时的最优算法</li><li>非抢占式(preemptive)算法</li></ul><h3 id="STCF-Shortest-Time-to-Completion-First"><a href="#STCF-Shortest-Time-to-Completion-First" class="headerlink" title="STCF(Shortest Time-to-Completion First)"></a>STCF(Shortest Time-to-Completion First)</h3><ul><li>抢占式策略，又名Preemptive Shortest Job First(PSJF)</li><li>轮转时间短但响应时间长</li></ul><h3 id="RR-Round-Robin"><a href="#RR-Round-Robin" class="headerlink" title="RR(Round Robin)"></a>RR(Round Robin)</h3><ul><li>每个进程运行一段时间片(time slice, sometimes called scheduling quantum)</li><li>时间片越短，响应时间越短，但是切换上下文的时间会变长(trade-off)</li><li>当考虑轮转时间时非常糟糕</li><li>保证了公平性但是损失了效率</li></ul><h3 id="MLFQ-Multi-level-Feedback-Queue"><a href="#MLFQ-Multi-level-Feedback-Queue" class="headerlink" title="MLFQ(Multi-level Feedback Queue)"></a>MLFQ(Multi-level Feedback Queue)</h3><p>MLFQ有很多种实现但都大同小异，书上只介绍一种</p><ul><li>有很多队列，每个队列具有不同的优先级，优先级高的先运行</li><li>通过观察进程过去的行为调整优先级<ul><li>如果一个进程频繁让出CPU，保持高优先级；反之一个进程如果长时间占用CPU则会被降低优先级</li></ul></li><li>并不知道一个任务是长是短，因此先假设是短的，然后根据进程的后续表现修改认知</li></ul><h4 id="优先级的修改"><a href="#优先级的修改" class="headerlink" title="优先级的修改"></a>优先级的修改</h4><p>workload: 交互式短时间任务(会频繁让出CPU)+不交互的长时间任务(响应时间不那么重要)</p><h4 id="Basic-Rules"><a href="#Basic-Rules" class="headerlink" title="Basic Rules"></a>Basic Rules</h4><ol><li>If Priority(A)&gt;Priority(B), A runs (B doesn’t)</li><li>If Priority(B)==Priority(B), A &amp; B runs in RR</li><li>一个任务最初进入系统时位于最高优先级<br>4(a). 如果一个任务耗尽了时间片，则优先级下降<br>4(b). 如果一个任务在时间片耗尽之前放弃了CPU,优先级不变<br>4(改进). 当一个任务在一定程度上用尽了被分配到的时间，优先级就下降<br>5(新增). 在一段时间$S$后，将所有任务移到最高优先级上(Priority-boost) </li></ol><p>缺陷： </p><ul><li>饥饿：如果交互式进程很多就会完全占用CPU使得长任务得不到调度(5解决)</li><li>有些心脏的应用可以玩弄这个规则，一直主动让出一小会儿CPU来使自己停留在高优先级上(4解决)</li><li>任务的行为可能会随着时间改变(5解决)</li></ul><h3 id="PS-Proportional-share"><a href="#PS-Proportional-share" class="headerlink" title="PS(Proportional-share)"></a>PS(Proportional-share)</h3><ul><li>老子才不管什么的轮转时间和响应时间，老子只要每个任务都能按比例分到一定时间</li></ul><h4 id="lottery-scheduling"><a href="#lottery-scheduling" class="headerlink" title="lottery scheduling"></a>lottery scheduling</h4><blockquote><p>随机的好处</p><ul><li>防止了边界情况</li><li>轻量级，需要记录的信息少</li><li>快(太快了可能会变成伪随机数)</li></ul></blockquote><p>怎么分配彩票也是个很棘手的问题</p><h4 id="stride-scheduling"><a href="#stride-scheduling" class="headerlink" title="stride scheduling"></a>stride scheduling</h4><ul><li>根据每个任务的彩票数决定每次调度执行的时间长短</li><li>每次调度都选取运行时间最短的任务</li></ul><h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><p>不想看了【瘫</p><h2 id="链接和加载"><a href="#链接和加载" class="headerlink" title="链接和加载"></a>链接和加载</h2><ul><li>静态链接下的加载：<code>_start(程序自己的)-&gt;__libc_start_main-&gt;generic_start_main-&gt;...-&gt;main</code></li><li>动态链接：<ul><li>PLT：程序链接表，放入进行链接的代码，方便lazy linking(名字叫表格其实就是一小段代码，用来判断是否已经完成链接)</li><li>GOT：全局偏移表，存放函数代码开始的地址</li></ul></li></ul><h3 id="第一条指令"><a href="#第一条指令" class="headerlink" title="第一条指令"></a>第一条指令</h3><ul><li>静态链接：<code>a.out</code>的entry</li><li>动态链接：<code>ld.so</code>的entry</li><li>动态链接libc：链接器使用一系列mmap把libc链接进进程地址空间</li></ul><h2 id="虚存抽象"><a href="#虚存抽象" class="headerlink" title="虚存抽象"></a>虚存抽象</h2><p>多级页表(PML): 复习ICS<br>反置页表(IPT): 硬件维护一个全局的hash table，计算$f(as,x)$<br>IPT实现Copy-on-Write有困难，且PML能高效地标记一段连续内存为某个权限</p><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>把操作系统里的对象映射到进程的地址空间</p><ul><li>e.g.加载可执行文件的时候把文件搬到某个地址处</li><li>不映射任何文件的时候就相当于malloc</li><li>只记录相关信息，余下的等发生缺页时再处理，所以非常快</li><li>可以用红黑树维护分配的内存</li><li>fork采用写时复制</li></ul><h3 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h3><p><code>pmap</code>-查看进程的地址空间</p><p>静态链接的程序的地址空间：代码、数据、bss、堆、栈、用户态系统调用<br>动态链接：多了动态链接库和链接器</p><h1 id="期中复习"><a href="#期中复习" class="headerlink" title="期中复习"></a>期中复习</h1><p>系统调用：操作系统为用户进程提供的一组API，通常在内核空间中实现，实现用户进程对操作系统对象/物理硬件访问的请求。<br>进程=操作系统中的数据<br>系统调用=这些数据上的操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;应用眼中的OS&quot;&gt;&lt;a href=&quot;#应用眼中的OS&quot; class=&quot;headerlink&quot; title=&quot;应用眼中的OS&quot;&gt;&lt;/a&gt;应用眼中的OS&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;操作系统一方面需要提供程序的&lt;strong&gt;执行的环境&lt;/strong&gt;和&lt;strong
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>问题求解学习笔记-密码算法</title>
    <link href="https://mengzelev.github.io/2019/04/13/ps-4-7-cryptographic-algorithm/"/>
    <id>https://mengzelev.github.io/2019/04/13/ps-4-7-cryptographic-algorithm/</id>
    <published>2019-04-13T04:04:44.000Z</published>
    <updated>2019-06-19T02:47:13.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RSA公钥加密系统"><a href="#RSA公钥加密系统" class="headerlink" title="RSA公钥加密系统"></a>RSA公钥加密系统</h1><p>每个参与者都有一把公钥($P$)和密钥($S$)</p><p>$\mathcal{D}$表示允许信息的集合，要求公钥与密钥指定一种从$\mathcal{D}$到自身的一一对应的函数。<br>Alice的公钥函数$P_A$和密钥函数$S_A$都是$\mathcal{D}$的排列</p><p>系统中任何参与者的公钥与密钥都是匹配对，指定函数互为反函数，对任何消息$M\in \mathcal{D}$，有<br>$$M=S_A(P_A(M))$$<br>$$M=P_A(S_A(M))$$</p><h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><ul><li>Bob取得Alice的公钥$P_A$</li><li>Bob计算出相应与$M$的密文$C=P_A(M)$，并把$C$发送给Alice</li><li>当Alice收到密文$C$后，运用自己的密钥$S_A$恢复原始信息$M$</li></ul><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul><li>Alice运用密钥$S_A$和等式$\sigma=S_A)M’$计算出信息$M’$的数字签名$\sigma$</li><li>Alice把消息/签名对$(M’,\sigma)$发给Bob</li><li>Bob收到$(M’,\sigma)$时，通过验证等式$M’=P_A(\sigma)$来证实消息的确是来自Alice</li></ul><p>任何人都可以把数字签名翻译出来，但只有密钥持有者可以生成数字签名</p><h2 id="RSA加密系统"><a href="#RSA加密系统" class="headerlink" title="RSA加密系统"></a>RSA加密系统</h2><p><img src="/2019/04/13/ps-4-7-cryptographic-algorithm/rsa.png"></p><p>加密<br>$$P(M)=M^e\bmod n$$<br>解密<br>$$S(C)=C^d\bmod n$$</p><p>上述加密解密操作可以使用快速幂实现。</p><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>假定：</p><ul><li>公钥$(e,n)$和密钥$(d,n)$满足$\lg~e=O(1), \lg~d\le\beta, \lg~n\le\beta$</li><li>应用公钥需要执行$O(1)$次模乘法运算和$O(\beta^2)$次位操作</li><li>应用密钥需要执行$O(\beta)$次模乘法运算和$O(\beta^2)$次位操作。</li></ul><h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p><strong>定理31.36(RSA的正确性)</strong>：RSA加密和解密等式定义了满足再上面两个等式的$\mathbb{Z}_n$的逆变换</p><p>RSA加密系统的安全性主要来源于对大整数进行因子分解的困难性</p><h3 id="效率提高"><a href="#效率提高" class="headerlink" title="效率提高"></a>效率提高</h3><ul><li>无公钥加密系统</li><li>抗冲突散列函数$h$</li><li>证书</li></ul><h1 id="整数的因子分解"><a href="#整数的因子分解" class="headerlink" title="整数的因子分解"></a>整数的因子分解</h1><h3 id="Pollard的rho启发式方法"><a href="#Pollard的rho启发式方法" class="headerlink" title="Pollard的rho启发式方法"></a>Pollard的rho启发式方法</h3><p><img src="/2019/04/13/ps-4-7-cryptographic-algorithm/pr.png"></p><ul><li>通过随机数寻找$n$的非平凡约数</li><li>可能会出现”$\rho$”字型回路，在出现回路之前预计要执行的步数为$\Theta(\sqrt{n})$</li><li>一种找出大整数的小素数因子的可供选择的办法</li></ul><h2 id="私钥密码学"><a href="#私钥密码学" class="headerlink" title="私钥密码学"></a>私钥密码学</h2><p>仿射密码系统(affine cryptosystem)：$f(p)=ap+b\bmod 26$, $f^{-1}(p)=a^{-1}p-a^{-1}b\bmod 26$</p><p>多字码密码系统(polyalphabetic cryptosystem): $f(\textbf{p})=A\textbf{p}+b$,其中$A$是矩阵，$b$是列向量，$f^{-1}(\textbf{p})=A^{-1}\textbf{p}-A^{-1}\textbf{p}$</p><h2 id="公钥密码学"><a href="#公钥密码学" class="headerlink" title="公钥密码学"></a>公钥密码学</h2><p>RSA加密系统（CLRS上已讲</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RSA公钥加密系统&quot;&gt;&lt;a href=&quot;#RSA公钥加密系统&quot; class=&quot;headerlink&quot; title=&quot;RSA公钥加密系统&quot;&gt;&lt;/a&gt;RSA公钥加密系统&lt;/h1&gt;&lt;p&gt;每个参与者都有一把公钥($P$)和密钥($S$)&lt;/p&gt;
&lt;p&gt;$\mathcal{
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-数论算法</title>
    <link href="https://mengzelev.github.io/2019/04/06/clrs-31Number-Theoretic-Algorithms/"/>
    <id>https://mengzelev.github.io/2019/04/06/clrs-31Number-Theoretic-Algorithms/</id>
    <published>2019-04-06T03:18:48.000Z</published>
    <updated>2019-06-18T09:43:32.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输入规模和算数计算的代价"><a href="#输入规模和算数计算的代价" class="headerlink" title="输入规模和算数计算的代价"></a>输入规模和算数计算的代价</h1><p>给定$k$个整数输入$a_1,a_2,\cdots ,a_k$，如果算法可以在关于$\lg~a_1,\lg~a_2,\cdots ,\lg~a_k$的多项式时间内完成，即算法在<strong>关于二进制编码后的输入长度</strong>的多项式时间内完成，则称该算法为<strong>多项式时间</strong>算法</p><p>当输入很大时，基本运算也会变得耗时。<br>两个$\beta$位整数相乘需要耗时$\Theta(\beta^2)$.<br>一个$\beta$为整数除以另一个较短整数的商或余数需要耗时$\Theta(\beta^2)$</p><h1 id="基础数论概念"><a href="#基础数论概念" class="headerlink" title="基础数论概念"></a>基础数论概念</h1><h2 id="整除性与约数"><a href="#整除性与约数" class="headerlink" title="整除性与约数"></a>整除性与约数</h2><p>你懂的</p><h2 id="素数与合数"><a href="#素数与合数" class="headerlink" title="素数与合数"></a>素数与合数</h2><p>你也懂的</p><h2 id="除法定理、余数和等模"><a href="#除法定理、余数和等模" class="headerlink" title="除法定理、余数和等模"></a>除法定理、余数和等模</h2><p><strong>定理31.1(除法定理)</strong>: 对于任何整数$a$和任何正整数$n$，存在唯一整数$q$和$r$，满足$0\le r&lt;n$且$a=qn+r$</p><p>根据整数模$n$的余数，可以将所有整数划分成$n$个等价类。<br>包含整数$a$的模$n$等价类为$\left[a\right]_n={a+kn:k\in\mathbb{Z}}$<br>所有这类等价类的集合是$\mathbb{Z}_n={[a]_n:0\le a\le n-1}$</p><h2 id="公约数与最大公约数"><a href="#公约数与最大公约数" class="headerlink" title="公约数与最大公约数"></a>公约数与最大公约数</h2><p>公约数的重要性质：</p><ul><li>$d\mid a$且$d\mid b$蕴含$d\mid (a+b)$且$d\mid (a-b)$</li><li>对任意整数$x$和$y$，都有$d\mid a$且$d\mid b$蕴含$d\mid(ax+by)$</li><li>$a\mid b$且$b\mid a$蕴含$a=\pm b$</li></ul><p><strong>定理31.2</strong>: 如果任意整数$a$和$b$不都为0，则gcd$(a,b)$是$a$与$b$线性组合集${ax+by:x,y\in\mathbb{Z}}$中的<strong>最小正元素</strong>。(最小正线性组合)</p><p><strong>推论31.3</strong>: 对任意整数$a$与$b$，如果$d\mid a$且$d\min b$，则$d\mid gcd(a,b)$</p><p><strong>推论31.4</strong>: 对所有整数$a$和$b$以及任意非负整数$n$，有$gcd(an,bn)=n~gcd(a,b)$</p><p><strong>推论31.5</strong>: 对于任意正整数$n,a$和$b$，如果$n\mid ab$且$gcd(a,n)=1$,则$n\mid b$.</p><h2 id="互质数"><a href="#互质数" class="headerlink" title="互质数"></a>互质数</h2><p><strong>定理31.6</strong>: 对任意整数$a,b$与$p$,如果$gcd(a,p)=1$且$gcd(b,p)=1$，则$gcd(ab,p)=1$.</p><h2 id="唯一因子分解定理"><a href="#唯一因子分解定理" class="headerlink" title="唯一因子分解定理"></a>唯一因子分解定理</h2><p><strong>定理31.7</strong>: 对所有素数$p$和所有整数$a,b$，如果$p\mid ab$,则$p\mid a$或$p\mid b$(或两者都成立)。</p><p><strong>定理31.8(唯一因子分解定理)</strong>: 合数$a$仅能以一种方式写成如下乘积形式<br>$$a=p_1^{e_1}p_2^{e_2}\cdots p_r^{e_r}$$<br>其中$p_i$为素数，$p_1&lt;p_2&lt;\cdots p_r$且$e_i$为正整数</p><h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><p><strong>定理31.9(GCD递归定理)</strong>: 对任意非负整数$a$和任意正整数$b$，$gcd(a,b)=gcd(b,a\bmod b)$</p><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p><strong>引理31.10</strong>: 如果$a&gt;b\ge 1$并且EUCLID($a,b$)执行了$k\ge 1$次递归调用，则$a\ge F_{k+2}， b\ge F_{k+1}$.($F_n$为斐波那契数列的第$n$项)</p><p><strong>定理31.11(Lame定理)</strong>: 对任意整数$k\ge 1$,如果$a&gt;b\ge 1$,且$b&lt;F_{k+1}$,则EUCLID($a,b$)的递归调用次数少于$k$次<br>该上界是最优的，因为$k\ge 2$时，EUCLID$(F_{k+1},F_k)$正好调用了$k$次</p><p>$F_k$约为$\phi^k/\sqrt{5}$, $\phi=(1+\sqrt{5})/2$<br>EUCLID执行中递归调用的次数为$O(\lg b)$<br>如果EUCLID作用于两个$\beta$位数，则将执行$O(\beta)$次算术运算和$O(\beta^3)$次位操作</p><h3 id="扩展形式"><a href="#扩展形式" class="headerlink" title="扩展形式"></a>扩展形式</h3><p>用于计算满足下列条件的整系数$x$和$y$(可能为0或负数):<br>$$d=gcd(a,b)=ax+by$$</p><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/exEUCLID.png"></p><p>运行时间与EUCLID相同</p><h1 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h1><p>群论复习</p><h2 id="模-n-加法群"><a href="#模-n-加法群" class="headerlink" title="模$n$加法群"></a>模$n$加法群</h2><p>你懂的</p><h2 id="模-n-乘法群"><a href="#模-n-乘法群" class="headerlink" title="模$n$乘法群"></a>模$n$乘法群</h2><p>$$(\mathbb{Z}_n^*, \cdot_n)$$</p><p>$$\mathbb{Z}_n^*={[a]_n\in\mathbb{Z}_n: gcd(a,n)=1}$$</p><p><strong>定理31.13</strong>: 模$n$乘法群是有限交换群</p><p>$\mathbb{Z}_n^*$中的除法由等式$a/b\equiv ab^{-1}\pmod n$定义</p><p>$\mathbb{Z}<em>n^*$的规模表示为欧拉phi函数($\phi(n)$)<br>$$\phi(n)=n\prod\limits</em>{p:\text{p is prime and }p\mid n}(1-\frac{1}{p})$$<br>直观理解(类似筛法求质数思想)：开始有一张$n$个余数组成的表，然后对于每个能整除$n$的素数$p$,在表中划掉所有$p$的倍数。</p><ul><li>若$p$是素数，则$\phi(p)=p-1$</li><li>若$n$是合数，$$\frac{n}{e^\gamma\ln\ln n+\frac{3}{\ln\ln n}}&lt;\phi(n)&lt;n-1$$($n\ge 3$, $\gamma=0.5772156649\cdots$是欧拉常数)<ul><li>$n&gt;5$时有个更松弛的下界$$\phi(n)&gt;\frac{n}{6\ln\ln n}$$</li></ul></li></ul><h2 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h2><p><strong>定理31.14</strong>: 一个有限群的非空封闭子集是一个子群</p><p><strong>定理31.15(拉格朗日定理)</strong>: 如果$(S,+)$是一个有限群，$(S’,+)$是$(S,+)$的一个子群，则$|S’|$是$|S|$的一个约数</p><p><strong>推论31.16</strong>: 如果$S’$是$S$的有限子群，则$|S’|\le |S|/2$</p><h2 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h2><p><strong>定理31.17</strong>: 对任意有限群$(S,+)$和任意$a\in S$, 一个元素的阶等于它所生成的循环子群的规模，即$ord(a)=|\langle a\rangle|$</p><p>$a^{(0)}=e, a^{(i)}=a^{(i\bmod t)}(t=\bmod a)$</p><p><strong>推论31.18</strong>: 序列$a^{(1)},a^{(2)},\cdots$是周期序列，其周期为$t=\bmod a$, 即$a^{(i)}=a^{(j)}$当且仅当$i\equiv j\pmod t$</p><p><strong>推论31.19</strong>: 如果$(S,+)$是具有单位元$e$的有限群，则对所有$a\in S$，$a^{(|S|)}=e$</p><h1 id="求解模线性方程"><a href="#求解模线性方程" class="headerlink" title="求解模线性方程"></a>求解模线性方程</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>$$ax\equiv b\pmod n$$<br>假设已知$a,b$和$n$，求出所有满足上述方程的对模$n$的$x$的值<br>该方程可能无解、仅有一解或有多解</p><h2 id="数学准备"><a href="#数学准备" class="headerlink" title="数学准备"></a>数学准备</h2><p><strong>定理31.20</strong>: 对任意正整数$a$和$n$，如果$d=gcd(a,n)$, 则在$\mathbb{Z}_n^*$中，$$\langle a\rangle=\langle d\rangle={0,d,2d,\cdots,((n/d)-1)d}$$<br>因此，$|\langle a\rangle|=n/d$.</p><p><strong>推论31.21</strong>: 当且仅当$d\mid b$时，方程$ax\equiv b\pmod n$对于未知量$x$有解。这里$d=gcd(a,n)$.<br>i.e. 当且仅当$[b]\in\langle a\rangle$时，方程有解</p><p><strong>推论31.22</strong>: 方程$ax\equiv b\pmod n$或者对模$n$有$d$个不同的解，或者无解。这里$d=gcd(a,d)$.</p><p><strong>定理31.23</strong>: 令$d=gcd(a,n)$, 假设对某些整数$x’$和$y’$,有$d=ax’+ny’$(例如EXTENDED-EUCLID所计算出的结果)。如果$d\mid b$,则方程$ax\equiv b\pmod n$有一个解的值为$x_0$,这里$x_0=x’(b/d)\pmod n$.</p><p><strong>定理31.24</strong>: 假设方程$ax\equiv b\pmod b$有解(即$d\mid b$),且$x_0$是该方程的任意一个解。因此，该方程对模$n$恰好有$d$个不同的解，分别为$x_i=x_0+i(n/d)$, 这里$i=0,1,\cdots,d-1$.</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/mod.png"></p><h2 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h2><p>执行$O(\lg n+gcd(a,n))$次算术运算</p><p><strong>推论31.25</strong>： 对任意$n&gt;1$, $a$和$n$互质时方程对模$n$有唯一解</p><p><strong>推论31.26</strong>： 对任意$n&gt;1$，若$a,n$互质，则方程$ax\equiv 1\pmod n$对模$n$有唯一解，否则方程无解。<br>因此，当$a$和$n$互质时，可以用记号$a^{-1}\bmod n$表示$a$对模$n$的乘法逆元</p><h1 id="中国余数定理"><a href="#中国余数定理" class="headerlink" title="中国余数定理"></a>中国余数定理</h1><p><strong>定理31.27(中国余数定理)</strong>: 令$n=n_1n_2\cdots n_k$,其中因子$n_i$两两互质。考虑以下对应关系:$$a\leftrightarrow(a_1,a_2,\cdots,a_k)$$这里$a\in\mathbb{Z}_n,a_i\in\mathbb{Z}_{n_i}$, 而且对$i=1,2,\cdots,k$, $$a_i=a\bmod n_i$$.</p><p>该映射是一个在$\mathbb{Z}<em>n$ 与笛卡尔积 $\mathbb{Z}</em>{n_1}\times\mathbb{Z}_{n_2}\times\cdots\times\mathbb{Z}_{n_k}$之间的一一对应，对$\mathbb{Z}_n$中元素所执行的运算可以等价地作用于对应的$k$元组</p><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/a+b.png"></p><p>从$(a_1,a_2,\cdots,a_k)$计算$a$：</p><ul><li>定义$m_i=n/n_i=n_1n_2\cdots n_{i-1}n_{i+1}\cdots n_l$</li><li>对$i=1,2, \cdots l$, 定义$c_i=m_i(m_i^{-1}\bmod n_i)$<ul><li>In fact, $c_i\leftrightarrow(0,0,\cdots ,0,1,0,\cdots 0)$ 除了在$i$个坐标上为1外其余坐标均为0</li></ul></li><li>$a\equiv (a_1c_1+a_2c_2+\cdots +a_kc_k)\pmod n$</li></ul><p>对任意$x$和$i=1,2,\cdots k,$有$x\bmod n_i=(x\bmod n)\mod n_i$.</p><p><strong>推论31.28</strong>: 如果$n_1,n_2,\cdots ,n_k$两两互质，$n=n_1n_2\cdots n_k$,则对任意整数$a_1,a_2,\cdots ,a_k$, 关于未知量$x$的联立方程组$$x\equiv a_i\pmod n_i,i=1,2,\cdots k$$对模$n$有唯一解</p><p><strong>推论31.29</strong>: 如果$n_1,n_2,\cdots ,n_k$两两互质，$n=n_1n_2\cdots n_k$, 则对所有整数$x$和$a$，$x\equiv a\pmod {n_i}$(其中$i=1,2,\cdots k$)当且仅当$x\equiv a\pmod n$.</p><p><strong>可以把模大数的线性方程转换为模小数的线性方程组</strong></p><h1 id="元素的幂"><a href="#元素的幂" class="headerlink" title="元素的幂"></a>元素的幂</h1><p><strong>定理31.30</strong>: 对于任意整数$n&gt;1$, $a^{\phi(n)}\equiv 1\pmod n$对所有$a\in\mathbb{Z}_n^*$都成立</p><p><strong>定理31.31</strong>: 若$p$是素数，则$a^{p-1}\equiv 1\pmod p$对所有$a\in\mathbb{Z}_p^*$都成立</p><p><strong>定理31.32</strong>: 对所有素数$p&gt;2$和所有正整数$e$，使得$\mathbb{Z}_n^*$是循环群的$n&gt;1$的值为2,4，$p^e$和$2p^e$。</p><p>若$g$是$\mathbb{Z}_n^<em>$的生成元，则对于任意$a\in\mathbb{Z}_n^</em>$存在一个$z$，使得$g^z\equiv a\pmod n$. 这个$z$称为对模$n$到基$g$上的$a$的一个<strong>离散对数</strong>或<strong>指数</strong>，记为$ind_{n,g}(a)$</p><p><strong>定理31.33(离散对数定理)</strong>: 如果$g$是$\mathbb{Z}_n^*$的一个生成元，则当且仅当等式$x\equiv y\pmod {\phi(n)}$ 成立时，有等式$g^x\equiv g^y\pmod n$成立。</p><p><strong>定理31.34</strong>: 如果$p$是一个奇素数且$e\ge 1$，则方程$$x^2\equiv 1\pmod {p^e}$$仅有两个解，即$x=\pm 1$。</p><p>如果$x$满足$x^2\equiv 1\pmod n$， 但$x$不等于以$n$为模的两个平凡平方根，则$x$是一个以$n$为模的<strong>非平凡平方根</strong></p><p><strong>推论31.35</strong>: 如果对模$n$存在1的非平凡平方根，则$n$是合数</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>又名：用反复平方法求数的幂</p><p><img src="/2019/04/06/clrs-31Number-Theoretic-Algorithms/modex.png"></p><p>$c$只是用来辅助正确性证明的变量</p><p>循环不变式：</p><ul><li>$c$的值与$b$的二进制表示的前缀$\langle b_k,b_{k-1},\cdots b_{i+1}\rangle$相同</li><li>$d=a^c\pmod n$</li></ul><p>时间复杂度$O(\beta^3)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;输入规模和算数计算的代价&quot;&gt;&lt;a href=&quot;#输入规模和算数计算的代价&quot; class=&quot;headerlink&quot; title=&quot;输入规模和算数计算的代价&quot;&gt;&lt;/a&gt;输入规模和算数计算的代价&lt;/h1&gt;&lt;p&gt;给定$k$个整数输入$a_1,a_2,\cdots ,a_k
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
  </entry>
  
  <entry>
    <title>问题求解学习笔记-数论基础</title>
    <link href="https://mengzelev.github.io/2019/03/30/ps-4-6-basic-number-theory/"/>
    <id>https://mengzelev.github.io/2019/03/30/ps-4-6-basic-number-theory/</id>
    <published>2019-03-30T06:49:23.000Z</published>
    <updated>2019-06-18T09:18:23.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h1><p>你都懂的</p><h1 id="辗转相除法-Division-Algorithm"><a href="#辗转相除法-Division-Algorithm" class="headerlink" title="辗转相除法(Division Algorithm)"></a>辗转相除法(Division Algorithm)</h1><p><strong>定理2.9(辗转相除法)</strong>: $a,b$为整数，满足$b&gt;0$，则存在唯一的整数$q$和$r$使得$a=bq+r$，此处$0\le r&lt;b$</p><p>$a\mid b$: $a$能整除$b$,$b$能被$a$整除</p><p><strong>定理2.10</strong>: $a,b$为非零整数，则存在整数$r,s$使得gcd($a,b)=ar+bs$. $gcd(a,b)$是唯一的。但$r,s$不唯一</p><p><strong>推论2.11</strong>: $a,b$为互质的整数，则存在整数$r,s$使得$ar+bs=1$【事实上是当且仅当的关系】</p><h2 id="欧几里得算法-The-Euclidean-Algorithm"><a href="#欧几里得算法-The-Euclidean-Algorithm" class="headerlink" title="欧几里得算法(The Euclidean Algorithm)"></a>欧几里得算法(The Euclidean Algorithm)</h2><p>使用多次除法得到一个递减的序列来求出gcd$(a,b)$<br>$b=aq_1+r$<br>$a=r_1q_2+r_2$<br>$r_1=r_2q_3+r_3$<br>$\vdots$<br>$r_{n-2}=r_{n-1}a_n+r_n$<br>$r_{n-1}=r_nq_{n+1}$<br>将这一系列等式反过来书写可以得到$d$的表示(略)</p><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p><strong>引理2.13(Euclid)</strong>: $a,b$为整数，$p$为质数。如果$p\mid ab$,则$p\mid a$或$p\mid b$</p><p><strong>定理2.14(Euclid)</strong>: 质数的个数是无限的</p><p><strong>定理2.15(算术基本定理Fundamental Theorem of Arithmetic)</strong>: $n$为大于1的整数，则$n=p_1p_2\cdots p_k$，其中$p_1,…,p_k$为质数。这个分解是唯一的，即若$n=q_1q_2\cdots q_l$，则$k=l$且$q_i$只是$p_i$的排列</p><p>以下内容出自CZ</p><h2 id="mathbb-Z-n-上的乘法逆元"><a href="#mathbb-Z-n-上的乘法逆元" class="headerlink" title="$\mathbb{Z}_n$上的乘法逆元"></a>$\mathbb{Z}_n$上的乘法逆元</h2><p><strong>乘法逆元(multiplicative inverse)</strong>: $a’\cdot_{n}a=1$,则称$a’$是$a$在$\mathbb{Z}_n<br>$中的乘法逆元</p><p><strong>引理2.5</strong>: 设$a$在$\mathbb{Z}_n$中存在乘法逆元$a’$. 则对于任意$b\in\mathbb{Z}<em>n$,等式$a\cdot</em>{n}x=b$有唯一解$x=a’\cdot_{n}b$.</p><p><strong>推论2.6</strong>: 若存在$b\in\mathbb{Z}<em>n$使得$a\cdot</em>{n}x=b$的$a$无解，则$a$在$\mathbb{Z}_n$上不存在乘法逆元</p><p><strong>定理2.7</strong>: 若$\mathbb{Z}_n$中的元素有一个乘法逆元，则它的乘法逆元是唯一的。<br>因此可以用$a^{-1}$来表示乘法逆元。</p><p><strong>引理2.8</strong>: $a\cdot_{n}x=1$有解当且仅当存在整数$x,y$使得$ax+ny=1$</p><p><strong>定理2.9</strong>: $a$在$\mathbb{Z}_n$中有乘法逆元当且仅当存在整数$x,y$使得$ax+ny=1$</p><p><strong>推论2.10</strong>: 若$a\in\mathbb{Z}_n$且$x,y$是满足$ax+ny=1$的整数，则$a$在$\mathbb{Z}_n$中的乘法逆元是$x\bmod n$</p><p><strong>引理2.11</strong>: 若存在整数$x,y$使得$ax+ny=1$，则$a,n$互质</p><p><strong>定理2.12(欧几里得除法定理)</strong>: 同最TJ的定理2.9</p><p><strong>引理2.13</strong>: 若$j,k,q,r$是满足$k=jq+r$的正整数，则gcd($j,k$)=gcd($r,j$)</p><h2 id="欧几里得扩展算法"><a href="#欧几里得扩展算法" class="headerlink" title="欧几里得扩展算法"></a>欧几里得扩展算法</h2><p>其实就是计算$x$和$y$的算法</p><p><strong>定理2.15</strong>: 两个正整数$j$和$k$互质当且仅当存在整数$x,y$使得$jx+ky=1$</p><p><strong>推论2.16</strong>: 对于任意正整数$n$A，$\mathbb{Z}_n$的元素$a$有乘法逆元当且仅当$gcd(a,n)=1$</p><p><strong>推论2.17</strong>: 对任意质数$p$,$\mathbb{Z}_p$的任意非零元素存在乘法逆元。</p><h2 id="计算乘法逆元"><a href="#计算乘法逆元" class="headerlink" title="计算乘法逆元"></a>计算乘法逆元</h2><p>跑欧几里得算法求出满足$ax+ny=1$的$x$,就是$a$在$\mathbb{Z}_n$中的乘法逆元</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数学归纳法&quot;&gt;&lt;a href=&quot;#数学归纳法&quot; class=&quot;headerlink&quot; title=&quot;数学归纳法&quot;&gt;&lt;/a&gt;数学归纳法&lt;/h1&gt;&lt;p&gt;你都懂的&lt;/p&gt;
&lt;h1 id=&quot;辗转相除法-Division-Algorithm&quot;&gt;&lt;a href=&quot;#辗转相除法
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法导论学习笔记-字符串匹配</title>
    <link href="https://mengzelev.github.io/2019/03/23/clrs-32String-Mathcing/"/>
    <id>https://mengzelev.github.io/2019/03/23/clrs-32String-Mathcing/</id>
    <published>2019-03-23T06:42:50.000Z</published>
    <updated>2019-03-23T15:40:43.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="问题的形式化定义"><a href="#问题的形式化定义" class="headerlink" title="问题的形式化定义"></a>问题的形式化定义</h2><ul><li>文本是一个长度为$n$的数组$T[1,…n]$</li><li>模式是一个长度为$m$的数组$P<a href="m\le n">1,…m</a>$</li><li>$P$和$T$的元素都是来自一个有限字母集$\Sigma$的字符</li><li>若$0\le s\le n-m$,且$T[s+1,…s+m]=P[1,…m]$,则称模式$P$在文本$T$中<strong>出现</strong>，且<strong>偏移</strong>为$s$(模式$P$在文本$T$中出现的位置是$s+1$开始的)</li><li>如果$P$在$T$中以偏移$s$出现，那么称$s$是<strong>有效偏移</strong>，否则是无效偏移</li><li>字符串匹配问题：找到<strong>所有</strong>的有效偏移</li><li>算法总运行时间=预处理时间+匹配时间</li></ul><p><img src="/2019/03/23/clrs-32String-Mathcing/time.png"></p><h2 id="符号和术语"><a href="#符号和术语" class="headerlink" title="符号和术语"></a>符号和术语</h2><ul><li>$\Sigma^*$: 包含所有有限长度的字符串的集合</li><li>$\varepsilon$: 长度为0的空字符串，$\varepsilon\in\Sigma^*$</li><li>$|x|$: 字符串$x$的长度</li><li>$xy$: 两个字符串$x$和$y$的<strong>连结(concatenation)</strong></li><li>若对某个字符串$y\in \Sigma^*$有$x=wy$，则称字符串$w$是字符串$x$的<strong>前缀</strong>，记作$w\sqsubset x$</li><li>若对某个字符串$y$有$x=yw$，则称字符串$w$是字符串$x$的后缀，记作$w\sqsupset x$</li><li>空字符串$\varepsilon$同时是任何一个字符串的前缀和后缀</li><li>$x\sqsupset y$当且仅当$xa\sqsupset ya$</li><li>$\sqsubset$和$sqsupset$都是<strong>传递关系</strong></li></ul><p><strong>引理32.1(后缀重叠引理)</strong>: 假设$x,y$满足$x\sqsupset z$和$y\sqsupset z$的字符串。如果$|x|\le |y|$, 那么$x\sqsupset y$; 如果$|x|\ge |y|$, 那么$y\sqsupset x$; 如果$|x|=|y|$, 那么$x=y$</p><ul><li>把模式$P[1..m]$的由$k$个字符组成的前缀$P[1..k]$记作$P_k$，因此$P_0=\varepsilon$,$P_m=P=P[1..m]$</li><li>把文本$T$中由$k$个字符组成的前缀记为$T_k$</li><li>采用这种记号，字符串匹配问题能被表述为：找到所有偏移$s(0\le s\le n-m)$, 使得$P\sqsupset T_{s+m}$</li><li>假设：检测$x==y$需要时间$\Theta(t+1)$，其中$t$是满足$z\sqsubset x$和$z\sqsubset y$的最长字符串$z$的长度</li></ul><h1 id="朴素字符串匹配算法"><a href="#朴素字符串匹配算法" class="headerlink" title="朴素字符串匹配算法"></a>朴素字符串匹配算法</h1><p>通过循环找到所有有效偏移<br>对$n-m+1$个可能的$s$进行检测</p><p><img src="/2019/03/23/clrs-32String-Mathcing/naive.png"></p><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>最坏情况下：$O((n-m+1)m)$<br>无预处理时间</p><h1 id="Rabin-Karp算法"><a href="#Rabin-Karp算法" class="headerlink" title="Rabin-Karp算法"></a>Rabin-Karp算法</h1><p>为了便于说明，假设$\Sigma={0,1,2,…,9}$<br>在通常情况下可以假定每个字符都是以$d$为基数表示的数字<br>$p$: 模式$P$表示的十进制值<br>$t_s$: 文本$T[s+1..s+m]$对应的十进制值<br><strong>把字符串匹配转化为数值匹配</strong></p><p>计算$t_1,…t_s$时，可以根据$t_s$计算$t_{s+1}$<br>$$t_{s+1}=10(t_s-10^{m-1}T[s+1])+T[s+m+1]$$<br>(去掉高位数字，左移，加上低位数字)</p><p>如果$p$和$t_s$的值太大，可以选取一个合适的模$q$来计算$p$和$t_s$的模<br>在一般情况下，选取一个$q$，使得$dq$在一个计算机字长内，调整递归式<br>$$t_{s+1}=(d(t_s-T[s+1]h)+T[s+m+1])\mod~q$$<br>其中$h\equiv d^{m-1}(mod q)$是一个具有$m$数位的文本窗口的高位数位上的数字”1”的值</p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/RK.png"></p><ul><li>计算所有长度为$m$的文本窗口对$q$取模的值</li><li>找出$t_s\equiv q(\mod~q)$的$s$值(<strong>伪命中点</strong>)</li><li>进行字符串匹配检验</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/RKM.png"></p><ul><li>去除$t$的下标不会影响程序运行</li><li>循环不变量：$t_s=T[s+1…s+m]\mod~q$</li></ul><h2 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h2><p>预处理：$\Theta(m)$<br>最坏情况运行时间: $\Theta((n-m+1)m)$(e.g.$P=a^m$且$T=a^n$时需要对所有可能进行字符串匹配验证，相当于退化为朴素算法)</p><p>若有效便宜只有常数$c$个，算法的期望匹配时间为$O((n-m+1)+cm)=O(n+m)$</p><p>若假设$q$是从适当大的整数中随机得出的，则伪命中的次数为$O(n/q)$(因为任意$t_s$模A$q$与$p$同余的概率为$1/q$)。 第10行中的测试会在$O(n)$个位置上失败，每次命中的时间代价是$O(m)$。因此Rabin-Karp算法的期望运行时间是$$O(n)+O(m(v+n/q))$$其中$v$为有效偏移量</p><p>若选取的素数$q$大于模式的长度，则可以估计Rabin-Karp算法的匹配时间为$O(n+m)=O(n)$</p><h1 id="利用有限自动机进行字符串匹配"><a href="#利用有限自动机进行字符串匹配" class="headerlink" title="利用有限自动机进行字符串匹配"></a>利用有限自动机进行字符串匹配</h1><h2 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h2><p>一个有限自动机$M$是一个五元组$(Q,q_0,A,\Sigma,\delta)$,其中：</p><ul><li>$Q$是<strong>状态</strong>的有限集合</li><li>$q_0\in Q$是<strong>初始状态</strong></li><li>$A\subseteq Q$是一个特殊的<strong>接受状态</strong>集合</li><li>$\Sigma$是<strong>有限输入字母表</strong></li><li>$\delta$是一个从$Q\times\Sigma$到$Q$的函数，称为$M$的<strong>转移函数</strong> </li></ul><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><ul><li>开始状态为$q_0$，每次读入输入字符串的一个字符</li><li>如果在状态$q$时读入字符$a$，就从状态$q$变为状态$\delta(q,a)$(进行了一次转移)</li><li>当前状态$q\in A$时，就说$M$<strong>接受</strong>了迄今为止所读入的字符串，没有被接受的输入称为<strong>被拒绝</strong>的输入</li></ul><h3 id="终态函数"><a href="#终态函数" class="headerlink" title="终态函数"></a>终态函数</h3><p>终态函数$\phi:\Sigma^*\to Q$<br>$\phi(w)$: $M$在扫描字符串$w$后终止时的状态<br>当且仅当$\phi(w)\in A$时，$M$接受字符串$w$</p><p>用转移函数递归定义$\phi$:<br>$$\phi(\varepsilon)=q_0,$$<br>$$\phi(wa)=\delta(\phi(w),a), ~~w\in\Sigma^*,a\in\Sigma$$</p><h2 id="字符匹配自动机"><a href="#字符匹配自动机" class="headerlink" title="字符匹配自动机"></a>字符匹配自动机</h2><p>后缀函数$\sigma:\Sigma^*\to{0,1,…,m}$，满足$\sigma(x)$是同时是$x$的后缀和$P$的前缀的字符串的长度<br>$$\sigma(x)=\max{k:P_k\sqsupset x}$$</p><p>对于任意的状态$q$和字符串$a$，转移函数$\delta$定义如下：<br>$$\delta(q,a)=\sigma(P_qa)$$<br>记录已得到的与模式$P$匹配的文本字符串$T$的最长前缀</p><p><img src="/2019/03/23/clrs-32String-Mathcing/auto.png"></p><p>匹配时间为$\Theta(n)$</p><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p><strong>引理32.2(后缀函数不等式)</strong>: 对任意字符串$x$和字符$a$，$\sigma(xa)\le\sigma(x)+1$</p><p><strong>引理32.3(后缀函数递归引理)</strong>: 对任意$x$和字符$a$，若$q=\sigma(x)$,则$\sigma(xa)=\sigma(P_qa)$</p><p><strong>定理32.4</strong>: 如果$\phi$是字符串匹配自动机关于给定模式$P$的终态函数，$T[1..n]$是自动机的输入文本，则对$i=0,1,..,n,\phi(T_i)=\sigma(T_i)$(终态函数的值=后缀函数的值)</p><h2 id="计算转移函数"><a href="#计算转移函数" class="headerlink" title="计算转移函数"></a>计算转移函数</h2><p><img src="/2019/03/23/clrs-32String-Mathcing/compute.png"></p><p>计算转移函数的运行时间为$O(m^3|\Sigma|)$，可以改进为$O(m\Sigma)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h1&gt;&lt;h2 id=&quot;问题的形式化定义&quot;&gt;&lt;a href=&quot;#问题的形式化定义&quot; class=&quot;headerlink&quot; title=&quot;问
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-群同构基本定理与正规子群</title>
    <link href="https://mengzelev.github.io/2019/03/14/ps-4-4-isomorphism/"/>
    <id>https://mengzelev.github.io/2019/03/14/ps-4-4-isomorphism/</id>
    <published>2019-03-14T08:20:40.000Z</published>
    <updated>2019-06-18T03:21:47.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同构-Isomorphisms"><a href="#同构-Isomorphisms" class="headerlink" title="同构(Isomorphisms)"></a>同构(Isomorphisms)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对两个群$(G,\cdot)$和$(H,\circ)$，若存在一个保群运算的双射$\phi:G\to H$，即对于任意$a,b\in G$<br>$$\phi(a\cdot b)=\phi(a)\circ\phi(b)$$<br>则称$G$和$H$<strong>同构(isomorphic)</strong>，记作$G\cong H$. $\phi$称为<strong>同构函数(isomorphism)</strong>。</p><h2 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h2><p><strong>定理9.6</strong>: Let $\phi: G\to H$ be an isomorphism of two groups. Then the following statements are true.</p><ol><li>$\phi^{-1}:H\to G$ is an isomorphism (废话)</li><li>$|G|=|H|$ (废话)</li><li>If $G$ is abelian, then $H$ is abelian.</li><li>If $G$ is cyclic, then $H$ is cyclic.</li><li>If $G$ has a subgroup of order $n$, then $H$ has a subgroup of order $n$.</li></ol><p><strong>定理9.7</strong>: All cyclic groups of infinite order are isomorphic to $\mathbb{Z}$. 无穷阶循环群与$\mathbb{Z}$同构。</p><p><strong>定理9.8</strong>: If $G$ is a cyclic group of order $n$, then $G$ is isomorphic to $\mathbb{Z}_n$.</p><p><strong>推论9.9</strong>: If $G$ is a group of order $p$, where $p$ is a prime number, then $G$ is isomorphic to $\mathbb{Z}_p$. (不需要是循环群)</p><p><strong>定理9.10</strong>: The isomorphism of groups determines an equivalence relation on the class of all groups. 群的同构关系将群划分成等价类。</p><h2 id="Cayley’s-Theorem"><a href="#Cayley’s-Theorem" class="headerlink" title="Cayley’s Theorem"></a>Cayley’s Theorem</h2><p><strong>定理9.12(Cayley定理)</strong>: Every group is isomorphic to a group of permutations. 任意群都与一个置换群同构。</p><p>The isomorphism $g\mapsto \lambda_g$ is known as the <strong>left regular representation</strong>of G.</p><h1 id="直积-Direct-Products"><a href="#直积-Direct-Products" class="headerlink" title="直积(Direct Products)"></a>直积(Direct Products)</h1><p>qlz管它叫直和</p><h2 id="外直积"><a href="#外直积" class="headerlink" title="外直积"></a>外直积</h2><p>定义运算$$G\times H: (g_1,h_1)(g_2,h_2)=(g1\cdot g_2, h_1\circ h_2)$$</p><p><strong>命题9.13</strong>: Let $G$ and $H$ be groups. The set $G\times H$ is a group under the operation $(g_1,h_1)(g_2,h_2)=(g1\cdot g_2, h_1\circ h_2)$ where $g_1, g_2\in G$ and $h_1, h_2\in H$.</p><p>群$G\times H$称为$G$和$H$的<strong>外直积(external direct product)</strong></p><p><strong>定理9.17</strong>: 设$(g,h)\in G\times H$. 若$g$和$h$分别为有限阶$r$和$s$,则$(g,h)$在$G\times H$中的阶数是$r$和$s$的<strong>最小公倍数(least common multiple)</strong></p><p><strong>推论9.18</strong>: 设$(g_1,…g_n)\in \prod G_i$. 若$g_i$在$G_i$中为有限阶$r_i$，则$(G-1,..g_n)$在$\prod G_i$中的阶数为$lcm(r_1,…r_n)$.</p><p><strong>定理9.21</strong>: 群$\mathbb{Z}_m\times\mathbb{Z}<em>n$与$Z</em>{mn}$同构当且仅当$m,n$互质($gcd(m,n)=1$). (From定理9.17)</p><p><strong>推论9.22</strong>: $n_1,…n_k$为正整数，则$\prod\limits_{i=1}^{k}\mathbb{Z}_{n_1…n_k}$当且仅当$gcd(i,j)=1$对任意$i\neq j$恒成立。</p><h2 id="内直积-Internal-Direct-Product"><a href="#内直积-Internal-Direct-Product" class="headerlink" title="内直积(Internal Direct Product)"></a>内直积(Internal Direct Product)</h2><p>外直积把小群组建成大群，内直积把大群打碎成小群</p><p>群$G$拥有子群$H,K$满足以下条件:</p><ul><li>$G=HK={hk:h\in H, k\in K}$</li><li>$H\cap K={e}$</li><li>$hk=kh$ for all $k\in K$ and $h\in H$</li></ul><p>称$G$是$H$和$K$的<strong>内直积</strong></p><p>不是所有的群都可以写成其真子群的内积的形式</p><p><strong>定理9.27</strong>: 设$G$是其子群$H$和$K$的内直积，则$G$与$H\times K$同构。(外直积群与内直积群同构)</p><p>推广到多维：</p><ul><li>$G=H_1H_2…H_n={h_1h_2…h_n:h_i\in H_i}$</li><li>$H_i\cap\left\langle \cup_{j\neq i}H_j\right\rangle={e}$</li><li>$H_ih_j=h_jh_i$ for all $h_i\in H_i$ and $h_j\in H_j$</li></ul><p><strong>定理9.29</strong>: 若$G$是其子集$H_i(i=1,2,…n)$的内直积，则$G$与$\prod_i H_i$同构</p><h1 id="正规子群-Normal-Subgroups"><a href="#正规子群-Normal-Subgroups" class="headerlink" title="正规子群(Normal Subgroups)"></a>正规子群(Normal Subgroups)</h1><p>若对任意$g\in G$有$gH=Hg$, 则称$H$是$G$的正规子群。(左陪集与右陪集相同)<br>交换群的所有子群都是正规的。</p><p><strong>定理10.3</strong>: 设$N$为$G$的子群，则如下命题等价：</p><ol><li>$N$是$G$的正规子群</li><li>$\forall g\in G, gNg^{-1}\subseteq N$.</li><li>$\forall g\in G, gNg^{-1}=N$.</li></ol><h1 id="商群-Factor-Group"><a href="#商群-Factor-Group" class="headerlink" title="商群(Factor Group)"></a>商群(Factor Group)</h1><p><strong>定理10.4</strong>: $N$为$G$的正规子群，$N$在$G$中的陪集构成了一个群$G/N$, 阶为$[G:N]$(复习: $[G:N]=|G|/|N|$). 该群的运算为$(aN)(bN)=abN$.<br>这个群被称为<strong>商群(fatcor or quotient group)</strong>.<br>$eN=N$是单位元，$g^{-1}N$是$gN$的逆元。<br>商群是<strong>集合</strong>组成的群。<br>简记为$N\triangleleft G$</p><p>对于正多边形旋转群$D_n$, 旋转群$R_n$是$D_n$的一个正规子群。</p><h1 id="交替群的简单性"><a href="#交替群的简单性" class="headerlink" title="交替群的简单性"></a>交替群的简单性</h1><p><strong>单群(simple group)</strong>: 没有非平凡正规真子群的群 e.g.$\mathbb{Z}_p$($p$为质数)</p><p><strong>引理10.8</strong>: 替换群$A_n(n\ge 3)$是由3-cycles生成的。</p><p><strong>引理10.9</strong>: $N$是$A_n(n\ge 3)$的正规子群.若$N$包含了一个3-cycle，则$N=A_n$.</p><p><strong>引理10.10</strong>: 对$n\ge 5$, $A_n$的每一个非平凡正规子群$N$都包含一个3-cycle.</p><p><strong>引理10.11</strong>: $n\ge 5$的替换群$A_n$是单群。</p><h1 id="同态-homomorphism"><a href="#同态-homomorphism" class="headerlink" title="同态(homomorphism)"></a>同态(homomorphism)</h1><p>两个群$(G,\cdot)$和$(H,\circ)$间的同态函数是一个映射$\phi:G\to H$，满足$\phi(g_1\cdot g_2)=\phi(g_1)\circ\phi(g_2)$,其中$g_1,g_2\in G$.<br>$\phi$在$H$中的值域被称为<strong>同态像(homomorphism image)</strong>.<br>若$\phi$是双射，则$G$和$H$同构。</p><p><strong>命题11.4</strong>: 设$\phi:G_1\to G_2$是群间的同态函数，则</p><ol><li>若$e$是$G_1$的单位元，则$e$是$G_2$的单位元</li><li>对于任意$g\in G_1$, $\phi(g^{-1})=[\phi(g)]^{-1}$</li><li>若$H_1$是$G_1$的子群，则$\phi(H_2)$是$G_2$的子群</li><li>若$H_2$是$G_2$的子群，则$\phi^{-1}(H_2)={g\in G_1: \phi(g)\in H_2}$是$G_1$的子群。此外，若$H_2$是$G_2$的正规子群，则$\phi^{-1}(H_2)$是$G_1$的正规子群</li></ol><p>由命题11.4知，$\phi^{-1}({e})$是$G$的子群，这个子群被称为$\phi$的<strong>核(kernel)</strong>,记为$ker\phi$. 该子群是正规的。</p><p><strong>定理11.5</strong>： 设$\phi:G\to H$是群的同态函数，则$\phi$的核是$G$的一个正规子群<br>潜台词：对于每一个同态函数都能找到一个正规子群$ker\phi$</p><p>核函数可以用来推测两个群间是否存在单射同态函数。(e.g. Example11.9 $\mathbb{Z}<em>7$与$\mathbb{Z}</em>{12}$不存在单射同态函数)</p><h1 id="同态定理"><a href="#同态定理" class="headerlink" title="同态定理"></a>同态定理</h1><p>设$H$是$G$的正规子群。定义<strong>自然同态函数</strong>或<strong>规范同态函数</strong>(<strong>natural</strong> or <strong>canonical homomorphism</strong>) $$\phi:G\to G/H$$为$$\phi(g)=gH$$<br>该同态函数的核为$H$</p><p><strong>定理11.10(第一同态定理)</strong>:  若$\varphi:G\to H$是核为$K$的同态函数， 则$K$是$G$的正规子群。设$\phi:G\to G/K$是规范同态函数。则存在唯一的同构函数$\eta:G/K\to\varphi(G)$使得$\varphi=\eta\phi$</p><p>规范同态函数产生的商群与原同态函数的像同构</p><p><strong>定理11.12(第二同态定理)</strong>: 设$H$是$G$的子群(不需要正规)，$N$是$G$的正规子群，则$HN$是$G$的子群，$H\cap N$是$H$的正规子群，且<br>$$H/H\cap N\cong HN/N$$</p><p><strong>定理11.13(一致性定理)</strong>: 设$N$是$G$的正规子群，则$H\mapsto H/N$是<strong>包含$N$的子群$H$</strong>的集合与<strong>$G/N$的子群</strong>的集合间的一对一关系。此外，包含$N$的$G$的正规子群与$G/N$的正规子群相对应。</p><p><img src="/2019/03/14/ps-4-4-isomorphism/corr.png" alt="wiki上的解释"></p><p><strong>定理11.14(第三同构定理)</strong>: 设$N$和$H$是$G$的正规子群满足$N\subseteq H$,则$$G/H\cong\frac{G/N}{H/N}$$. (可以当成分数来直观理解)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;同构-Isomorphisms&quot;&gt;&lt;a href=&quot;#同构-Isomorphisms&quot; class=&quot;headerlink&quot; title=&quot;同构(Isomorphisms)&quot;&gt;&lt;/a&gt;同构(Isomorphisms)&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-置换群与拉格朗日定理</title>
    <link href="https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/"/>
    <id>https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/</id>
    <published>2019-03-09T09:15:13.000Z</published>
    <updated>2019-06-17T14:18:27.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="置换群-Permutation-Group"><a href="#置换群-Permutation-Group" class="headerlink" title="置换群(Permutation Group)"></a>置换群(Permutation Group)</h1><p><strong>定理5.1</strong>:The symmetric group on $n$ letters, $S_n$, is a group with $n!$ elements, where<br>the binary operation is the composition of maps.</p><p>置换群(permutation group):所有排列的集合$S_n$的一个子集</p><h2 id="Cycle-Notation"><a href="#Cycle-Notation" class="headerlink" title="Cycle Notation"></a>Cycle Notation</h2><p>A permutation $\sigma\in S_X$ is a <strong>cycle of length</strong> $k$ if there exist elements $a_1,a_2,…a_k\in X$ such that<br>$$\sigma(a_1) = a_2$$<br>$$\sigma(a_2) = a_3$$<br>$$…$$<br>$$\sigma(a_k) = a_1$$<br>and $\sigma(x)=x$ for all other elements $x\in X$. </p><p>We write $(a_1,a_2,…a_k)$ to denote the cycle $\sigma$.</p><p>Cycles are the building blocks of all permutations.循环是所有排列的基石。</p><p>Two cycles in $S_X$, $\sigma=(a_1,a_2,…a_k)$, $\tau=(b_1,b_2,…b_l)$, are <strong>disjoint</strong> if $a_i\neq b_j$ for all $i$ and $j$</p><p><strong>命题5.8</strong>: Let $\sigma$ and $\tau$ be 2 disjoint cycles in $S_X$. Then $\sigma\tau=\tau\sigma$.</p><p><strong>定理5.9</strong>: $S_n$中的所有排列都可以被写成不相交循环的乘积的形式。</p><p><strong>Transpositions</strong>: a cycle of length 2 (任意两个数交换位置)</p><p><strong>命题5.12</strong>: 任意至少含有两个元素的有限集的排列都可以写成transposition乘积的形式<br>e.g. (253)=(23)(25)</p><p><strong>引理5.14</strong>: identity(恒等变换)只能写成<strong>偶数个</strong>transposition的乘积的形式</p><p><strong>定理5.15</strong>: 如果一个排列能被写成偶数个置换乘积的形式，那么另一个与之等价的排列也一定拥有偶数项置换乘积。奇数同理。<br>据此定理可以将排列分为奇偶两类</p><h3 id="交替组-The-Alternating-Groups"><a href="#交替组-The-Alternating-Groups" class="headerlink" title="交替组(The Alternating Groups)"></a>交替组(The Alternating Groups)</h3><p>交替组$A_n$是所有偶排列的集合</p><p><strong>定理5.16</strong>: 集合$A_n$是$S_n$的子群</p><p><strong>命题5.17</strong>: $S_n$中奇排列和欧排列的数目相等，都为$n!/2$</p><h1 id="反组-Dihedral-Groups"><a href="#反组-Dihedral-Groups" class="headerlink" title="反组(Dihedral Groups)"></a>反组(Dihedral Groups)</h1><p>the <strong>nth dihedral group</strong>($D_n$): the group of rigid motions of a regular n-gon(正多边形的刚性运动=转动+反射)</p><p><strong>定理5.20</strong>: $D_n$ is a subgroup of $S_n$ of order $2n$</p><p><strong>定理5.23</strong>: The group $D_n$, $n\ge 3$, consists of all products of the two elements $r$ and $s$, satisfying the relations<br>$$r^n=1$$<br>$$s^2=1$$<br>$$srs=r^{-1}$$<br>($r,s$分别为转动和反射)</p><p>$$D_n={1,r,r^2,..,r^{n-1},s,sr,sr^2,…,sr^{n-1}}$$</p><h2 id="立方体的运动"><a href="#立方体的运动" class="headerlink" title="立方体的运动"></a>立方体的运动</h2><p><strong>命题5.27</strong>: The group of rigid motions of a cube contains 24 elements.</p><p><strong>命题5.28</strong>: The group of rigid motions of a cube is $S_4$.(看体对角线)</p><h1 id="陪集-Coset"><a href="#陪集-Coset" class="headerlink" title="陪集(Coset)"></a>陪集(Coset)</h1><p>$G$为群，$H$为$G$的子群，定义<br><strong>左陪集(left coset)</strong>: $gH={gh:~h\in H}$<br><strong>右陪集(left coset)</strong>: $Hg={hg:~h\in H}$ <s>(这真的不是汞吗)</s><br>其中$g\in G$称为<strong>代表元(representative)</strong></p><p>在交换群中，左陪集与右陪集是相同的。</p><p><strong>引理6.3</strong>: $g_1,g_2\in G$，以下条件等价:<br>$1. g_1H=g_2H$;<br>$2. Hg_1^{-1}=Hg_2^{-1}$;<br>$3. g_1H\subset g_2H$;<br>$4. g_2\in g_1H$;<br>$5. g_1^{-1}g_2\in H$;</p><p><strong>定理6.4</strong>: $H$为$G$的子群。$H$的左陪集分割(partition)了$G$,即$G$是$H$的左陪集的disjoint union. (右陪集同理)</p><p><strong>index</strong> of $H$: the number of left cosets of $H$ in $G$. 表示为$[G:H]$</p><p><strong>定理6.8</strong>: $H$在$G$中的左陪集与右陪集的个数相等。</p><h1 id="拉格朗日定理"><a href="#拉格朗日定理" class="headerlink" title="拉格朗日定理"></a>拉格朗日定理</h1><p><strong>命题6.9</strong>: 定义映射$H\to gH$ by $\phi(h)=gh$. 该映射是双射，$H$中元素的个数等于$gH$中元素的个数。</p><p><strong>定理6.10(拉格朗日定理)</strong>: Let $G$ be a finite group and let $H$ be a subgroup of $G$. Then $|G|/|H|=[G:H]$ is the number of distinct left cosets of $H$ in $G$. In particular, the number of elements in $H$ must divide the number of elements in $G$.<br>$$|G|=[G:H]|H|$$</p><p><strong>推论6.11</strong>: Suppose that $G$ is a finite group and $g\in G$. Then the order of $g$ must divide the number of elements in $G$.</p><p><strong>推论6.12</strong>: Let $|G|=p$ with $p$ a prime number. Then $G$ is cyclic and any $g\in G$ such that $g\neq e$ is a generator. 含有质数个元素的群为循环群且任何非单位元的元素都是生成元。</p><p><strong>推论6.13</strong>: Let $H$ and $K$ be subgroups of a finite group $G$ such that $G\supset H\supset K$. Then $[G:K]=[G:H][H:K]$.</p><p><strong>拉格朗日定理的逆命题是不成立的</strong></p><p><strong>命题6.15</strong>: The group $A_4$ has no subgroup of order 6.</p><p><strong>定理6.16</strong>: Two cycles $\tau$ and $\mu$ in $S_n$ have the same length if and only if there exists a $\sigma\in S_n$ such that $\mu=\sigma\tau\sigma^{-1}$.</p><h1 id="费马与欧拉定理"><a href="#费马与欧拉定理" class="headerlink" title="费马与欧拉定理"></a>费马与欧拉定理</h1><p>欧拉函数$\phi(n)$表示$n$以内与$n$互质的数的个数<br>对任意质数$p$, $\phi(p)=p-1$</p><p><strong>定理6.17</strong>: Let $U(n)$ be the group of units in $\mathbb{Z}_n$. Then $|U(n)|=\phi(n)$</p><p><s>怎么又是欧拉</s><br><strong>定理6.18(欧拉定理)</strong>: Let $a$ and $n$ be integers such that $n&gt;0$ and $gcd(a,n)=1$. Then $a^{\phi(n)}\equiv 1\pmod n$</p><p><strong>定理6.19(费马小定理)</strong>: Let $p$ be any prime number and suppose that $p\nmid a$($p$ does not divide $a$). Then $a^{p-1}\equiv 1\pmod p$.<br>Furthermore, for any integer $b$, $b^p\equiv b\pmod p$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;置换群-Permutation-Group&quot;&gt;&lt;a href=&quot;#置换群-Permutation-Group&quot; class=&quot;headerlink&quot; title=&quot;置换群(Permutation Group)&quot;&gt;&lt;/a&gt;置换群(Permutation Group)
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
  <entry>
    <title>问求学习笔记-群论初步</title>
    <link href="https://mengzelev.github.io/2019/03/02/ps-4-2-group/"/>
    <id>https://mengzelev.github.io/2019/03/02/ps-4-2-group/</id>
    <published>2019-03-02T06:03:29.000Z</published>
    <updated>2019-06-17T09:30:57.511Z</updated>
    
    <content type="html"><![CDATA[<p>由于接下来的书没有中文版了，因此笔记中英文都<u>看心情</u></p><h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><h2 id="整数等价类"><a href="#整数等价类" class="headerlink" title="整数等价类"></a>整数等价类</h2><p><strong>命题3.4</strong>：模运算下的整数等价类具有以下性质：</p><ol><li>加法和乘法交换律</li><li>加法和乘法结合律</li><li>加法(0)与乘法(1)恒等式</li><li>乘法分配律</li><li>任意元素都存在加法逆元</li><li>$a$为非零整数，$gcd(a,n)=1$当且仅当$a$存在乘法逆元，即存在非零整数$b$，使得$ab\equiv 1(mod n)$</li></ol><p>(虽然我觉得这玩意儿记了应该没什么卵用)<br>【复习时的我回来打脸了</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>二元运算(binary operation)或合成律(law of composition):a function $G\times G\to G$ that assigns to each pair $(a,b)\in G\times G$ a unique element $a\circ b$, or $ab$ in $G$, called the composition of $a$ and $b$</li><li>群(group): a set $G$ together with a law of composition $(a,b)\mapsto a\circ b$ that satisfies the following axioms:<ol><li>合成律满足<strong>结合律</strong>(asscociative)</li><li>存在<strong>单位元(identity element)</strong>$e\in G$，满足$e\circ a = a\circ e = a$</li><li>对于每个$a\in G$，都存在<em>逆元</em>$a^{-1}$，使得$a\circ a^{-1}=a^{-1}\circ a=e$</li></ol></li><li>群 = 运算封闭+结合律+单位元+逆元</li><li>阿贝尔群(Abelian)或交换群(commutative):满足$a\circ b=b\circ a$的群，反之为nonabelian或noncommutative</li><li>凯莱表(Cayley table):用加法或乘法描述群的表格</li><li>可逆元素群(group of units): 拥有逆元的元素组成的群</li><li>一般线性群(general linear group)</li><li>四元群(quaternion group)</li><li>群是<strong>有限的(finite)</strong>，或者说有<strong>有限序数(has finite order)</strong>，当它具有有限个元素，否则是无限的(infinite)或有无限序数(infinite order)</li></ul><h2 id="群的基本性质"><a href="#群的基本性质" class="headerlink" title="群的基本性质"></a>群的基本性质</h2><p><strong>命题3.17</strong>: 群中的单位元是唯一的<br><strong>命题3.18</strong>: 逆元是唯一的<br><strong>命题3.19</strong>: $G$是群，$a,b\in G$，则$(ab)^{-1}=b^{-1}a^{-1}$<br><strong>命题3.20</strong>: $(a^{-1})^{-1}=a$<br><strong>命题3.21</strong>: $ax=b$和$xa=b$在$G$中有唯一解<br><strong>命题3.22</strong>(左右消去律right and left cancellation law): $ba=ca$ implies $b=c$ and $ab=ac$ implies $b=c$</p><p>对群中的元素，可以定义乘方</p><p><strong>定理3.23</strong>: 在群中，一般指数的运算律成立</p><h2 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h2><ul><li>子群(subgroup):仿照子空间的定义<ul><li>平凡子群(trivial subgroup):$H={e}$</li><li>真子群(proper subgroup)</li></ul></li><li>子群必须继承群的二元运算</li></ul><h3 id="子群相关的定理"><a href="#子群相关的定理" class="headerlink" title="子群相关的定理"></a>子群相关的定理</h3><p><strong>命题3.30</strong>: $G$的子集$H$是子群当且仅当</p><ol><li>$G$的单位元$e\in H$</li><li>$H$对$G$的运算封闭：If $h_1,h_2\in H$, then $h_1h_2\in H$</li><li>If $h\in H$, then $h^{-1}\in H$</li></ol><p><strong>命题3.31</strong>: $H$是$G$的子群当且仅当$H\neq\emptyset$ and whenever $g,h\in H$ then $gh^{-1}$ is in $H$</p><h1 id="循环子群-Cyclic-Subgroups"><a href="#循环子群-Cyclic-Subgroups" class="headerlink" title="循环子群(Cyclic Subgroups)"></a>循环子群(Cyclic Subgroups)</h1><p><strong>定理4.3</strong>: Let $G$ be a group and $a$ be any element in $G$. Then the set $\left⟨a\right⟩={a^k:k\in\mathbb{Z}}$is a subgroup of $G$. Furthermore, $⟨a⟩$ is the <strong>smallest</strong> subgroup of $G$ that contains $a$.</p><p><strong>循环子群(Cyclic Subgroup)</strong>:$⟨a⟩$<br><strong>循环群(Cyclic group)</strong>: 包含了某个元素$a$，使得$G=⟨a⟩$.此时$⟨a⟩$是$G$的<strong>生成器(generator)</strong>.<br>The <strong>order</strong> of $a$: 最小的整数$n$满足$a^n=e$，表示为$|a|=n$。如果不存在满足要求的$n$，则称$a$是<strong>无穷的(infinite)</strong>，表示为$|a|=\infty$<br>e.g. $\mathbb{Z}$和$\mathbb{Z}_n$都是循环群，1和-1是$\mathbb{Z}$的生成器，1是$\mathbb{Z}_n$的生成器但不一定是唯一的。</p><p><strong>定理4.9</strong>: 所有循环群都是可交换的。(Every cyclic group is abelian).</p><p><strong>定理4.10</strong>: 循环群的子群都是循环子群。(Every subgroup of a cyclic group is cyclic.)</p><p><strong>引理4.11</strong>: The subgroups of $\mathbb{Z}$ are exactly $n\mathbb{Z}$ for $n=0,1,2…$</p><p><strong>命题4.12</strong>: Let $G$ be a cyclic group of order $n$ and suppose that $a$ is a generator<br>for $G$. Then $a^k = e$ if and only if $n$ divides $k$.($n$能整除$k$,$k$能被$n$整除)</p><p><strong>定理4.13</strong>: Let $G$ be a cyclic group of order $n$ and suppose that $a\in G$ is a generator<br>of the group. If $b = a^k$, then the order of $b$ is $n/d$, where $d = gcd(k, n)$.</p><p><strong>引理4.14</strong>: The generators of $\mathbb{Z}_n$ are the integers $r$ such that $1\le r&lt; n$ and<br>$gcd(r,n) = 1$. $\mathbb{Z}_n$的生成器与$n$互质。</p><h2 id="复数乘法群-Multiplicative-Group-of-Complex-Numbers"><a href="#复数乘法群-Multiplicative-Group-of-Complex-Numbers" class="headerlink" title="复数乘法群(Multiplicative Group of Complex Numbers)"></a>复数乘法群(Multiplicative Group of Complex Numbers)</h2><p>一堆复数的基础知识…….</p><p>$r(\cos\theta+i\sin\theta)$ 会被简写为 $r~cis\theta$</p><p><strong>命题4.20</strong>: $z=r~cis\theta$ and $w=s~cis\phi$. Then $zw=rs~cis(\theta+\phi)$</p><h3 id="圆群-The-circle-group"><a href="#圆群-The-circle-group" class="headerlink" title="圆群(The circle group)"></a>圆群(The circle group)</h3><p>定义: $$\mathbb{T}={z\in\mathbb{C}: |z|=1}$$</p><p><strong>命题4.24</strong>: 圆群是$\mathbb{C}^*$的子群</p><p><strong>定理4.25</strong>: If $z^n=1$, then the nth roots of unity are $$z=cis(\frac{2k\pi}{n})$$<br>where $k-0,1,…n-1$. Furthermore, the nth roors of unity form a cyclic subgroup of $\mathbb{T}$ of order $n$.</p><p>A generator for the group of the nth roots of unity is called a <strong>primitive nth root of<br>unity</strong>.</p><h2 id="重复平方法-The-Method-of-Repeated-Squares"><a href="#重复平方法-The-Method-of-Repeated-Squares" class="headerlink" title="重复平方法(The Method of Repeated Squares)"></a>重复平方法(The Method of Repeated Squares)</h2><p>其实就是快速幂</p><p>理论基础: If $b\equiv a^x (\mod n)$ and $c\equiv a^y (\mod n)$, then $bc\equiv a^{x+y}(\mod n)$<br>$(a^{2n})^2\equiv a^{2\cdot 2n}\equiv a^{2^{n+1}}(\mod n)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于接下来的书没有中文版了，因此笔记中英文都&lt;u&gt;看心情&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&quot;群&quot;&gt;&lt;a href=&quot;#群&quot; class=&quot;headerlink&quot; title=&quot;群&quot;&gt;&lt;/a&gt;群&lt;/h1&gt;&lt;h2 id=&quot;整数等价类&quot;&gt;&lt;a href=&quot;#整数等价类&quot; class
      
    
    </summary>
    
      <category term="Notes" scheme="https://mengzelev.github.io/categories/Notes/"/>
    
    
      <category term="Problem Solving" scheme="https://mengzelev.github.io/tags/Problem-Solving/"/>
    
      <category term="CLRS" scheme="https://mengzelev.github.io/tags/CLRS/"/>
    
      <category term="Group Theory" scheme="https://mengzelev.github.io/tags/Group-Theory/"/>
    
  </entry>
  
</feed>
