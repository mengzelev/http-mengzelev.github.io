<html>
  <Head>
    <link rel="stylesheet" href="/static/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="/static/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" href="/static/css/katex.min.css"/>
    <link rel="stylesheet" href="/static/css/wiki.css"/>
    <link rel="stylesheet" href="/static/css/codehilite.css"/>

    <script src="/static/js/katex.min.js"></script>
    <script src="/static/js/jquery.min.js"></script>
    
    
<link rel="stylesheet" href="/static/css/slides.css"/>


    <title>PA 选讲</title>
  </Head>
  <body>
   
   
<textarea id="source">
public: true
class: center, middle

# PA 选讲

欧先飞 <ouxianfei@smail.nju.edu.cn>

南京大学计算机软件研究所

---

# 提纲

* yemu到nemu
* nemu中的译码执行解耦合
* nemu中的硬件模拟
* JIT初步
* nemu中的差分测试

----

* slides下载地址：114.212.83.188:8080/Thursday-slides.7z
 * `php -S localhost:8080 -t $PWD`

---

# 必要的复习

如何调试segment fault？ (其实[之前](http://114.212.81.193:5000/wiki/ICS2018_6.slides#25)蒋神已经讲过)

```bash
Program received signal SIGSEGV, Segmentation fault.
exec_wrapper (print_flag=print_flag@entry=0 '\000') at src/cpu/exec/exec.c:248
248       *(uint32_t *)0x12345678 = 0x12345678;
(gdb) bt
#0  exec_wrapper (print_flag=print_flag@entry=0 '\000') at src/cpu/exec/exec.c:248
#1  0x000055555555b717 in cpu_exec (n=n@entry=18446744073709551615) at src/monitor/cpu-exec.c:38
#2  0x000055555555bcc0 in cmd_c (args=<optimized out>) at src/monitor/debug/ui.c:31
#3  0x000055555555bfa7 in ui_mainloop (is_batch_mode=<optimized out>) at src/monitor/debug/ui.c:108
#4  0x000055555555ac50 in main (argc=<optimized out>, argv=<optimized out>) at src/main.c:9
(gdb)
```

---

# yemu到nemu之间还有多远？

首先我们准备好轮廓(yemu)

<img class="pull-bottom" src="/static/image/draw_horse_1.png"/>

---

# yemu到nemu之间还有多远？

然后我们补充点细节

<img class="pull-bottom" src="/static/image/draw_horse_2.png"/>

---

# yemu到nemu之间还有多远？

细节也是一步一步来的

<center>
<img class="pull-bottom" src="/static/image/draw_horse_3.jpg"/>
</center>

---
class: center, middle

# yemu到nemu的进化（伪）

---

# 似乎不怎么work的第一版


```c
typedef union inst {
  struct { u8 rs  : 2, rt: 2, op: 4; } rtype;
  struct { u8 addr: 4,        op: 4; } mtype;
} inst_t;

#define RTYPE(i) u8 rt = (i)->rtype.rt, rs = (i)->rtype.rs;
#define MTYPE(i) u8 addr = (i)->mtype.addr;

void execute() {
  inst_t *cur = (inst_t *)&M[pc];
  switch (cur->rtype.op) {
  case 0b0000: { RTYPE(cur); R[rt]   = R[rs];   pc++; break; }
  case 0b0001: { RTYPE(cur); R[rt]  += R[rs];   pc++; break; }
  case 0b1110: { MTYPE(cur); R[0]    = M[addr]; pc++; break; }
  case 0b1111: { MTYPE(cur); M[addr] = R[0];    pc++; break; }
  default: assert(0);
  }
}
```

---

# 对接完x86手册

```c
typedef int (*helper_fun)(swaddr_t);

int inv(swaddr_t eip) { assert(0); }
int add_r2rm_b(swaddr_t eip) { /* ... */ }
int add_r2rm_v(swaddr_t eip) { /* ... */ }
int add_rm2r_b(swaddr_t eip) { /* ... */ }
// ...

helper_fun opcode_table [256] = {
/* 0x00 */	add_r2rm_b, add_r2rm_v, add_rm2r_b, add_rm2r_v,
/* 0x04 */	add_i2a_b, add_i2a_v, inv, inv,
/* .... */  // ...
};

int exec() {
  uint8_t op = instr_fetch(eip, 1);
  return opcode_table[op](eip);
}
```

---

# 对接完x86手册

符合x86手册
* 自定义的虚拟机操作码 -> x86标准的操作码

--
count: false

代码风格
* `switch-case` 变更成了 `opcode_table`
* 有什么好处？

--
count: false
未实现指令
* 用`inv`代替，`inv`直接`assert(0)`
* 预防于未然(不然程序跑飞了都不知道错在哪)
* 除了直接`assert(0)`还可以做些什么？

---

# 更友好的inv
PA2最头疼的地方(其实包含着yzh学长满满的人文关怀)

```bash
If it is the first case, see
 _ ____   ___    __    __  __                         _ 
(_)___ \ / _ \  / /   |  \/  |                       | |
 _  __) | (_) |/ /_   | \  / | __ _ _ __  _   _  __ _| |
| ||__ < > _ <| '_ \  | |\/| |/ _` | '_ \| | | |/ _` | |
| |___) | (_) | (_) | | |  | | (_| | | | | |_| | (_| | |
|_|____/ \___/ \___/  |_|  |_|\__,_|_| |_|\__,_|\__,_|_|

for more details.

If it is the second case, remember:
* The machine is always right!
* Every line of untested code is always wrong!

nemu: ABORT at eip = 0x00100012
```

---
class: center, middle

# 解耦合的必要性

---

# copy-paste模式的第一版

我们需要实现`add`指令
* 先按手册写一个`add_r2rm_b`

--
count: false
很快我们发现

--
count: false
* `add_r2rm_v`好像可以把`add_r2rm_b`拷过去稍微改改

--
count: false

* `add_rm2r_b`好像也可以把`add_r2rm_b`拷过去稍微改改
--
count: false

* `add_rm2r_v`好像也可以...
--
count: false

紧接着我们发现
* `sub_r2rm_v`好像也可以把`add_r2rm_b`拷过去稍微改改
* `sub_rm2r_r`, `sub_rm2r_v`...

--
count: false
最后我们发现
* 几乎所有算术指令都可以这样干

---

# copy-paste一时爽

仅合半个小时，我们便实现了xxx条指令

<img class="pull-bottom" src="/static/image/copy_paste.png"/>

---

# debug时火葬场

某一天你发现add的某条指令的操作数扩展方式写错了，而且非常遗憾的是其它算术指令直接拷贝了这一份代码。你费尽辛苦终于改完了所有的指令的扩展方式，却忘了在某一条不常用的指令里面也拷贝了这一份代码。

--
count: false

假设相应的寻址方式用的非常少，编译器只在非常奇怪的上下文中才会生成这一条指令，于是你只能面对所有的测试用例都可以跑，但跑nanos-lite这些大项目时就会莫名`HIT BAD TRAP`的崩溃场景（进一步假设还没有差分测试）。

--
count: false

----

> 消除项目中的重复代码也是在节省我们的时间

---

# 第一次译码执行解耦合

cpu/exec/exec.c
```c
helper_fun opcode_table [256] = { add_r2rm_b, ... };
```

cpu/exec/arith/add-template.h
```c
#include "cpu/exec/template-start.h"

#define instr add

static void do_execute() {
  DATA_TYPE dst = op_dest->val + op_src->val;
  // update flags
}

make_instr_helper(i2a);
make_instr_helper(i2rm);

#include "cpu/exec/template-end.h"
```

---

# 第一次译码执行解耦合

cpu/exec/arith/add.c
```c
#define DATA_BYTE 1
#include "add-template.h"
#undef DATA_BYTE

#define DATA_BYTE 2
#include "add-template.h"
#undef DATA_BYTE

#define DATA_BYTE 4
#include "add-template.h"
#undef DATA_BYTE
```

--
count:false

----

第一次不太成功的解耦合之后的启示：

1. 同一指令的不同宽度形式，可以拓展到同一位宽之后进行执行
2. 不同指令的相同译码方式可以进一步解耦(在表项中就指明译码方式)

---

# 第二次译码执行解耦合

```c
typedef struct {
  DHelper decode;
  EHelper execute;
  int width;
} opcode_entry;

#define IDXW(id, ex, w) {concat(decode_, id), concat(exec_, ex), w}
#define IDX(id, ex) IDEXW(id, ex, 0)

opcode_entry opcode_table [512] = {
  /* 0x00 */ IDEXW(G2E, add, 1), IDEX(G2E, add), IDEXW(E2G, add, 1), IDEX(E2G, add),
  /* 0x04 */ IDEXW(I2a, add, 1), IDEX(I2a, add), EMPTY, EMPTY,
  /* .... */ // ...
};
```

---

# 第二次译码执行解耦合

看着略蛋疼，我们稍微展开一下

```c
opcode_entry opcode_table [512] = {
  /* 0x00 */ {decode_G2E, exec_add, 1}, {decode_G2E, exec_add, 0}, {decode_E2G, exec_add, 1}, {decode_E2G, exec_add, 0},
  /* .... */ // ...
};
```

----
操作码表的每一项变成了三元组`<decoder, executor, width>`，这样以来对于一种指令我们只需要实现一个executor，并且不同指令的相同译码形式可以共用decoder。

> 解耦合之后的nemu执行每一条指令均由三个过程组成：译码、执行、更新pc，实际上这也暗合cpu的内部架构。

---

# 解耦合之后的nemu

指令执行函数`exec_real`先取一个字节的指令，查表得对应的译码函数和执行函数，再交由`idex`进行译码执行。

```c
make_EHelper(real) {
  uint32_t opcode = instr_fetch(eip, 1);
  decoding.opcode = opcode;
  set_width(opcode_table[opcode].width);
  idex(eip, &opcode_table[opcode]);
}

static inline void idex(vaddr_t *eip, opcode_entry *e) {
  if (e->decode)
    e->decode(eip);
  e->execute(eip);
}
```

---

# 译码函数示例

```c
#define make_DHelper(name) void concat(decode_, name) (vaddr_t *eip)

static inline void decode_op_rm(vaddr_t *eip, Operand *rm, bool load_rm_val, Operand *reg, bool load_reg_val) {
  read_ModR_M(eip, rm, load_rm_val, reg, load_reg_val);
}

make_DHelper(G2E) {
  decode_op_rm(eip, id_dest, true, id_src, true);
}

```

----
于是你兴奋的展开了`read_ModR_M`函数，却发现每一个单词都能认识，就是不知道这是干嘛的。

实际上read_ModR_M这一部分属于硬件强相关代码，你们可以选择通过阅读i386手册来了解，不过充满人文关怀的yzh学长已经帮你们处理掉了这个问题。

---

public: true
class: center, middle

# 简单的硬件模拟

---

# 一个ALU还不够

我们需要输入输出，我们需要图形界面，我们还需要窗口管理器、各种小游戏。

--
count:false

在数电课上，你们已经学会了如何编写VGA控制器和串口控制器，现在只需要将他们模拟一遍。

--
count:false

----

cpu两种外设寻址模式

* memory mapped io (vaddr_read/vaddr_write)：

  * VGA、MIPS架构的全部外设寻址方式

* port mapped io (pio_read/pio_write)：

  * x86的端口（串口、nemu中的键盘和时钟）

--
count:false

> 模拟外设就是模拟外设提供的寄存器读写行为，而外设寄存器的读写暴露在cpu的两种外设寻址模式下。

---

# nemu中的输入输出(serial)

```c
#define SERIAL_PORT 0x3F8
#define CH_OFFSET 0
#define LSR_OFFSET 5

static uint8_t *serial_ch_base; /* character */
static uint8_t *serial_lsr_base; /* line status register */
static void serial_ch_io_handler(ioaddr_t addr, int len, bool is_write) {
  assert(is_write && len == 1); /* only simulate write */
  char c = serial_ch_base[0];
  putc(c, stdout);
  if(c == '\n') fflush(stdout);
}

void init_serial() {
  serial_ch_base = add_pio_map(SERIAL_PORT + CH_OFFSET, 1, serial_ch_io_handler);
  serial_lsr_base = add_pio_map(SERIAL_PORT + LSR_OFFSET, 1, NULL);
  serial_lsr_base[0] = 0x20; /* the status is always free */
}
```

---

# nemu的硬件访问回调机制

src/device/io/port-io.c

```c
void *add_pio_map(); /* register callback and return registered virtual address */
```

----

回调触发的时机：
* read:
  * pio_read_l/pio_read_w/pio_read_b
  * pio_read_common
  * pio_callback
* write (similar to read)

---
# nemu中其他的硬件

* 时钟
 * gettimeofday
* 键盘
 * nemu中通过SDL库的SDL_KEYDOWN/SDL_KEYUP事件获取
* VGA (编址在mmio中)
 * 通过调用SDL库的SDL_Render进行模拟

--
count:false

----
> 为了降低模拟的复杂度，键盘可以通过libc(scanf/getch)来模拟，但这样一来方向键、F系列按键将会无法模拟，你知道如何处理这个问题吗？（提示：ANSI escape code）

---

public: true
class: center, middle

# 通往更高速的次元

(JIT优化初步介绍)

---

# RTL开始的时代

同样一条指令push，实现方式却有一堆：

```c
cpu.esp -= 4;
vaddr_write(cpu.esp, *src1, 4);
```

```c
rtl_subi(&cpu.esp, 4);
vaddr_write(cpu.esp, *src1, 4);
```

```c
rtl_subi(&cpu.esp, 4);
rtl_sm(&cpu.esp, src1, 4);
```

--
count:false

----
> 似乎能间接辅助我们检测作弊

---
# RTL开始的时代

RTL真正的用途

* 记录指令执行的方式

--
count:false

记录执行方式有什么好处？

* 我们可以对执行方式做一些分析，甚至优化
* 事实证明：通过这种方式我们可以将nemu的性能优化20倍

---
# RTL开始的时代

举个简单的例子，寄存器之间的data dependency
 * 读后读 (no dependency)
 * 读后写 (false dependency)
 * 写后读 (true dependency)
 * 写后写 (false dependency)

--
count:false

----

false dependency:
 * 本质是资源竞争

true dependency:
 * 本质是数据流依赖

---
# RTL开始的时代

举个简单的例子，以写后写为例

* 如果某一段指令流连续对某一个寄存器发生了写入行为，那么先写入的值毫无疑问会被后写入的值覆盖掉，那么实际上除了最后一个写入行为之前的写入操作都可以删除。

--
count:false

----

> 真实的cpu中除了写后写还会通过寄存器重命名处理掉所有的读后写依赖，不过在虚拟机中我们没必要处理掉读后写。

---

# RTL开始的时代

举个简单的例子，以写后写为例

* 编译器优化很少会生成写后写的指令，但是在nemu中，写后写的行为还是普遍存在：

```asm
addl $eax, $eax
addl $eax, $eax
```

在nemu中，这两条addl指令都会更新eflag，而实际上第一条add指令的更新完全是无意义的，并且更新eflag也是一个代价很高的操作。

---
# RTL开始的时代

完整的以rtl表述的加法指令（基本都是更新eflag操作）：

```c
rtl_add(&t0, &id_dest->val, &id_src->val);
operand_write(id_dest, &t0);

rtl_update_ZFSF(&t0, id_dest->width);

// CF <- (result < dest)
rtl_setrelop(RELOP_LTU, &t1, &t0, &id_dest->val);
rtl_set_CF(&t1);

// OF <- (MSB[src] == MSB[dest] && MSB[result] != MSB[dest])
rtl_xor(&t1, &id_dest->val, &id_src->val);
rtl_not(&t1);
rtl_xor(&t2, &id_dest->val, &t0);
rtl_and(&t0, &t1, &t2);
rtl_msb(&t0, &t0, id_dest->width);
rtl_set_OF(&t0);
```

---
# RTL开始的时代

处理掉所有写后写的通用方案，死代码消除(dce)

* 倒排一个基本块内指令流的读写依赖
* 将包括通用寄存器、RTL扩展的寄存器、eflag均打上读写标记
* 保留对某一个寄存器连续写入操作的最后一个写入操作

--
count:false

----

保守预估跑分： 80 -> 800

跑分暴涨的两个原因：
 * RTL层记录了指令的译码方式，不用再重复译码
 * 死代码消除处理掉了多余的写后写

---
# RTL开始的时代

一些其他的优化方案

* switch-case优化掉函数指针表
  * 800 -> 1000
* 跳转表优化
  * 1000 -> 1400
* 常量折叠
  * 1400 -> 2000
* binary translator
  * 至少5000
* qemu参考实现: 10000，kvm实现: 100000

---
# RTL开始的时代

一些参考跑分：

* 200，能够很卡的玩仙剑
* 800，能够流畅的玩仙剑
* 1400，能够在仙剑里面流畅的发大招
* 2000，能够流畅的玩超级马里奥

---

public: true
class: center, middle

# 更高效的调试/"作弊"方式

---

# 痛苦的调试经历

来自某位PA经历者的[亲身经历](https://www.zhihu.com/question/64475453/answer/224647520)

----

起因
* 不明(暂定)

现象
* cputests中除了matrix-mul-big其他都能过

条件
* cputests中没有printf、没有差分测试、没有AM

---

# 痛苦的调试经历

通过内联汇编在matrix-mul-big中打印一些调试信息
* matrix-mul-big可以HIT GOOD TRAP

删除仅有的log之后
* matrix-mul-big又会GIT BAD TRAP

----

> 真正难调试的bug不仅难于定位，甚至还会躲着你。
>     -- 沃•镃基•硕德

---

# 差分测试的重要意义

你的某条指令如果实现错了，差分测试会在第一时间汇报给你，而不至于像滚雪球一样，等你发现bug，离出错的地点已经遥不可及。

--
count:false

----

又是某位学长的亲身经历：

在第二届****比赛中，离决赛提交还剩一个星期的时候，yzh突然让lzg实现一下乱序核心，并让oxf实现一下mmu，最终这两个特性都作为亮点加入到了决赛提交的作品中，而能完成这一壮举的关键，就在于差分测试。

比赛一开始，队伍便实现了一个mips32的模拟器，随后一直跟进硬件的实现同步演化。在硬件电路上加指令、新特性或外设之前，先在模拟器上跑通，然后再让硬件实现跟模拟器进行差分。

---

# nemu上的差分测试原理

涉及到的源文件
* src/monitor/diff-test/
* tools/qemu-diff/

基本过程
* **nemu通过gdb serial protocol向qemu服务器通信**
  * https://sourceware.org/gdb/current/onlinedocs/gdb/Remote-Protocol.html#Remote-Protocol
* nemu每执行一条指令之后，都发送请求，让qemu也执行一条指令
* qemu执行完毕之后，nemu请求所有的寄存器信息，然后与本地寄存器进行比对

---

# 更实用的调试器

假设你在nemu的naive的调试器中想要执行下面一条语句
* `x/32w ((struct _RegSet *)pcb->regs)->esp`

在你的naive的调试器中非常难实现
* 需要读符号表、更完善的表达式求值器、...

--
count:false

----

基于gdb serial protocol的实用调试器
* 在nemu中实现gdb stuff
* 启动nemu时fork出gdb子进程使其与nemu通信
* 向gdb输入调试指令，gdb将调试指令翻译成原语发送给nemu
* nemu只需要执行一些简单的原语就可以获得一个强力的调试器

---

# 更实用的调试器

一些需要实现的原语
* gdb_read_registers / gdb_write_registers
* gdb_read_memory / gdb_write_memory
* gdb_single_step / gdb_continue
* gdb_insert_breakpoint / gdb_remove_breakpoint (非必须)

--
count:false

----

在之前所说的大赛中，我们的队伍编写的nemu-mips32模拟器便使用了这样的调试器来调试linux（虽然最后没能调通）。

---

# 推荐的参考代码

互联网博客/问答

* 🚫 不推荐CSDN/cnblogs/...的代码 (参差不齐)
* ✅ Stackoverflow上的高票回答

参考代码 (RTFSC)

* 暂时没有想到好的ICS参考代码。想到可以告诉我。QEMU好像太复杂了点。
* OS课的参考代码：busybox (本课程也推荐), newlib, xv6 (进阶)
    * 就像大家都喜欢把每天身边用的东西拆了看看怎么工作的，busybox就是个不错的简化版

</textarea>

<script src="/static/js/remark-latest.min.js"></script>

<script>
  var slideshow = remark.create();
  // $('.remark-slide-content').quickfit({'font-size':12px});
</script>

    <script>
      $("math").each(function() {
        var tex = $(this).text();
        var html = katex.renderToString(tex, {
          throwOnError: false
        });
        $(this).replaceWith(html);
      });
    </script>
  </body>
</html>
