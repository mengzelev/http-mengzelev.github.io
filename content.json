{"meta":{"title":"Mengzelev's blog","subtitle":null,"description":"nothing to write","author":"Mengzelev","url":"https://mengzelev.github.io"},"pages":[{"title":"萌捷列夫的自我介绍","date":"2019-01-15T16:00:00.000Z","updated":"2019-01-16T10:05:51.829Z","comments":true,"path":"about/index.html","permalink":"https://mengzelev.github.io/about/index.html","excerpt":"","text":"南京大学计算机科学与技术系就读中 作业都写不完，分数也没有的菜鸡 喜欢写点新手友好的教程和大家分享cs学习的心路历程 也会放笔记和实验报告上来凑数 是个话痨 喜欢敲代码，但是算法题苦手 业余爱好是看番和听VOCALOID 总之请多指教！"},{"title":"友情链接","date":"2019-01-16T09:40:48.000Z","updated":"2019-01-16T11:29:37.225Z","comments":true,"path":"friends/index.html","permalink":"https://mengzelev.github.io/friends/index.html","excerpt":"","text":"My Friends Link Marukohe Ricky-Ting Doowzs Fancy Michael Yan kuangsl congee"}],"posts":[{"title":"问求学习笔记-置换群与拉格朗日定理","slug":"ps-4-3-permutation-lagrange","date":"2019-03-09T09:15:13.000Z","updated":"2019-03-10T07:40:08.172Z","comments":true,"path":"2019/03/09/ps-4-3-permutation-lagrange/","link":"","permalink":"https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/","excerpt":"","text":"置换群(Permutation Group)定理5.1:The symmetric group on $n$ letters, $S_n$, is a group with $n!$ elements, wherethe binary operation is the composition of maps. 置换群(permutation group):所有排列的集合$S_n$的一个子集 Cycle NotationA permutation $\\sigma\\in S_X$ is a cycle of length $k$ if there exite elements $a_1,a_2,…a_k\\in X$ such that \\sigma(a_1) = a_2\\sigma(a_2) = a_3...\\sigma(a_k) = a_1and $\\sigma(x)=x$ for all other elements $x\\in X$. We write $(a_1,a_2,…a_k)$ to denote the cycle $\\sigma$. Cycles are the building blocks of all permutations.循环是所有排列的基石。 Two cycles in $S_X$, $\\sigma=(a_1,a-2,…a_k)$, $\\tau=(b_1,b_2,…b_l)$, are disjoint if $a_i\\neq b_j$ for all $i$ and $j$ 命题5.8: Let $\\sigma$ and $\\tau$ be 2 disjoint cycles in $S_X$. Then $\\sigma\\tau=\\tau\\sigma$. 定理5.9: $S_n$中的所有排列都可以被写成不相交循环的乘积的形式。 Transpositions: a cycle of length 2 (任意两个数交换位置) 命题5.12: 任意至少含有两个元素的有限集的排列都可以写成transposition乘积的形式e.g. (253)=(23)(25) 引理5.14: identity(恒等变换)只能写成偶数个transposition的乘积的形式 定理5.15: 如果一个排列能被写成偶数个置换乘积的形式，那么另一个与之等价的排列也一定拥有偶数项置换乘积。奇数同理。据此定理可以将排列分为奇偶两类 交替组(The Alternating Groups)交替组$A_n$是所有偶排列的集合 定理5.16: 集合$A_n$是$S_n$的子群 命题5.17: $S_n$中奇排列和欧排列的数目相等，都为$n!/2$ 反组(Dihedral Groups)the nth dihedral group($D_n$): the group of rigid motions of a regular n-gon(正多边形的刚性运动=转动+反射) 定理5.20: $D_n$ is a subgroup of $S_n$ of order $2n$ 定理5.23: The group $D_n$, $n\\ge 3$, consists of all products of the two elements $r$ and $s$, satisfying the relations r^n=1s^2=1srs=r^{-1}($r,s$分别为转动和反射) D_n=\\{1,r,r^2,..,r^{n-1},s,sr,sr^2,...,sr^{n-1}\\}立方体的运动命题5.27: The group of rigid motions of a cube contains 24 elements. 命题5.28: The group of rigid motions of a cube is $S_4$.(看体对角线) 陪集(Coset)$G$为群，$H$为$G$的子群，定义左陪集(left coset): $gH=\\{gh:~h\\in H\\}$右陪集(left coset): $Hg=\\{hg:~h\\in H\\}$ (这真的不是汞吗)其中$g\\in G$称为代表元(representative) 在交换群中，左陪集与右陪集是相同的。 引理6.3: $g_1,g_2\\in G$，以下条件等价:$1. g_1H=g_2H$;$2. Hg_1^{-1}=Hg_2^{-1}$;$3. g_1H\\subset g_2H$;$4. g_2\\in g_1H$;$5. g_1^{-1}g_2\\in H$; 定理6.4: $H$为$G$的子群。$H$的左陪集分割(partition)了$G$,即$G$是$H$的左陪集的disjoint union. (右陪集同理) index of $H$: the number of left cosets of $H$ in $G$. 表示为$[G:H]$ 定理6.8: $H$在$G$中的左陪集与右陪集的个数相等。 拉格朗日定理命题6.9: 定义映射$H\\to gH$ by $\\phi(h)=gh$. 该映射是双射，$H$中元素的个数等于$gH$中元素的个数。 定理6.10(拉格朗日定理): Let $G$ be a finite group and let $H$ be a subgroup of $G$. Then $|G|/|H|=[G:H]$ is the number of distinct left cosets of $H$ in $G$. In particular, the number of elements in $H$ must divide the number of elements in $G$. |G|=[G:H]|H|推论6.11: Suppose that $G$ is a finite group and $g\\in G$. Then the order of $g$ must divide the number of elements in $G$. 推论6.12: Let $|G|=p$ with $p$ a prime number. Then $G$ is cyclic and any $g\\in G$ such that $g\\neq e$ is a generator. 含有质数个元素的群为循环群且任何非单位元的元素都是生成元。 推论6.13: Let $H$ and $K$ be subgroups of a finite group $G$ such that $G\\supset H\\supset K$. Then $[G:K]=[G:H][H:K]$. 拉格朗日定理的逆命题是不成立的 命题6.15: The group $A_4$ has no subgroup of order 6. 定理6.16: Two cycles $\\tau$ and $\\mu$ in $S_n$ have the same length if and only if there exists a $\\sigma\\in S_n$ such that $\\mu=\\sigma\\tau\\sigma^{-1}$. 费马与欧拉定理欧拉函数$\\phi(n)$表示$n$以内与$n$互质的数的个数对任意质数$p$, $\\phi(p)=p-1$ 定理6.17: Let $U(n)$ be the group of units in $\\mathbb{Z}_n$. Then $|U(n)|=\\phi(n)$ 怎么又是欧拉定理6.18(欧拉定理): Let $a$ and $n$ be integers such that $n&gt;0$ and $gcd(a,n)=1$. Then $a^{\\phi(n)}\\equiv 1(\\mod~n)$ 定理6.19(费马小定理): Let $p$ be ant prime number and suppose that $p\\nmid a$($p$ does not divide $a$). Then $a^{p-1}\\equiv 1(\\mod p)$.Furthermore, for any integer $b$, $b^p\\equiv b(\\mod p)$.","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Group Theory","slug":"Group-Theory","permalink":"https://mengzelev.github.io/tags/Group-Theory/"}]},{"title":"问求学习笔记-群论初步","slug":"ps-4-2-group","date":"2019-03-02T06:03:29.000Z","updated":"2019-03-09T09:16:30.471Z","comments":true,"path":"2019/03/02/ps-4-2-group/","link":"","permalink":"https://mengzelev.github.io/2019/03/02/ps-4-2-group/","excerpt":"","text":"由于接下来的书没有中文版了，因此笔记中英文都看心情 群整数等价类命题3.4：模运算下的整数等价类具有以下性质： 加法和乘法交换律 加法和乘法结合律 加法(0)与乘法(1)恒等式 乘法分配律 任意元素都存在加法逆元 $a$为非零整数，$gcd(a,n)=1$当且仅当$a$存在乘法逆元，即存在非零整数$b$，使得$ab\\equiv 1(mod n)$ (虽然我觉得这玩意儿记了应该没什么卵用) 定义 二元运算(binary operation)或合成律(law of composition):a function $G\\times G\\to G$ that assigns to each pair $(a,b)\\in G\\times G$ a unique element $a\\circ b$, or $ab$ in $G$, called the composition of $a$ and $b$ 群(group): a set $G$ together with a law of composition $(a,b)\\mapsto a\\circ b$ that satisfies the following axioms: 合成律满足结合律(asscociative) 存在单位元(identity element)$e\\in G$，满足$e\\circ a = a\\circ e = a$ 对于每个$a\\in G$，都存在逆元$a^{-1}$，使得$a\\circ a^{-1}=a^{-1}\\circ a=e$ 群 = 运算封闭+结合律+单位元+逆元 阿贝尔群(Abelian)或交换群(commutative):满足$a\\circ b=b\\circ a$的群，反之为nonabelian或noncommutative 凯莱表(Cayley table):用加法或乘法描述群的表格 可逆元素群(group of units): 拥有逆元的元素组成的群 一般线性群(general linear group) 四元群(quaternion group) 群是有限的(finite)，或者说有有限序数(has finite order)，当它具有有限个元素，否则是无限的(infinite)或有无限序数(infinite order) 群的基本性质命题3.17: 群中的单位元是唯一的命题3.18: 逆元是唯一的命题3.19: $G$是群，$a,b\\in G$，则$(ab)^{-1}=b^{-1}a^{-1}$命题3.20: $(a^{-1})^{-1}=a$命题3.21: $ax=b$和$xa=b$在$G$中有唯一解命题3.22(左右消去律right and left cancellation law): $ba=ca$ implies $b=c$ and $ab=ac$ implies $b=c$ 对群中的元素，可以定义乘方 定理3.23: 在群中，一般指数的运算律成立 子群 子群(subgroup):仿照子空间的定义 平凡子群(trivial subgroup):$H=\\{e\\}$ 真子群(proper subgroup) 子群必须继承群的二元运算 子群相关的定理命题3.30: $G$的子集$H$是子群当且仅当 $G$的单位元$e\\in H$ $H$对$G$的运算封闭：If $h_1,h_2\\in H$, then $h_1h_2\\in H$ If $h\\in H$, then $h^{-1}\\in H$ 命题3.31: $H$是$G$的子群当且仅当$H\\neq\\emptyset$ and whenever $g,h\\in H$ then $gh^{-1}$ is in $H$ 循环子群(Cyclic Subgroups)定理4.3: Let $G$ be a group and $a$ be any element in $G$. Then the set $\\left⟨a\\right⟩=\\{a^k:k\\in\\mathbb{Z}\\}$is a subgroup of $G$. Furthermore, $⟨a⟩$ is the smallest subgroup of $G$ that contains $a$. 循环子群(Cyclic Subgroup):$⟨a⟩$循环群(Cyclic group): 包含了某个元素$a$，使得$G=⟨a⟩$.此时$⟨a⟩$是$G$的生成器(generator).The order of $a$: 最小的整数$n$满足$a^n=e$，表示为$|a|=n$。如果不存在满足要求的$n$，则称$a$是无穷的(infinite)，表示为$|a|=\\infty$e.g. $\\mathbb{Z}$和$\\mathbb{Z}_n$都是循环群，1和-1是$\\mathbb{Z}$的生成器，1是$\\mathbb{Z}_n$的生成器但不一定是唯一的。 定理4.9: 所有循环群都是可交换的。(Every cyclic group is abelian). 定理4.10: 循环群的子群都是循环子群。(Every subgroup of a cyclic group is cyclic.) 引理4.11: The subgroups of $\\mathbb{Z}$ are exactly $n\\mathbb{Z}$ for $n=0,1,2…$ 命题4.12: Let $G$ be a cyclic group of order $n$ and suppose that $a$ is a generatorfor $G$. Then $a^k = e$ if and only if $n$ divides $k$.($n$能整除$k$,$k$能被$n$整除) 定理4.13: Let $G$ be a cyclic group of order $n$ and suppose that $a\\in G$ is a generatorof the group. If $b = a^k$, then the order of $b$ is $n/d$, where $d = gcd(k, n)$. 引理4.14: The generators of $\\mathbb{Z}_n$ are the integers $r$ such that $1\\le r&lt; n$ and$gcd(r,n) = 1$. $\\mathbb{Z}_n$的生成器与$n$互质。 复数乘法群(Multiplicative Group of Complex Numbers)一堆复数的基础知识……. $r(\\cos\\theta+i\\sin\\theta)$ 会被简写为 $r~cis\\theta$ 命题4.20: $z=r~cis\\theta$ and $w=s~cis\\phi$. Then $zw=rs~cis(\\theta+\\phi)$ 圆群(The circle group)定义: \\mathbb{T}=\\{z\\in\\mathbb{C}: |z|=1\\} 命题4.24: 圆群是$\\mathbb{C}^*$的子群 定理4.25: If $z^n=1$, then the nth roots of unity are z=cis(\\frac{2k\\pi}{n})where $k-0,1,…n-1$. Furthermore, the nth roors of unity form a cyclic subgroup of $\\mathbb{T}$ of order $n$. A generator for the group of the nth roots of unity is called a primitive nth root ofunity. 重复平方法(The Method of Repeated Squares)其实就是快速幂 理论基础: If $b\\equiv a^x (\\mod n)$ and $c\\equiv a^y (\\mod n)$, then $bc\\equiv a^{x+y}(\\mod n)$$(a^{2n})^2\\equiv a^{2\\cdot 2n}\\equiv a^{2^{n+1}}(\\mod n)$","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Group Theory","slug":"Group-Theory","permalink":"https://mengzelev.github.io/tags/Group-Theory/"}]},{"title":"2019年寒假计划(flags)","slug":"2019-winter-flags","date":"2019-02-17T16:00:00.000Z","updated":"2019-01-31T10:11:55.613Z","comments":true,"path":"2019/02/18/2019-winter-flags/","link":"","permalink":"https://mengzelev.github.io/2019/02/18/2019-winter-flags/","excerpt":"","text":"美赛准备 MATLAB入门《MATLAB数学工具软件实例简明教程》 《MATLAB在数学建模中的应用》 研读优秀论文，总结模板 项目 学习Python 分析minilab的git log中的CE数据 HK学术竞赛 等打完美赛再来研究 番剧追番 多罗罗 灵能百分百第二季 关于我转生成为史莱姆的这档事 强风吹拂 不吉波普不笑 约定的梦幻岛 补番 战栗杀机 小林家的龙女仆 吉他 看B站教学视频","categories":[{"name":"Flags","slug":"Flags","permalink":"https://mengzelev.github.io/categories/Flags/"}],"tags":[{"name":"Flags","slug":"Flags","permalink":"https://mengzelev.github.io/tags/Flags/"}]},{"title":"算法导论学习笔记-线性规划","slug":"clrs-29Linear-Programming","date":"2019-02-13T12:28:03.000Z","updated":"2019-02-27T06:24:13.155Z","comments":true,"path":"2019/02/13/clrs-29Linear-Programming/","link":"","permalink":"https://mengzelev.github.io/2019/02/13/clrs-29Linear-Programming/","excerpt":"","text":"知识背景 一个线性规划问题是一个线性函数最小化或最大化的问题，该线性函数服从一组有限个线性约束，分为最小化线性规划和最大化线性规划 可行解：所有满足约束条件的自变量的取值 可行区域：所有可行解在二维空间中构成的凸区域 目标函数：希望最大化的函数 目标值：目标函数在一个特定点上的值 最优解：所有目标值中最大的一个，其目标值为最优目标值 不可行的：一个线性规划没有可行解 无界的：一个线性规划有可行解但没有有限的最优目标值 标准型和松弛型标准型 所有的约束都是不等式 标准型=目标函数+约束+非负约束 重写为向量与矩阵的形式，可以用一个元组$(A,b,c)$来表示一个标准型的线性规划 最大化c^Tx满足约束Ax\\le b x\\ge 0 线性规划的等价：对两个最大化线性规划$L$和$L’$，如果对$L$的每个目标值为$z$的可行解$\\overline{x}$，都存在一个对应的$L’$的目标值为$z$的可行解的$\\overline{x}’$；(反过来同理)，则称$L$和$L’$是等价的。 最小化线性规划和目标函数取负后得到的最大化线性规划是等价的 非标准型的标准化 目标函数是最小化：取负 某些变量不具有非负约束：假设$xj$无线性约束，则将所有出现的$x_j$替换为$x{j}’-x{j}’’$，并令$x{j}’\\ge 0, x_{j}’’\\ge 0$ 存在等式约束：$\\ge + \\le$ 存在大于等于约束：取负 松弛型 松弛变量$s=bi-\\sum\\limits{j=1}^{n}a_{ij}x_i,s\\ge 0$ 只有非负约束是不等式，其余都是等式 当从标准型转换到松弛型时，我们将使用$x{n+i}$表示与第$i$个不等式相关的松弛变量$$x{n+i}=bi-\\sum\\limits{j=1}^{n}a{ij}x_i,x{n+i}\\ge 0$$ 基本变量：等式左边的变量 非基本变量：等式右边的变量 有时描述时会省略词语“最大化”和“满足约束”以及明显的非负约束要求 简洁记号 $N$:非基本变量下标的集合 $B$:基本变量下标的集合 $N\\cup B=\\{1,2,…,n+m\\}$ 用一个元组$(N,B,A,b,c,v)$来表示松弛型 这里的$a_{ij}$是“出现”在松弛型中的 负数 $A,b,c$的小标不必是连续整数的集合，依赖于索引集合$B$和$N$ 将问题表达为线性规划单对最短路径如下的线性规划可以计算从$s$到$t$的最短路径权值 之所以是最大化目标函数，是因为最短路径问题的一个最优解把每一个$\\overline{d}_v$设置成所有$\\overline{d}_u+w(u,v)$的最小值，使得$\\overline{d}_v$是小于等于集合$\\{\\overline{d}_u+w(u,v)\\}$所有值的最大值；而最小化目标函数会使所有$\\overline{d}_v=0$，这个解显然没有意义 最大流最大流问题表示为一个线性规划 这个线性规划可以重写为有$O(V+E)$个约束的表示，这样计算起来会更高效 最小费用流问题描述 最大流的推广 每条边除了容量还有费用值$a(u,v)$。如果通过边$(u,v)$传送了$f{uv}$个单位的流，那么产生了一个费用$a(u,v)f{uv}$。 求从$s$到$t$发送$d$个单位的流(流目标)，使得流上发生的总费用$\\sum\\limits{(u,v)\\in E}a(u,v)f{uv}$最小 最小费用流有专门设计的多项式时间算法，但算导上没有涉及到 线性规划建模 这不是很直观吗 多商品流问题描述 在最小费用流问题的基础上，有$k$种不同的商品$K_1,K_2,…,K_k$，其中用三元组$K_i=(s_i,t_i,d_i)$来详细说明商品的源点、汇点和需求 定义商品$i$的流$fi$，汇聚流为各种商品流的总和$f{uv}=\\sum\\limits{i=1}^{k}f{iuv}$ 不用最小化任何目标函数，只需要确定是否存在这样的一个流 线性规划建模 单纯性算法 求解线性规划的经典方法 在最坏情况下执行时间非多项式 在实际中次算法通常相当快速 可以看成不等式上的高斯消元法 主要思想 每轮迭代都关联一个“基本解” 从松弛型中得到“基本解” 将每个非基本变量设为0，并从等式约束中计算基本变量的值 每轮迭代把一个松弛型转换成一个等价的松弛型 如果一个非基本变量从0开始增加时目标值也增加(目标函数中系数为正)，则增加该非基本变量直到某基本变量为0 重写松弛型，交换此基本变量和选定的非基本变量，这个操作称为转动 一个转动选取一个非基本变量$x_e$(替入变量)和一个基本变量$x_l$(替出变量) 单纯型算法执行了两个操作 重写等式使得变量再等式的左边与右边之间移动 替换一个等式为另一个等式 这两个操作都建立了等价的问题 步骤 在目标函数中选一个最大正系数非基本变量$x_1$，尝试增大$x_1$，使得$z$增大(增大时必须满足约束条件) 找到最紧的约，解出$x_1$ 将$x_1$代入系统中其他约束和目标函数【转动】 找到新系统的基本解 转动 输入：元组$(N,B,A,b,c,v)$，替出变量$x_l$的下标$l$(从左边调到右边),以及替入变量$x_e$的下标$e$(从右边调到左边)出入是相对非基本变量集合$N$而言的 输出：新松弛的元组$(\\hat{N},\\hat{B},\\hat{A},\\hat{b},\\hat{c},\\hat{v})$ 正式的单纯性算法SIMPLEX 输入：一个标准型的线性规划 输出：一个$n$维向量，表示该线性规划的一个最优解 假设INITIALIZE-SIMPLEX过程返回一个初始基本解可行的松弛型或不可解信息 3~12行：算法主体 如果都是目标函数所有系数为负，则while循环终止，否则第4行选择替入变量$x_e$ 5~9行检查每个约束，然后挑出一个最严格限制$x_e$增加幅度的约束相关联的基本变量$x_l$，如果没有约束能够限制替入变量增加的幅度，则在第11行返回“无界” 调用PIVOT交换替入变量和替出变量 13~16行吧所有非基本变量设为0，把基本变量$\\overline{x_i}$设为$b_i$ 17行返回这些值 循环不变式while循环每次迭代开始： 此松弛型等价于调用INITIALIZE-SIMPLEX返回的松弛型 对每个$i\\in B$，有$b_i\\ge 0$(保证新系统的基本解可行) 此松弛型相关的基本解是可行的 需要保证while循环终止，可以通过第4行和第9行总是选择具有最小下标的变量来打破目标值不变的局面 假设INITIALIZE-SIMPLEX返回一个基本解可行的松弛型，那么SIMPLEX要么报告一个线性规划是无界的，要么以一个可行解结束，且至多$(^{m+n}_{m})$次循环内终止 对偶性对偶性：给定一个最大化问题，我们定义一个相关的最小化问题，使得这两个问题具有同样的最优目标值(e.g.最大流最小割) 给定一个标准型的原式线性规划，我们定义其对偶线性规划为(将最大化改为最小化，交换右边系数与目标函数的系数) 弱对偶性：原式线性规划的任意可行解的值不大于此对偶线性规划的任意可行解的对应值 引理 29.8：线性规划对偶性 证明涉及大量数学推导 对偶问题都可以像最大流最小割一样，用来转移火力，找到一个等价的问题来求解原来的问题","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://mengzelev.github.io/tags/Graph-Algorithms/"}]},{"title":"SVM的临时抱佛脚for HK","slug":"SVM-getstart","date":"2019-02-12T06:28:39.000Z","updated":"2019-03-02T02:32:09.405Z","comments":true,"path":"2019/02/12/SVM-getstart/","link":"","permalink":"https://mengzelev.github.io/2019/02/12/SVM-getstart/","excerpt":"","text":"参考资料B站 机器学习（Machine Learning）- 吴恩达（Andrew Ng） 关于调参使用SVM需要指定的参数 参数$C$ $C$较大：小偏差，大方差 $C$较小：大偏差，小方差 核函数(kernel)的选择 线性核函数(Linear Kernel/No Kernel) 高斯核函数(Gaussian Kernel) 以上是两个最常用的核函数 多项式核函数 字符串核函数 卡方核函数 …. $n=$number of features, $m=$number of training examples If $n$ is large(relative to $m$),e.g.$n\\ge m$, use logistic regression or SVM without a kernel If $n$ is small, $m$ is intermediate, use SVM with Gaussian kernel If $n$ is is small, $m$ is large, create/add more features, then use logistic regression or SVM without a kernel 线性核函数特征数较多，样本数较少时选择 高斯核函数f_i=exp(-\\frac{\\Vert{x-l^{(i)}}^2}{2\\sigma^2}),\\text{where} l^{(i)}=x^{(i)}选择高斯核的情况：特征数较少，样本较多 $\\sigma$的选取： 大$\\sigma$: high bias, low variance 小$\\sigma$: low bias, high variance Note:在使用高斯核之前记得特征归一化(feature scaling) 多项式核函数(x^Tl + C)^d 当$x$和$l$都是严格的非负数时才会使用 用得不多","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://mengzelev.github.io/tags/Machine-Learning/"}]},{"title":"HKUST项目讨论内容","slug":"HKUST-discussion","date":"2019-02-11T07:12:48.000Z","updated":"2019-02-19T07:05:47.387Z","comments":true,"path":"2019/02/11/HKUST-discussion/","link":"","permalink":"https://mengzelev.github.io/2019/02/11/HKUST-discussion/","excerpt":"","text":"问题理解原文【来自有道机翻】预测Sklearn程序的运行时间在共享基础设施上高效运行分布式应用程序具有挑战性。过去的研究表明，选择合适的硬件配置可以显著提高性能和降低成本。为了选择最佳配置，需要准确地预测不同应用程序的性能。 我们考虑这个挑战的一个简化版本:预测单个服务器上机器学习程序的性能。Scikit-learn (sklearn)是一个用于python的机器学习库。提供的数据集描述了在sklearn中运行SGDClassifier的几个示例。数据集的特征描述了SGDClassifier以及用于生成综合训练数据的特征。待分析数据为SGDClassifier的训练时间。 在这个文件夹中，您可以找到一个样例训练数据集(“sample_train.csv”)。“Time”是模型的训练时间。具体来说，“n_samples”、“n_features”描述了如何使用sklearn.dataset.make_classification生成训练合成数据集。在生成数据集之后，即使用SGDClassifier进行分类。‘l1_ratio’，‘alpha’，‘max_iter’描述了sklearn.linear.model.SGDClassifier的设置。所有特性名称都遵循sklearn文档中的定义。 本项目的目标是最小化预测运行时间的误差，即您应该预测接近真实运行时间的测试集的运行时间。使用的评价指标是均方误差。您可以找到“sample_test.csv”和“sample_submission”，用于测试集和解决方案提交格式。 项目分为两个阶段: 阶段1：在访问HKUST前，你可浏览样本数据集及草拟解决方案。建议您提前处理数据集并准备模型。 阶段2:在您访问期间，我们将为您提供一个更大的数据集，包含更多的示例和特性。然后，您可以使用扩展的数据集处理您的解决方案。请注意，我们在阶段1中提供的数据只是一个示例，在示例数据集上建立一个准确的模型并不一定意味着在这个阶段在真实数据集上具有良好的性能。 项目的其他信息和要求: 所有的训练和测试数据集都在同一个服务器上生成。 不受编程语言或机器学习技术的限制。但是，您不允许运行sklearn程序来扩展训练集或预测测试集。 你需要在你自己的笔记本电脑上编程和训练你的模型。 任何查询欢迎发送邮件至jxiaab @ust.hk与Jiacheng Xia联络 相关名词说明 make_classification sklearn.linear_model.SGDclassifier 任务概括 得到一个时间关于l1_ratio, alpha, max_iter, n_samples, n_features这5个参数的回归方程 将以上5个参数重新命名一下，即求$T(x_1,x_2,x_3,x_4,x_5)$ 任务理解看到这个问题，有以下两种思路 把SGDclassifier当成黑盒处理，不管SGD分类器算法的内部运作，用现有的算法作回归分析，拟合回归方程 根据SGD分类器具体运行的原理，自己确定一个时间函数 后者需要的数学知识过多，几乎是不可能做到的，而且到时候还会有一个更大、feature更多的数据集，所以采用前者 数据分析参数解释SGD分类器模型相关 penalty:惩罚函数的选择 l1_ratio:混合惩罚函数中l1和l2方法的比例 alpha:乘以正则项的常数 max_iter:最大迭代次数 random_state:随机数种子 n_jobs:运算使用的CPU个数，’-1’表示使用了所有的CPU 数据生成相关 n_samples:样本个数 n_features:feature个数 n_classes:类别的个数 n_clusters: 每一个分类中的团簇个数 n_informative:看不懂orz flip_y:随机交换所属类别，越大噪声越多 scale:对每个值乘以一个数 演讲思路 问题分析(如果已经有人讲过可以简单带过 简述问题【提取关键字 简要介绍一下SGDclassifier 拉出我们参考的一篇论文，仿照论文决定训练模型计算 我们尝试了诸多算法，决策树表现得比较好【数据可视化列举各种算法的表现情况 介绍决策树 对决策树进行改进【决策树，随机森林 总结结果","categories":[],"tags":[]},{"title":"2019美赛经历","slug":"ICM-feelings","date":"2019-01-30T09:45:38.000Z","updated":"2019-01-31T10:09:50.651Z","comments":true,"path":"2019/01/30/ICM-feelings/","link":"","permalink":"https://mengzelev.github.io/2019/01/30/ICM-feelings/","excerpt":"","text":"在经过了一夜的通宵之后终于把论文交上去惹，然后睡了一天，摸了一天，终于想起来要写这篇blog了。 赛前准备 学习MATLAB基本语法，笔记见MATLAB临时抱佛脚 学习数模基本算法，资料见NJUBroccoli的github仓库 抄写常用算法模板，如：规划问题、AHP、灰色系统、灰色预测、主成分分析、方差分析等 阅读往年赛题和O奖论文，摸清套路 和朋友出去看电影 和队友做迫真模拟 补番 团队配置 po主：cs大二狗，会C/C++，LaTeX，以及Java和Verilog的皮毛，MATLAB是比赛前速成的。建模、计算、写论文、校对多面打杂，兼职美工和排版工人。 队友A：数学系大二小姐姐。建模扛把子。 队友B：大气科学大二小哥哥。负责给建模提供灵感，负责抱大气老师教授大腿，负责询问环科同学、商科同学…这么写会不会被打死 分工 模型是一起讨论建的 数据是一起找的(虽然后来没怎么用上) 编程队友B不会所以我和队友A小姐姐一起负责 论文是每个人挑几个部分一起写的 翻译是交给有道姬完成的，由我和队友A校对因为队友B校对的质量堪忧 排版由原po一人完成 比赛过程选题之前和队友商量好了选E或F题，因为MCM比较有难度，D题需要排队论和马氏链不想看。比赛当天题目公布的时候，看到F题需要不少硬核经济学知识果断放弃了，然后果断就上了E题这条贼船。MCM碰都没碰所以错过了养龙的机会，我想养康娜酱啊呜呜呜 今年赛题内容大致为 A题：养龙 B题：救救难民 C题：美国总统五大洲四日游 D题：逃离卢浮宫 E题：生态服务成本估价 F题：电子货币 (只有E题是认真看过的，如有偏差欢迎指出) 题目概述E题按照惯例是环境问题，今年是要求对生态系统服务(ecological services)进行估价。生态系统服务是指生态系统提供的诸如净化空气、水体自净、保持水土等功能。要求大概有以下几点 建立生态系统估价模型(ecological services valuation model) 对不同规模的土地开发利用项目进行成本效益分析(CBA)，评估这些项目的真实经济成本 决策者和管理者提出建议(implication) 随着时间推移模型如何修改 本来是抱着AHP+GRA+PCA的觉悟来选的E题，结果一看这tm难道不是$\\sum$单价$\\times$数量的小学生模型吗，只要我找到每吨废水处理的价格，每吨垃圾回收的价格etc.然后标准结局出现了：找不到！！！比如污水处理费，中国大陆，HK和法国是按吨收的，美国英国是每年交固定的类似于下水道保护费一样的费用。而且题干里都说了“现在的土地利用项目一般不考虑环境成本”，所以根本就找不到工程前后环境相关的数据。几篇类似的论文都是有自己的监测站的啊！！！！我们上哪找去啊！！！环境经济学的书查了一堆啊！！！直接说环境估价是一个尚未解决的难题啊！！！！【废话要是解决了还会出成赛题吗如此绝望了一天半之后，我们决定，死马当活马医：gtnd，上AHP！然后就开始了玄学AHP玄学建模玄学论文解释由于只是个心路历程记录，所以就不详细解释了 计算我们的玄学模型只有CBA那一块有一丢丢计算量，直接上MATLAB甚至把图调得更好看花的时间还多一些【丢人 论文是大家一起写的中文稿，然后扔给有道姬翻成英文，再手动修改 流水账DAY1： 1234567选题while(true)&#123; 讨论模; 找论文; 找数据; 推翻模型;&#125; DAY2： 找数据 推翻模型 玄学建模开始 玄学AHP 玄学CBA 玄学编程 队友B开始玄学扯淡写论文 DAY3： 12345while(true)&#123; 论文扯淡; 发现模型有问题; 打补丁;&#125; DAY4(通宵)： 写论文 继续给模型打补丁 翻译并校对 排版 提交 感想 美赛是真的很累！！！【不过也有些队伍早早就做完提交了根本没有通宵 前面不知道做些什么，所以每天都睡足了8小时，事情都积到最后一天做了，所以不得不通宵，所幸还是赶上了的 没有养龙好遗憾啊，反正哪题都不会做，不如养龙爽一把，非要吊死在E题上 美赛过于昂贵。3人平分100美元的报名费不说，因为作死没有留在学校里打，导致只能去市图书馆讨论，花费大量金钱在吃饭上，最后一天为了通宵还开了个房 这次的E题感觉还是挺坑的，涉及到不少环境经济学的知识，外行人慎选。其实哪道题都是坑 我们的模型后来算出来西气东输是个失败的工程，感觉小命不保了 33.33美元，体验通宵的感觉，参赛一次，受益一生【棒读】 MCM/ICM真是一个骗钱又坑爹的比赛啊","categories":[{"name":"Diary","slug":"Diary","permalink":"https://mengzelev.github.io/categories/Diary/"}],"tags":[{"name":"Math Modeling","slug":"Math-Modeling","permalink":"https://mengzelev.github.io/tags/Math-Modeling/"}]},{"title":"python学习笔记","slug":"python-getstart","date":"2019-01-23T07:37:50.000Z","updated":"2019-03-13T03:42:01.600Z","comments":true,"path":"2019/01/23/python-getstart/","link":"","permalink":"https://mengzelev.github.io/2019/01/23/python-getstart/","excerpt":"","text":"持续更新中参考： 廖雪峰的Python3教程 《Python编程：从入门到实践》 数据类型Python是动态语言，即变量本身类型不固定，不需要提前声明变量类型的Python有三大数据类型：整数、浮点数、字符串 整数整数可以是任意大小的 浮点数浮点数可以是任意精度的【但是运算也会出现误差】 字符串 字符串用单引号或双引号括起来 会涉及到转义符的问题 在字符串前加r表示让所有的转义符都不转 字符串拼接：+号 几个骚方法 title()首字母大写 upper()全部大写 lower()全部小写 rstrip()暂时删除字符串右端的空白 123456&gt;&gt;&gt; s = 'python '&gt;&gt;&gt; s.rstrip()'python'&gt;&gt;&gt; s'python '&gt;&gt;&gt; s = rstrip() #永久删除右端空格 lstrip()暂时删除字符串左端的空白 strip()同时暂时删除字符串两端空白 注释 Python中使用#注释掉一整行 PyCharm中可以使用Ctrl+/ 类型转换函数 int(x)把x转化为整数 float(x)把x转化为浮点数 str(x)把x转化为字符串 编码问题 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 Python 3的字符串是以Unicode编码的 ord()获取字符的整数表示，chr()把编码转换为对应的字符 字符串类型是str，加前缀b&#39;可以转换为bytes类型 Unicode表示的str通过encode()方法可以编码为bytes类型，反过来bytes类型可以通过decode()方法解码为str类型 12345678&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8')'中文' len()函数返回字符串长度或bytes字节数 始终坚持使用UTF-8对str和bytes进行转换 开头通常需要加上 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 格式化字符串%，用法同C的printf 布尔值 值为True或False 运算and、or、not 空值 None，是一个特殊变量 常量 习惯用全部大写的变量名表示常量 然而并不能保证该变量不会改变，不像C有const list 列表 []表示list []为下标索引，从0开始，同C [-1]表示最后一个元素,负号索引-n就表示倒数第n个这也太nb了吧 list里的数据类型可以不同 list可以嵌套 list方法123456789101112131415len(mylist) #获得list元素的个数 mylist.append('a') # 往list中追加元素到末尾mylist.insert(1, 'a') # 把元素插入到指定位置mylist.pop() # 删除list末尾的元素mylist.pop(1) # 删除指定位置的元素#pop返回值为被删除的元素del mylist[1] #使用del可以删除任何位置的列表元素，条件是知道索引mylist.remove() #按值删除元素，只删除第一个指定的值# `pop和`del`的选择：删除后是否还要使用该元素mylist.sort() #永久排序mylist.sort(reverse = True) #倒序排序sorted(mylist) #暂时排序，也可以加入倒序参数mylist.reverse() #永久倒置mylist[1:3] #list切片，同MATLAB，首尾可缺省copy_list = mylist[:] #通过切片赋值list 切片1234567L[head : tail :step]L[:3] #取出从第0个到第3个元素L[1:3] #取出从第1个到第3个元素L[:10:2] #前10个数，每2个取一个L[::5] #所有数，每5个取一个L[:] #原样复制一个list'ABCDEFG'[1:3] #字符串也可以看成List 列表生成式1234squares = [value ** 2 for value in range(1,11)]squares = [value ** 2 for value in range(1,11) if value % 2 == 0][m + n for m in 'ABC' for n in 'XYZ'] #两两组合双重循环[s.lower() for s in L] #将一个list中所有字符串变成小写 上述代码等价于对squares这个list执行了一个for循环，每个元素都平方(**是乘方的意思)自然语言编程指日可待 生成器generator lits保存的是数据，generator保存的是算法 使用next()函数可以获得generator的下一返回值 generator也是可迭代对象 定义generator 把list的[]变成() 使用yield关键字把函数变成generator 变成generator的函数，每次调用next()时执行，遇到yield语句返回，再次执行时 12345&gt;&gt;&gt; g = (x * x for x in range(10)) #把list的[]变成()就可以得到生成器&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;&gt;&gt;&gt; for n in g: print(n) 1234567891011#斐波那契数列def fib(max): n, a, b = 0, 0, 1 while(n &lt; max): yield b a, b = b, a + b #相当于(a,b) = (b, a+b) n = n + 1 return 'done'&gt;&gt;&gt; for n in fib: print(n) 12345678910111213141516#杨辉三角生成器def triangles(): L = [1,] while True: yield L L = [1,] + [L[i-1] + L[i] for i in range(1, len(L))] + [1,]n = 0results = []for t in triangles(): print(t) results.append(t) n = n + 1 if n == 10: break tuple 元组 与list类似，但是一旦初始化就不能修改，类似于C的enum 不可变的tuple使代码更安全 注：定义一个元素的tuple时需要加一个逗号, tuple的不变是指向不变，即给元组变量赋值是合法的 1234t = () #定义空tuplet = (1,) #定义单元素tupledim = (200, 5)dim = (400, 10) #合法，相当于重新定义了整个元组 分支语句if 除了不要括号、冒号换行、缩进代替大括号外，其他都和C语言一样 else if可以缩写为elif if mylist 可以检验列表是否非空 if a in mylist你以为我是自然语言编程其实我只是检查某个元素在不在列表里哒 123456789# -*- coding: utf-8 -*-s = input('birth:')birth = int(s) //将字符串输入转化为数字类型if birth &gt;= 2000: print('00后')elif birth &lt; 1960: print('60前')else: print('00前') 循环语句forpython有2种循环 for x in ...循环，依次把list或者tuple中的每个元素迭代出来 range(m,n,step)函数生成从m开始到n的整数序列，步长为step，m缺省为0，step缺省为1 123for value in range(1,6): #行尾要有冒号 print(value) #别忘了缩进对齐numbers = list(range(1,11,2)) #list()函数将参数转换为列表 类似C语言的循环123456for i, value in enumerate(['A','B','C']): print(i, value)# enumerate可以将list变成索引-元素对，相当于数组for x,y in [(1,1),(2,4),(3,9)]: print(x,y)#同时对两个变量进行迭代 迭代对象for可以作用于所有可迭代对象 123456789101112# 可以通过isinstance()函数判断一个对象是否为Iterable(可迭代对象)&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)True&gt;&gt;&gt; isinstance('abc', Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False 迭代器 可以被next()调用并不断返回下一个值的对象成为迭代器Iterator Iterator对象表示的是一个数据流 生成器都是Iterator对象 Iterable可迭代对象不一定是Iterator 123456789&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)False&gt;&gt;&gt; isinstance('abc', Iterator)False while123456ans = 0;n = 99;while n &gt; 0: ans += n n -= 2 # 没有n--这种语法糖了print(ans) break和continue都可以像以前一样用 字典dict dict就相当于C++里的map，功能类似于Hash Table 是关键字-值对(key-value),key和value只是名字，并不规定类型 dict相比于list，是在用空间换时间 dict的key必须是不可变对象 创建dict注意dict的初始化使用的{}花括号 12d = &#123;'Michael':95, 'Bob':75, 'Tracy':85&#125; #将名字和成绩对应起来，项比较多的时候可以加上换行d['Adam'] = 67 #直接通过关键字索引放入数据 多次对一个关键字放入数据，后面的值会把前面的冲掉 访问了不存在的关键字时会报错 12'Thomas' in d #返回布尔值，判断某关键字是否在该字典中del d['Bob'] #删除指定关键字 dict方法12d.get('Thomas',-1) #寻找某个关键字的值，-1是规定的不存在时的返回值，缺省时返回None，Python交互环境不显示结果d.pop('Bob') #删除一个关键字 遍历dict12345678for key,value in d.items(): # 使用items()方法可以访问所有条目 print(key + \":\" + value)# 需要声明两个变量，命名任意for key in d.keys(): # 使用keys()方法可以访问所有的关键字 print(key.title())#遍历字典时默认遍历所有key#同理有values()方法 集合set 无序、无重复元素的集合 不能放入可变对象 创建set1s = set([1,1,2,2,3]) #需要提供一个list作为输入，重复元素自动过滤 set方法12s.add(4) #添加元素s.remove(4) #删除元素 set操作12s1 &amp; s2 #交集s1 | s2 #并集 可变对象与不可变对象不可变对象：调用对象自身的方法不会改变该对象自身的内容，而是会创建新的对象并返回，如str可变对象：恰恰相反，如list 函数 函数名可以像变量一样赋值【太骚了 定义函数12345def my_abs(x): #行尾加个冒号 if x = 0: return x else: return -x 空操作123def nop(): pass# pass可以用作占位符，没想好写什么但函数可以先运行起来 参数类型检查1234567def my_abs(x): if not isinstance(x,(int, float)): #数据类型检查 raise TypeError('bad operand type') #异常处理(后续会提到) if x &gt;= 0: return x else: return -x 返回多值这也太骚了 123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 事实上返回的是一个tuple 参数 位置参数：普通意义上的参数 默认参数：有缺省值的参数，如def power(x,n=2) 必选参数在前，默认参数在后 多个默认参数时，可以按顺序调用，也可以将需要修改的参数值的名称写好，不写的使用默认值，如enroll(&#39;Adam&#39;, &#39;M&#39;,city=&#39;Tianjin&#39;) 默认参数必须指向不变对象，例如默认参数为list时用None代替[] 可变参数：参数个数不确定时，可以使用list或tuple传参，带*表示可变参数 参数在函数调用时自动组装为tuple12345678def cal(*numbers): #加*表示可变参数 ans = 0 for n in numbers: ans += n * n return ans #传参&gt;&gt;&gt; cal(1,2) #传递变量&gt;&gt;&gt; cal(*number) #传递list和tuple 关键字参数：允许传入0个或任意个含参数名的参数 参数在内部自动组装为dict123456789101112131415161718192021 def person(name, age, **kw): #表示接受关键字参数`kw` print('name:', name, 'age:', age, 'other:', kw) #调用 &gt;&gt;&gt; person('Michael', 30) #可以只传入必选参数 &gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer') &gt;&gt;&gt; person('Adam', 45, **extra) #将现成的dict作为参数+ 命名关键字参数：在函数内部检查传入了哪些参数 + 为了限制调用者可以传入的参数名，同时可以提供默认值。 + 必须传入参数名，否则调用将报错 + 命名关键字参数可以有缺省值 + 使用时，如果没有可变参数，必须加一个`*`作为分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数 ```py def person(name, age, **kw): if 'city' in kw: #有city参数 pass if 'job' in kw: #有job参数 pass def person(name, age, *, city, job): #限制关键字参数的名字，分隔符*后的参数被视为命名关键字参数 def person(name, age, *args, city, job): #有可变参数时后面的命名关键字参数不再需要分隔符* 参数定义顺序：必选参数、默认参数、可变参数、命名关键字参数和关键字参数 对于任何函数，都可以通过类似func(*args, **kw)的形式调用 P.S. 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3)) 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{&#39;a&#39;: 1, &#39;b&#39;: 2}) *args和**kw是习惯写法 递归12345def fact(n): if n == 1: return n else: return n * fact(n-1) 函数式编程 函数名也是变量 有点C里面函数指针的感觉 123&gt;&gt;&gt; f = abs&gt;&gt;&gt; f(-10)10 高阶函数 接收函数作为参数的函数叫做高阶函数 map map(f,L)，f为函数，L为一个list，表示将f作用于L的每一个元素上 123&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81] reduce reduce(f,L)，把结果继续和序列的下一个元素做累计计算 reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 使用时需要加上from functools import reduce 1234567&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25#求和运算可以直接用sum()函数 map()与reduce()结合使用可以用很少的代码写出str2int函数 12345678910num = &#123;'0':0, '1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9&#125;from functools import reducedef str2num(s): def fn(x,y): return x * 10 + y def char2num(s): return num[s] return reduce(fn, map(char2num, s)) filter 用于过滤list 把传入的函数依次作用于某个元素，根据返回值是True还是False决定保留还是丢弃该元素 返回的是一个惰性序列，需要用list()函数将所有结果组织为list 1234567#筛选回文数def is_palindrome(n): s = str(n) rev = s[::-1] #使用切片倒转字符串 return s == revoutput = filter(is_palindrome, range(1, 1000)) sorted 可以直接对全是数据的list排序，sort(L)返回升序排序的L 可以接受一个key函数来实现自定义的排序，sort(L,key) key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序 然后sorted()函数按照keys进行排序，并按对应关系返回原list的相应元素 要进行反向排序可以传入第三个参数reverse=True 1234567891011def by_name(t): return t[0] #按姓名字母顺序排序def by_score(t): return -t[1] #按分数降序排序L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]L1 = sorted(L, key=by_name)L2 = sorted(L, key=by_score)print(L1)print(L2) 返回函数 函数作为返回值的函数 “闭包”程序结构：相关参数和变量都包含在返回的函数中 返回的函数不会被立刻执行，而是直到调用了才执行 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量 有啥卵用：保存当前的运行环境。被引用的自由变量与函数同在，即使离开了创造它的环境也不例外 将外部函数的变量与内部函数绑定 匿名函数 关键字lambda表示匿名函数，冒号前的x表示函数参数 1234lambda x : x * x#相当于def f(x): return x * x 只能有一个表达式，不用写return，返回值就是该表达式的结果 好处：没有名字，不用担心和其他函数名冲突 匿名函数也是函数对象，可以把匿名函数赋值给一个变量，再利用变量来调用该函数【有毒吗，不能直接def吗 匿名函数也可以作为返回值返回 1L = list(filter((lambda x : x%2==1), range(1,20))) 装饰器 函数对象有个__name__属性，可以获得函数的名字 在代码运行期间动态增加函数的功能的方式成为装饰器(decorator) 123456789101112131415import functoolsdef log(func): @functools.wraps(func) # 把原始函数的属性复制到wrapper()函数中 def wrapper(*args, **kw): print('call %s():' % func.__name__) # 先打印日志 return func(*args, **kw) # 再调用原函数 return wrapper@log # @语法，相当于执行now=log(now)def now(): print(\"2019-2-6\")&gt;&gt;&gt; now()call now():2019-2-6 偏函数 把一个函数的某些参数固定住(设置一个参数的默认值)，返回一个新的函数，可以直接调用这个新的函数 functools.partial(f,*args,**kw) 12int2 = functools.partial(int, base=2) #固定转化为二进制的函数 模块 一个.py文件就是一个模块 可以避免函数名和变量名冲突 包下的是模块，包中必包含init.py模块 注意模块命名不要与python原有模块冲突 模块名为包名.模块名 类似于C的库 标准模块文件123456#!/usr/bin/env python3# -*- coding: utf-8 -*-' a test module '__author__ = 'Michael Liao' 第一行：标准注释，表示该文件可以直接在Unix/Linux/Mac上运行 第二行：标准注释，表示该文件本身使用标准UTF-8编码 第四行：模块文档注释，任何模块代码的第一个字符串都被视为模块的文档注释 第六行：作者标注，使用__author__变量把作者写进去 使用模块 导入模块：import 模块名 函数和变量的作用域 正常的函数和变量名是公开的(public)，可以直接被引用 类似__xxx__的变量是特殊变量，可以被直接引用，但一般不建议这么做 例如，如果调用len()试图获取一个对象的长度，会自动调用该类的__len__方法 类似_xxx和__xxx的函数或变量是非公开的(private)，不应该被引用，但是Python不能完全限制它们的引用 外部不需要引用的函数和变量全部定义为private，只有外部需要引用的函数才定义为public 安装第三方模块1pip install [模块名] OOP类的定义12class Student(object):# Student是类名 类名一般首字母大写 括号中标明了从哪个类继承下来，所有类最终都继承自object(同Java) 实例 创建实例：类名+()，如bart = Student() 可以自由地给一个实例变量绑定属性 实例的初始化可以使用__init__函数 将一些必须绑定的属性写上去 __init__方法的第一个参数永远是self，需要声明但无需传递(类似于C的this) 不就是构造函数吗123456class Student(object): def __init__(self, name, score): self.name = name self.score = score# 创建实例bart = Student('Bart Simpson',59) 定义方法除了第一个参数是self外，与定义函数无异 访问限制 私有变量：名称前加两个下划线__xxx，外部无法访问(其实只是Python解释器把它解释为了另一个名字) 单下划线实例变量名:“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问” 继承和多态 基本类似Java的继承 子类继承父类的方法 子类和父类可以有相同的方法，但子类的方法会覆盖父类的方法 “鸭子类型”：一个对象只要“看起来像鸭子，走起路来像鸭子”，就可以被看成鸭子 不要求严格的继承体系，调用方法时只要保证对象有这样的方法 获取对象信息 type()函数：判断对象、函数类型，返回对应的Class类型，可以用if语句比较两个变量的类型是否相同 判断基本数据类型可以直接写int，str等 判断一个对象是否是函数可以使用types模块中定义的常量1234567891011121314&gt;&gt;&gt; type(123) == intTrue&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():... pass...&gt;&gt;&gt; type(fn) == types.FunctionTypeTrue&gt;&gt;&gt; type(abs) == types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x : x) == types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10))) == types.GeneratorTypeTrue isinstance()可以用来判断继承关系 能用type()判断的基本类型也可以用isinstance()判断 优先使用isinstance() dir()可以获得一个对象的所有属性和方法，返回一个包含字符串的list 12&gt;&gt;&gt; dir('ABC')['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill'] 配合getattr()，setattr()和hasattr()可以直接操作一个对象的状态 12345678910111213141516171819202122&gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？False&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？True&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'19&gt;&gt;&gt; obj.y # 获取属性'y'19&gt;&gt;&gt; hasattr(obj, 'power') # 有属性'power'吗？True&gt;&gt;&gt; getattr(obj, 'power') # 获取属性'power'&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81 只有在不知道对象具体信息时，才会去获取对象的信息1234567 #正确用法 def readImage(fp):if hasattr(fp, 'read'): return readData(fp)return None# 假设我们希望从文件流fp中读取图像# 我们首先要判断该fp对象是否存在read方法 实例属性和类属性 给实例绑定属性：通过实例变量或self变量 类本身需要绑定属性：直接在class中定义 类的所有实例都可以访问类属性1234567891011class Student(object): count = 0 def __init__(self, name): self.name = name Student.count += 1 # 类的属性增加一，而非实例的属性self.countAbart = Student('Bart')print(Student.count)lisa = Student('Lisa')print(Student.count) slots 实例可以绑定属性和方法 绑定方法需要使用到types模块中的MethodType`方法 12345&gt;&gt;&gt; from types import MethodType&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法&gt;&gt;&gt; s.set_age(25) # 调用实例方法&gt;&gt;&gt; s.age # 测试结果25 以上方法绑定的方法对其他的实例是不起作用的 给类绑定方法可以给所有实例绑定方法，是一种动态绑定，绑定后所有实例均可调用 1234&gt;&gt;&gt; def set_score(self, score):... self.score = score...&gt;&gt;&gt; Student.set_score = set_score 使用__slots__可以限制实例的属性 仅对当前类的实例起作用，对继承的子类是不起作用的 如果在子类中也定义__slots__，则子类实例允许定义的属性 = 自身的__slots__ + 父类的__slots__ @property @property是装饰器，负责把一个setter方法变成属性赋值 123456789101112class Student(object) @property def score(self): return self._score # getter属性 @score.setter def score(self, value): # setter属性 if not isinstance(value, int): raise ValueError('score must be an integer') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 and 100') self._score = value @property使得对实例属性操作时，通过getter和setter方法来实现 是定义getter方法就相当于定义了一个只读属性 多重继承 一个子类可以同时获得多个父类的所有功能 12class Dog(Mammal, Runnable): pass MixIn:除主线之外的继承关系 为了更好地看出继承关系，可以把主线外的继承类命名为xxxMixIn，如RunnableMixIn 这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类 Java是只允许单一继承的，不允许MixIn的继承 定制类上文提到的 __len__方法能让class作用于len()函数，就是一种定制类的方法 str __str__方法可以改变类的实例的打印方式，类似于Java的toString 12345678class Student(object): def __init__(self): self.name = name def __str__(self): return 'Student object (name: %s)' % self.name&gt;&gt;&gt; print(Student('Michael'))Student object (name: Michael) repr __repr__方法 直接显示变量调用(在交互模式下敲出变量名) __str__()方法返回用户看到的字符串，__repr__()返回程序开发者看到的字符串，为调试服务 通常__str__()和__repr__()代码都是一样的，有个偷懒的写法 123def __str__(self): pass__repr__ = __str__ iter __iter__方法返回一个迭代对象，让类可以被用用于for ... in循环 配合__next__方法，for循环会不断调用该迭代对象的__next__()方法得到循环的下一个值，直到遇到StopIteration错误退出循环 1234567891011121314151617181920212223class Fib(object): def __init__(self): self.a,self.b = 0,1 def __iter__(self): return self def __next__(self): self.a,self.b = self.b, self.a+self.b if self.a &gt; 100000: raise StopInteration() return self.a &gt;&gt;&gt; for n in Fib(): print(n) 1 1 2 3 5 ... 46368 75025 getitem __getitem__方法使类可以像list那样根据下标取出元素 123456789101112131415161718192021222324252627class Fib(object): def __getitem__(self, n): if(isinstance(n, int)): # n是索引 a,b = 1,1 for x in range(1, n): a,b = b,a+b return a if(isinstance(n, slice)): # n是切片 start = n.start stop = n.start if start is None: start = 0 a,b = 1,1 L = [] for x in range(stop): if x &gt;= start: L.append(a) a,b = b,a+b return L&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f[0]1&gt;&gt;&gt; f[100]573147844013817084101&gt;&gt;&gt; f[0:5][1, 1, 2, 3, 5] 以上__getitem__()方法没有对步长和负数做处理，因此要正确实现一个__getitem__()还是有很多工作要做的 如果把对象看成dict，__getitem__()的参数也可能是一个可以作key的object，例如str，与之对应的还有__setitem__和__delitem__ getattr __getattr__方法能够动态返回一个属性，当调用不存在的属性时，会试图调用__getattr__(self,属性)来尝试获得属性 只有在没有找到属性的情况下才会调用__getattr__，已有的属性是直接获取的 123456class Student(object):def __getattr__(self, attr): if attr=='age': return lambda: 25 raise AttributeError('\\'Student\\' object has no attribute \\'%s\\'' % attr) call __call__使实例自身能被当作函数调用 12345678910class Student(object): def __init__(self, name): self.name = name def __call__(self): print('My name is %s.' % self.name)&gt;&gt;&gt; s = Student('Michael')&gt;&gt;&gt; s()My name is Michael 通过callable函数可以判断一个对象是否能被调用 12345678910&gt;&gt;&gt; callable(Student())True&gt;&gt;&gt; callable(max)True&gt;&gt;&gt; callable([1, 2, 3])False&gt;&gt;&gt; callable(None)False&gt;&gt;&gt; callable('str')False 枚举类Enum12from enum import EnumMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')) 这样就得到了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量 也可以枚举该类的所有成员 12from name,member in Month.__members.items() print(name, '=&gt;', member, ',', member.value) value属性是自动赋给int常量，默认从1开始计数(居然不是从0开始) 从Enum派生自定义类可以精确控制枚举类型 12345678910111213141516from enum import Enum@unique #装饰器，帮忙检查有无重复值class Weekday(Enum): # Enum的子类 Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6# 访问Weekday.MonWeekday['Tue']Weekday(1) type()函数 动态语言的函数和类不是编译时定义的，而是运行时动态创建的 type()函数可以查看一个类型或变量的类型 type()函数可以创建出新的类型，而无需通过class定义 123456def fn(self, name='world'): print('Hello, %s.' % name)Hello = type('Hello', (object,), dict(hello=fn)) #创建Hello类&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world. type()函数需依次传入3个参数 class的名称 继承的父类的集合，注意单元素tuple的写法 class的方法名称与函数绑定 metaclass()函数 先定义metaclass(元类)，就可以创建类，然后创建实例 可以把类看成metaclass创建出来的实例 metaclass正常情况下不会用到所以看不懂也没关系 123456789# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs)# 使用metaclass定制类class MyList(list, metaclass=ListMetaclass): pass 创建Mylist时，通过ListMetaclass.__new__()来创建 可以用来修改类的定义，例如加上新的方法(样例中在MyList类中增加了add方法) __new__()方法接收的参数依次是 当前准备创建的类的对象 类的名字 类继承的父类的集合 类的方法的集合 应用上与SQL相结合的较多，等用到的时候再看了 错误、调试和测试try 当我们认为某些代码可能会出错时，可以用try来运行这段代码 如果出错，后续代码不会继续执行，而是直接跳转至错误处理代码 12345678910try: print('try...') r = 10 / 0 print('result:', r)# 错误处理代码except ZeroDivisionError as e: # 可以有多个except print('except:', e)finally: # finally无论如何都会被执行，表示执行结束 print('finally...')print('END') except后可加else语句块，当没有错误发生时会执行else语句块 try...except可以跨越多层调用，被调用者出错，调用者也能捕捉到 Python的错误也是类，所有错误类型都继承自BaseException 常见的错误类型和继承类型 记录错误 python有内置的logging模块，可以记录错误信息 程序打印完错误信息后会继续执行并正常退出 1234try: bar('0') except Exception as e: logging.exception(e) 抛出错误 根据需要，可以定义一个错误的类，选择好继承关系，用raise语句抛出一个错误的实例 只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型，尽量使用Python内置的错误类型 当前函数不知道如何处理该错误时，还可以在打印错误后再往上抛，让顶层调用者去处理 raise语句如果不带参数，就会将当前错误原样抛出 在except中raise一个Error，可以将错误转化成另一种类型 调试 print调试法 assert调试法 12assert n != 0, 'n is zero!'# 表达式应该为True，否则输出AssertionError+后接的字符串 启动python解释器时可以用-O参数来关闭assert log调试法(Python管这叫logging) 1234import logginglogging.basicConfig(level=logging.INFO) # 配置logging.info('n = %d' % n) # logging.info: 输出信息 可以指定DEBUG&gt;INFO&gt;WARNING&gt;ERROR几个不同级别(level)的信息，级别越高越先被屏蔽，e.g.level=INFO时DEBUG的logging就不起作用了 pdb调试法(命令同gdb) l: 查看代码 n: 单步执行 p 变量名: 打印变量 c: 继续执行 pdb.set_trace()在程序中设置断点，运行时程序会自动暂停并进入pdb 123456import pdbs = '0'n = int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 / n) PyCharm调试法 I/O文件读写读文件1234f = open('/path/to/file', 'r')# 失败时会返回IOErrorf.read() #一次性读取全部内容到内存，用一个str对象表示f.close() #关闭文件，回收资源 为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现： 123456try: f = open('/path/to/file', 'r') print(f.read())finally: if f: f.close() 嫌长可以简化为with语句123with open('/path/to/file', 'r') as f: print(f.read())#隐式调用了f.close() 不想一次读取所有文件 123f.read(size) # 读取一定size个字节的内容f.readline() # 一次读取一行f.readlines() # 一次读取所有行并返回list 还可以有效防止内存爆炸 内存的字节流，网络流，自定义流等等都是file-like Object，只需要写个read()方法就能用 二进制文件需要用&#39;rb&#39;模式打开 读取默认使用UTF-8编码，需要编码转换的时候要给open()传入encoding参数,errors参数表示出现错误后怎么处理，一般选择忽略 1f = open('/Users/michael/gbk.txt', 'r', encoding='gbk',errors='ignore') 写文件和读一样，把r改成w(跟C也差不多) StringIO在内存中读写str 12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO() # 创建StringIO对象&gt;&gt;&gt; f.write('hello')5&gt;&gt;&gt; f.write(' ')1&gt;&gt;&gt; f.write('world!')6&gt;&gt;&gt; print(f.getvalue()) #getvalue()用于获得写入后的strhello world! 可以用一个str初始化StringIO，然后，像读文件一样读取 BytesIO操作内存中的二进制数据 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87 操作系统命令Python内置的os模块可以直接调用操作系统提供的接口函数 文件名操作只对字符串进行，并不要求文件真实存在 shutil中可以找到很多对os的补充 1234567891011121314151617181920212223&gt;&gt;&gt; import os&gt;&gt;&gt; os.name #查看操作系统名称&gt;&gt;&gt; os.environ # 查看操作系统中所有的环境变量&gt;&gt;&gt; os.environ.get('key') # 获取某个环境变量的值&gt;&gt;&gt; os.path.abspath('.') # 查看当前目录的绝对路径:'/Users/michael'&gt;&gt;&gt; os.path.join('/Users/michael', 'testdir')# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:'/Users/michael/testdir'# 然后创建一个目录:&gt;&gt;&gt; os.mkdir('/Users/michael/testdir')# 删掉一个目录:&gt;&gt;&gt; os.rmdir('/Users/michael/testdir')# 拆分路径，把当前文件名与目录分开&gt;&gt;&gt; os.path.split('/Users/michael/testdir/file.txt')('/Users/michael/testdir', 'file.txt')# 拆分文件扩展名&gt;&gt;&gt; os.path.splitext('/path/to/file.txt')('/path/to/file', '.txt')# 对文件重命名:&gt;&gt;&gt; os.rename('test.txt', 'test.py')# 删掉文件:&gt;&gt;&gt; os.remove('test.py') 过滤文件不都是一行命令行就能搞定的吗 1234&gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isdir(x)]['.lein', '.local', '.m2', '.npm', '.ssh', '.Trash', '.vim', 'Applications', 'Desktop', ...]&gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']`['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py'] 还有psutil模块提供了对cpu信息、内存和磁盘使用信息的访问 序列化 把变量从内存中变成可存储或传输的过程叫作序列化(picking).序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 用到了再看吧","categories":[{"name":"Self-learning","slug":"Self-learning","permalink":"https://mengzelev.github.io/categories/Self-learning/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://mengzelev.github.io/tags/Python/"}]},{"title":"数学建模几种常用算法","slug":"matlab-usage","date":"2019-01-19T08:41:45.000Z","updated":"2019-01-24T13:22:25.808Z","comments":true,"path":"2019/01/19/matlab-usage/","link":"","permalink":"https://mengzelev.github.io/2019/01/19/matlab-usage/","excerpt":"","text":"数据拟合多项式拟合123456x = [...];y = [...];P = polyfit(x,y,n); % n是多项式的次数xi = 0: .2 :10;yi = polyval(P, xi);plot(xi, yi, x, y, 'r*'); 规划线性规划标准型\\min~c^Tx s.t. Ax\\le b 1[x,y] = linprog(c, -a, -b, [], [], zeros(3,1)) 非线性规划123456[x,y] = fmincon(fun, x0, A, B, Aeq, Beq, LB, UB, [c,ceq], OPTIONS)% fun:目标函数% x0:x的初始条件% A,B,Aeq,Beq:线性约束条件% LB,UB:上下界% [c,ceq]:.m文件定义的非线性约束条件,分别为不等式与等式约束 二次规划1[x, fval] = quadprog(H, f, A, b, Aeq, Beq, LB, UB, X0, OPTIONS) 整数规划 隐枚举法 随机算法(蒙特卡洛) 分枝定界法 其他求解约束最优化问题的函数 fminbnd:单变量非线性函数在区间上的极小值 fseminf fminimax:函数族的极大极小值 灰色预测GM(1,1)模型适用于具有较强指数规律的序列，只能描述单调的变化过程，而Verhulst模型则适用于非单调的摆动发展序列或具有饱和状态的S形序列。原始数列$x^{(0)}$，AGO累加生成数列$x^{(1)}$，加权均值数列$z^{(0)}$ 关联分析和优势分析 根据bigger is better和smaller is better标准将数据分类进行初始化 根据公式算关联系数 根据关联系数计算关联度 灰色预测步骤 数据的检验与处理：计算级比，视情况进行必要的变换处理，使其落入可容覆盖内 建立模型 $x^{(1)}=…$可以得到预测值 残差检验 级比偏差检验 预测预报 另：灾变预测可以构造灾变数列 遗传算法 求解多约束复杂非线性规划问题 直接调库吧，不可能看懂的 层次分析法(Analytic Hierarchy Process) 用于解决较为复杂、模糊、难于定量分析的问题 当影响决策的因素较多且较主观时 分层、构造矩阵、检验一致性 因为基本上做E或F题都会用到，所以详细展开一下 基本步骤 建立递阶层次结构模型； 构造出各层次中的所有判断矩阵； 层次单排序及一致性检验； 层次总排序及一致性检验。 层次结构的建立 构造判断矩阵 层次单排序一致性检验 判断矩阵$A$对应于最大特征值$\\lambda_{max}$的特征向量$W$ ，经归一化后即为同一层次相应因素对于上一层次某因素相对重要性的排序权值，这一过程称为层次单排序 如果比较结果是前后完全一致的，则矩阵$A$的元素还应当满足$a{ij}a{jk}=a_{ik}$，此时矩阵$A$成为一致矩阵 $n$阶正互反矩阵$A$为一致矩阵当且仅当其最大特征根$\\lambda{max}=n$，且当正互反矩阵$A$非一致时，必有$\\lambda{max}&gt;n$ 一致性检验步骤 计算一致性指标$CI=\\frac{\\lambda_{max}-n}{n-1}$ 查找相应的平均随机一致性指标$RI$ 计算一致性比例$CR=\\frac{CR}{CI}$ $CR&lt;0.10$时，认为判断矩阵的一致性是可以接受的，否则应对判断矩阵作适当修正 层次总排序一致性检验设A层(上一层次)包含$A1,…A_m$共$m$个因素，层次总排序权重分别为$a_1,…a_m$，又设其后的下一层次B层包含$n$个因素$B_1,…B_n$，它们关于$A_j$的层次单排序权重分别为$b{1j},…b{nj}$(当$B_i$与$A_j$无关时，$b{ij}=0$)。现求$B$层中各因素关于总目标的权重，即求$B$层个因素的层次总排序权重$b1,…,b_n$。$B$层各因素的层次总排序权重$b_i=\\sum\\limits{j=1}^{m}b{ij}a{j}$B层总排序随机一致性比例CR=\\frac{\\sum\\limits_{j=1}^{m}CI(j)a_j}{\\sum\\limits_{j=1}^{m}RI(j)a_j}$CR&lt;0.10$时认为层次总排序具有较满意的一致性并接受该分析结果 方差分析(ANOVA) 又称F检验 用数理统计分析试验结果、鉴别各因素对结果影响程度的方法 单因素方差分析 任务：从试验结果推断某因素对指标有无显著影响 单因素方差分析表 方差分析命令anoval，p = anoval(x,group)将算得的概率p与\\alpha进行比较 双因素方差分析 p = anova2(x,reps) 多因素方差分析 anovan 12345y = [31 54 38 53 49 42 57 62 64]; %试验结果g1 = [1 2 3 1 2 3 1 2 3]; %正交表第一列g2 = [1 1 1 2 2 2 3 3 3];g3 = [2 1 3 1 3 2 3 2 1];[p,t,st] = anovan(y,&#123;g1,g2,g3&#125;) 回归分析 用来检验拟合函数的准确度 残差：实际观察值，估计值(拟合值)之间的差 $R^2$判定系数：可解释的变异占总变异的百分比 多元线性回归123456[b,bint,r,rint,stats] = regress(y,x,alpha);% b为回归系数估计值% bint为置信区间 % r为残差，rint为残差的置信区间% stats是用于检验回归模型的统计量[R^2,F,p,s^2]% alpha显著性水平，缺省时为0.05 一元多项式回归1234[p,s] = polyfit(x0, y0, 2);% s为用于计算函数值的数据结构，如[y,delta] = polyconf(p,x0,s);y%可以得到y的拟合值、置信区间半径delta 多元二项式回归1234rstool(x,y,model,alpha)% x:n×m维矩阵% y:n维向量%model:线性、纯二次、交叉、完全二次四选一 主成成分分析 用较少的变量去解释原来资料中的大部分变异 选出比原始变量个数少、能解释大部分资料中的变异的几个新变量 步骤 对原始数据进行标准化处理 计算相关系数矩阵$R$ 计算特征值和特征向量 选择$p$个主成分，计算综合评价值 计算综合得分 排队论 有很多公式，用的时候再查吧 优化：最优服务率，最优服务台数 灵敏度分析 当模型的数据中有一个或几个发生变化时，最优解会有什么变化 这些数据在什么范围内变化时，已求解的最优解不变","categories":[],"tags":[]},{"title":"MATLAB临时抱佛脚","slug":"matlab-getstart","date":"2019-01-16T09:04:59.000Z","updated":"2019-01-20T03:49:08.093Z","comments":true,"path":"2019/01/16/matlab-getstart/","link":"","permalink":"https://mengzelev.github.io/2019/01/16/matlab-getstart/","excerpt":"","text":"来源：王正盛 《MATLAB数学工具软件实例简明教程》 入门技能命令行命令matlab基本可以看成一个有自己语法的命令行终端使用下面列举一些我觉得自己将来可能会用到的 clc:擦除当前工作窗中所有显示内容 dir:相当于ls cd:你懂的 who:检查内存变量 whos:检查驻留变量的详细情况 help:召唤FM lookfor:对man进行grep MATLAB也是有当前工作路径的，同Linux的bash 变量变量基本以矩阵形式存在还有一些预定义的变量 eps:计算机表示的最小正数 pi:圆周率 inf或Inf NaN i,j flops:浮点运算次数，用于统计计算量 显示格式 short long short/long e 科学计数法显示 bank 银行格式 hex 十六进制格式 +用于大矩阵的紧凑格式 数值计算矩阵创建 直接输入法 reshape把长行向量拆成$n\\times m$的矩阵 diag可以实现向量和对角阵之间的互相转化 .m和.mat文件 矩阵运算与数组运算 矩阵运算：按矩阵法则进行的运算 数组运算：对元素逐个进行 可以将数组直接作为参数传入函数中，而不用写循环，不同于C MATLAB推荐：尽量使用除运算，少用逆运算 多项式表示 系数行向量表示：$p=[a_0,a_1,…a_n]$ 指令p=poly(AR)产生多项式 若AR是方阵，则产生特征多项式 若AR是向量，则AR中每个数是该多项式=0的解 多项式运算 R = roots(p)：求根 PA = polyval(p,S):按数组运算规则计算多项式的值 PA = polyvalm(p,S):按矩阵运算规则计算多项式的值 P = polyfit(x,y,n):用$n$阶多项式拟合$x,y$给定的数据 数值积分 S = quad(&#39;fname&#39;, a, b, tol, trace) 自适用Simpson数值积分法 S = quad8(&#39;fname&#39;, a, b, tol, trace)自适用Newton-Cotes数值积分法 quad8比quad性能和精度更好 非线性方程 r = roots(p) 多项式非线性函数求根 z = fzero(&#39;fname&#39;, x0, tol, trace) 单变量函数求零点，只给出离x0最近的根 微分方程的数值解 [t,x] = ode23/45(&#39;xprime&#39;, [t0,tf], x0, tol, trace) 文件管理 cd, type, delete, dir，和bash用起来差不多 !可用于执行外部程序 文件输入输出 fopen打开二进制文件 1fid = fopen('a.dat', 'r') fread将数据装入变量 123a = fread(fid);a = fread(fid, 100);a = fread(fid, [10,10]); fwrite按照指定的书精度将矩阵中的元素写入文件 123cnt = fwrite(fid, magic(5), 'integer * 4');%返回写入数据的个数status = fclose(fid); save命令及-ascii选项 12a = rand(4,3)save a.dat a -ascii 符号计算符号定义 sym定义符号或表达式 1234sym('x')sym(`1 + x / 2`)syms a b c d %syms可以定义多个符号 findsym确认符号表达式中的符号 微积分运算求导 diff(f,t,n)函数f对变量t求n阶导，t缺省时对x求导，n缺省为1 参数为矩阵时，作用于每个元素 积分 int(f,t) 函数f对变量t求不定积分 int(f,t,a,b) 函数f对符号变量求从a到b的定积分 极限 limita(f,t,a)当符号变量t-&gt;a时，函数f的极限，t缺省x，a缺省为0 级数和 symsum(s,t,a,b)``s中的符号变量t从a到b的级数和 Taylor展开 taylor(f,n,a)函数f对符号变量x或最接近字母x的符号变量在a点的n-1阶泰勒多项式,n缺省时值为6,a缺省值为0 解方程 solve(f,t)对f中的符号标量t解方程f=0 solve(&#39;fname&#39;,t) 求解形如f(x)=g(x)的方程 dsolve(&#39;S&#39;,&#39;s1&#39;,...&#39;x&#39;) 线性代数 用，都可以用 化简和代换 collect合并同类项 expand将乘积展开为和式 factor将和式展开为乘积 horner嵌套多项式 simplify利用各种 画图二维 plot(x,y)其中x和y为坐标向量 在plot指令中增加一些参数，可以绘制出不同颜色与不同线性的图形，e.g. 1plot(x, y1, 'k:', x, y2, 'b-') 每条曲线的线型和颜色由字符串&#39;cs&#39;指定，其中&#39;c&#39;表示颜色，&#39;s&#39;表示线型 图形标记指令title,xlabel,ylabel,text,legend axis([xmin, xmax, ymin, ymax])设定坐标轴 hold on保持已有图形绘制新的图形 fplot(fname, lims, tol)为函数提供自适应采样 loglog(x,y)双对数坐标 semilogx,semilogy 单对数坐标 polar(theat, rho) 极坐标 三维 plot3用法同plot mesh(x,y,z,c)绘制三维网格图 surf(x,y,z,c)三维曲面图 view指定视点 contour3等高线图 MATLAB程序设计输入输出 input函数 12A = input('Enter matrix A=&gt;')%这样可以在执行该语句时首先给出提示，再接收键盘输入 pause(延迟秒数) Disp()输出函数， 输出项可以为矩阵或字符串 分支语句if语句 结尾需要加end else和if可以连起来写成elseif swith语句与C相比： default改为otherwise 结尾加end 循环语句for语句 for 初始条件:步长(缺省为1):终值 123for i = 1 : 2 : 2*n-1 %循环体end for 循环变量=矩阵表达式，使循环变量取遍矩阵里每个数的值(以行为周期) while语句 结尾加end，用法同C 函数文件 一般格式为 1234function 输出形参表 = 函数名(输入形参表) %注释说明部分 %函数体end 当输出形参多于1个时，用方括号括起来 函数调用[输出参数表]=函数名(输入参数表)，支持嵌套调用和递归 参数个数可变：通过变量nargin和nargout实现 函数内部申明的变量都是局部变量 全局变量前缀global，所有函数都可以对其进行存取和修改 关于括号() 圆括号引用数组中的元素 [] 方括号表示向量或矩阵 {} 花括号用于元胞(cell)数组的分配和引用元胞与矩阵的区别是能放任何类似的元素，而矩阵只能放数值型数据 12345678910D=&#123;[1 2 3 4],'abc',&#123;7 8 9&#125;，[4 5 6;11 22 33]&#125;D&#123;1&#125; %表示D中第一个元素 显示为 1 2 3 4D&#123;1&#125;(2) %表示D中第一个元素中第二个元素 显示为 2D&#123;3&#125;&#123;1&#125; %表示第三个元素中第一个元素 显示为 7D&#123;3&#125;(1) %表示第三个元素中第一个元素 显示为&#123;[7]&#125;D&#123;[1 2 3]&#125; %表示前三个元素 显示为1 2 3 4 ; ‘abc’ ;&#123;[7]&#125; &#123;[8]&#125; &#123;[9]&#125;","categories":[{"name":"Self-learning","slug":"Self-learning","permalink":"https://mengzelev.github.io/categories/Self-learning/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://mengzelev.github.io/tags/MATLAB/"}]},{"title":"问题求解3-总复习","slug":"Problem-Solving-3","date":"2019-01-07T11:21:20.000Z","updated":"2019-01-08T15:40:21.122Z","comments":true,"path":"2019/01/07/Problem-Solving-3/","link":"","permalink":"https://mengzelev.github.io/2019/01/07/Problem-Solving-3/","excerpt":"","text":"动态规划最优子结构 问题的最优解由相关子问题的最优解组合而成，这些子问题可以独立求解 使用“剪切-粘贴”技术证明：假设原问题取得最优解时，子问题没有取最优解，那么可以将子结构从整体删除替换为最优解，这与原问题取得最优解的前提矛盾 子问题间互相独立 运行时间：子问题总数*每个问题要考察的选择数 求解时先找出最优子结构，列出递推式 实现 自顶向下的备忘算法（带备忘的递归） 自底向上的动态规划算法（难写，但是快） 并没有板子 能解决的问题 矩阵乘法问题 最长公共子序列 最长上升子序列 &gt;主要就是一个列递推式的问题但是就是列不出来 贪心贪心选择性质 进行选择时，直接做出当前问题中看来最优的选择，而不必考虑子问题的解 贪心不太方便时可以进行预处理 证明：替换法 贪心算法得到一个解S，假设存在一个抽象的最优解S’，证明S’可以通过若干步满足要求的替换变成S 也可以证明S优于S(e.g.S的代价$\\le$S’的代价)，加上S’优于S的天然条件，可知S与S’都是最优解 解决问题 教室安排问题 Huffman编码树【可以等价为叶结点的带权路径长度之和最小问题 区间选点问题 数轴上有n个闭区间$[a_i,b_i]$。取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以是同一个） 将区间按右端点升序排序，优先处理小区间 实现 这个完全就是因题而异的了啊【哭了 并查集三个基本操作 MAKE-SET($x$) UNION($x,y$) FIND-SET($x$)：返回$x$所在集合的代表元 链表 时间复杂度make和find是$O(1)$，UNION$O(n\\lg n)$ 简单加权合并式启发策略（小的并到大的上 不相交集合森林 按秩合并，路径压缩 make和find$O(1)$，UNION$O(m_{\\alpha}(n))$ 板子123456789101112131415161718192021222324252627282930313233void init() &#123; for(int i = 1; i &lt;= n; ++i) &#123; f[i] = i; rank[i] = 0; &#125;&#125;/*递归版*/int find(int i) &#123; return f[i] == i ? i : f[i] = find(f[i]);&#125;/*非递归版*/int find(int x) &#123; int root = f[x]; while(root != f[root]) root = f[root]; int y = f[x]; while(x != root) &#123; y = f[x]; f[x] = root; x = y; &#125; return root;&#125;void unite(int a, int b) &#123; int fa = find(a); int fb = find(b); if(fa != fb) &#123; if(rank[a] &lt; rank[b]) f[a] = fb; else f[b] = fa; &#125;&#125; 变种 带权并查集 分类并查集 &gt;考到自求多福 解决问题 无向图连通分量个数 图的基本概念参考了ytr的整理 概念 诱导子图 链walk，迹trail，路path 回路circuit，圈cycle 连通性，连通分支 距离，测地线(长度为$u-v$距离的$u-v$路)，直径 环(loop)，你 连 你 自 己 平行边：重边 度数deg，最小度数$\\delta(G)$，最大度数$\\Delta(G)$ 度序列，可图的 几种图 完全图$K_n$ 补图 二部图，完全二部图($K{s,t}$)，星图star($K{1,s}$) 多部图，完全多部图(K_{s,s,s}) $G+H$：$G$和$H$放一起，顶点两两连起来 $G\\times H$：$G$的每个点都替换成一个$H$ n方体cube($Qn=Q{n-1}\\times K_2$) $r-$正则图：每个点度数都为$r$ 定理 设$G$是一个阶至少为3的图，则$G$是连通的当且仅当$G$包含两个不同的顶点$u$和$v$,使得$G-u$和$G-v$都是连通的 非平凡图$G$是二部的当且仅当$G$不含奇圈 图论第一定理：度数和=边数*2 每一个图都有偶数个奇点 设$G$为$n$阶图,若对于$G$中任意两个不邻接的顶点$u$和$v$, 都满足deg~u+deg~v\\geq n-1，则$G$是连通的且$diam(G)\\leq$2 设$r$和$n$为满足$0\\leq r\\leq n-1$的整数． 则存在n阶的r正则图当且仅当$r$和$n$中至少有一个为偶数 度序列可图的充要条件(删掉一个点依然可图) 树定义 割边 树，森林 定理 某条边是割边当且仅当该边不在任何一个cycle上 每一棵非平凡树都至少有两个端点(最长路径的两个端点) 【可以成为数学归纳法的依据】 使用数学归纳法证明图论问题的关键在于找到一个端点 有$k$个连通分量的森林有$n-k$条边，树就有$n-1$条边 每一个有$n$个顶点的连通图至少有$n-1$条边【证明：最小数原理】 任意两条可得树：连通、无环、$m=n-1$ 每个连通图都包含一棵生成树 Matrix Tree Theorem：连通图$G$的生成树个数可以用行列式求得 $T$是唯一最小生成树当且仅当$\\forall e\\in G\\setminus T: w(e)&gt;w(\\text{every other edge on the cycle in $T+e$})$ 推论：distinct weights $\\Leftarrow$ unique MST 推论：Maximum-weight edge in any cycle is unique $\\Leftarrow$ unique MST 若每个点度数大于等于2，则该图有cycle $e$是割边当且仅当$e$存在于$G$的某一棵生成树上 最小生成树性质 Cut Property VER I:$X$是某棵最小生成树的一部分，$(S,V\\setminus S)$是一个$X$没有横跨的切割，$e$为横跨$(S,V\\setminus)$的一条最轻的边，则$X\\cup \\{e\\}$是某棵最小生成树$T_2$的一部分。 VER II:$e$为横跨$(S,V\\setminus)$的一条最轻的边，则$e$属于某棵最小生成树 贪心选择性质，可由替换法证明 Cycle Property 若$e$为任意一个cycle上权重最大的一条边，则存在一棵最小生成树$T$，使$e\\notin T$ Kruskal $O(E\\lg~V)$ 123456789101112131415161718int kruskal() &#123; sort(edge, edge + m, cmp);//将边按权重从小到大排序 int cnt = 0; int ans = 0; for(int i = 1; i &lt;= n; ++i) f[i] = i;//初始化并查集 for(int i = 0; i &lt; m; ++i) &#123; int a = edge[i].u; int b = edge[i].v; int fa = find(a), fb = find(b); if(fa != fb) &#123; f[fa] = fb; ans += edge[i].w; cnt ++; if(cnt == n - 1) break; &#125; &#125; return ans;&#125; Prim $O(E\\lg V)$ 1234567891011121314151617181920int my_prim() &#123; int ans = 0; for(int i = 0; i &lt; n; ++i) &#123; mincost[i] = INF; vis[i] = false; &#125; while(true)&#123; int v = -1; for(int i = 0; i &lt; n; ++i) &#123; if(!vis[i] &amp;&amp; (v == -1 || mincost[i] &lt; mincost[v])) v = i; &#125; if(v == -1) break; vis[v] = true; ans += mincost[v]; for(int i = 0; i &lt; n; ++i) &#123; mincost[i] = min(mincost[i], map[v][i]); &#125; &#125; return ans;&#125; 图的计算机表示及其遍历图的表示 邻接链表 邻接矩阵 BFS 维护一个队列 时间复杂度$O(V+E)$ 搜完了会得到广度优先树 DFS 前驱子图：深度优先森林 边的类型 树边 前向边F：祖宗指向儿子 后向边B：儿子指向祖宗 横向边C：没有亲缘关系 复杂度$O(V+E)$ 每个结点有两个时间戳 $v.d$：记录该结点第一次被发现的时间 $v.f$：记录搜索完成对$v$的邻接链表的扫描的时间 $v.d&lt;v.f$ 拓扑排序 根据DFS后的$v.f$时间戳降序排序，即拓扑序最前的最晚结束访问 若$(u,v)\\in G$，则$v.f&lt;u.f$ 只有DAG才有拓扑排序 SCC算法描述 DFS($G$) DFS($G^{T})$，在主循环根据$v.f$的大小降序访问其邻接点，得到的每棵树都是一个强连通分量 单源最短路径 松弛操作是唯一导致最短路径估计和前驱结点发生变化的操作 性质 三角不等式性质：$s,u,v$ 上界性质：$v.d$撑死就是$\\delta(s,v)$ 非路径性质：$s-v$之间没路则$\\delta(s,v)=+\\infty$ 收敛性质：松弛前是最短路径，松弛后也是最短路径 路径松弛性质：一条最短路径上的点按先后顺序松弛，则终点的估计值等于最短路径长度 前驱子图性质：$v.d=\\delta(s,v)$，则前驱子图是一棵根结点为$s$的最短路径树 Bellman-Ford 对每条边进行$|V|-1$次relax 可以识别负权重环 $O(VE)$ 本质上是DP 12345678910111213void bellman_ford() &#123; dist[s] = 0; for(int i = 1; i &lt;= n - 1; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; if(dist[e[j].u &lt; INF &amp;&amp; dist[e[j].v] &gt; dist[e[j].u] + e[j].w) &#123; dist[e[j].v] = dist[e[j].u] + e[j].w; pre[e[j].v] = e[j].u; &#125; &#125; &#125; for(int j = 1; j &lt;= m; ++j) if(dist[e[j].v] &gt; dist[e[j].u] + e[j].w) flag = false;&#125; DAG 按拓扑序松弛结点（路径松弛性质保证） $\\Theta(V+E)$ Dijkstra 所有权重都非负 二叉堆实现$O(E\\lg V)$ 123456789101112131415161718void dijkstra() &#123; prority_queue &lt;node&gt; q; ver[0].d = 0; q.push(ver[0]); while(!q.empty()) &#123; node u = q.top(); q.pop(); for(int i = 0 ; i &lt; son[u].size(); ++i) &#123; int vid = son[u.id][i]; if(ver[vid].d &lt; u.d) continue; if(ver[vid].d &gt; u.d + map[u.id][vid]) &#123; ver[vid].d = u.d + map[u.id][vid]; q.push(ver[vid]); &#125; &#125; &#125;&#125; 差分约束 差分图：若$x_j-x_i\\le b_k$，则$w(v_i,v_j)=b_k$ Bellman-Ford可以求解 所有结点对最短路矩阵乘法 我不想管了！！ 是$n$维的Bellman-Ford Floyd-Warshall 本质DP，枚举最短路径上的中间结点 不允许负权重环，但是能报错（看对角元是否有负数） $\\Theta(n^3)$ 1234567void floyd() &#123; init(); //记得将所有map[i][i]置零 for(int k = 1; k &lt;= n; ++k) for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) map[i][j] = min(map[i][j], map[i][k] + map[k][j]);&#125; Johnson算法 用于稀疏图 重新赋值 新增源点$s$，该点与各点有权重为0的边 先跑一次Bellman-Ford，没有负权重环就重新赋值为$\\hat{w}(u,v)=w(u,v)+\\delta(s,u)-\\delta(s,v)$ 对每个点Dijkstra 恢复权重并返回 $O(VE\\lg E)$ 连通度割点 $v$与割边相连，则$v$是割点当且仅当$deg~v\\ge 2$ 对于至少有3个顶点的连通图，只要有割边，就一定有割点 $v$是连通图$G$的割点，当且仅当存在两个不同的顶点$u$和$w$，使得$v$位于$u-w$的任意一条路径上 非平凡连通图中，距离某个点最远的点不是割点 任意非平凡连通图至少包含两个非割点的顶点 不可分图：没有割点的非平凡连通图 块 图的一个最大不可分子图【类比连通分量 任意两个不同块的性质 不相交 至多一个公共点 如果有公共点，则该公共点为割点 连通度 $\\kappa(G)$点连通度=最小顶点割基数 $\\lambda(G)$边连通度=最小边割基数 点连通度$\\le$边连通度$\\le$最小度数 $\\kappa(G)\\le \\lfloor\\frac{2m}{n}\\rfloor$ Menger定理 设$u$和$v$是$G$中两个不邻接的顶点，则$u-v$的最小分离集的顶点个数等于内部不相交$u-v$路的最大个数 类似的有边定理：分离$u-v$的边的最小个数等于边不相交$u-v$路的最大个数 $k$连通当且仅当任意两个顶点至少有$k$条内部不相交路 $k$连通图中任意$k$个顶点均位于某一个圈上 Tarjan算法12345678910111213141516171819/*无向图tarjan*/void tarjan(int u, int pre) &#123; int child = 0; dfs_clock ++; dfn[u] = low[u] = dfs_clock; for(int i = 0; i &lt; son[u].size(); ++i) &#123; int v = son[u][i]; if(!dfn[v]) &#123;//(u,v)是树边 tarjan(v,u); child ++; low[u] = min(low[u], low[v]); if((u == 1 &amp;&amp; child &gt; 1) || (u != 1 &amp;&amp; dfn[u] &lt;= low[v])) &#123; cut_node.push_back(u); &#125;//割点判定：根结点有多个子树，或非根结点的访问序数小于等于能回溯的最大祖先 if(low[v] &gt; dfn[u]) bridge.push_back(&#123;min(u,v), max(u,v)&#125;); &#125; else if(dfn[v] &lt; dfn[u] &amp;&amp; v != pre) low[u] = min(low[u], dfn[v]); &#125;&#125; 旅行问题欧拉图 欧拉回路【闭合】/欧拉迹 有欧拉回路才算欧拉图 一个非平凡连通图是Euler的 当且仅当它的每个顶点的度都为偶数 有欧拉迹当且仅当只有两个奇度点 哈密尔顿图 哈密尔顿圈/哈密尔顿路 性质 $G$的任一非空子集$S$，都有$k(G-S)\\ge |S|$（$G$是哈密尔顿图，$k(G)$指图$G$的连通分支数） 充分条件 (Ore定理)对于不少于3个顶点的图，任意两个不邻接的顶点度数之和大于等于$n$，则$G$是哈密尔顿的。 推论：每个点的度数大于等于$n/2$ $u$和$v$是不邻接的两个顶点，且度数之和大于等于$n$，则$G+uv$是哈密尔顿的当且仅当$G$是哈密尔顿的 一个图是哈密尔顿的当且仅当它的闭包是哈密尔顿的 对于每个整数$j(1\\le j\\le n/2)$，$G$中度数至多为$j$的顶点数小于$j$，则$G$是哈密尔顿的 匹配与覆盖匹配 Hall条件：$\\forall X\\subseteq U, |N(X)\\ge |X|$ 婚姻定理：$r$个女人，$s$个男人，可能出现$r$对婚姻当且仅当对任意$k$，任意$k$个女人共认识至少$k$个男人。 最大匹配 完美匹配：阶为$2k$的图存在一个基数为$k$的匹配 任意$r$正则二部图均有一个完美匹配 独立性参数 最大边独立数$\\alpha’(G)$ 最下边覆盖数$\\beta’(G)$ 最大点独立数$\\alpha’(G)$ 最小点覆盖数$\\beta(G)$ Gallai恒等式 点独立数+点覆盖数=$n$ 边独立数+边覆盖数=$n$ 一般独立集比覆盖集好求 因子分解 $r-$因子：图$G$的$r-$正则生成图 完美匹配产生1-因子 图$G$包含1-因子当且仅当对于$V(G)$的任意真子集$S$,$k_O(G-S)\\le |S|$。($k_O(G)$表示$G$的奇连通分支个数) Petersen定理：所有无割边的3-正则图包含1-因子 任一至多有两条割边的3-正则图包含1-因子 可因子分解：能划分成多个因子 Petersen图不可1-因子分解 匈牙利算法123456789101112131415161718192021bool find(int x) &#123; for(int i = 1; i &lt;= n; ++i) &#123; if(map[x][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if(match[i] == 0 || find(match[i])) &#123; match[i] = x; return true; &#125; &#125; &#125; return false;&#125;int hungary() &#123; int ans = 0; for(int i = 1; i &lt;= n; ++i) &#123; memset(vis, 0 ,sizeof(vis)); if(find(i)) ans ++; &#125; return ans;&#125; 最大流流 $f:V\\times V\\to\\mathbb{R}$ 容量限制：$0\\le f(u,v)\\le c(u,v)$ 流量守恒：$\\forall u\\in V-s,t, \\sum\\limits{v\\in V}f(u,v)=\\sum\\limits_{v\\in V}f(v,u)$【流入=流出】 流的值$|f|=\\sum\\limits{v\\in V}f(s,v)-\\sum\\limits{v\\in V}f(v,s)$(从源结点流出的总流量-流入源结点的总流量) 几种特殊处理 反平行边：拆其中一条边为两条边 多源多汇 残存网络残存容量 c_f=(u,v)=\\begin{cases} c(u,v)-f(u,v) & (u,v)\\in E \\\\ f(v,u) & (v,u)\\in E\\\\ 0 & o.w.切割 把$V$划分为$S$和$T$两个集合，其中$s\\in S, t\\in T$ 横跨该切割的净流量：$f(S,T)=\\sum\\limits{u\\in S}\\sum\\limits{v\\in T}f(u,v)-\\sum\\limits{u\\in S}\\sum\\limits{v\\in T}f(v,u)$【所有结点对的流量之和 切割的容量：$c(S,T)=\\sum\\limits{v\\in S}\\sum\\limits{v\\in T}c(u,v)$【只考虑$S$出发进入$T$的容量 最小切割：容量最小的切割 最大流最小割定理 网络流解决最大匹配 一个集合连$s$，一个集合连$t$，两个集合间两两连，每条边都是单位容量 $O(VE)$ 图论证明方法解题时可能会用到一个或多个 反证法 构造法 临界法(最小/最大的满足条件的一个图) 归纳法 算两次","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"}]},{"title":"Lab4 实验报告","slug":"lab4-report","date":"2018-12-29T09:22:55.000Z","updated":"2019-01-07T11:15:17.436Z","comments":true,"path":"2018/12/29/lab4-report/","link":"","permalink":"https://mengzelev.github.io/2018/12/29/lab4-report/","excerpt":"","text":"实验进度描述我已完成所有内容。 以下是可以忽略的碎碎念： 实验开始一小时：写代码；实验开始两小时推翻前一个小时写的代码；实验开始四小时：推翻前两小时写的代码…… 会发生上面的情况其实是因为写cache_read的时候觉得调入调出可以封装为函数，写到cache_write的时候觉得cache_read里的寻找比对、缺失处理都可以封装成函数。在写PA的时候深受Copy-paste其害，所以想把能共享的代码都尽量封装成函数，减轻debug的痛苦 测试的时候曾经出现过写过的地址从cache调出之后回写到内存不成功。加了回写检查函数check_write_back()依然没有定位错误。出去吹了冷风突然意识到可能是回写的内存地址算错了。回去一看发现是cache装入的时候tag没有更新。结论：吹冷风调试法真有用 一开始在虚拟机里用vim写的时候，为了区分变量，都取了超长的名字，打起来很累，后来无奈先在windows里用CLion打开写了基本框架再放到Linux里进行调试(因为虚拟机里开CLion会卡爆)。CLion写代码真的是体验极佳，下学期OSLab双系统走起了 我个**！！！第一遍做完数据没用给定的trace！第二遍做的数据被我一个手抖永久删除了！！！excel还没办法脚本导入！！！一个数据做了3遍！！！ 代码解释为了提高代码的复用率、降低debug负担，我封装了很多API。 为了模拟cache结构定义了如下结构体 123456struct CacheLine &#123; bool valid; //有效位 bool dirty; //脏位 uint32_t tag; //标记位 uint32_t data[16]; //一行64B数据&#125;line[1024]; 定义了如下全局变量来记录cache的相关信息 123456/* cache info */int ass_width; //关联宽度int total_width; //总宽度int group_width; //组宽度(指cache组号在主存地址中的位数)#define NR_ASS exp2(ass_width) //宏定义，组内行数#define OFFSET 0x3f //与操作后可以取出块内偏移量 将以下功能封装为了API。因为宏定义会涉及到加括号等问题，怕出现奇奇怪怪的bug，所以并没有使用宏定义，而是直接用函数代替 123456789uint32_t get_tag(uintptr_t addr) &#123; //获得一个内存地址的tag字段 return (addr &gt;&gt; (group_width + BLOCK_WIDTH));&#125;uint32_t get_group(uintptr_t addr) &#123; //获得一个内存地址的cache组号字段 return ((addr &gt;&gt; BLOCK_WIDTH) &amp; mask_with_len(group_width));&#125; 1234567891011121314151617181920212223void move_in(uintptr_t addr, int line_num) &#123; //将主存中某一块调入cache中 assert(line[line_num].valid == false); uint32_t block_num = addr &gt;&gt; BLOCK_WIDTH; mem_read(block_num, (uint8_t*)(line[line_num].data)); line[line_num].valid = true; line[line_num].dirty = false; line[line_num].tag = get_tag(addr);&#125;void move_out(int group_num, int line_num) &#123; //将cache的某一行调回到主存中，同时判断dirty bit并写回 assert(line[line_num].valid == true); assert(line_num &lt; 1024); line[line_num].valid = false; if(line[line_num].dirty) &#123; uintptr_t block_num = (line[line_num].tag &lt;&lt; group_width) + group_num; mem_write(block_num, (uint8_t*)line[line_num].data); line[line_num].dirty = false; //write back &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435int find_in_group(uintptr_t addr, int group_num) &#123; //在某一组寻找找某主存地址对应的行，返回其所在行号，缺失则返回-1 int group_start = group_num * NR_ASS; int group_end = group_start + NR_ASS; uint32_t tag = get_tag(addr); for(int i = group_start; i &lt; group_end; ++i) &#123; if(line[i].valid &amp;&amp; line[i].tag == tag) &#123; cycle_increase(1); hit_visit ++; return i; &#125; &#125; return -1;&#125;int replace_in_group(uintptr_t addr, int group_num) &#123; //将主存地址对应的主存块调入cache中 miss_visit ++; int group_start = group_num * NR_ASS; int group_end = group_start + NR_ASS; for(int i = group_start; i &lt; group_end; ++i) &#123; if(!line[i].valid) &#123; move_in(addr, i); return i; &#125; &#125; //如果组内有空行，则直接放入空行中 int line_out = group_start + choose(NR_ASS); assert(line_out &lt; group_end); move_out(group_num, line_out); move_in(addr, line_out); //否则随机替换一行 return line_out;&#125; 123456void write_in_line(int line_num, int index, uint32_t data, uint32_t wmask) &#123; //将数据写入cache某一行的某个index中 line[line_num].dirty = true; line[line_num].data[index] &amp;= (~wmask); line[line_num].data[index] |= (data &amp; wmask);&#125; 这样一来需要实现的3个函数只需要调用以上API即可 1234567891011121314151617181920212223242526272829303132333435363738394041void init_cache(int total_size_width, int associativity_width) &#123; /*设置cache的一系列参数*/ total_width = total_size_width; assert(total_width &lt;= 14); ass_width = associativity_width; group_width = total_width - ass_width - BLOCK_WIDTH; /*初始化用于统计的变量*/ cycle_cnt = 0; total_visit = hit_visit = miss_visit = 0; /* set all the valid bits and dirty bits to invalid */ for(int i = 0; i &lt; NR_LINE; ++i) line[i].valid = line[i].dirty = false;&#125;uint32_t cache_read(uintptr_t addr) &#123; total_visit ++; uint32_t group_num = get_group(addr); uint32_t index = (addr &amp; OFFSET) / sizeof(int); //index in group int line_num = find_in_group(addr, group_num); if(line_num &gt;= 0) return line[line_num].data[index]; //hit则直接读出 int line_out = replace_in_group(addr, group_num); return line[line_out].data[index]; //否则从主存调入cache&#125;void cache_write(uintptr_t addr, uint32_t data, uint32_t wmask) &#123; total_visit++; uint32_t group_num = get_group(addr); uint32_t index = (addr &amp; OFFSET) / sizeof(int); //index in group int line_num = find_in_group(addr, group_num); if(line_num &gt;= 0) write_in_line(line_num, index, data, wmask); //hit则直接写入 else &#123; int line_out = replace_in_group(addr, group_num); write_in_line(line_out, index, data, wmask); &#125;//否则写分配&#125; cache性能测试运行时间测算 框架代码已经给内存的读写赋好了相应的时钟周期数，所以我很自然地想到通过统计时钟周期数来统计运行的时间 关于怎么对cache读写操作的时钟周期测算，讲义说可以建立关于关联度的带参数的模型，但是我回想起来课本上讲过，组相联组内是用了很多比较器进行并行比较的。所以我认为读写的时钟周期数应该和关联度以及cache容量关系不大，所以将读写的时钟周期都设置为1。&gt;可能也有想省事的惰性成分在里面 除时钟周期数外，还衡量一个缺失率。由于主存读写比cache读写慢得多，读写命中率也能表征cache的性能 声明了一些用于统计的变量 1234/* statistics */uint64_t total_visit = 0;uint64_t hit_visit = 0;uint64_t miss_visit = 0; 测算方法：控制变量法，控制组相联度或cache总宽度其中一个量不变，改变另外一个量。每种配置测量3次后取平均。根据结果使用excel作图，得到如下结果。【数据已经放在打包上传的.xlsx文件中】 从以上数据和图表中可以看出： cache容量越大，缺失率越低，花费的总时钟周期数也越少。这是因为cache容量大了以后，能装入更多的主存块，缺失率就会相应地降低，需要进行替换的次数也会变少。但是cache大就意味着高昂的造价，而且SDRAM的材质(?)决定了cache不可能做到很大。而且由图中可以看出，当cache容量增大到一定大小时，其性能增长就很不明显了，因此一般会选择比较中等的大小。 缺失率与组相联度似乎并不是呈单调关系。原理上分析，组相联度越大，同一组内发生冲突的概率就越低，需要调出的次数也会越低。但有可能microbench-test中的访存顺序会导致某些经常访问的块，在相联度较小时被放到了不同的组中，而相联度较大时被放到了同一组中，导致发生冲突的次数增加。而且越高的组相联度，意味着越多的比较器，意味着更大的体积和更高的造价。 综上，对于microbench-test下的workload，我认为最佳的组相联宽度是2(4路组相联)。如果有钱任性，cache容量越大越好；如果要省钱经济，12或13的容量宽度(4KB或8KB的容量)是比较理想的。 思考题数据对齐和存储层次结构 如果没有对齐，同一个数据可能会被分配再两个主存块的交界处，读取这个数据的时候发生cache miss的概率更大，cache miss后可能需要调入两个主存块，代价更大，运行速度会大大降低。 不知道cache的复杂性对频率的影响? 我不是很看得懂这里的建模的意思。我认为$ak^2+b$中%a,b$只是两个参数，考察它们对cache性能的影响是没有意义的，而是应该固定$a,b$，考察组相联度和cache容量对cache性能的影响。但是我已经在上文提到了我并没有把这两者与cache的读写速度关联起来。所以我没有建立带参数的模型。 Acknowledgements 感谢不水的正经学习群的朋友们当我的小黄鸭，帮我调试 感谢*的自己，因为一系列\\*行为，成功锻炼了心理承受能力","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Lab","slug":"Lab","permalink":"https://mengzelev.github.io/tags/Lab/"},{"name":"Ics","slug":"Ics","permalink":"https://mengzelev.github.io/tags/Ics/"}]},{"title":"PA4实验报告","slug":"PA4-report","date":"2018-12-28T08:00:32.000Z","updated":"2019-01-07T11:13:04.106Z","comments":true,"path":"2018/12/28/PA4-report/","link":"","permalink":"https://mengzelev.github.io/2018/12/28/PA4-report/","excerpt":"","text":"实验进度我已完成全部实验内容。 2018/12/15:完成PA4.1。不少自认为关键的地方竟然怎么改都是对的，有点慌 2018/12/16:PA4.2第一个任务完成，再不开始做数电大实验就要死了，只能封印PA 2018/12/23：被数电大实验折磨完，PA4.2完成。仙剑跑得慢到感人。 2018/12/24：平安夜，发现4.2最后一个task忘了跑了，定位了半天bug发现是context_kload忘了改成context_uload，心情简单。开始做4.3，但是由于前几天睡眠不足连着写了好几个沙雕bug，于是决定先放弃。 2018/12/25：圣诞节，继续写PA4.3，花了一个小时解决了平安夜昏睡状态下写出的沙雕bug，花了4个小时解决了当天写出的沙雕bug，也就是PA最后一个bug。PA通关! 蓝框思考题迫于作业和复习考试压力，这次也一道都没做…… 我遇到的bug 没看到讲义上要求把loader把文件映射到物理页的要求，映射到虚拟页上，结果一直出发pte.present==0的assert。仔细一想loader的确有义务把程序搬到合适的实际位置 即使是一个简单的dummy程序，其内容也有两页多。而且不能直接用文件大小/PGSIZE，否则余数部分会被丢弃 make run的时候可能会碰到一大堆链接报错，原因不明，目前解决方案是在所有目录下都来一遍clean(-update)-run全家桶。这时候调试公理1是不是被打破了呢？ _switch是用来切换到下一个进程的，因此传入参数肯定为next而非tf【这不是我遇到的bug，是我不少同学都遇到的bug，所以也记下来了 增加时钟中断时需要填写idt表，太久没碰系统调用这个都忘了 4.3最后测试进程切换的时候千万不要因为嫌仙剑跑得太慢换成bmptest，这玩意儿是根本block了events_read()的，导致我debug了4个小时才发现 实验中的发现 与cr3和cr0有关的指令的译码函数其实可以使用框架代码提供的现成的译码函数,只不过需要研究一下怎么使用 在写_map函数时，我思考了很久，为什么当页目录的present位无效时，要用回调函数申请一个新的物理页。觉得应该是把这一页作为了存放页表的物理页 一些头文件里有不少讲义没提到的、可以方便coding的宏定义，例如x86.h和mmu.h,论RTFSC的重要性 实验心得 一定要好好读讲义 和同学交流了一下，发现不一定要全部理解了再开始写代码。可以把框架代码中提供的东西输出一下，根据输出的值来猜测这个变量的含义，或者这个函数的功能。做实验和理解理论是相辅相成的 每次开机，看着一行行初始化Log，就会想到这只是一个比我刚刚造完的(其实大部分都是yzh写的)的东西复杂一点(这个一点有点多)的家伙，就觉得五味杂陈 迫于时间压力不少挑战极限的选做题都没做 这学期做PA还是依赖了不少人的帮助，寒假想要二周目并完成PA5，希望也能把不少选做题都做一下 Acknowledgements 感谢某人提供的探路和盯着写bug服务 感谢不水的正经学习群的群友们互帮互助的debug氛围 本实验报告同样会将去掉必答题的版本同步上传至个人blog","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"},{"name":"ICS","slug":"ICS","permalink":"https://mengzelev.github.io/tags/ICS/"}]},{"title":"算法导论学习笔记-矩阵运算","slug":"clrs28Matrix-Operation","date":"2018-12-18T01:50:18.000Z","updated":"2019-01-07T11:16:02.932Z","comments":true,"path":"2018/12/18/clrs28Matrix-Operation/","link":"","permalink":"https://mengzelev.github.io/2018/12/18/clrs28Matrix-Operation/","excerpt":"","text":"求解线性方程组Ax=b欠定的(underdetermined)：方程的数目少于未知变量数目$n$，则该线性方程组为欠定的超定的(overdetermined):方程数目超过未知变量数目$n$非奇异矩阵：$A$的秩等于未知变量的个数$n$ LUP分解思想：找出3个$n\\times n$矩阵$L,U,P$，满足$PA=LU$,其中$L$是一个单位下三角矩阵$U$是一个上三角矩阵$P$是一个置换矩阵每一个非奇异矩阵$A$都会有这样一种分解 Ax=bPAx=PbLUx=Pbx求解两个三角线性系统下三角系统$Ly=Pb$上三角系统$Ux=y$ 正向替换与方向替换可在$\\Theta(n^2)$时间内求解下三角系统 置换阵$P$可以用数组$\\pi[1..n]$表示 P_{i,j}= \\begin{cases} 1 & (j == \\pi[i])\\\\ 0 & (j\\neq\\pi[i]) \\end{cases}从第一个式子开始正向替换，可以得到 y_i=b_{\\pi[i]}-\\sum\\limits_{j=1}^{i-1}l_{ij}y_i反向替换同理，最终可以得到 x_i=(y_i-\\sum\\limits_{j=i+1}^{n}u_{ij}x_j)/u_{ii} LU分解计算Gauss消元法： 行消元得到的行梯阵即$U$ $L$由消去变量所用的行的乘数组成 可以看成a_{ij}=a_{ij}-\\frac{a_{ik}a_{kj}}{a_{kk}} 运行时间$\\Theta(n^3)$ LUP分解计算在LU分解的基础上，为了保证除数不为0和减少数值不稳定，每次选择该列中具有最大绝对值的元素，交换到对角元的位置 运行时间$\\Theta(n^3)$ 矩阵求逆LUP分解可以用于计算逆矩阵(废话，高斯消元可以，LUP当然可以)AX_{i}=e_i 矩阵乘法和矩阵求逆具有相同的时间复杂度 证明时间复杂度相同：两个问题都能在O(另一个问题算法的时间复杂度)时间内解决 证明的时候可能会用到分块阵的思想来转化问题 对称正定阵引理28.3：任何对称正定矩阵都是非奇异矩阵任何对称正定矩阵都有逆矩阵。 引理28.4：如果$A$是一个对称正定矩阵，那么$A$的每一个主子矩阵都是对称正定的。 舒尔补：矩阵$A$关于主子矩阵$A_k$的舒尔补为$S=C-B{A_k}^{-1}B^T$。其中，$A$为对称正定阵且 A=\\left[ \\begin{matrix} A_k & B^T \\\\ B & C \\end{matrix} \\right]舒尔补定理：如果$A$是一个对称正定矩阵，$A_k$是$A$的$k\\times k$主子矩阵，那么$A$关于$A_k$的舒尔补是对称正定的。 推论28.6：一个对称正定矩阵的LU分解永远不会出现除数为0的情形 最小二乘逼近就是看上去很厉害实际上真的很厉害的曲线拟合","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://mengzelev.github.io/tags/Graph-Algorithms/"}]},{"title":"图论学习笔记-平面图与着色","slug":"planar-graph-and-coloring","date":"2018-12-13T06:30:30.000Z","updated":"2018-12-15T03:40:57.630Z","comments":true,"path":"2018/12/13/planar-graph-and-coloring/","link":"","permalink":"https://mengzelev.github.io/2018/12/13/planar-graph-and-coloring/","excerpt":"","text":"平面图平面图(planar graph)：如果$G$能够被画在一个平面上而使得任何两条边都不会交叉 平图(plane graph)：如果$G$是平面图且$G$的任何两条边都不交叉 平面图的例子：cycle, path, star, tree 区域(regions)：一个平图把平面分成一些连通片外区域(exterior region)：每个平图中总有的一个无界的区域边界(boundary)：在一个平图中，顶点和边斗鱼某个给定区域$R$关联的子图称为是$R$的边界 割边总是恰好在一个区域的边界上非割边一定位于两个区域的边界上 如果$G$是一个至少含有三条边的连通平图，则$G$的而每个区域的边界至少含有三条边 定理9.1(Euler恒等式)：如果$G$是一个阶为$n$，边数为$m$且含有$r$个区域的连通平图，则$n-m+r=2$ 定理9.2：如果$G$是一个阶为$n\\ge 3$且边数为$m$的平面图，则$m\\le 3n-6$。(平面图的必要条件，非平面图的充分条件)逆否命题：设$G$阶为$n$，若$m&gt;3n-6$，则$G$是非平面图。注：满足$m\\le 3n-6$的不一定是平面图 推论9.3：每个平面图含有一个度小于或等于5的顶点。 推论9.4：完全图$K_5$是非平面的。 极大平面的(maximal planar)：若$G$是平面的，且在$G$的任意两个不邻接的顶点之间添加一条边即可产生一个非平面图。另一种表述：$G$是平面的，但$G$不是任何一个平面图的生成子图极大平面图满足$m=3n-6$ 定理9.5：图$K_{3,3}$是非平面的 细分(subdivision)： 如果有一个或多个度为2的顶点被插入到$G$的一条或多条边中，则称图$G’$是图$G$的一个细分 定理9.7(Kuratowski定理)：一个图$G$是平面图当且仅当$G$不含$K5$，$K{3,3}$，或者$K5$或$K{3,3}$的一个细分作为子图。 如果一个图$G$含有(1)至多4个度大于或等于4的顶点(2)至多5个度大于或等于3的顶点，则$G$必定是平面的。 顶点染色对偶(dual)：每张地图都有一个与之关联的图$G$，称为该地图的对偶，其中$G$的顶点即为地图的区域，$G$的两个顶点是邻接的当且仅当它们所对应的区域是相邻的每张地图的对偶图都是平面图，每个连通的平面图都是某个地图的对偶。 真染色(proper coloring)：给$G$的顶点分配一些颜色(来自于某个颜色集合)，是的每个顶点都能分配到一种颜色，且邻接的顶点被染成不同的颜色，简称为染色(coloring) 色数(chromatic number)$\\chi(G)$：在$G$的所有染色中，所用的最少颜色数 $k$可染色的(k-colorable)：如果能用一个含有$k$种颜色的集合给$G$的顶点染色，则称$G$是$k$可染色的(k-colorable)，应用$k$种颜色的染色称为是$k$染色(k-coloring)。 若$\\chi(G)=k$，则$G$也称为是$k$色的(k-chromatic)，并且$G$的每个$k$染色都是$G$的最小染色(minimum coloring) 定理10.1(四色定理)：每个平面图的色数至多是4 色类(color classes)：若$G$是一个$k$色图，则可以把$V(G)$划分成$k$个独立集$V_1,V_2,…,V_k$，此时这些顶点集称为色类。 定理10.2：图$G$的色数是2当且仅当$G$是一个非空的二部图。 (复习：定理1.12：图$G$是二部的当且仅当其不含奇圈)若$G$含有奇圈，则$\\chi(G)\\ge 3$ $n$阶图$G$的色数为$n$当且仅当$G=K_n$ 证明$\\chi(G)=k$，必须证明： 至少需要$k$种颜色来为$G$染色(不能用$k-1$种颜色为$G$染色) 存在$G$的一个$k$染色 若$H$为$G$的一个子图，则$\\chi(H)\\le\\chi(G)$ 团(clique)：$G$的一个完全子图团数(clique number)\\omega(G)：图$G$中最大团的阶数$\\alpha(G)=k$当且仅当$\\omega(G)=k$ 定理10.5：对每个$n$阶图$G$：\\chi(G)\\ge\\omega(G), \\chi(G)\\ge\\frac{n}{\\alpha(G)}(给出了图$G$的色数的下限) 图$G$的染色可以看成是$V(G)\\to\\mathbb{N}$的一个函数$c:V(G)\\to\\mathbb{N}$，使得当$uv\\in E(G)$时，$c(u)\\neq c(v)$ 定理10.7：对于每个图$G$，$\\chi(G)\\le 1+\\Delta(G)$。($\\Delta(G)$为$G$的最大度) 定理10.8(Brooks定理)：对每个非奇圈也非完全的连通图$G$，$\\chi(G)\\le\\Delta(G)$ 定理10.9：对于每个图$G$,$\\chi(G)\\le 1+\\max\\{\\delta(H)\\}$，其中$\\max$取遍$G$的所有诱导子图$H$。 影子图(shadow graph)$S(G)$:通过在$G$中，对其每个顶点$v$，增加一个新的顶点$v’$，称之为$v$的影子顶点(shadow vertex) 定理10.10：对于每个整数$k\\ge 3$，都存在一个色数为$k$的无三角的图。","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"Graph Theory","slug":"Graph-Theory","permalink":"https://mengzelev.github.io/tags/Graph-Theory/"}]},{"title":"卫宫家今天的饭","slug":"Dinner","date":"2018-12-10T08:22:19.000Z","updated":"2018-12-10T09:43:06.918Z","comments":true,"path":"2018/12/10/Dinner/","link":"","permalink":"https://mengzelev.github.io/2018/12/10/Dinner/","excerpt":"","text":"题源POJ 3281 Diningopenjudge传送门饱受OJ折磨的我决定以德报怨给大家出道水题 题目描述基本只是把原题搬到了月球上 N位客人，F种食物，D种饮料 每位客人有多种喜欢的事物和饮料 每位客人只吃一种食物、只喝一种饮料 每种食物，每种饮料只能被一位客人吃/喝 可以看成两个二分图最大匹配问题 构建流网络 先尝试：食物-客人-饮料 会出现一位客人对应多份食物或饮料的情况 客人结点需要加上结点容量 将每个客人结点拆分为两个 源点s-食物-客人1-客人2-饮料-汇点 最大流算法 数据规模[1,100] EK完全OK 没有刻意生成卡任何算法的数据，也许可以尝试暴力 板子写起来有丶难度 代码虽然我贴了，但是务必自己写一遍！ EK板子 容量c[N][N]，流量f[N][N] 只需要一个记录当前残存容量的数组map[N][N] 随便搜一下就能找到 板子代码int edmonds_karp() { int ans = 0; int minc; while((minc = bfs()) != -1) { //bfs找到一条增广路径 ans += minc; //加上这条增广路径的流量 int tt = t,pt; while(tt != s) { pt = pre[tt]; map[pt][tt] -= minc; map[tt][pt] += minc; tt = pt; } //修改这条增广路径上的边的残存容量 } return ans; } bfs寻找增广路径int bfs(){ memset(pre, -1, sizeof(pre)); int minc = 1e9; queue &lt;int&gt; q; q.push(s); while(!q.empty()){ int u = q.front(); q.pop(); if(u == t) break; for(int i = 1; i &lt;= t; ++i) { if(pre[i] == -1 &amp;&amp; map[u][i]) { minc = min(minc, map[u][i]); //更新当前路径的最小残存容量 q.push(i); pre[i] = u; //pre数组用于记录bfs找到的增广路径 } } } if(pre[t] == -1) return -1; else return minc; } 建图代码不贴惹，自己写吧:) Tips:为了将各种不同类型的所有点都囊括在一个数组里的同时，增强代码的可读性，可以使用宏定义 #define FOOD(x) **我** #define GUEST1(x) **是** #define GUEST2(x) **马** #define DRINK(x) **赛** #define s **克** #define t **!**","categories":[],"tags":[]},{"title":"PA3实验报告","slug":"PA3-report","date":"2018-12-08T08:00:32.000Z","updated":"2019-01-07T11:11:41.963Z","comments":true,"path":"2018/12/08/PA3-report/","link":"","permalink":"https://mengzelev.github.io/2018/12/08/PA3-report/","excerpt":"","text":"实验进度我已完成所有内容。好，下面是惯例碎碎念。 2018/11/18心态爆炸的一天！先是因为脑子短路完全没有想到idt的地址就在lidt译码过后的id_dest里。然后还因为惯性思维从id_dest-&gt;val里读地址，疯狂出错才发现应该在id_dest-&gt;addr里（因为是地址）。组织Context的时候思考了半天，最后问了大腿才知道怎么判断上下文的组织结构。感觉还是课本知识学得不够扎实的恶果。今日不宜PA，关机睡觉。 2018/11/19PA3.1完成。感觉测试手段都不太给力，不知道有没有埋下隐藏bug 2018/11/24PA3.2完成。感觉莫名顺利，可能是3.3要自闭的征兆 2018/12/1开始自闭PA3.3，实现了文件读写操作，死活看不到PASS!!!，文件读写时对长度超过文件大小的情况的处理有一些麻烦，调了半天，最后发现是PA3.2时就好了的SYS_write没有加上刚刚写的fs_write，喷了。开始编写设备文件操作，看不懂vga那块到底是要干啥，机房关门了，回去睡觉。 2018/12/2继续自闭PA3.3。为了看懂VGA那块的架构直接翻出了bmptest的源码，然后一路摸到NDL库的源码，花了大概一个下去终于显示出了ProjectN的Logo。实现events_read()时还把事件的格式搞错了debug了半天，终于可以开始跑仙剑了。小心翼翼地开始游戏，没有注释掉Log因此看到了瀑布般的Log信息，然后50min才播放完片头对话，所幸无事。然后注释掉了所有Log，又胆战心惊地开始尝试所有存档点，尝试了穿墙和穿人，全部失败，确认了没有肉眼可见的bug。长舒一口气，然后加急写完了批处理系统，机房关门，走人。难以置信我居然跑出了仙剑，亢奋。 必答题其实我写PA的时候都在系统调用过程梳理里做好笔记了 游戏的存档 仙剑奇侠传中调用C标准I/O库函数fread() 库函数fread()会调用libos中的系统调用的封装函数_read() libos中的_read()函数通过调用_syscall_()，直接使用内联汇编语句编译出int 0x81的系统调用内陷指令，并将相应的参数放入约定的寄存器中(%eax,%ebx，%ecx，%edx) nemu执行指令时遇到了int 0x81指令，译码后执行raise_intr()，将EFLAGS，CS，EIP的值压入栈中，并到am中的中断门描述符表idt中查询0x81对应的跳转目标的偏移量offset，为vectrap() vectrap()直接通过汇编指令将错误码irq压栈，然后跳转到asm_jmp函数执行（nexus-am/am/arch/x86-nemu/src/trap.S中定义） 在asm_trap中通过pusha指令让nemu将所有寄存器压栈，然后执行irq_handle()函数（在nexus-am/am/arch/x86-nemu/src/cte.c中） irq_handle()把执行流切换的原因打包成事件，然后调用在_cte_init() 中注册的事件处理回调函数, 将事件交给Nanos-lite来处理 Nanos-lite中的do_event()函数根据nemu打包传过来的时间决定系统调用类型，此处是_EVENT_SYSCALL类型的，就调用do_syscall()函数来处理这个系统调用 do_syscall()根据上下文中寄存器%eax保存的参数确定系统调用的类型，此时为SYS_read类型，就调用文件系统中的fs_read()并将相应的参数传入 fs_read()根据传入的文件名（存档信息文件的名称）读取需要的长度到指定的位置，恢复成存档前的状态，就可以从存档点继续游戏 fs_read()执行完成后，一路返回到asm_trap中，恢复之前压入栈中保存的寄存器，然后执行iret指令 nemu执行iret指令，恢复EFLAGS，CS，EIP，跳转到EIP所指向的地方继续执行之后的指令 至此，一次读取存档的系统调用全部完成 更新屏幕 仙剑奇侠传中调用libndl中的库函数NDL_DrawRect() NDL_DrawRect()会调用C标准I/O库函数fwrite()，将当前的像素信息写入stdout中，这里的stdout不是终端里的标准输出，而是应用程序的标准输出_REENT-&gt;stdout 系统调用过程同上，此处不再赘述。进入Nanos-lite的文件系统后，由于是对显示设备抽象成的文件/dev/fb进行读取，fs_write()调用的是fb_write() fb_write()调用了am的klib中提供的screen_width()和draw_rect() am中的draw_rect()调用了vga设备的写函数video_write()，把相应的像素信息写入到映射到vga_memory的物理内存中 当nemu访问到从0x4000开始的一段被映射到I/O空间的物理地址时，就会通过mmio_write来修改I/O空间的数据 I/O空间的数据被修改后调用了update_screen()，由nemu把更新后的屏幕显示信息显示了出来 进行系统调用的返回操作，同样不再赘述 至此，一次更新屏幕的系统调用完成 蓝框思考题最近太忙了一题都没写…想写的时候讲义又挂了…二周目的时候再思考吧orz 实验中的发现关于nanos-lite和nemu是怎么通讯的在写PA3.1中的lidt指令的时候，我有个很大的疑惑，idt是在nanos-lite里被定义的，nemu要怎么获取它的地址呢？_cte_init中有一步调用了set_idt函数，将idt的地址和大小用内联汇编语句写入了指令集。因此当nanos编译成nemu可执行的指令后，idt的地址就可以通过相应的译码函数写入id_dest中。问了一位nb的学长后，学长给出了如下理解 不在system.c里的指令，一般靠编译c文件成机器码就可以给nemu做事，所以pa2很顺利；而system.c的东西依赖于系统（比如中断），只靠编译c文件做不到int、lidt这些东西，所以要内联汇编 关于如何判断_Context结构的组织顺序_Context是在函数irq_handle里作为参数的类型被传入的，然而irq_handle是通过汇编代码直接调用的，因此没有显式的参数传递语句，实际的参数是存放在栈中%ebp-8的位置开始的位置，观察call irq_handle之前所有的push相关语句就可以得知寄存器的顺序。而eip,eflags和eip是硬件保存的，因此需要观察int指令中的入栈顺序才能知道这三者的顺序。 系统调用过程梳理 用户层navy-apps在相应的系统调用函数（如_exit()）中调用系统调用接口函数_syscall_() _syscall_用内联汇编语句将int 0x80和相应的系统调用参数传给nemu nemu执行int指令，叫出nanos-lite irq_handler通过int指令传入的参数识别出这是一次系统调用的event，打包传给do_event irq.c中的do_event()函数调用do_syscall()执行系统调用事件 syscall.c中的do_syscall()函数根据传入的参数（在上下文的相应寄存器中）执行相应的系统调用操作，设置返回值并返回 我遇到的bug 堆区管理的时候声明的用于记录program break的变量pbrk没有初始化【所以说初始化真的是个好文明 写了fs_write却忘了修改相应的系统调用SYS_write找了一个下午 所有关于文件读写的系统操作都需要控制open_offset，不能超过当前文件的size，但是serial_write和dispinfo_read等不同文件的读写又不能一概而论，写bug和debug的时候要特别注意 fs_lseek最后要控制当前的open_offset，不然可能会导致fs_read和fs_write的功能无法正常使用 fs_read和fs_write需要对open_offset做出修改 函数指针的调用就跟函数一样用就行了 fb_write里的offset怎么用，怎么给draw_rect传参，可能要一直摸到libnbl才能搞清楚 字符串不能x**初始化，会由于某些我搞不懂的原因编译出STOS指令，导致看到亲切的i386 Logo if((keytemp &amp; 0x8000) == 1)和if(keytemp &amp; 0x8000)是不一样的！！！！！！[你是沙雕吗.jpg] 对讲义的一些建议（你们选择性反馈给yzh） 建议把能看到PASS!!!信息的放在serial_write()之后，不少同学都在实现完SYS_write之后没看到PASS！！！感到困惑（当然仔细想一下还是能想通） 堆区管理那一块太考验阅读理解水平了，而且大部分人会忘掉PA2还接触过AM里一个叫heap的结构体，就稍微提醒一下下呗（ 让dummy实现_syscall_时，最好能提醒一下如果按照之前加系统调用一下加入do_event中会触发死循环，或者干脆把下面的必做部分并到一起写，减少困惑 实验心得 RTFSC是很难的，不要一下子看不出来就自闭，不然会出事情的 要成为一名优秀的程序猿，首先你要学好语文 出bug不可怕，如果能通过debug的过程对框架代码和计算机系统的原理有更深刻的理解，其实是一件很赚的事情。听了助教讲课之后我深刻感受到，一出bug就问大腿“怎么写才是对的”，实在太亏了，应该搞清楚哪里写错了，为什么写的fault这个出现这样的failure。 Appreciation 感谢某人提供的探路和debug服务，我觉得有点保护过度了再这样下去我要不会自己写代码了【捂脸 感谢名字一直在换的学习群的群友们互帮互助的debug氛围 本实验报告同样会将去掉必答题的版本同步上传至个人blog","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"}]},{"title":"算法导论学习笔记-最大流","slug":"clrs-26Maximum-Flow","date":"2018-12-05T07:03:20.000Z","updated":"2019-01-17T12:08:51.319Z","comments":true,"path":"2018/12/05/clrs-26Maximum-Flow/","link":"","permalink":"https://mengzelev.github.io/2018/12/05/clrs-26Maximum-Flow/","excerpt":"","text":"流网络流网络 有向图$G=(V,E)$ 图中中每条边$(u,v)\\in E$有一个非负的容量值$c(u,v)\\ge 0$ 如果$(u,v)\\notin E$，定义$c(u,v)=0$ 如果边集合$E$包含一条边$(u,v)$，则图中不存在反方向的边$(v,u)$ 有源结点$s$和汇点$t$ 流网络图是连通的 除源结点外的每个结点都至少有一条进入的边，$|E|\\ge |V|-1$ 流设$G=(V,E)$为一个流网络，其容量函数为$c$。设$s$为网络的源结点，$t$为汇点。$G$中的流是一个实值函数$f: V\\times V \\to \\mathbb{R}$，满足下面两条性质： 容量限制：对于所有的结点$u,v\\in V$，要求$0\\le f(u,v)\\le c(u,v)$ 流量守恒：对于所有的结点$u\\in V-\\{s,t\\}$，要求\\sum\\limits f(v,u)=\\sum\\limits f(u,v)当$(u,v)\\notin E$时，从结点$u$到结点$v$之间没有流，因此$f(u,v)=0$ 称非负数值$f(u,v)$为从结点$u$到结点$v$的流。（流入=流出） 一个流$f$的值$|f|=\\sum\\limits{v\\in V}f(s,v)-\\sum\\limits{v\\in V}f(v,s)$ （从源结点流出的总流量减去流入源结点的总流量） 最大流问题：给定一个流网络$G$、一个源结点$s$、一个汇点$t$，找到值最大的一个流 反平行边 如果要使用反平行边来模拟一个流问题，就选择两条反平行边中的一条，加入一个新结点来将其分解为两段，并以新的结点到原来边的结点的两条路替换所选边，同时将两条新设立的边的容量设置为与原来的边的容量相同。 具有多个源结点和多个汇点的网络加入一个超级源结点$s$和一个超级汇点$t$ Ford-Fulkerson方法 残存网络给定流网络$G$和流量$f$，残存网络$G_f$由那些仍有空间对流量进行调整的边构成。 残存容量为$c_f(u,c)=c(u,v)-f(u,v)$ 对正流量的缩减：将边$(v,u)$加入到图$G_f$中，并将其残存容量设置为$c_f(v,u)=f(u,v)$ 残存容量的形式化定义如下： 给定一个流网络$G=(V,E)$和一个流$f$，则有$f$所诱导的图$G$的残存网络为$G_f=(V,E_f)$，其中$E_f=\\{(u,v)\\in V\\times V: c_f(u,v)&gt;0\\}$，有$|E_f|\\le 2|E|$ 递增：如果$f$是$G$的一个流，$f’$是对应的残存网络$G_f$的中的一个流，定义f'\\uparrow f':V\\times V\\to\\mathbb{R}为流$f’$对流$f$的递增 抵消操作：在残存网络中将流量推送回去 引理26.1：|f\\uparrow f'|=|f|+|f'| 增广路径增广路径$p$：残存网络$G_f$中一条从源结点$s$到汇点$t$的简单路径 残存容量：在一条增广路径$p$上能够为每条边增加的流量的最大值c_f(p)=\\min\\{c_f(u,v): (u,v)\\in p\\} 流网络的切割流网络的切割：将结点集合$V$划分为$S$和$T=V-S$两个集合，使得$s\\in S, t\\in T$ 横跨切割的$(S,T)$的净流量$f(S,T)$：f(S,T)=\\sum\\limits_{u\\in S}\\sum\\limits_{v\\in T}f(u,v)-\\sum\\limits_{u\\in S}\\sum\\limits_{v\\in T}f(v,u) 切割$(S,T)$的容量：c(S,T)=\\sum\\limits_{v\\in S}\\sum\\limits_{v\\in T}c(u,v)最小切割：整个网络中容量最小的切割 对于容量，只计算从集合$S$发出进入集合$T$的边的容量，而忽略反方向边上的容量 对于流，考虑从$S$到$T$的流量减去从$T$到$S$的反方向的流量 引理26.4：整个流网络的流量与横跨某一个切割的流量相等f(S,T)=|f| 推论26.5：$|f|\\ge c(S,T)$ 定理26.6(最大流最小割定理) 基本的Ford-Fulkerson算法 粗糙的时间复杂度上界：$O(E|f|)$（$f$为将有理数流网络转换成整数流网络后，网络中的一个最大流） Edmonds-Karp算法在Ford-Fulkerson算法的第三行使用广度优先搜索来寻找增广路径。每次在残存网络中选择的增广路径是一条从源结点$s$到汇点$t$的最短路径，其中每条边的权重为单位距离。 时间复杂度：$O(VE^2)$ 引理26.7：使用Edmonds-Karp算法，对于除源结点和汇点外的所有结点$v$，残存网络$G_f$中的最短路径距离$\\delta_f(s,v)$随着每次流量的递增而单调递增。 定理26.8：Edmonds-Karp算法所执行的流量递增操作的总次数为$O(VE)$ 关键边：在残存网络中，一条路径$p$的残存容量是该条路径上边$(u,v)$的残存容量，即$c_f(p)=c_f(u,v)$对于$E$的每条边来说，其成为关键边的次数最多为$|V|/2$次。 最大二分匹配在一个二分图中，结点集合可以划分为$V=L\\cup R$，其中$L$和$R$是不相交的，并且边集合$E$中所有的边都横跨$L$和$R$。 构造一个流网络$G=(V’,E’)$，其中V'=V\\cup\\{s,t\\}$$$$E=\\{(s,u):u\\in L, u\\in L\\}\\cup \\{(u,v):(u,v)\\in E\\}\\cup \\{(v,t):v\\in\\mathbb{R}\\}给$E’$中的每条边赋单位容量 流$f$是整数值的：对于所有的边$(u,v)\\in V\\times V$，$f(u,v)$都是整数值。 定理26.10（完整性定理Integrality theorem）：如果容量函数$c$只能取整数值，则$Ford-Fulkerson$方法所生成的最大流$f$满足$|f|$是整数值的性质。而且，对于所有的结点$u$和$v$，$f(u,v)$都是整数。 推论26.11：二分图$G$中的一个最大匹配$M$的基数等于其对应的流网络$G’$中某一最大流$f$的值。 时间复杂度：$O(VE)$","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://mengzelev.github.io/tags/Graph-Algorithms/"}]},{"title":"图论学习笔记-图中的匹配与覆盖","slug":"matchings","date":"2018-11-28T06:59:39.000Z","updated":"2018-12-01T02:14:22.945Z","comments":true,"path":"2018/11/28/matchings/","link":"","permalink":"https://mengzelev.github.io/2018/11/28/matchings/","excerpt":"","text":"匹配匹配的定义独立：若图的边集中任意两条边不邻接，则称该集合是独立的 匹配：图$G$中的边的一个独立集$G$的匹配是一个边的集合$M={e_1,e_2,…,e_k}$，其中$e_i=u_iw_i(1\\le i\\le k)$，使得$u_1,u_2,…,u_k$是$U$中$k$个不同的顶点，$w_1,w_2,…,w_k$是$W$中$k$个不同的顶点。 匹配存在的条件邻域(neighbourhood)$N(X)$：设$G$为二部图，其部集为$U$和$W$，且$|U|\\le |W|$，对于$U$的非空子集$X$，$X$中所有顶点的邻域的并。 Hall’s condition/友好的(neighborly)：对于$U$的任意非空子集$X$，均有$|N(X)|\\ge |X|$。 定理8.3：设$G$为二部图，其部集为$U$和$W$，且$r=|U|\\le |W|$。则$G$包含一个基数为$r$的匹配当且仅当$U$是友好的。 定理8.4：非空有限集族$\\{S_1,S_2,…,S_n\\}$有一个互异代表元系(system of distinct representative) 当且仅当 对于任一整数$k(1\\le k\\le n)$，集族中任意$k$个集合的并至少包含$k$个元素。 定理8.5(婚姻定理):在一个由$r$个女人和$s$个男人构成的人群中，$1\\le r\\le s$，在熟识的男女之间可能出现$r$对婚姻当且仅当对每个整数$k(1\\le k\\le r)$，任意$k$个女人共认识至少$k$个男人。 最大匹配(maximum matching)：具有最大基数的匹配 完美匹配(perfect matching)：阶为$2k$的图$G$存在一个基数为$k$的匹配$M$，则称该匹配$M$为完美匹配 定理8.6：任意$r$正则二部图$(r\\ge 1)$均有一个完美匹配。 边的独立性参数边独立数(edge independence number)$\\alpha ‘(G)$：最大边独立集的基数 覆盖：一个顶点和与其相连的一条边 边覆盖数(edge covering number)$\\beta ‘(G)$：$G$中所有边覆盖的最小基数 最小边覆盖集(minimum edge cover)：具有最小基数的边覆盖集 定理8.7：对于任意不包含孤立点的$n$阶图$G$，\\alpha'(G)+\\beta'(G)=n 顶点的独立性参数如果图中的一个顶点集合中任意两顶点都不邻接，则称该顶点的集合是独立的 点独立数(vertex independence number)$\\alpha(G)$:$G$中点独立集的最大基数，又称独立数 最大独立集(maximum independence set)：图$G$中基数为$\\alpha(G)$的独立集 点覆盖(vertex cover)：图$G$的某个顶点子集可以覆盖$G$的所有边 点覆盖数(vertex covering number)$\\beta(G)$：$G$的所有点覆盖的最小基数 最小点覆盖(minimum vertex cover)：基数为$\\beta(G)$的点覆盖 定理8.8:对于任意不包含孤立点的$n$阶图，\\alpha(G)+\\beta(G)=n 定理8.7与定理8.8合称为Gallai恒等式 一般独立集比覆盖集好求 因子分解1因子1因子(1-factor)：图$G$的1正则生成子图。$n$阶图$G$的完美匹配$M$的诱导的子图$F[M]$是$G$的1因子。图$G$有1因子当且仅当$G$有完美匹配。 连通分支的奇偶性就是该连通分支的阶的奇偶性。$k_O(G)$表示图$G$的奇连通分支的个数。 定理8.10：图$G$包含1因子当且仅当对于$V(G)$的任意真子集$S$，$k_O(G-S)\\le |S|$。 定理8.11(Petersen定理)：所有无割边的3正则图包含1因子。 定理8.12：任一至多含有两条割边的3正则图包含1因子。 分解可因子分解的(1-factorable)：若$G$有1因子$F_1,F_2,…,F_r$，使得$\\{E(F_1),E(F_2),…,E(F_r)\\}$是$E(G)$的一个划分，此时我们称$G$被因子分解(factored)成1因子$F_1,F_2,…,F_r$；这些1因子构成了$G$的1因子分解(1-factorization) 任一可1因子分解的图是正则的，反之不真，反例：Peterson图 定理8.13：Petersen图是不可1因子分解的。 定理8.14：对于任意正整数$k$，完全图$K_{2k}$是可1因子分解的。 循环因子分解(cyclic factorization)：如图所示，所有因子分解可以由某一个因子分解旋转一定角度得到 定理8.15：任意$r$正则的二部图$(r\\ge 1)$是可1因子分解的。 2因子2因子(2-factor)：图$G$的二正则生成子图 2因子的任一连通分支是一个圈。 可2因子分解的(2-factorable)：定义类似1因子 定理8.16：图$G$是可2因子分解的当且仅当存在某个正偶数$r$，是的$G$是$r$正则的。 *Hamilton因子分解(Hamilton factorization)：$G$的一个2因子分解，满足该分解中所有2因子均是Hamilton圈 定理8.17：对于任一整数$k\\ge 1$，完全图$K_{2k+1}$是可Hamilton分解的。证明：构造法（如图） 因子因子(factor)：图$G$不含有孤立点的生成子图 可因子分解(factorable)：因子$F_1,F_2,…,F_r$，满足$\\{E(F_1),E(F_2),…,E(F_r)\\}$是$E(G)$的一个划分。 可F-因子分解的(F-factorable)：若存在某个图$F$，是的每个因子$F_i\\cong F$ Kirkman三元系n阶的Kirkman三元系(Kirkman triple system)：有一个基数为$n$的集合$S$，和$S$的三元子集（称为三元组(triple)）族$T$，以及$T$的一个划分$\\mathcal{P}$构成，且满足如下性质： $S$中任意两个不同的元素属于$T$中唯一的三元组 $S$中任一元素属于划分$\\mathcal{P}$的每一元素的唯一的三元组 存在一个$6k+3$阶Kirkman三元系当且仅当存在一个$K_{6k+3}$的$(2k+1)K_3$因子分解 定理8.19：$n(n\\ge 3)$阶的Kirkman三元系存在当且仅当$n\\equiv 3(mod 6)$，即$n=6k+3$ 定理8.20：对于每个整数$k\\ge 1$，完全图$K_{2k}$可因子分解为$k-1$个Hamilton圈和一个1因子。","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"Graph Theory","slug":"Graph-Theory","permalink":"https://mengzelev.github.io/tags/Graph-Theory/"},{"name":"Matchings","slug":"Matchings","permalink":"https://mengzelev.github.io/tags/Matchings/"},{"name":"Factorization","slug":"Factorization","permalink":"https://mengzelev.github.io/tags/Factorization/"}]},{"title":"Lab3：链接与加载（2）实验报告","slug":"lab3-report","date":"2018-11-24T09:17:47.000Z","updated":"2018-11-30T14:18:07.067Z","comments":true,"path":"2018/11/24/lab3-report/","link":"","permalink":"https://mengzelev.github.io/2018/11/24/lab3-report/","excerpt":"","text":"实现描述寻找正确的入口地址在框架代码抽取出的symtab中主项寻找，如果该项的Type属性为STT_FUNC，就根据其st_name属性去字符串表strtab里寻找该函数的Name属性，并与main进行对比，就能找到main函数对应的表项，此时该表项的st_value属性即 我们需要的入口地址。 加载程序loader()函数的实现需要程序头表，模仿load_elf_table()函数的写法可将程序头表抽取到结构体Elf32_phdr中，找到p_type为PT_LOAD的表项，读取其p_offset，p_vaddr，p_filesz，p_memsz属性，按照讲义的描述，使用fread函数将可执行文件中相对文件偏移p_offset的内容读取p_filedz到内存地址为[p_addr, p_addr + p_filesz的地方，并用memset函数将[p_vaddr + p_filesz, p_vaddr + p_memsiz)对应的物理区间清零。 打印栈帧链第一次打印eip的值作为当前地址，之后每次都取内存中ebp-4的地址存放的返回地址作为函数调用的地址。函数的名字通过去symtab中寻找对应表项并从strtab中提取而得。仿照gdb的bt命令输出打印出来。对ebp的值解引用能得到上一个函数的ebp的值。如此循环直到ebp的信息为0为止。 实验过程留着以后当笑话看的碎碎念 寻找正确的入口地址我本来以为这个只要做好RTFSC就不会花太多时间的，man 5 elf之后理所当然地写了如下代码： if(symtab[i].st_info == STT_FUNC) 发现怎么都找不到main，各种调试了一个多小时之后，问了同学才意识到，st_info不是直接的type值，type只占了低四位，高四位为绑定属性bind，把FM继续往下翻可以看到 ELF32_ST_BIND(info), ELF64_ST_BIND(info) Extract a binding from an st_info value. 泪，可以流下来吗论耐心RTFM的重要性 加载程序这部分基本是照抄框架代码抽取El32_Shdr的方法抽取了Elf32_Phdr，让我自己写大概还是写不出来的吧[自卑.jpg] 打印栈帧连先用gdb调试了给的segmentfault.c，摸索了一下bt命令的打印格式，确认了打印的栈帧链中的地址为函数调用时压入栈中的返回地址。 思考题堆和栈在哪里？经过PA3.2的调教，可以知道堆是程序运行时调用malloc动态向高地址申请空间维护的。堆区的开始位置就是数据段的结束位置。当调用malloc函数时，会触发系统调用sbrk查询并调整堆区的结束位置，即program break，以调整堆区的大小。栈区是从内核虚存区开始向低地址方向生长的，栈顶的地址保存在寄存器esp中。通过push和pop等指令来调整栈区大小。堆和栈的内容不放入可执行文件，我猜想一方面因为这些部分是动态生成的，程序执行过程中它们的大小时刻变化着，因此不能放入静态的可执行文件中。另一方面，栈区会有一个随机化操作来防止恶意攻击，不便于放入可读的可执行文件中。 如何识别不同格式的可执行文件？ELF可执行目标文件有ELF头，根据ELF可执行文件的各种规范书写。Windows生成的可执行文件应该也有自己的文件头的格式，在GNU/Linux下执行时，系统按照ELF头的格式解析该文件的文件头出现了错误，例如没有读到“魔数”，就会报告“格式错误”。 消失的符号因为这些符号只在本模块内被使用，其被动态分配在栈中，链接器并不需要这些符号的信息，因此不会出现在符号表中。符号是指参与链接的变量名和函数名。 寻找”Hello World!”用上述方法找到hello程序的字符串表，会发现“Hello World!”字符串…它…根本不在字符串表中，而是在.rodata节中。 因为printf中的格式化字符串是一个只读的字符串，所以编译时会被放入只读数据节.rodata节中。 冗余的符号表编译单独的hello程序没有问题，但是尝试对hello.o进行链接时就会链接报错（忘了截图了）。因为符号表用于链接中的符号解析，单独运行程序时没有符号表，单有指令就也没有问题。 冗余的属性？起初我猜测是.bss节的数据没有在Filesz中被计算，而是计算在了Memsz中。但是我把.bss节的大小加上Filesz后还是比Memsz小一些，STFW发现stackoverflow上有人问了类似的问题，欣喜地点进去发现并没有人回答….我再思考一下说不定就有stackoverflow首答了… 为什么要清零？数电和问求还没写完，溜了…….","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Lab","slug":"Lab","permalink":"https://mengzelev.github.io/tags/Lab/"},{"name":"Ics","slug":"Ics","permalink":"https://mengzelev.github.io/tags/Ics/"}]},{"title":"图论学习笔记-旅行问题","slug":"traversability","date":"2018-11-21T13:05:50.000Z","updated":"2018-11-30T14:19:40.503Z","comments":true,"path":"2018/11/21/traversability/","link":"","permalink":"https://mengzelev.github.io/2018/11/21/traversability/","excerpt":"","text":"Euler图Euler回路(Euler cycle)：图$G$的一条包含$G$的每一条边的回路$C$ Euler图(Euler graph):含有Euler回路的连通图 Euler迹(Euler trial)含有连通图$G$的每条边的开迹 当讨论图的Euler性质时， 定理6.1：一个非平凡连通图$G$是Euler的 当且仅当 $G$的每个顶点的度都为偶数 推论6.2：一个连通图$G$含有一条Euler迹当且仅当$G$恰有两个度为奇数的顶点，而且$G$的每一条Euler迹始于一个度为奇数的顶点而终止于另一个度为奇数的顶点。 例6.3结论：设$G$和$H$是两个非平凡的连通图，则$G\\times H$是Euler的当且仅当$G$和$H$都是Euler的或者$G$和$H$的每个顶点度均为奇数。 Hamilton图Hamilton圈(Hamiltonian cycle)：一个含图$G$的每个顶点的圈 Hamilton图(Hamiltonian graph)：一个含有Hamilton圈的图 Hamilton路(Hamiltonian path)：一条含图$G$的每个顶点的路 有Hamilton圈, 一定有Hamilton路；有Hamilton路，不一定有Hamilton圈 Hamilton图的特征 $n\\ge 3$阶图的一个Hamilton圈$C$是$n$阶的连通2正则子图 $C$不含有阶小于$n$的圈作为子图 $G$也不含有有度大于等于3的子图 如果$G$含有度为2的顶点，则与$v$关联的两条边一定位于$C$上 定理6.4：Peterson图不是Hamilton的 Hamilton图的性质$k(G)$：图的连通分支数 定理6.5：如果$G$是一个Hamilton图，则对$G$顶点的任一非空真子集$S$，都有$k(G-S)\\ge |S|$（一个图是Hamilton图的必要条件）逆否命题：设$G$为一个图。如果对$V(G)$的某个非空真子集$S$,有$k(G-S)&gt;|S|$，则$G$不是Hamilton的（一个图为非Hamilton的充分条件）如果图$G$含有一个割点$v$，则$G$不是Hamilton的 Hamilton图的充分条件定理6.6(Ore 定理)：设$G$为一个$n(n\\ge 3)$阶的图，如果对于$G$的每对不邻接的顶点$u,v$，有$deg u +deg v\\ge n$,则$G$是Hamilton的。该定理给出的界是紧的 推论6.7：设$G$为一个$n\\ge 3$的图，如果对于$G$的每个顶点$v$，均有$deg v\\ge n/2$，则$G$是Hamilton的。 定理6.8：设$u$和$v$是一个$n$阶图$G$的两个不邻接的顶点，并且$deg u + deg v\\ge n$，则$G+uv$是Hamilton的当且仅当$G$是Hamilton的。 闭包(closure)：由$G$出发递归地连接度数之和至少为$n$的不邻接顶点对，记为$C(G)$ 定理6.9：一个图是Hamilton的当且仅当它的闭包是Hamilton的。 推论6.10：如果$G$是一个阶至少为3的图，且它的闭包$C(G)$是一个完全图，则$G$是一个Hamilton图 定理 6.11：设$G$是一个$n(n\\ge 3)$阶的图。如果对于每个整数$j(1\\le j&lt;\\frac{n}{2})$，$G$中度至多为$j$的顶点数小于$j$，则$G$是Hamilton的。","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"Graph Theory","slug":"Graph-Theory","permalink":"https://mengzelev.github.io/tags/Graph-Theory/"},{"name":"Traversibility","slug":"Traversibility","permalink":"https://mengzelev.github.io/tags/Traversibility/"}]},{"title":"图论学习笔记-图中的连通性与距离","slug":"connectivity","date":"2018-11-14T08:19:10.000Z","updated":"2018-11-30T14:19:28.693Z","comments":true,"path":"2018/11/14/connectivity/","link":"","permalink":"https://mengzelev.github.io/2018/11/14/connectivity/","excerpt":"","text":"割点割点的定义：去掉这个点后，原图不再连通 定理5.1：设$v$是连通图$G$中与bridge相连的一个结点，则$v$是割点当且仅当$deg v\\ge 2$非简单树 = 端点 + 割点 推论5.2：设$G$是一个至少有3个顶点的连通图，若$G$有bridge，则$G$一定有割点 定理5.3：设$v$是连通图$G$的一个割点，$u$和$w$是$G-v$不同components中的两个顶点，则$v$位于$G$的任意一条$u-w$路径上。 回顾定理4.1：边$e$是bridge当且仅当$e$不存在于任何一个cycle上 推论5.4：$v$是连通图$G$的一个割点 当且仅当 存在与$v$不同的两个顶点$u$和$w$，使得$v$位于$G$的任意一条$u-w$路上 定理5.5：设$G$是非平凡连通图，$u\\in V(G)$。若$v$是$G$中距离$u$最远的顶点，则$v$不是$G$的割点。 推论5.6：任意非平凡的连通图至少包含两个非割点的顶点。 块(Blocks)不可分图(nonseparable graph)：没有割点的非平凡连通图 定理5.7：结点数不少于3的图是不可分的 当且仅当 任意两个顶点都位于某个圈上 块(block):图$G$的一个最大的不可分子图 定理5.8：$R$是定义在非平凡连通图$G$的边集上的关系：对于$e,f\\in E(G)$，若$e=f$或$e,f$位于$G$的同一个圈上，则$e,f$有关系$R$，即为$eRf$且$R$是等价关系。该定理将图$G$的边画划分为了若干等价类。 推论5.9：非平凡连通图$G$的任意两个不同的块$B_1$和$B_2$具有下面性质： $B_1$和$B_2$是不相交的 $B_1$和$B_2$至多有一个公共结点 若$B_1$和$B_2$有一个公共结点$v$，则$v$是$G$的割点 连通度顶点割顶点割(vertex-cut)：顶点集$U$，$G-U$是不连通的 最小顶点割：自行感受一下 只有非完全图才有顶点割，且所有非完全图都有顶点割 (点)连通度(vertex-connectivity):$\\kappa(G)$=最小顶点割的基数 0\\le \\kappa(G)\\le n-1图$G$是k-连通的(k-connected)，即$\\kappa(G)\\ge k$，随便去掉$k$个点之后依然是连通的 边割(edge-cut)边割(edge-cut)：边集$X$，$G-X$是不连通的 最小边割和极小边割是不同的概念 边连通度(edge-connectivity):$\\lambda(G)$=最小边割的基数 0\\le \\lambda(G)\\le n-1完全图的边连通度$\\lambda(K_n)=n-1$ 点、边连通度间的关系定理5.11：对于任意图$G$，\\kappa(G)\\le \\lambda(G)\\le \\delta(G)点连通度$\\le$边连通度$\\le$最小度数 定理5.12：立方图$\\kappa(G)=\\lambda(G)$ 定理5.13：$G$顶点数为$n$，边数为$m$，则$\\kappa(G)\\le \\lfloor\\frac{2m}{n}\\rfloor$ Harary图定理5.14：如果$G$是至少有3个结点的连通图，则$G^2$时候2-连通的。 定理5.15：对于任意整数$r,n$满足$2\\le r&lt;n$，有$$\\kappa(H_{r,n})=r$ Menger定理分离集(separating set)：$S$是图$G$的顶点集的一个子集，$u$和$v$是$G$的两个顶点。若$G-S$是不连通的且$u$和$v$属于$G-S$不同的连通分支，则称$S$分离$u$和$v$，$S$是一个$u-v$分离集 内点(internal vertex):一条$u-v$路径上除去$u,v$的点内部不相交(internally disjoint)：两条路径除端点外没有公共点 定理5.16(Menger定理)：设$u$和$v$是图$G$的不邻接的两个顶点，则$u-v$分离集中顶点的最小个数等于$G$中内部不相交$u-v$路的最大个数。证明使用了数学归纳法，归纳步时分了3种情况讨论 定理5.17：一个非平凡图$G$是$k$连通的($k\\ge 2$) 当且仅当 对于$G$的任意两个顶点$u,v$，$G$至少有$k$条内部内部不相交的$u-v$路。 推论5.18：设$G$为$k$连通图，$S$是由$G$中任意$k$个顶点构成的集合。若图$H$是由$G$通过添加一个新的顶点$w$以及连接$w$到$S$中所有的顶点所得，则$H$也是$k$连通的。 推论5.19：若$G$为$k$连通图，$u,v_1,v_2,…,v_k$为$G$中$k+1$个不同的顶点，则$G$有内部不相交的$u-v_i$路($1\\le i\\le k$) 定理5.20：若$G$为$k$连通图($k\\ge 2$)，则$G$中任意$k$个顶点均位于某一个圈上。 定理5.21：对于图$G$两个不同的顶点$u$和$v$，$G$中分离$u,v$的边的最小个额数等于$G$中边不相交$u-v$路的最大个数 定理5.22：一个非平凡图$G$是$k$边连通的当且仅当对于$G$中任意两个不同的顶点$u,v$，$G$包含$k$条边不相交的$u-v$路","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"Graph Theory","slug":"Graph-Theory","permalink":"https://mengzelev.github.io/tags/Graph-Theory/"},{"name":"Connectivity","slug":"Connectivity","permalink":"https://mengzelev.github.io/tags/Connectivity/"}]},{"title":"算法导论学习笔记-所有结点对的最短路径问题","slug":"clrs-25All-Pairs-Shortest-Paths","date":"2018-11-07T08:17:34.000Z","updated":"2019-01-07T11:15:54.734Z","comments":true,"path":"2018/11/07/clrs-25All-Pairs-Shortest-Paths/","link":"","permalink":"https://mengzelev.github.io/2018/11/07/clrs-25All-Pairs-Shortest-Paths/","excerpt":"","text":"矩阵乘法最优子结构$l_{ij}^(m)}$:从结点$i$到结点$j$的至多包含$m$条边的任意路径中的最小权重。 l_{ij}^{(m)} = \\min\\limits_{1\\lek\\le n}\\{l_{ik}^{(m1)}+w_{kj}\\}自底向上计算最短路径权重 三重循环，时间复杂度为$\\Theta(n^3)$ 形式上与矩阵乘法的计算非常类似 计算$L^{(n-1)}=W^{n-1}$ 这个算法本质上就是对$n$个点每个跑了一遍Bellman-Ford 改进运行时间重复平方技术二分计算矩阵的幂 优化后时间复杂度为$\\Theta(n^3\\lgn n)$ Floyd-Warshall算法枚举最短路径上的中间结点来进行递归的计算 不允许有负权重环 但是可以做到在有负权重环的情况下报告（看对角元是否有负数） $d_{ij}^{(k)}$：从$i$到$j$经过的中间结点为$\\{1,…k\\}$的子集的最短路径长度 伪代码 时间复杂度$\\Theta(n^3)$ 空间复杂度看似需要$\\Theta(n^3)$，但是作业题中证明了只需要一个矩阵来存储，为$\\Theta(n^2)$ 构建最短路径采用动态规划的思想，递推式如下 用于稀疏图的Johnson算法用一种神奇的方式对图中每条边的权重进行重新赋值，使新的图满足 所有权重都为非负值 新图中的最短路径就是旧图中的最短路径 伪代码 先增加一个新结点$s$，该点到原先各结点都有边相连，权重为0对新图进行一次Bellman-Ford算法，寻找是否有负权重环路没有负权重环，就用神奇的长得像顶点的势能函数一样的函数给每条边重新赋值 \\hat{w}(u,v)=w(u,v)+h(u)-h(v)h(u)=\\delta(s,u)然后对每个点进行Dijkstra最后记得将最短路径的权重恢复，并存入矩阵$D$中返回 时间复杂度二叉最小优先队列实现Dijkstra：$O(VE\\lg V)$斐波那契堆实现：$O(V^2\\lgV+VE)$在稀疏图的情况下，表现比Floyd-Warshall好","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://mengzelev.github.io/tags/Graph-Algorithms/"}]},{"title":"Lab2:链接与加载 实验报告","slug":"lab2-report","date":"2018-11-06T09:17:47.000Z","updated":"2018-11-30T14:17:54.141Z","comments":true,"path":"2018/11/06/lab2-report/","link":"","permalink":"https://mengzelev.github.io/2018/11/06/lab2-report/","excerpt":"","text":"实验过程按照实验讲义的提示，首先找到了libc库所在的位置，输出基本与讲义中给出的一致，不作赘述。 编写的测试文件a.c的代码为 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main (){ int a = rand(); printf(&quot;%d\\n&quot;,a); return 0; } 只需要有对rand的调用且保证不会被编译器优化掉就可以了。 找到动态库文件之后，对该二进制文件进行反汇编 $ objdump -d /lib/x86_64-linux-gnu/libc.so.6 &gt; libc64 然后对反汇编后的文件进行查看，可以看到一堆库函数的反汇编代码。此时我看到了讲义中的这句话： 然后你会发现这个文件对你并没有什么卵用，好吧，其实一会儿是会用到的。 导致我真的以为现在用不到这个文件，于是，我傻fufu地按照讲义的指示去找rand函数的地址了。gdb，启动！看到了一堆跳转语句，感受到了自己对课本内容掌握不足；课本，打开！复习了一下动态链接相关的知识点；gdb，开始！单步执行到&lt;rand@plt&gt;处时，发现了rand对应的GOT表项的地址，为0x55555575020 然后疯狂si，会看一堆dl_开头的，八成是和动态链接有关的函数。一不小心回车过头，最后在main里停下来，总之动态链接过程已经完成了，这时候可以查看内存地址为0x55555575020处的内容为0x7ffff7a70820（忘了截图了） 打印0x7ffff7a70820的内容，确认了确实为rand函数的地址 做到这里，感觉像是完成了什么，开始思考下一步要做什么。等一下，我们的最终目标不是只要得到system到rand的偏移量吗，那我费尽千辛万苦搞到rand的地址干什么……算了，就当复习了一下动态链接的相关知识点和回忆了一下gdb的使用方法吧 不管了，总之先打开之前反汇编的动态库看一下，分别找到rand和system的地址 偏移量为0x3f480-0x36820=0x8c60 为了验证一下正确性，使用gdb打印了和rand具有相应偏移量（其实就是后3位不同）出的内存内容 这下准没错了，于是开始编写oj_killer函数 代码解释最初仅考虑64位情况的oj_killer函数代码如下 #include &lt;stdlib.h&gt; void* oj_killer(){ void* randptr = (void *)rand; //获得rand函数的地址 return (void*)(randptr + 0x8c60); //加上libc中rand到system的偏移量，返回system函数的地址 } 编译运行后能够成功输出Hello World 兼容32位接下来考虑32位的情况 如果将上述程序直接编译为32位，会得到Illegal instruction的错误 对a.c加上-m32选项进行编译后查看其调用的动态链接库，可以发现调用的是32位的库，和64位的库是不一样的（当然了 $gcc a.c -m32 -o a32.out $file a32.out a32.out: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically link│ ed, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=b3e591a0858f18│ 2549e63239c338f5fd30496ce2, not stripped $ldd a32.out linux-gate.so.1 (0xf77ac000) libc.so.6 =&gt; /lib32/libc.so.6 (0xf75d1000) /lib/ld-linux.so.2 (0xf77ae000) $file -L /lib32/libc.so.6 /lib32/libc.so.6: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=84bb53910470c7ceb2a0963044117fdf8a2bb975, for GNU/Linux 2.6.32, stripped 使用同样的方法进行反汇编后 $objdump -d /lib32/libc.so.6 &gt; libc32 分别得到rand和system在libc内的地址 于是可以按照同样的思路编写代码 真·代码解释void* oj_killer(){ int type = sizeof(void*); void* randptr = (void *)rand; //获得rand函数的地址 if(type == 8) //判断当前环境是否为64-bit return (void*)(randptr + 0x8c60); //加上64位时libc中的偏移量 else return (void*)(randptr - 0x2f6f0 + 0x3a850); //加上32位时libc的偏移量 } 为了保证代码的可移植性，特意将变量randptr声明为void*类型，而非int或long long。判断当前环境为32/64位则依靠对void*长度的判断。 暴露了不太会用#if预编译指令的事实 分别按32位和64位编译后，可以得到Hello World的输出：","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Lab","slug":"Lab","permalink":"https://mengzelev.github.io/tags/Lab/"},{"name":"Ics","slug":"Ics","permalink":"https://mengzelev.github.io/tags/Ics/"}]},{"title":"PA2实验报告","slug":"PA2-report","date":"2018-11-06T01:33:26.000Z","updated":"2018-11-06T01:34:50.453Z","comments":true,"path":"2018/11/06/PA2-report/","link":"","permalink":"https://mengzelev.github.io/2018/11/06/PA2-report/","excerpt":"","text":"实验进度描述2018/10/04RTF实验讲义，RTFSC，我是谁，我在哪儿，我要干什么 2018/10/05经历了两天的RTFSC后终于看懂了框架代码是干嘛的，RTFM实现了sub,push,ret,call等指令，在nemu中运行了第一个程序dummy 2018/10/21听了同学们的建议，先实现了diff-test，结果发现PA2.1的指令实现有bug。修复了这些bug并温故框架代码的构成 2018/10/22花了一整天对照着FM实现了exec目录下大部分指令，填写opcode_table巨表，然而有海量bug等待发现 2018/10/27开diff-test跑完了cputest中所有的测试，修复了能发现的PA2.2中的bug。bash runall后看到了绿油油的full-combo，心情舒畅。然而并不知道2.3的时候还有海量bug等着自己 2018/10/28实现了string.c中所有的库函数和sprintf，先在nemu外单独手动测试，然后放入klib中，成功运行string.c和hell-str.c，PA2.2基本完成，make submit 2018/11/2实现了in/out指令，成功运行hello。与同学出去吃火锅，讨论发现自己的diff-test歪打正着可以正常运行。 2018/11/3实现了printf，测试时钟时陷入莫名其妙的Segmentation Fault，在指令中加入大量Log测试，无果；找到大腿进行文件替换，无果；把指令实现和库函数又给了大腿二号进行替换，发现一切运行正常。心态爆炸，怀疑人生，git滚回到2.2完成的状态，从2开始的PA2.3。修仙实现了时钟、键盘和vga，并通过了相关测试，成功运行打字游戏（虽然慢的一笔）。跑分测试时还是出现了bug，遂开启diff-test后滚去睡觉 2018/11/4起来看到结果发现是neg指令写错了，修复bug后成功运行了三个跑分测试。看到超级无敌慢动作马里奥，差点笑死，录成视频发到qq空间被jyy点赞了。复习链接相关知识，自学Makefile语法，编写硬核实验报告。 必答题 只有聪明的人才看得见 我遇到的那些bug以后实验报告新增这一环节，希望可以帮到其他人 有些指令不是RTL完了就完事的，还需要operand_write写入到相应位置 test指令手册表意不清，虽然写了DEST := LeftSRC AND RightSRC，但是两个操作数并不需要改变，不需要进行operand_write 框架里已经为你准备了丰富多彩的译码函数，有些指令有自己特殊的译码函数，赶紧到decode.h里去康康吧！ ret指令需要跳转到返回地址的，没有好好RTFM的后果 sar是需要符号扩展的 译码函数的立即数读入也是需要符号扩展的 编译timetest的时候链接出错：undefined reference to，其实是因为stdio.c没有加上重要的头文件 运行跑分测试coremark时出现内存地址越界，发现是opcode_table中的imul指令的译码函数写错了 neg指令只需要直接取反加一 不知道时钟怎么写，可以参考一下_putc的代码，里面有提示 native的输入输出实现里有不少提示可供参考 框架代码中没有rol指令，不知道是可爱PA作者的疏忽还是故意让我们练手的 蓝框思考题临近期中考试，时间不是很充裕，写得很少，但愿今后有机会二周目思考吧 Q:AT&amp;T格式反汇编结果中的少量指令, 与i386手册中列出的指令名称不符, 如cltd. 除了STFW之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?A:先STFW试图搞清楚这个指令是干什么的，然后翻手册的目录寻找描述差不多的指令。比如cltd是Convert longword to doubleword的意思，翻手册的目录能找到意思差不多的Convert word to double word。运气好的话可能在STFW的时候就能找到对应的i386的指令名称了。 Q：你或许会感到疑惑, 代码优化不是一件好事情吗? 为什么会有volatile这种奇葩的存在? 思考一下, 如果代码中p指向的地址最终被映射到一个设备寄存器, 去掉volatile可能会带来什么问题? A：因为编译器基本是根据输入输出状态进行的代码优化，而我们有些时候是care中间过程的，例如lab01中的性能测试。如果代码中p指向的地址最终被映射到一个设备寄存器，可能会发生设备状态的跳变，比如显示器某块地方应该是由蓝变绿再变红，会直接从蓝色变成红色。 实验心得 未测试的代码永远是错的，测试过的代码也不会是对的！隐藏bug无处不在。【PA2.2full-combo的大家几乎都在2.3里发现了cputests没能暴露的bug，以此类推PA3的时候可能还会发现PA2的bug 要及时坚定滚回去从头再来的决心，试过了力所能及的所有方法都找不出来的bug就不要找了，肯定是在一些玄学的地方犯了玄学的错误，干脆从头重新写一遍 am相关的概念还不是非常清楚，目前还不影响做实验，但还是想进一步了解 Copy-paste是坏文明 github private远程库保命是真的很重要，安心多了 跑分结果堪忧，但是本着先写对，再完美的宗旨，不管了还是值得开心一下的 bug死活找不出的时候容易心态血崩，但是这时候只要实现一个小的功能就能瞬间高兴回来 敲代码真**开心 Appreciation 感谢“™写™PA真™开心”群的群友们，一起修仙，一起写bug，一起交流bug，帮忙debug，还在心态快崩的时候一起出去约了顿火锅 感谢xy同学，提供了可供替换的大腿，做得太快了，还给我剧透了不少，让我少踩了不少坑 感谢ldw同学，用我的代码替换到了他的代码上证明我的指令集和库函数并没有大问题，给了我滚回去重做的决心（ 感谢某位还是不愿意透露姓名的nb学长，通过千里眼，帮忙发现了不少bug 本实验报告同样会将去掉必答题的版本同步上传至个人blog","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"}]},{"title":"算法导论学习笔记-单源最短路径","slug":"clrs-24Single-Source-Shortest-Path","date":"2018-10-30T14:29:50.000Z","updated":"2018-11-07T08:18:49.729Z","comments":true,"path":"2018/10/30/clrs-24Single-Source-Shortest-Path/","link":"","permalink":"https://mengzelev.github.io/2018/10/30/clrs-24Single-Source-Shortest-Path/","excerpt":"","text":"前备概念环路如果有负权重环路，问题比较大，因为你在环路里往死里转路径要多短有多短，这时候定义最短路径长度为负无穷。$\\delta(u,v)=-\\infty$ 如果有正权重环路，那最短路径肯定不会走这个环路，所以不影响 如果有0权重环路，那这个环路等于没有，也不影响 初始化$v.d$：最短路径估计 使用下面运行时间为$\\Theta(V)$的算法来对最短路径估计和前驱结点进行初始化： 初始化操作的时间复杂度为$\\Theta(V)$ 松弛操作松弛过程：试图改善从$s$到$v$的最短路径。可能降低最短路径的估计值$v.d$并更新$v$的前驱属性$v.\\pi$ 松弛是唯一导致最短路径估计和前驱结点发生变化的操作 本章讨论的所有算法之间的不同之处是对每条边进行松弛的次数和松弛边的次序有所不同 最短路径和松弛操作的性质这几条最好要背下来的，我觉得考试很容易考 为了方便记忆，po主尝试着用人话复述一遍： 三角不等式性质：图里任意两个点和源点$s$构成一个三角形（可以退化为直线），有两边之和大于等于第三边 上界性质：$v.d$撑死就是$\\delta(s,v)$，不能再小了 非路径性质：原话已经很人话了 收敛性质：松弛前边的起点已求得最短路径，松弛后边的终点也将获得最短路径buff 路径松弛性质：只要一条最短路径上的点是按松弛的，那么估计值就等于最短路径 前驱子图性质：最短路径算完了，前驱子图是一颗根结点为$s$的最短路径树 Bellman-Ford算法描述 先将结点进行初始化 对每条边进行$|V|-1$次松弛操作 当存在负权重环路时会返回FALSE 如果不存在负权重环路，则返回TRUE，每个结点的$v.d$即为源点$s$到该点的最短路径长度 伪代码 时间复杂度$O(VE)$ 正确性证明用到了三角不等式 + 非路径性质 + 前驱子图性质 有向无环图（DAG）中的单源最短路径问题无环，因此没有负权重的环，对于任何结点，最短路径都是存在的 算法描述先对DAG进行拓扑排序，按照拓扑排序的顺序对每个结点进行松弛操作 伪代码 时间复杂度 拓扑排序(1)： $\\Theta(V+E)$ 初始化(2)：$\\Theta(V)$ 3~5行的循环（聚合分析）：$\\Theta(V)$总时间复杂度：$\\Theta(V+E)$ 正确性证明精髓还是在于神奇的路径松弛性质，只要保证每条最短路径上边的松弛次序，就能得出算法终止时$v_i.d=\\delta(s,v_i)$ 应用PERT图 Dijkstra算法描述 解决带权重的有向图上的单源最短路径问题 要求所有边的权重都为非负值 维护一组结点结合$S$，从源点$s$到该集合中每个结点之间的最短路径已经被找到 使用贪心策略，每次都从结点集$V-S$中选择最短路径估计最小的结点$u$，然后更新与$u$相连的结点的最短路径估计值 伪代码 正确性证明循环不变式：在算法第4~8行的while语句的每次循环开始前，对于每个结点$v\\in S$，有$v.d=\\delta(s,v)$ 证明使用了反证法+最小数原理关键步用到了收敛性质和权重非负的假设 时间复杂度依赖于最小优先队列的实现 数组遍历： $O(V^2)$ 二叉堆：$O(E\\lg V)$ 斐波那契堆:$O(V\\lg V+E)$ 最短路径性质的证明三角不等式根据最短路径的定义即可得证 最短路径树性质最短路径树的三条性质： $v’$是图$G$中从源结点$s$可以到达的所有结点的集合 $G’$形成一棵根结点为$s$的树 对于所有的结点$v\\in V’$，图$G’$中从结点$s$到结点$v$的唯一简单路径是图$G$中从结点$s$到结点$v$的一条最短路径 未完待不会续","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Single Source Shortest Path","slug":"Single-Source-Shortest-Path","permalink":"https://mengzelev.github.io/tags/Single-Source-Shortest-Path/"},{"name":"Bellman-Ford","slug":"Bellman-Ford","permalink":"https://mengzelev.github.io/tags/Bellman-Ford/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://mengzelev.github.io/tags/Dijkstra/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://mengzelev.github.io/tags/Graph-Algorithms/"}]},{"title":"算法导论学习笔记-基本图论算法","slug":"clrs-22graphic-algs","date":"2018-10-24T06:20:35.000Z","updated":"2018-10-30T15:04:07.416Z","comments":true,"path":"2018/10/24/clrs-22graphic-algs/","link":"","permalink":"https://mengzelev.github.io/2018/10/24/clrs-22graphic-algs/","excerpt":"","text":"辣鸡po主只挖坑不填坑因为作业实在太多了！！！ 试一下Mathjax有没有配置成功！ 图的表示邻接链表(Adjacency-list) 由一个包含$|V|$条链表的数组Adj所构成，Adj[u]包含所有与结点u之间有右边相连的结点v 存储空间需求：$\\Theta(V+E)$ 鲁棒性高，稍加修改可以支持许多图的变种（如：有权图） 缺陷：无法快速判断一条边是否在图中 邻接矩阵(Adjacency-matrix) 用矩阵来存储连通信息 存储空间需求：\\Theta(V^2) 与边数|E|无关 简单，图规模较小时优先使用 广度优先搜索BFS算法描述 从一个源结点s开始，每次从已发现的结点向未发现的结点扩展 算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点 用三种颜色标记结点的访问状态： 白色：未被发现 黑色：本身被发现且所有与之相连的结点都已经被发现 灰色：本身被发现且与之相连的结点中存在未被发现的 结果可能以来 伪代码 使用队列存储所有灰色结点 while循环的循环不变式：队列Q中包含的是灰色结点的集合 分析 结点信息初始化： O(V) 队列操作总时间： O(V) （每个结点都要进出各一次） 扫描邻接链表： O(E) 总时间复杂度： O(V+E)是图G的邻接链表大小的一个线性函数 最短路径正确性证明一堆定理和证明 广度优先树深度优先搜索DFS算法描述 大胆地往前走，走到底再回头（雾 深度优先搜索的前驱子图可能有多棵树组成，即深度优先森林因为搜索可能从多个源结点重复进行 对结点进行黑白灰染色，可以保证每个结点仅在一棵深度优先树中出现，保证所有的深度优先树是不相交的 时间戳： 每个结点v有两个时间戳 第一个时间戳v.d记录结点v第一次被发现的时间（染上灰色的时候） 第二个时间戳v.f记录搜索完成对v的邻接链表扫描的时间（图上黑色的时候） 时间戳都是处于1和2|V|之间的整数 u.d &lt; u.f 非树边： 前向边F：从祖先指向后代 后向边B：从后代指向祖先（包括有向图中的自循环） 横向边C：两端点无血缘关系 伪代码 时间复杂度 结点信息初始化： O(V) DFS-VISIT： O(E) 总运行时间： O(V+E) 性质能提供关于图结构的价值很高的信息 括号化结构","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Single Source Shortest Path","slug":"Single-Source-Shortest-Path","permalink":"https://mengzelev.github.io/tags/Single-Source-Shortest-Path/"},{"name":"Bellman-Ford","slug":"Bellman-Ford","permalink":"https://mengzelev.github.io/tags/Bellman-Ford/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://mengzelev.github.io/tags/Dijkstra/"}]},{"title":"图论学习笔记-树","slug":"tree","date":"2018-10-14T08:00:05.000Z","updated":"2018-10-15T01:17:40.985Z","comments":true,"path":"2018/10/14/tree/","link":"","permalink":"https://mengzelev.github.io/2018/10/14/tree/","excerpt":"","text":"本章可用结论整理 定理4.1：e是图G的桥当且仅当e不在G的任何一个cycle上 定理4.2：图G是树当且仅当G的任意两个顶点只有唯一的path相连 定理4.3：每一棵非简单树都有至少两个端点(end-vertice) 定理4.4：每棵有n个顶点的树都有n-1条边 推论4.6：每棵有k个component的森林都有n-k条边 定理4.7：每一个有n个顶点的连通图至少有n-1条边 定理4.8：有n个顶点、m条边的图G，若满足以下3条性质中的2条：(1)连通 (2)无环 (3)m = n - 1，则G是树 定理4.9：设T是一棵有k个顶点的树。如果图G中最小的度数不小于k-1，那么T与G的某个子图同构 定理4.10：每个连通图都包含了一棵生成树 定理4.15(Tree Formula): 有n个不相同的顶点的树的个数为$n^{n-2}$ 定理4.16(Matrix Tree Theorem): 桥(Bridges)概念如果$e=uv$是连通图$G$的一条边，且$G-e$不连通，则$e$称为连通图$G$的桥. 如果$G$是非连通图，那么桥$e$是G一个部分(component)的桥。 考虑componnet的数目，边$e$是图$G$的桥当且仅当$k(G-e)=k(G)+1$ 定理4.1$e$是图$G$的桥当且仅当$e$不在$G$的任何一个cycle上。 树树即无环的连通图。树所有的边都是桥。树也是所有边都是桥的连通图。 双星(double star):包含了恰好两个非端点的树（这两个端点必然相邻） 毛虫树(caterpillar):定点数大于等于3、除去端点后得到的是path的树。除去端点后得到的path叫作毛虫树的脊椎(spine)；顶点数不小于3的path，star，double star都是毛虫树端点其实就是毛毛虫的脚脚 森林(Forests):无环图。森林的每个component的都是树。(过于形象森林不一定要是连通的，但是树必须是。 定理4.2图$G$是树当且仅当$G$的任意两个顶点只有唯一的path相连 这个证明嘛，只有唯一的path不是和无环是等价的吗(流汗.jpg 定理4.3每一棵非简单树都有至少两个端点(end-vertice) 证明取了最长路径的两个端点，利用了最长路径上的端点都不与非路径上点相邻的性质，证得最长路径的两个端点都是end-vertice 这条性质非常有用，可以成为对树结构使用数学归纳法的依据，划掉一个端点就会使order-1使用数学归纳法证明图相关结论的关键在于找到一个end-vertice 定理4.4每棵有n个顶点的树都有n-1条边 证明使用了基于定理4.3的数学归纳法，很直观 推论4.6每棵有k个component的森林都有n-k条边 简单的边数计算就能证明 定理4.7每一个有n个顶点的连通图至少有n-1条边。 证明用到了最小数原理，假设存在一个顶点最少的图少于n-1条边，然后证明此时至少会有一个端点(end vertex)，这时就可以把那一个端点去掉得到一个更小的满足条件的图，从而与假设矛盾。 定理4.8有n个顶点、m条边的图G，若满足以下3条性质中的2条： 连通 无环 m = n - 1则G是树 证明非常直观，活用了上面的定理 定理4.9设T是一棵有k个顶点的树。如果图G中最小的度数不小于k-1，那么T与G的某个子图同构 最小生成树问题实际中存在村庄造路的问题，即造一些路使得所有村庄都连通，并保证造这些路的开销最小这样的问题可以归结为最小生成树问题，求解一个有权图中权值最小的生成树 Kruskal’s Algorithm算法描述：先取权最小的两条边，从第三次开始，每次都取不与取过的边构成cycle的、权最小的边，直到取满n-1条边为止。类似于贪心算法。 正确性证明也类似于证明贪心用到的替换法，取最优解中与算法解重叠最大的解，进行替换，导出矛盾。 Prim’s Algorithm算法描述：先取权最小的一条边，之后每次都选择连接了未连接的点和已连接的点的边中权最小的一条，知道选择了n-1条边为止。类似于动态规划。 证明思路类似于剪切-粘贴法。难以概括…… 生成树的个数书上这部分完全就是在讲故事啊(╯°Д°)╯︵┻━┻ 图论证明特点自己xjb总结的，仅供参考 多用反证法 …….我再想想","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"Graph","slug":"Graph","permalink":"https://mengzelev.github.io/tags/Graph/"},{"name":"Tree","slug":"Tree","permalink":"https://mengzelev.github.io/tags/Tree/"}]},{"title":"Lab1-乘法 实验报告","slug":"lab1-report","date":"2018-10-12T09:17:47.000Z","updated":"2018-10-15T01:25:08.817Z","comments":true,"path":"2018/10/12/lab1-report/","link":"","permalink":"https://mengzelev.github.io/2018/10/12/lab1-report/","excerpt":"","text":"任务1：实现multimod使用了高精度数乘法计算a*b，然后模拟手算除法的形式写了高精度除法（取模）。代码见文件p1.c. 正确性(伪)证明使用python随机生成生成了1000000组a、b、m，0~9223372036854775807(int64_t的最大值)并计算对应答案，与p1.c的计算结果进行对比。 python随机数生成代码如下： import random MAX = 9223372036854775807 for i in range(1,1000000)： a = random.randint(0,MAX) b = random.randint(0,MAX) m = random.randint(1,MAX) ans = (a * b) % m print (a,b,m,ans) 测试结果一百万组全对（从零开始计数的） 任务2：性能优化由于是先听的课再做的lab，出于惰性直接按照jyy课上讲的方法做了（我去面壁）就不多解释了，代码见p2.c 时间测试思路STFW找到了计算使用time.h库函数计算运行时间的方法，也有计算时钟周期的方法，但是后者使用了汇编代码，在对未知事物的恐惧(这样真的不好)的驱使下还是选择了比较好理解、比较好控制的前者。为了防止计算步骤被优化，又不能让多于的操作占用过多的时间，就使程序计算了正确的case的个数并输出。所以得到的时间应该比实际运行时间长一些。 运行时间注：其中p1.c为任务一中的高精度实现，p2.c为任务二中的优化算法，p3.c为任务三中的神奇代码 运行时间分析记a,b,m的位数为n高精度除法需要做O(n)次减法和比较，每次减法和比较的时间复杂度也都为O(n)，因此总时间复杂度是O(n^2)任务二中优化过的时间需要循环次数是O(n)的，每次循环的操作都能在常数时间O(1)内完成，因此总时间复杂度为O(n)而神奇代码对任何输入消耗的时间都是相同的，时间复杂度为O(1)从运行时间上来看的确是t(p1)&gt;t(p2)&gt;t(p3)，符合预期一个神奇的现象是，随着优化等级的升高，运行时间不一定缩短。尤其是p2.c的运行情况，O1和O2反而不如O0（虽然也只差了0.001ms），于是我反汇编对比了一下，发现multimod、testcases和main几个函数的汇编代码几乎一模一样，但对应行的行数不同，可能是调用了不同的系统库函数。对优化的原理不太了解，暂时无法想到合理的解释。可能是因为这个程序的优化空间不是太大？但是编译器肯定比我智能多了，我想不到优化方法不能看不起编译器啊。 任务3：解析神秘代码结论：ab乘积不超过2^53次方，m在int64_t范围内任意取值，可以保证multimod_fast总是能返回正确的数值 过程非常曲折，以下都是流水账碎碎念，老师嫌长可以不看，自己写着好玩，回头上传个人Blog 刚拿到手先试了一大堆随机数据，发现一百万组测试样例总只能过1w+组，正确率非常低。后来和同学讨论了一下，听说m比较小的时候结果最容易出错，我就把m的随机范围改成了1~3，果然错误率高了很多。大概是因为神秘代码中(int64_t)((double)a * b / m + 1e-8)强制类型转换后要除以m，如果m偏小，那么a*b的误差就很容易保存下来，引起答案出错。 保持m1~3的范围，我又试了几组大数。发现是在ab乘积为10^19左右的时候（a和b在算法找中地位是等价的，所以只需要关注ab的乘积的范围）会出现计算错误，于是在这个范围附近取了一些数，绝了，这个使结果正确的区间并不是连续的！然后理智烧却瞎测了几组数据，不太能发现规律，决定先冷静下来，从理论上思考一下算法。毕竟这次是关于数据表示形式的Lab嘛 这个神奇代码大概是把ab乘积转换为double类型。double类型能表示的范围是大于int64_t的，但是精度不够，尾数部分只有52位的精度（加上前面的1一共是53位），所以应该是只能保证这53位的精度，于是我打开python计算器计算了一下2^26.5 =，大概是94900000，于是我把任务一中随机数的生成范围改为了(0,94900000)，测试了5次，每次一百万组，都是全对的。 到这里我就很想吐槽了，这范围怎么还能算int64_t的，保证结果正确的a和b的范围int都达不到，如果能保证输入在这个范围之内，还不如直接用int64_t算呢，ab相乘肯定不会溢出的。但是如果a和b乘积位表示下末尾零比较多，还是有可能正确的。所以这根本就是一份拼人品的神奇代码吗….. 目前尚未想通的问题： 为什么要+1e-8？ 为什么返回时需要判断t的正负并做相应修正？ 最后，这个神奇代码毕竟是O(1)的，凭我的算法功底实在没办法优化到O(n)以下，所以神奇代码虽然正确率不高，但是效率还是很感人的","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Lab","slug":"Lab","permalink":"https://mengzelev.github.io/tags/Lab/"},{"name":"Ics","slug":"Ics","permalink":"https://mengzelev.github.io/tags/Ics/"}]},{"title":"算法导论学习笔记-用于不相交集合的数据结构","slug":"clrs-21DisjointSets","date":"2018-10-06T08:05:58.000Z","updated":"2018-10-07T07:33:25.694Z","comments":true,"path":"2018/10/06/clrs-21DisjointSets/","link":"","permalink":"https://mengzelev.github.io/2018/10/06/clrs-21DisjointSets/","excerpt":"","text":"不相交集合的操作一个不相交集合数据结构维护了一个不相交动态集的集合每个集合都有一个代表标识，它是该集合的某个成员 我们希望集合支持以下三个操作： 应用：确定无向图的连通分量 算法就是将连通的顶点全部合并到同一个集合中。 不相交集合的链表表示每个集合可以用一个自己的链表来表示链表中对象可以以任意次序出现 每个链表组成为： head— 指向表的第一个对象（代表元） tail— 指向表的最后一个对象 链表中每个对象的组成为： 关键字key 指向head的指针prev 指向后一个对象的指针next 时间复杂度：MAKE-SET O(1)FIND-SET O(1)UNION（简单实现） $\\Theta(n^2)$ 【摊还分析】 简单加权合并启发式策略策略是，每次合并时都将较小的链表挂到较大的链表上，需要多维护一个链表长度的属性。 证明的核心在于每个对象的指针在所有的UNION操作中最多被更新$\\lceil\\lg n\\rceil$次，因此所有UNION操作中被更新的对象的指针总数为$O(n\\lg n)$。加上MAKE-SET和FIND-SEt的O(m)。 不相交集合森林使用有根树来表示集合。每棵树表示一个集合，树的根结点是该集合的代表元。执行UNION操作时将两棵树的树根合并。实现时可以用到两种改进运行时间的启发式策略。 按秩合并类似链表的加权合并启发式策略为了易于分析，对于每个结点，维护一个秩，表示该结点高度的一个上界。秩x.rank代表x的高度的一个上界，高度即从x到某一后代叶结点的最长简单路径上边的数目。UNION操作中 如果根的秩不同，则让较大秩的根成为较小秩的根的父结点，但秩本身保持不变 如果根的秩相同，则任意选择两个中的一个作为父结点，并使它的秩+1 路径压缩在FIND-SET操作中是查找路径中的每个结点直接指向根，不改变任何结点的秩。 伪代码","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Disjoint Sets","slug":"Disjoint-Sets","permalink":"https://mengzelev.github.io/tags/Disjoint-Sets/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://mengzelev.github.io/tags/Data-Structure/"}]},{"title":"做pa的时候可能会用到的操作","slug":"pa-inspirations","date":"2018-10-04T09:18:29.000Z","updated":"2018-10-04T09:21:25.581Z","comments":true,"path":"2018/10/04/pa-inspirations/","link":"","permalink":"https://mengzelev.github.io/2018/10/04/pa-inspirations/","excerpt":"","text":"当做笔记随便写写的，希望能帮到一些人吧。毕竟作为一名优秀的bug maker，别人遇到的问题我基本都能遇到的。 vim和tmux另外写了教程： vim初探 使用tmux变身炫酷程序猿(x 持续更新中最后更新: 2018/10/04 17:18:29 新增PA2时运行dummy出错的解决方式 语言规范 这名字很中二…但其实就是个人写文章的时候一点习惯用的表示，和别人的可能不一样，很可能非常不标准，注意区分就好 []方括号表示需要自定义的内容，括起来的只是你应该输入的东西的名字 $开头的表示在命令行中键入的代码，否则为文件中的代码 在整个目录下查找代码 在某个文件里看到某个函数或者宏或者变量的定义的时候经常会好奇在哪里、怎么使用过，除了用/+(搜索内容)靠vim的功能在文件内搜索外，还可以 $ grep &quot;搜索内容&quot; -r &lt;目录&gt; e.g. $ grep &quot;CPU_state&quot; -r . 其中-r表示递归搜索，可以搜索整个目录下所有的文件 一键跳转定义处 创建接口的时候经常需要查看某些函数、宏、结构体的定义，于是被某位nb的学长安利了ctags神器，可以一键跳转至定义处并一键调回，先贴上自己查到的教程 首先需要安装ctags，一般来说直接apt就好了，但是莫名不行，可能是镜像源的问题 $ sudo apt install ctags 于是我选择了从ctags官网手动下载ctags-5.8.tar.gz 如果是在host里下载的，下载后通过自己的共享方式扔到虚拟机里面，进行解压缩 $ cd [压缩包所在目录] $ tar jxvf [文件名].tar.bz 解压后手动安装 $ cd ctags-5.8 $ ./configure $ make $ make install 安装完成后测试一下是否安装成功 $ whereis ctags 你应该能看到让你觉得成功的提示信息。 安装成功后，为源码生成tags文件，在需要使用ctags的目录下(所有子目录都可以享受到)运行 $ ctags -R 为了使得字段补全有效，在生成tags时需要一些额外的参数，推荐的c语言（c处可以替换成其他语言）参数主要是： $ ctags -R --c-kinds=+px --fields=+iaS --extra=+q 其中，fileds 用于指定每条标记的扩展字段域，extra 选项用于增加额外的条目，f表示每个文件增加一个条目，q为每个类增加一个条目 之后配置vim，就不用每次都手动设置 $ vim ~/.vimrc 在.vimrc 中加入如下内容 set tags=[path]/tags set tags=./tags,tags;$HOME 第二行我暂时也不知道是干什么的，但是不加上去好像用不起来（小声 然后用vim编辑你需要的代码文件，当光标落到你想查询定义的函数上时使用Ctrl + ]跳转到定义处（其实明明是两键跳转对不对），然后Ctrl + o或者Ctrl + t返回跳转前的位置。 参考教程原地址 编译dummy时出错进行到PA2开始时，试图编译dummy会产生如下的报错： 这时候如果STFW得到的答案应该是安装libc6-dev-i386 $ sudo apt-get install libc6-dev-i386 然而我装了之后还是报错，到stackoverflow上稍微刨了一下发现可能还需要安装gcc-multilib $ sudo apt-get install gcc-multilib 然后可以开始愉快的PA2了 stackoverflow原回答地址","categories":[],"tags":[{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"},{"name":"Linux","slug":"Linux","permalink":"https://mengzelev.github.io/tags/Linux/"},{"name":"vim","slug":"vim","permalink":"https://mengzelev.github.io/tags/vim/"}]},{"title":"PA1实验报告","slug":"PA1-report","date":"2018-10-04T09:17:47.000Z","updated":"2018-10-04T09:18:35.194Z","comments":true,"path":"2018/10/04/PA1-report/","link":"","permalink":"https://mengzelev.github.io/2018/10/04/PA1-report/","excerpt":"","text":"实验进度2018/9/15：完成阶段一，实现了单步执行、打印寄存器和扫描内存（简易版）开始做之前忘了git checkout pa1导致工作都在pa0分支里完成了，后来在pa1分支下返工了一遍，两边的git log里都可以查到记录所以求求老师不要扣我的分qwq我下次确定一定肯定确认分支后再开始工作 2018/9/23:完成阶段二，实现了包含(、)、+、-、*、/和十进制数字的表达式计算。为了处理负数将类型都实现为了long long而不是uint32_t，需要按uint32_t类型使用时进行强制类型转换。实现了表达式生成器并测试。 2018/9/29:完成阶段三，扩展了表达式计算中的==、!=、&gt;=、&lt;=、&gt;、&lt;、解除引用和寄存器计算。实现了监视点添加、删除和打印信息功能。用自带的用户镜像初步测试无问题。 2018/9/30:早上起来和同学聊天发现了自己监视点实现的隐藏bug，一开始看了半天没理解到底怎么回事，然后动手加了一堆printf语句缩小范围终于找到了出错的区间，虽然具体的原理还没理解透彻，但是靠着一知半解成功修复了隐藏bug。 必答题不敢po上来的！ 部分蓝框思考题Q：假设你在Windows中使用Docker安装了一个GNU/Linux container, 然后在container中完成PA, 通过NEMU运行Hello World程序. 在这样的情况下, 尝试画出相应的层次图.A：参考了docker官网上的架构图 架构 “Hello World” program simulated x86 hardware NEMU bins/libs Docker host os (windows) Hardware Q：如果没有寄存器, 计算机还可以工作吗? 如果可以, 这会对硬件提供的编程模型有什么影响呢?A：我认为没有寄存器计算机是可以工作的，但是效率会非常低，因为数据的读写只能从内存中进行，而内存的读写速度是慢于寄存器的。而且现在我们学的IA-32架构是不允许在两个内存单元之间进行数据操作的，必须用寄存器作为中间媒介。编程模型一周目的我查了一下没有看懂，但愿二周目的我能看懂吧。 Q：我们知道, 时序逻辑电路里面有”状态”的概念. 那么, 对于TRM来说, 是不是也有这样的概念呢? 具体地, 什么东西表征了TRM的状态? 在状态模型中, 执行指令和执行程序, 其本质分别是什么?A：TRM中存在一个叫做状态寄存器的组成部分，会存储图灵机当前的状态。（状态模型又是什么）执行指令和执行程序的本质区别是程序是一大堆指令的集合。（个人理解） Q：嗯… 如果你觉得提示还不够, 那就来一个劲爆的: 回忆程序设计课的内容, 一个程序从哪里开始执行呢?如果你不屑于回答这个问题, 不妨先冷静下来. 其实这是一个值得探究的问题, 你会在将来重新审视它.A：我正在尝试冷静下来…. Q：阅读reg_test()的代码, 思考代码中的assert()条件是根据什么写出来的A：我不太理解“根据什么写出来”是什么意思……反正没有对错我就说一下个人理解吧。reg_test里的assert们应该是check了一下所有寄存器的存储状态，包括整个32位、低16位和两个低8位，从而来检查CPU_state的结构是否正确。根据…根据CPU_state应有的结构写出来的？ Q：在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1, 你知道这是什么意思吗?A：这样就不会做cpu_exec()中的for循环而直接执行if(nemu_state == NEMU_RUNNING) nemu_state = NEMU_STOP语句实现单步执行。 Q：opcode_table到底是个什么类型的数组?A：是一个opcode_entry结构体类型的数组，通过RTFSC推测应该是模拟指令码的结构体。 Q：你可能会抑制不住编码的冲动: 与其RTFM, 还不如自己写. 如果真是这样, 你可以考虑一下, 你会如何测试自己编写的字符串处理函数?A：其实我更愿意RTFM，有现成的为什么要造轮子写个随机生成字符串的程序产生输入，然后将输入和输出全部都输出肉眼比对一下，大概测试个20组没问题就当过了吧。（做oj的后遗症） Q：框架代码中定义wp_pool等变量的时候使用了关键字static, static在此处的含义是什么? 为什么要在此处使用它?A：static是Internal Linkage的意思，是指编译过程中进行链接时由static修饰的变量不参与与外部文件的链接。这样就使外部的函数一旦使用了这几个变量，编译器就会报错，保证了与WP相关的操作都只能定义在这个文件中。（如果真是这样就有点OOP的感觉？对外只提供接口，实现都在内部，保证了数据和操作的安全性） 剩下一些思考题要么是能力不够STFW找不到满意的答案，要么是找到了看上去满意的答案然而看不懂…. 遇到的问题以及对问题的思考 git merge的时候发生了conflictSTFW之后发现需要先git reset –merge然后cat冲突文件查看是哪里冲突，修改相应地方之后再git merge 全部写完之后才发现写错分支了本来以为git merge之后再给分支重命名就可以了，但是各种冲突实在太多了，所以重新写了一遍，血的教训告诉我们以后一定要在写之前反复检查git branch。因为难以找到一段完整的时间一次性写完，所以每次开始工作之前都需要git branch。 vim忽然“死机”写完一段之后下意识Ctrl+S，之后发现其实是把vim锁定了，Ctrl+Q解锁 vim非正常退出后再次打开与.swp文件发生冲突按R检查是否是自己需要的状态，然后rm .[filename].c.swp将交换文件删除（删之前一定要谨慎不然就是作死） 量子态更新个人blog中，欢迎老师视奸后加分 实验心得 PA虽然是个时间黑洞但是真的很好玩！ 开始动手之前一定要认真RTFSC 看不懂代码的时候手动加点测试可以帮助理解 人真是越学越挑剔，曾经我可以看着全默认的ui手动缩进代码，现在编辑器要是没有（配置）喜欢的字体、自动缩进、括号匹配、甚至一键函数跳转，我可能都会当场疯掉某种意义上越挑剔也就越有学习的欲望很多大佬的故事都告诉我们，工具的改进源于对现有工具的极大不爽 PA1完全是写给自己用的程序而不是OJ那样的了，一定要扪心自问：你写的代码对得起你自己吗？ Acknowledegments 感谢 Massimo同学 在我vim出现异常的时候告诉我是Ctrl+s把屏幕给锁死了并成功教我“急救”方法 感谢 某不愿透露姓名的nb学长 帮忙看了一下表达式生成器的bug，还解决了我的一堆疑问，并且提供深夜debug陪聊服务，并给我负罪感使我以后牢记优先STFW 感谢 xy同学 提供轻度剧透，使我避免了一些bug，还告诉了我一个隐藏bug的存在 感谢 不学习的正经水群 交流pa心得一起快乐编程 实验报告虽然写了很多还是意犹未尽啊，为了赶ddl并尽快愉快地开始PA2先交了，等ddl过了之后会上传删掉了必做题的版本到个人blog，不定时更新","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"}]},{"title":"关于“过程调用”的讨论","slug":"ics-process-calling","date":"2018-09-27T01:59:13.000Z","updated":"2018-10-04T09:15:16.428Z","comments":true,"path":"2018/09/27/ics-process-calling/","link":"","permalink":"https://mengzelev.github.io/2018/09/27/ics-process-calling/","excerpt":"","text":"这是计算机系统基础课上的开放课题，在不同环境下测试一些UB的结果，照理说此处应该有分析但是萌捷列夫懒了，等ddl处理掉了再来写。 实验一代码#include &lt;stdio.h&gt; int main(int argc, char* argv[]){ int a = 10; double *p = (double*)&amp;a; printf(&quot;%f\\n&quot;, *p); printf(&quot;%f\\n&quot;, ((double)(a))); return 0; } windows10环境：dev-cpp/TDM-GCC 4.9.2 64bit Release Debian-64bit Ubuntu-32bit 实验二代码#include&lt;stdio.h&gt; int main(){ double a = 10; printf(&quot;a = %d\\n&quot;, a); return 0; } windows10 Debian Ubuntu-32bit","categories":[],"tags":[{"name":"ics","slug":"ics","permalink":"https://mengzelev.github.io/tags/ics/"},{"name":"process calling","slug":"process-calling","permalink":"https://mengzelev.github.io/tags/process-calling/"}]},{"title":"正则表达式学习笔记","slug":"regex","date":"2018-09-21T14:04:40.000Z","updated":"2018-09-21T14:38:21.936Z","comments":true,"path":"2018/09/21/regex/","link":"","permalink":"https://mengzelev.github.io/2018/09/21/regex/","excerpt":"","text":"废话不多说，贴4张截图就跑路（。 有空还是会回来写的，容我先把ddl肝完（瘫）。 PA讲义中的Linux-C教程","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"},{"name":"regular expressions","slug":"regular-expressions","permalink":"https://mengzelev.github.io/tags/regular-expressions/"},{"name":"linux","slug":"linux","permalink":"https://mengzelev.github.io/tags/linux/"}]},{"title":"算法导论学习笔记-摊还分析","slug":"clrs-17amortized","date":"2018-09-17T15:47:29.000Z","updated":"2018-09-20T15:58:45.393Z","comments":true,"path":"2018/09/17/clrs-17amortized/","link":"","permalink":"https://mengzelev.github.io/2018/09/17/clrs-17amortized/","excerpt":"","text":"聚合分析聚合分析指，证明对所有n，一个n个操作的序列的最坏情况下花费的总时间为T(n)。因此在最坏情况下，每个操作的平均代价，或摊还代价为T(n)/n。 摊还操作可以看作是不带概率计算的平均情况分析。因为概率不好计算。概率什么时候好计算过了 此摊还代价适用于每个操作，即使序列中有多种类型的操作也是如此。 算法导论上给出的示例为增加了MULTIPOP的栈操作和二进制计数器递增问题，简单概括一下二者的共同点： 需要分析复杂度的操作由连续的n个操作构成 每个单步操作的时间复杂度难以确定为与n有关的表达式，与当前状态密切相关 对每个单步操作取最坏情况得出的上界过于宽松，浪费时间 n个连续操作的总时间复杂度比较容易求得 大致感觉就是，使用摊还分析可以给这些操作一个清白，它们事实上没有那么慢。 核算法核算法就是对不同的操作赋予不同的信用，这个信用值可能会多于或少于实际消耗的代价。实际操作时采用多退少补的原则，保证总信用（支付的代价-实际的代价）始终非负即可。 一般用于解决不同操作间具有依赖关系的问题，例如聚合分析中提到的栈操作问题（出栈操作次数上界即为进栈操作次数）和二进制计数器递增问题（复位操作次数依赖于置位操作次数）。 势能分析势能分析看上去更加数(wu)学(li)一点，与核算法有点类似，不同之处势能分析为每一个状态都设置了一个对应的势能，即势能函数。虽然在操作过程中势能可能有升有降，但只要最终势能是增加的，就可以证明代价的上界。 选择势能函数应该是比较困难的。产生的摊还代价依赖于选择的势能函数。具体根据需要证明的上界来选择适度的势能函数，毕竟最优势能函数不是那么好找的。 动态表这个有丶玄学，是势能分析的综合应用，建议看书。 睡觉了，先更到这里，明天继续更","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"amortized analysis","slug":"amortized-analysis","permalink":"https://mengzelev.github.io/tags/amortized-analysis/"}]},{"title":"算法导论学习笔记-贪心算法","slug":"clrs-16greedy","date":"2018-09-17T02:53:05.000Z","updated":"2018-09-18T03:10:20.626Z","comments":true,"path":"2018/09/17/clrs-16greedy/","link":"","permalink":"https://mengzelev.github.io/2018/09/17/clrs-16greedy/","excerpt":"","text":"前一篇dp写得又乱又烂简直不想看。但愿自己能坚持下去吧。可是这依然改变不了搬运和截图多于实际内容的事实 基础理论贪心算法可以看做是动态规划的弱化版，处理某一类特殊的具有最优子结构的问题。 在每个贪心算法之下，几乎总有一个更繁琐的动态规划算法。 算法设计步骤 将最优化问题转化为这样的形式：对其作出一次选择后，只剩下一个子问题需要求解【子问题削减】 证明作出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的【安全性证明：替换法】 证明作出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构【确认最优子结构】 贪心选择性质贪心选择性质是指，当进行选择时，我们直接作出在当前问题中看来最优的选择，而不必考虑子问题的解【鼠目寸光】 贪心起来不太方便的时候，可以改进贪心选择，例如做一些预处理（活动选择问题中按照结束时间对活动进行排序） 最优子结构证明：子问题最优解 + 贪心选择 = 原问题最优解隐含地使用了数学归纳法 两种背包问题 0-1背包问题 分数背包问题 共同的条件是有一堆不同价值、重量的东西，用一个有一定承重量的背包去装，求装得的最大价值。不同在于，0-1背包问题中每个东西要么拿要么不拿，而分数背包问题中可以拿分数个东西。 前者无法用贪心算法求解，但后者可以，主要区别在于考虑0-1背包问题中是否将一个商品装入背包时，必须比较包含此商品的子问题的解和不包含此商品的子问题的解。简单来说就是，空闲空间的存在非常讨厌。只能使用动态规划来求解 活动选择问题问题描述 最优子结构通俗地说，对于某一个活动$a_k$，在它开始之前结束的所有活动，和在它结束之后开始的所有活动，这两个集合都应该取到最优解，可以使用剪切-粘贴发得到证明。因为如果子问题存在更优解，只需替换即可得到原问题的最优解，与原问题已经是最优解矛盾。 严谨化表述可以描述为： 其中，$S{ij}$表示在$ai$结束后开始、在$aj$开始前结束的活动的集合； c[i,j]表示集合$S{ij}$的最优解。 贪心选择 --------------------------------- 抛开各种分析直接来看这个问题，或者说和一个不知道动态规划的人谈起这个问题，很容易（大概）有这样一种想法： 对于每一次选择，都取不冲突的、最早结束的活动，感觉应该能够得到最优解。 事实上这个想法是对的，可以使用[替换法](#replace)进行证明。 这样每次做选择的时候就只剩下了一个子问题。 递归实现贪心算法可以自顶向下实现。 迭代实现 其中Q是一个单调队列。如果用最小堆实现，则该算法的时间复杂度为O(nlgn)。 时间复杂度如果直接使用dp，状态转移是O(n)的，子问题总数为O(n^2)，因此总时间复杂度为O(n^3)。 而如果使用贪心策略，压缩了解空间，限制了解的范围，从伪代码可以看出每个$a_{i}$都被检查且只被检查了一次，因此时间复杂度是O(n)的。 如果输入数据是无序的那么还需要一个O(nlgn)的排序时间，总体的时间复杂度为O(nlgn)。 赫夫曼编码问题描述解释起来有点麻烦，提供STFW快捷入口 百度百科-哈夫曼编码 wikipedia-Huffman coding 简单概括一下： 用变长编码压缩编码长度 Huffman树的叶结点与码字的编码一一对应 字符的二进制码字用从根结点到该字符对应的叶结点的简单路径表示 代价的定义： 伪代码 正确性证明这一块设计很多数学推导，难度比较大，此处指概括大致思路，配合算法导论原书食用风味更佳 主要是需要证明两个引理。 引理2旨在说明在单步选择下，贪心能得到是最优解。用的是替换法。从假想出一个抽象的最优解T，经过某些变换得到根据贪心选择构造出的解T’’，运用数学手段证明这两个解具有相等的代价。此处采用的是相减得到大于等于关系，与最优解天然具有的小于等于构造解相结合，证明等价。 引理3旨在证明该问题的最优子结构。采用了喜闻乐见的的剪切-粘贴法，也使用了一定的数学手段导出了矛盾。 引理2+引理3能证明上文的贪心算法可以生成一个最优前缀码。 课程要求暂时只需要看前三章","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"https://mengzelev.github.io/tags/greedy-algorithm/"}]},{"title":"面向OJ的Java学习","slug":"startjava","date":"2018-09-16T05:34:22.000Z","updated":"2018-09-17T15:49:24.661Z","comments":true,"path":"2018/09/16/startjava/","link":"","permalink":"https://mengzelev.github.io/2018/09/16/startjava/","excerpt":"","text":"各路ddl原因本文目前还处于混乱状态，十分丢人，谨慎阅读源代码为了防止查重，在OJ截止后会附上，也十分丢人 准备工作下载安装IDE本UI警察使用的是JetBrains的IntelliJ IDEA，可以直接从官网下载，用学生邮箱注册可以免费获得Utilmate版，下载后安装即可。安装时会安利一些插件，根据个人需要选择安装。 下载后打开IJ，选择新建一个工程，这时候会提醒你选择JDK，只需要点击Download JDK直接在官网上下载即可。（这一步忘记截图了） 下载并安装完JDK之后，可以先对编辑器进行设置(File -&gt; Settings 或 Ctrl + Alt +S)，选择自己喜欢的字体和配色风格。我使用的是默认的Darcula配色和Monaco字体。 大致效果如下（我jio得非常好看（请无视xjb乱写的第一个java程序 创建新项目由于暂时用于应付oj，以下步骤非常不严谨，不适合开发相关，只确保能正常完成oj作业，欢迎随时指出不严谨之处 点击File -&gt; New -&gt; Project，新建一个项目，其他东西可以暂时不用管，在新的项目中找到src文件夹，右键选择New -&gt; Java class，注意命名规范 之后会得到一个有模板的.java代码文件（球球无视一切xjb命名） 移动光标就可以开始敲代码啦！装了IdeaVim插件的童鞋别忘了用vim的相关快捷键啊~某捷列傻直接Ctrl-C+Ctrl-V半天没有反应 编译运行拷贝了一下poj上a + b问题的源代码，之后就要来尝试编译运行了。IJ并没有像dev一样的一键运行，但是如果做oj题的话还是比较方便的，直接右击左边项目列表的该.java文件选择Run &#39;Main.main()&#39;(快捷键Ctrl + Shift +F10)就可以在屏幕下方的运行窗口里得到运行结果并输入数据进行验证。 某捷列傻可是等了半天的黑框框的 开始编程基本工作都做好了以后可以开始学习一点基础的语法应付oj了，大佬们推荐了Thinking in Java这本书（可以下载到pdf），比较适合系统学习Java，但是萌捷列夫的ddl迫在眉睫，所以只能采用简易一点的菜鸟教程 Java的语法总体与C语言是比较相似的，而且默认本教程读者已有一定的C/C++编程基础，萌捷列夫在学的时候大致按照和C一样放心使用和和C不一样了两大类进行了整理，以供参考 时间原因暂时不能贴出比较简洁易懂的示例代码，可以参考上文的菜鸟教程中的代码，本文最后也会贴出本次OJ所有题的题解代码以供参考。 头文件写C程序的时候，第一件事肯定是#inlcude&lt;xxxx&gt;，在Java里也需要头文件，但稍有区别。 Java中的头文件分为package和import两类。package语句用于表示一个类定义在某个包中，包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。这个我们写oj暂时用不到我就先晾这儿了。 import语句的作用类似于C的inlcude，用来提供一个合理的路径，使编译器可以找到某个类。poj的a+b程序源码中有 import java.io.*; 就是用于让命令编译器载入java_installation/java/io路径下的所有类，从名称可以看出这些类与输入输出有关。特别地，IJ提供自动补全import语句的功能，萌捷列夫在手动赋值a+b源码的时候IJ自动将POJ上的import替换为了 import java.util.Scanner; 一样可以正常运行。 头文件命名要遵循的规范： 如果一个类定义在某个包中，那么package语句应该在源文件的首行 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明 各种声明写C的时候敲完所有头文件，差不多就该int main()了，（当然还有全局变量和函数声明），Java也有类似的主方法入口： public static void main(String []args) 所有Java程序都是从这个入口开始执行的。 Java里也有变量的概念，但声明不是从变量开始的，而是从类开始的，充分贯彻了OOP的思想。类声明类似于用C++进行OOP编程，有public和private之别，还有其他一些特殊的类，写oj暂时用不到。类中可以定义变量和方法。 类与对象类的声明遵循以下规范： 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java 同C++一样，类也可以添加不同的访问修饰词 public:表示公开的类和变量，既所有的类都可以引入使用的 protected：表示受保护的类，只有子孙类和本类可以引入使用 private：表示私人的，只有在本类中可以引入使用 啥都不加（默认）：表示同包中和本类中可以引入使用。 定义了类之后可以使用new关键字创建属于这个类的对象。对象是类的实例化，大致需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 变量Java中的变量有三种： 局部变量： 定义在方法、构造方法或者语句块之中，变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。例如循环变量i 成员变量： 定义在类中、方法体之外，表示类的某种属性，在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问，例如人的身高、体重数据 类变量：声明在类中、方法体之外，但必须声明为static类型，为属于该类的所有对象所共有，不会因为对象的个体差异而改变。例如Student类中可以定义一个类变量n来统计学生的总人数，不会因为是不同的学生而不同。 数据类型Java的内置数据类型基本同C，char,short,int,long,float,double,boolean都可以放心使用，默认值都是相应类型下的0。相比于C多出来一个byte，表示8位、有符号的，以二进制补码表示的整数。 Java还有一类引用数据类型变量，类似于C的指针，引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型，所有引用类型的默认值都是null。一个引用变量可以用来引用任何与之兼容的类型。e.g.Site site = new Site(&quot;Runoob&quot;) 方法构造方法：每个类都需要一个构造方法。如果没有显示定义，编译器会提供一个默认构造方法（这点同C）。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法 输入声明完乱七八糟一堆东西之后，一般会从输入入手。Java输入需要调用Scanner这个类，包含在“头文件”import java.util.Scanner中。 先要创建Scanner对象 Scanner cin = new Scanner(System.in) 读入整数，其中nextInt()是指输入中的下一个整数，类似的也可以有空白的next() int a = cin.nextInt(); Java命名规范首先，切记：Java是大小写敏感的 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写，例如myFirstJavaMethod 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java（如果文件名和类名不相同则会导致编译错误） Java所有的组成部分都需要名字，类名、变量名以及方法名都被称为标识符。标识符的命名规范与C/C++基本相同（不同之处已标出）： 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始 首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合 关键字不能用作标识符 标识符是大小写敏感的 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary 相关整理和C一样放心使用 注释语法 枚举语法enum 变量类型，如int,string,void等 和C不一样了 没有指针大快人心哈哈哈哈","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Java","slug":"Java","permalink":"https://mengzelev.github.io/tags/Java/"},{"name":"programming","slug":"programming","permalink":"https://mengzelev.github.io/tags/programming/"}]},{"title":"使用tmux变身炫酷程序猿(x","slug":"tmux","date":"2018-09-12T01:59:29.000Z","updated":"2018-09-15T09:46:34.113Z","comments":true,"path":"2018/09/12/tmux/","link":"","permalink":"https://mengzelev.github.io/2018/09/12/tmux/","excerpt":"","text":"以前看电影里面的程序猿都是屏幕上花花绿绿键盘噼里啪啦根本不用鼠标的觉得太炫酷了，学了cs以后以为希望破灭了，直到被pa讲义安利了tmux…… 本文只是一个备忘笔记，方便日后查阅 更新中未完待续 按键前缀默认是Ctrl-b，大部分话教程会修改成离得比较近的Ctrl-a 修改方法：打开tmux配置文件 $ vim ~/.tmux.conf 添加如下代码： unbind C-b set -g prefix C-a 分割窗口因为是针对pa才学的tmux，所以要用的操作都非常基本 从terminal进入tmux，直接在命令行里输入tmux即可 $ tmux 然后进行分屏 水平分屏: prefix + % 垂直分屏：prefix + &quot; 我一般都使用左1+右2的形式【暂时忘了截图下次贴】 关闭该窗口：prefix + &amp; 会询问是否确定关闭，按y即可 切换窗口：prefix +方向键 使用tmux操作时，先按住Ctrl再按前缀键，然后可以稍微停一下再按下一个功能键 以上操作目前做pa已经够用了，以后遇到新的问题再另寻解决方法并更新该文 他山之玉忙着赶作业来不及写完所以先贴篇别人整理的 tmux多窗口操作","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"linux","slug":"linux","permalink":"https://mengzelev.github.io/tags/linux/"},{"name":"tmux","slug":"tmux","permalink":"https://mengzelev.github.io/tags/tmux/"}]},{"title":"vim初探","slug":"vim","date":"2018-09-06T15:06:23.000Z","updated":"2018-10-01T14:59:18.004Z","comments":true,"path":"2018/09/06/vim/","link":"","permalink":"https://mengzelev.github.io/2018/09/06/vim/","excerpt":"","text":"网上类似的教程已经有很多了，只是在玩耍vimtutor过程中的一点笔记。 同时开markdownPad和vim输入的后果就是在精神分裂的边缘试探.jpg 然而关键还是多用，这些破整理并没有卵用。（不知道我能坚持用vim到什么时候 在学的过程中不断出现的提示： 光标移动方向键：j↓ k↓ h← l→ （两边左右，中间下上） 所以h这篇文l章里j突然出现一些hjkl也不奇怪了呢 光标向前移动n个单词:1w,2w,3w... 光标向前移动至第n个单词的末尾：1e,2e,3e... 移动至行首：0 移动至文末：G 移动至文章开始：gg Ctrl-G配合G使用风味更佳（跳转到某一行） 选中：v+光标移动 模式切换Normal mode: ESC 进入输入模式:i（要操作时记得按esc退出） 保存退出不保存并退出：:q! 保存并退出：:wq 另存为：:w [filename] 删除删除字符：x 删除单词：dw(光标需移动到单词的开头 删除至行末：d$ 删除至词末:dw 用count进行删除：d2w,d1e... 删除整行：dd，2dd,... 从此dd具有了全新的意思 用dd删除的行被放入了寄存器中，p可在上方恢复 撤销撤销最后一步操作:u 撤销整行所有的操作：U 恢复撤销：Ctrl+R 修改改写单个字符（rewrite）：r+(the right character) 改写多个字符：R+(right characters) 改写至词尾：ce（记得esc退出输入模式） 改写至行尾：c$ 整词替换： :s/old/new //替换第一个 :s/old/new/g //在光标所在单行内将&quot;old&quot;全部替换为&quot;new&quot; \\#,#old/new/g //在\\#标记出的行数范围内进行替换 :%s/old/new/g //在全文范围内进行替换 :%s/old/new/gc //在全文范围内查找并询问是否需要替换 插入插入某个文件的内容：:r+[filename] 插入某个命令行函数的返回值:e.g.:r !dir 在光标上方新建一行：O 在光标下方新建一行：o 从词末开始输入：a 从行末开始输入：A（Append） 复制：y(yank) yw可以复制一整个单词 粘贴：p(paste) 查找查找内容：/+（查找内容） 正向查找：n 反向查找：N 从文末开始查找：?+(查找内容) 返回查找前的地方：ctrl-o 是字母O不是数字0 括号匹配：% 忽略大小写：:set ic(ignore case) 关闭忽略大小写::set noic 查找内容高亮：:set hls/hlsearch 关闭高亮：:nohlsearch 部分查找：:set is/incsearch (incsearch) 分屏看到一篇不错的教程，就不复述了 vim分屏功能总结 暂时无法分组指令输入命令行指令::!+(命令行指令) 帮助：F1 or help 指令补全：Ctrl-D配合Tab","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"vim","slug":"vim","permalink":"https://mengzelev.github.io/tags/vim/"}]},{"title":"算法导论学习笔记-动态规划","slug":"clrs-15dp","date":"2018-08-31T08:37:42.000Z","updated":"2018-09-05T02:12:40.869Z","comments":true,"path":"2018/08/31/clrs-15dp/","link":"","permalink":"https://mengzelev.github.io/2018/08/31/clrs-15dp/","excerpt":"","text":"基本原理以下是大段算法导论原句搬运。 只有带下划线的句子才是自己总结的。 最优化问题 动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们成这样的解为问题的一个最优解，而不是最优解。 算法设计步骤 刻画一个最优解的结构特征 递归地定义最优解的值 计算最优解的值，通常采用自底向上的方法 利用计算出的信息构造一个最优解（有时不需要） 动态规划求解最优化问题应该具备的两个要素：最优子结构和子问题重叠。 简单来说就是，能根据原问题得到一个递推式（最优子结构），但是在这个递推式的计算过程中会出现大量重复计算的时候（子问题重叠），可以使用动态规划。 最优子结构性质 问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。 在发觉最优子结构性质的过程中，实际上遵循了如下的通用模式：1.证明问题最优解的第一个组成部分是做出一个选择；2.对于一个给定问题，在其可能的第一步选择中，你假定已经知道哪种选择才会得到最优解。3.给定可获得的最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；4.利用“剪切-粘贴”技术证明：作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解（反证法）：假设子问题存在更优解，将子结构从整体中删除替换为更优解，与最优假设矛盾。 保持子问题空间尽可能简单，只在必要时才扩展它。（e.g.矩阵链乘法问题必须允许子问题在“两端”都可变） 可以用子问题的总数和每个问题需要考察多少种选择这两个因素的乘积来粗略肥西动态规划算法的运行时间。 具有最优子结构的问题子问题之间是无关，同一个原问题的一个子问题的解不影响另一个子问题的解。e.g.无权最短路径vs无权最长路径 子问题重叠如果递归方法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。与之相对的，利用分治方法求解的问题通常在递归的每一步都生成全新的子问题。 重构最优解：用另一个数组来记录最优解 实现 自顶向下的备忘算法 自底向上的动态规划算法一般自底向上的动态规划算法会比较快（没有递归调用开销，表的维护开销也更小） 如果子问题空间中的某些子问题完全不必求解，备忘方法就会体现出优势 钢条切割问题问题描述某公司出售一段长度为i英寸的钢条的价格为$p_i(i=1,2,…,$单位为美元）。给定一段长度为n英寸的钢条和一个价格表$p_i(i=1,2,…,n)$，求切割钢条方案，使得销售收益$r_n$最大。 分析长度为n英寸的钢条共有$2^{n-1}$中不同的切割方案。 如果一个最优解将钢条切割为k段$(1\\le k\\le n$)，那么最优切割方案 n=i_1+i_2+...+i_k将钢条切割为长度分别为$i_1,i_2,…,i_k$的小段，得到最大收益 r_n=p_{i_1}+p_{i_2}+...+p_{i_k}对于$r_n\\ge 1$，我们可以用更短的钢条的最优切割收益来描述： r_n=max(p_n,r_1+r_{n-1},r_2+r_{n-2},...,r_{n-1}+r_1)更简单的，我们将钢条从左边切割下长度为$i$的一段，只对右边剩下的长度为$n-i$的一段继续进行切割（递归求解），对左边的一段则不再进行切割。可以得到r_n=max\\limits_{1\\le i\\le n}(p_i+r_{n-i})这样原问题只包含一个相关子问题的解而不是两个。 复杂度时间复杂度：$\\Theta(n^2)$ 子问题图 矩阵链乘法懒得写了。 最优子结构 对子问题的分析发现必须是子问题必须是两头可动的（i.e.一维数组是不够的） 伪代码为什么原书是分页的我还得手敲一遍不能忍 MATRIX-CHAIN-ORDER(p) //自底向上的动态规划实现 n=p.length-1 let m[1..n,1..n] and s[1..n-1,2..n] be new tables for i=1 to n m[i,i]=0 for l=2 to n for i=1 to n-l+1 j=i+l-1 m[i,j]=\\infty for k=i to j-1 q=m[i,k]+m[k+1,j]+p[i-1]*p[k]*p[j] if q&lt;m[i,j] m[i,j]=q s[i,j]=k return m and s 最长公共子序列（LCS）问题定义先略 最优子结构 伪代码 最优二叉搜索树和矩阵链乘法类似 也懒得抄了 一份毫无营养的学习笔记就完成了","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://mengzelev.github.io/tags/dynamic-programming/"}]},{"title":"汇编语言复习笔记（二）","slug":"asm2","date":"2018-08-30T08:37:42.000Z","updated":"2018-08-30T08:42:36.625Z","comments":true,"path":"2018/08/30/asm2/","link":"","permalink":"https://mengzelev.github.io/2018/08/30/asm2/","excerpt":"","text":"数据传送数据传送指令格式： mov S(源操作数), D(目标操作数) mov &nbsp;&nbsp; 一般传送指令 movs &nbsp;&nbsp; 符号扩展传送 movz &nbsp;&nbsp; 零扩展传送 push &nbsp;&nbsp; 压栈，等价于sub+mov pop &nbsp;&nbsp; 退栈，等价于mov+add 按源操作数的长度加上b,w,l后缀，分别表示1、2、4字节。(movz,movs需要双后缀) 见leal与movl的区别 指令后缀、操作数长度、目标寄存器宽度必须要一致！！ 操作数类型 立即数 Imm &nbsp;&nbsp; 整型常量，加$前缀，e.g.$233, $0x66FFCC 寄存器 Reg &nbsp;&nbsp; 加%前缀，e.g.%eax,%ebx,%esp 存储器 Mem &nbsp;&nbsp; 寻址操作 不能在一条指令里实现存储器到存储器的传送！！要实现存储器间的传送必须经过寄存器。 寄存器 所有寄存器都可以单独读取低16位 只有%eax,%ecx,%edx,%ebx可以读取低8位（x字辈） 地址运算指令格式: leal S,D S是复杂寻址地址形式的表达式，将表达式表示的值写入D，其中D一定是寄存器 用途： 直接计算地址的值 e.g.p=&amp;x 执行简单的算数运算 leal与mov操作的区别： leal不会对寻址表达式解引用 e.g. //R[%edx]=x movl 7(%edx,%edx,4),%eax //R[%eax]=M[5x+7] leal 7(%edx,%edx,4),%eax //R[%eax]=5x+7 算术和逻辑操作看表 ※使用时也需要根据操作数长度添加后缀 特殊操作imull &nbsp;&nbsp; 带符号乘法指令，只有一个操作数时，另一个乘数隐含在%eax中，乘积的高32位放入%edx,低32位存入%eax idivl &nbsp;&nbsp; 带符号除法指令，只有一个操作数时，%edx-%eax为被除数，操作数为除数，商存入%eax,余数存入%edx 还有无符号版本mull和divl cltd 符号扩展指令，将%eax中的数符号扩展至%edx成为64位,经常用于idivl的准备工作 关于imul 操作数个数 格式 操作 结果存放 1 imul src src*R[%eax]，完全乘法（自己取的名字） %edx-%eax 2 imul src dst src*dst,高位截断，只保留低位 dst 3 imul reg src imm R[reg]=src*imm，只保留低位 reg 具体还是看老师ppt截图吧（侵权删） 条件控制指令比较与测试 cmp和test指令实际上是用减法和按位与操作实现的。 注意两个操作数的先后顺序与实际是相反的 条件置位指令setXsetX指令根据相应的条件标志位将某一位置0或置1。 有符号数的大小关系用greater/less表示，无符号数的用above/below表示。 条件跳转指令jmpX基本同setX 间接跳转：跳转的目标是从寄存器或存储器中读取的，e.g.jmp *%eax表示跳转至R[%eax]存储的地址位置 跳转地址分为绝对地址和相对地址(PC-relative addressing)。 绝对地址即4个字节直接指定的目标地址。 PC-relative addressing程序计数器的值是跳转指令后的那条指令的地址，而非跳转指令本身的地址 实际跳转到的地址=下一条指令的地址+右边的操作数（小端补码表示） e.g. 804828f: 74 05 je XXXXXXX 8048291: e8 1e 00 00 00 call 80482b4 XXXXXXX=0x8048291+0x05=0x8048296 条件传送指令cmovX满足某个条件时执行mov操作 ※必须与cmp操作连用，比较的不是cmov指令的两个操作数而是cmp的两个操作数 条件分支语句的编译if-else语句通常按goto方式执行 一般翻译思路为: if (test-expr) then-statement else else-statement 会被翻译为 if(!test-expr) goto false then-statement goto done false:else-statement done: 可以参考下图中示例： 循环控制语句do-while循环一般循环语句都最终翻译成do-while的形式 do body-statement while(test-expr) 会被翻译为 loop: body-statement if(test-expr) goto loop; while循环while(test-expr) body-statement 会被翻译为 if(!test-expr) goto done; loop: body-statement if(test-expr) goto loop; done: for循环for(init-expr; test-expr; update-expr) body-statement 会被翻译为 init-expr; if(!test-expr) goto done; loop: body-statement update-expr if(test-expr) goto loop; done: switch语句跳跃表跳跃表是一个数组，其中每个下标i对应一个代码段的地址 好处：执行一个switch语句的时间和case的数量无关跳跃表一般被存放在内存的某个位置，可以调用gdb查看 一大波截图预警 作业二的教训 1.几个指令的名称对应功能要背熟 2.确定数据类型：确定长度+有无符号 3.别忘了指针也是一种数据类型 4.jmp指令的第二个操作数是小端补码表示 5.模拟汇编控制流就是要把代码拆分成简单语句（注意运算优先级） 6.分清andl和addl 7.补充C代码的时候就不要再写8x这样意义不明的东西了，是8*x啊老兄","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Assembly Language","slug":"Assembly-Language","permalink":"https://mengzelev.github.io/tags/Assembly-Language/"}]},{"title":"汇编语言复习笔记（一）","slug":"asm-notes","date":"2018-08-29T05:11:42.000Z","updated":"2018-08-30T03:32:00.252Z","comments":true,"path":"2018/08/29/asm-notes/","link":"","permalink":"https://mengzelev.github.io/2018/08/29/asm-notes/","excerpt":"","text":"前言本文为学校课程面向考试复习笔记，参考内容为老师的课堂讲义&amp;深入理解计算机系统，依据这两者做了一些个人的整理便于复习。然而浪了一个假期在退课的边缘试探 信息的表示数值的表示 原码：这个很直观的 反码：这个几乎不用的 补码：$D’=R^n-D$ / 按位取反加1； 移码：见浮点数 补码 相当于取模操作 着重区分基数的值(R)和补码位表示的实际的值(D) R与D的相对大小一致 $R=D+D_{w-1}\\cdot 2^w$ C语言中的整数 无符号数：在数后加U或u 同时有无符号数和带符号数，编译器将带符号数强制转换为无符号数 int的最大正值为2147483647，最大负值为-2147483648 比较时要特别注意是按什么规则进行的 数据的存放 小端：最低有效字节存放在最小地址 大端：最低有效字节存放在最大地址 浮点数编码表示分3个字段 符号s &nbsp; 0正1负 阶码E &nbsp; k位阶码字段exp 尾数M &nbsp; n位小数字段frac &nbsp; 表示的是a/2^n float &nbsp; k=8,n=23 double &nbsp; k=11,n=52 三种表示情况 1.规格化 &nbsp;&nbsp;阶码部分既不全0也不全1 采用偏置形式：E=e-Bias 其中，E为阶码实际的值，e为位模式下的无符号数，偏置Bias= $2^{k-1}-1$ float:127, double:1023 指数范围： float: -126~+127; double -1022~1023 尾数 M=f+1 &nbsp; 其中 0&lt;=f&lt;1; 1&lt;=M&lt;2 非规格化 &nbsp;&nbsp;阶码全0 阶码E=1-Bias 尾数M=f 存在意义：提供了0的表示方法，逐渐溢出 &nbsp; （否则[0,$2^{-n})范围内的数都无法表示） 特殊值 &nbsp;&nbsp;阶码全1 尾数全0：正负无穷大 尾数非全0： NaN 浮点数加减运算步骤：对阶→加减→规格化（→舍入） 对阶：小阶向大阶看齐，小阶尾数右移（带上隐含的1） 整数运算位运算没什么好说的。 移位运算 左移x&lt;&lt;k 丢弃最高k位，在右端补k个0 右移x&gt;&gt;k 丢弃最低k为，在右端补k个0/符号位 移位运算是向下取整 整数加减法发生在n位带标志加法器中 条件标志位计算t=a+b eflag 中文名称 有效条件 OF 溢出标志 a,b同号但t与a,b异号 SF 符号标志 t&lt;0 ZF 零标志 t==0 CF 进位标志 (unsigned)t&lt;(unsigned)a 比较大小相当于做减法 无符号数： CF==0 $\\Leftrightarrow$ a&gt;b 有符号数： OF==SF $\\Leftrightarrow$ a&gt;b 整数乘法乘数中有常数时：采用移位(左移)+加减法相结合的形式 整数除法默认朝0方向舍入：，即正数商取比自身小的最接近整数，负数商取比自身大的最接近整数 用移位代替除法时需要负数需要加上一个偏移量 除数为2的幂次时，采用右移运算，得到朝0方向舍入的结果 无符号数、有符号正整数： 移出的地位直接丢弃 有符号负整数： ：加偏移量 (2^k-1) ，然后再右移k位，低位截断 作业一的教训1.~按位取反 和 ！全部取反要区分清楚 2.非按位运算操作符非0的都视为true 3.浮点数的转化要好好看一下，把转化公式写好 4.移位是向下取整","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Assembly Language","slug":"Assembly-Language","permalink":"https://mengzelev.github.io/tags/Assembly-Language/"}]},{"title":"胡言乱语的大一总结","slug":"freshman","date":"2018-08-18T13:27:02.000Z","updated":"2018-08-18T15:46:17.255Z","comments":true,"path":"2018/08/18/freshman/","link":"","permalink":"https://mengzelev.github.io/2018/08/18/freshman/","excerpt":"","text":"&emsp;&emsp;生日兼七夕窝在家里无聊于是开了这样一篇文章写了整整两天，都是些碎碎念。本来并没有写这种东西的习惯的(:з」∠)但是既然开了个人blog总要写点什么的于是就写吧！试图掩盖写不出教程的事实将来过好几年来看可能会很有回忆的感觉。 学习篇刚进大学的时候，军训期间闲得蛋疼去考了计拔居然还被录取了，txp他老人家眼光真的没问题吗，于是就开始了贼船之旅。大一上第一个国庆长假就只能窝在家里写作业写了好久堪称心理阴影，大一上被问求这门神奇的课给吓尿了，动不动就为了赶作业修仙到两点。其实还是有在疯狂补小排球的 到了大一下觉得大一上还是很空闲的，起码不用搭面包板，也不用抄大物作业。大二上可能会觉得大一下很轻松吧，笑着活下去.jpg 大一上课表 大一下课表 随便说说几门课给我的感受。 微积分早有耳闻，学起来没有觉得很难，可能也是托了qlz的福，这样有主见有原则的老师我超级赞赏的，上课还会讲故事，最重要的是他给分高啊！ 本来和害怕数学的我渐渐也能感受到数学的美了吧，大概。 微电子，浪费生命的水课，课听了，作业做了，考试考了但是感觉毫无收获。 大物实验，水课，求求来个人告诉我实验报告怎样才能拿到优。 大物，不明觉厉，学学物理其实挺好玩的，但是ldx这本书为什么这么…【无fuck说.jpg】果然xmw这种老师还是早点辞退比较好 xw是真的很卖力啊但是为什么我还是听不懂，对不起他。虽然物理课每节都有在听但是经常忍不住水群导致错过了好多，下学期请务必全神贯注，不然电磁学要GG了。 思修， 军理， 马原， 水课三连，马原老师讲的哲学还有那么点意思，可惜全在写oj了没认真听。军理部分老师太sb了请立刻辞退 数电 嘛，还挺有意思的，搭面包板有点抓狂但是比比大班就有心里安慰了。还有wgs真的好帅啊！！！ 英语， 我喜欢，大一上的视听说拍视频很开心，虽然我只是个压榨组员的主催。大一下的配音和演讲超有意思的，演讲做了啊你妹相关的虽然很花时间但还是超开心的。Ruth的读写课天下第一好，我吹爆她！第一学期的时候就猜对了一个谜语而已她居然觉得我很厉害还送了我一个史迪仔期末还给了我满分，真的只是非洲人突然偷渡入欧而已…总之超级感谢的…第二学期结课的时候Ruth还哭了…能跟学生交心的老师是真的难得啊qwq 问求， 终于到了这门让我百感交集无fuck说的课。大一上:卧槽我在学什么；大一下：卧槽这题该怎么做。大一上作业不算难但是量炒鸡大，期末考试也莫名其妙。大一下，作业不多但是好多不会做的，其他课作业又比较多只能出卖灵魂与网络上的算法导论参考答案签订契约成为期末挂科烧酒（雾）。OJ…别提了…我只是题解的搬运工…期末mj查什么重啊…您出题出这么难不找题解还怎么做啊…把OJ当acm校队选拔吗… 汇编，一定要告诫学弟学妹，千万别听whj讲课，看csapp自学效率最高。whj讲课听不懂催眠效果还极好。实验部分装装Linux调调gdb还是挺好玩的，作业也还行，做下来对CPU的工作方式算是有了个全新的认识。【然而汇编笔记的文章还是没有产出来】拆炸弹是真的很有意思，每拆完一个phase都超有成就感，我应该是走火入魔了，连着3个晚上没睡好觉，闭眼就是寄存器，然后被自己炸醒。拆了三天也是够慢的，自卑.jpg.马上开学要考试了完全不想复习，在退课的边缘试探，，， 通识, 感觉这一年里还是太忙于专业课的学习了，通识课上下来并没有太大的收获，基本都是上课不听埋头写作业或者沉迷水群，期末论文之类的也是东拼西凑的学术垃圾。和进大学之前想的完全不一样唉…悦读经典emmmmm论理想与现实的差距，目前为止选的三本书没有哪一本是认真看过的，我什么时候能中《呐喊》、《彷徨》呢？即使中了，在专业课重压之下真的会好好看吗？ 课外学习的话，平时在校根本挤不出时间，总是带着不到ddl不写作业的惰性思维，这一点希望能改啊，可是既然有时间难道不应该优先看番吗。暑假龟速自学了git和markdown，其实都不是很有技术含量的东西，接下来的时间看看能不能学…你数学建模相关还一点没看呢吧…吧…美赛还没报名呢吧…咕掉了校内培训和选拔的严重后果…总之，加油吧。 也一度因为周围的人都去打acm迷茫过要不要去打，但是高中三年noip下来其实也不是太愉快，貌似不太喜欢这种过于理论、过于数学的题目，可能也是一种逃避现实的借口吧。嘛，既然决定了不打acm就一定要认真科研啊。不过现在学得太少真的不敢妄下定论自己喜欢什么。西瓜书，请。 还有既然决定要出国了，请认真背单词。 这个人真的不是精神分裂吗 社团活动篇说到大学必须得有社团活动哒！上大学之前幻想了很多的，进了大学为生活所迫也就活跃了几个地方。 吉协是早就想去的，结果实际上也就大一上去上了弹唱提高班。老师还挺好的吧，至少比家这里的好，还稍微入门了一下指弹。之后的活动完全没有参加了orz什么时候才能把曲子练到能上台表演的水平呢… 辩队还是有好好待的！虽然是被学姐忽悠进去的还只打了两场正式比赛全是输给冠军的一轮游。在辩队一年还从来没赢过一场，太惨了。每次比赛前讨论真的好花时间。一开始写一辩稿还好，后来开始被钦定打三辩稿子都是开场前30min写的了简直丢人。受了信管那边的学长学姐好多照顾（包括wrc)，除了辩论技巧还被拖着玩了狼人杀，所以，传火吧，骚年！ CAC音乐部每天水水群约约饭很开心der!还认识了一帮宅友！好多会玩乐器的、唱歌超好听的小哥哥小姐姐！还有豹跳如雷的海豹们两个月四对的传说！还有每次交作业被33处刑…去过大活楼梯间约歌（一次），线上歌会（两次），107（等末子姐姐拍照一次），完美错过所有线下约k。也算是遗憾比较大的一个地方，当初大一上觉得自己作业太多了没去Monge，乐队的锅也没接。现在Monge都凉了，大二上更不可能有空了。仔细想想大一上其实能好好安排时间的话完全是有空的，但是刚进大学谁能想到呢？还是太求稳了缺少逼自己一把的勇气吧。为才能不足而自卑.jpg。接了vocal团的锅希望表达一点愧疚之意吧。你们的(副)团长是全团最不会唱歌的人。 流跡是在你群水群聊骨头社意外被33拉进去的。之前完全没想过还有这么硬核的探讨宅话题的地方。一开始什么都看不懂（现在依然是），但是以此为契机了解了不少其实也不多啊你妹制作相关的知识。后来进来的玄枝爷爷讲了好多叙事学的东西，很厉害的样子但是完全没听懂自卑.jpg。自从能在流跡吹水新番之后感觉自己的追番越来越勤快了，经各位的安利看番面也越来越广了。和各位的约饭也非常愉快。英语pre做了动画制作流程相关的内容以及现在补《白箱》都和流跡脱不了干系，想快点变得pro能和各位聊起来啊qwq 排队是恶补了小排球之后才加的，虽然没有小排球里那么刺激也没有那么多可爱的男孩子但是打排球真的好开心！在场边加油很晒应该没晒黑多少吧(bushi)学姐们都好厉害！一路打进了院系杯四强！技术不足还不足以成为战力下个学期要好好加油了！ 除此之外开学乱加的几个早就为作业所迫咕掉了。比如校会学创啊，信管乒队什么的。（你真的会打乒乓吗）大二上也不敢对社团活动有所奢望了，好好在辩队带带小孩、vocal团的工作做做好，流跡快点把制作流程产出，我就满足了。你看又开始求稳没有拼劲了 生活篇大学生活的第一年吗…总体还算平稳的吧。 宿舍不是太愉快。烦心事也就不多提了，忘掉最好。 一年来基本都靠食堂过日子，叫外卖的次数屈指可数。大一上基本没出过几次校门，大一下逐渐开始放浪形骸。 寒假鼓起勇气买了人生第一套jk制服，月野家的奶油黄基础款冬服，到快入夏的时候才到的，也就穿了一次。之后入了优马家的绀金和红酒雪梨，燕子家的白五本，从此走上攒钱买衣服的不归路。优马大小姐的定金已经下了，最近出了那么多问题…等浅色的出货爱咋滴咋地吧。代码定金也下了，坐等出货，我也想穿着代码敲代码！ es军训的时候还在肝rock，开学后尝到了生活的艰辛，尤其是在做人情肝了一发节分守门两小时作业一笔未动修仙勉强做完后，从此es脱坑。现在极其想把手头的谷子都卖掉，忘记我这个出坑的人渣吧。fgo军训无聊稍微玩了一下，总之是不想过靠肝和欧生活的日子了，这月就不登了。 大一下开始学车，暑假的时候留校一个多礼拜把科三给考了，过得超惊险。大二上要在上课和作业的夹缝中学科二了。 补番篇就不一一列举了这一年里补/追过的番了，类似于推荐的形式挑几部印象深刻的写吧。 小排球 强推！吹爆！运动番天花板！剧情作画配乐都堪称一流！看到停不下来！一般深夜补番的我多次因为小排球亢奋到睡不着。好久没看这么从头正到尾的番了，既有很现实的设定（及川大王和影山）也有理想的处理（日向和乌野的大家）。不会气活牛顿的科学运动番，唯一不现实的地方是现实中的小男孩哪有这么可爱。看完甚至开始打排球的我不是一个人。心情不好的时候看看小排球就能马上开心起来。有生之年能遇到这样的番真是太好了。 三月的狮子 对上电波的慢节奏番，吹爆羽海野老师和新房！！零酱超可爱！！（摸摸）很喜欢这种有关人生与成长的题材，零酱和三姐妹经历的困难特殊而普遍，仿佛能看到自己的过去。身世悲惨的他们也时常享有寻常的幸福，这种强烈对比大概就是三狮的动人之处。岛田大师兄、小胖、老师等配角刻画得也很好。虽然将棋部分的内容完全看不懂但也不妨碍其成为一部佳作。 超自然九人组 志仓千代丸的作品，剧情，尤其是开头和中间展开很精彩，节奏飞快，收尾略显仓促，不少坑挖了没填，听说游戏表现得反而没有动画好有点可惜。佐仓这回治好了我的巨乳控！ 宅男腐女恋爱难 太甜了！一部刷新我恋爱观的番！我萌捷列夫就是饿死，死外边，也不会看狗粮番的——真香！ 其他看过的番bangumi上都有记录了就不作赘述了。顺便贴上我的bangumi。 恋爱篇您是不是一上来就通过目录索引跳这儿来了？哈哈！对不起！毛都没有！ …… 没有对象但还是想说说恋爱观的，毕竟之前也没有认真思考过这个问题，就大一上拒了俩然后被吓到了发表了一堆独身主义宣言现在想想全tm是黑历史啊好想删说说。其实也没有那么抗拒了啦首先你得...只是自己不是那种想随便玩玩的人，所以想尽可能抱着认真谨慎的心态来对待这么重要的事情首先你得...不过话说回来还是作业太多了，客观上不想再多加一件需要操心的事情了首先你得...没有空间里那些对象怪那么迫切，还是很享受单身的自由生活的，只要管好自己就行了，想喜欢谁就喜欢谁做个dd不好吗？也就是出去玩找不到小伙伴的时候会稍微有点寂寞（）。各有各的生活方式吧。总之，这么看缘分的事情还是随缘吧… 嗯？您问有没有喜欢的人了？这篇文章没加密我当然不会说啦！(doge)","categories":[{"name":"Diary","slug":"Diary","permalink":"https://mengzelev.github.io/categories/Diary/"}],"tags":[{"name":"freshman","slug":"freshman","permalink":"https://mengzelev.github.io/tags/freshman/"},{"name":"college life","slug":"college-life","permalink":"https://mengzelev.github.io/tags/college-life/"}]},{"title":"Markdown test","slug":"test-md","date":"2018-08-12T13:27:02.000Z","updated":"2018-08-12T13:35:34.586Z","comments":true,"path":"2018/08/12/test-md/","link":"","permalink":"https://mengzelev.github.io/2018/08/12/test-md/","excerpt":"","text":"这是标题君这是副标题君我知道这篇文章看起来很沙雕，因为作者就是一个沙雕 列表非常有趣 这是第一项 这是第二项 这是第三项 有时候会有需要强调的内容。 插入代码是一件非常爽的事情： printf(&quot;%s&quot;,&quot;Hello world!\\n&quot;); 突然发现自己不会用printf真是太丢人了。 有时候需要插入链接，这里贴一个百度。 有时候又需要插入图片 看张血小板冷静一下吧（图源网络） 图片的尺寸可以用命令进行修改 暂时先写这么多吧，敬请关注后面几期，计划中将会有 汇编课程相关学习笔记 日本动画制作流程及《白箱》观后感整理 大一回顾与总结 但愿到时候不要鸽（小声）评论功能等我明天再来开不要问我这里为什么是引用格式，看不出来我只是在试试吗","categories":[{"name":"Diary","slug":"Diary","permalink":"https://mengzelev.github.io/categories/Diary/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://mengzelev.github.io/tags/markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-28T06:23:10.175Z","updated":"2017-10-28T00:39:58.000Z","comments":true,"path":"2018/07/28/hello-world/","link":"","permalink":"https://mengzelev.github.io/2018/07/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}