{"meta":{"title":"Mengzelev's blog","subtitle":null,"description":"nothing to write","author":"Mengzelev","url":"https://mengzelev.github.io"},"pages":[{"title":"自我介绍测试","date":"2018-07-29T16:00:00.000Z","updated":"2018-07-30T05:00:44.032Z","comments":true,"path":"about/index.html","permalink":"https://mengzelev.github.io/about/index.html","excerpt":"","text":"这是一段自我介绍"}],"posts":[{"title":"关于“过程调用”的讨论","slug":"ics-process-calling","date":"2018-09-27T01:59:13.000Z","updated":"2018-09-27T03:30:46.356Z","comments":true,"path":"2018/09/27/ics-process-calling/","link":"","permalink":"https://mengzelev.github.io/2018/09/27/ics-process-calling/","excerpt":"","text":"实验一代码#include &lt;stdio.h&gt; int main(int argc, char* argv[]){ int a = 10; double *p = (double*)&amp;a; printf(&quot;%f\\n&quot;, *p); printf(&quot;%f\\n&quot;, ((double)(a))); return 0; } windows10环境：dev-cpp/TDM-GCC 4.9.2 64bit Release Debian-64bit Ubuntu-32bit 实验二代码#include&lt;stdio.h&gt; int main(){ double a = 10; printf(&quot;a = %d\\n&quot;, a); return 0; } windows10 Debian Ubuntu-32bit","categories":[],"tags":[{"name":"ics","slug":"ics","permalink":"https://mengzelev.github.io/tags/ics/"},{"name":"process calling","slug":"process-calling","permalink":"https://mengzelev.github.io/tags/process-calling/"}]},{"title":"图的基本概念","slug":"graph-intro","date":"2018-09-24T14:44:03.000Z","updated":"2018-09-27T03:31:16.966Z","comments":true,"path":"2018/09/24/graph-intro/","link":"","permalink":"https://mengzelev.github.io/2018/09/24/graph-intro/","excerpt":"","text":"图(Graph):由顶点集V和边集E组成，表示为G=(V,E)顶点集V(vertice):有限非空点集边集E(Edge):顶点集V的二元子集组成的集合图的相等：G和H等价当且仅当V(G)=V(H)且E(G)=E(H) 坑先挖这儿了！有时间再填&lt;\\u&gt;","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"graph theory","slug":"graph-theory","permalink":"https://mengzelev.github.io/tags/graph-theory/"},{"name":"problem solving","slug":"problem-solving","permalink":"https://mengzelev.github.io/tags/problem-solving/"}]},{"title":"正则表达式学习笔记","slug":"regex","date":"2018-09-21T14:04:40.000Z","updated":"2018-09-21T14:38:21.936Z","comments":true,"path":"2018/09/21/regex/","link":"","permalink":"https://mengzelev.github.io/2018/09/21/regex/","excerpt":"","text":"废话不多说，贴4张截图就跑路（。 有空还是会回来写的，容我先把ddl肝完（瘫）。 PA讲义中的Linux-C教程","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"},{"name":"regular expressions","slug":"regular-expressions","permalink":"https://mengzelev.github.io/tags/regular-expressions/"},{"name":"linux","slug":"linux","permalink":"https://mengzelev.github.io/tags/linux/"}]},{"title":"算法导论学习笔记-摊还分析","slug":"clrs-17amortized","date":"2018-09-17T15:47:29.000Z","updated":"2018-09-20T15:58:45.393Z","comments":true,"path":"2018/09/17/clrs-17amortized/","link":"","permalink":"https://mengzelev.github.io/2018/09/17/clrs-17amortized/","excerpt":"","text":"聚合分析聚合分析指，证明对所有n，一个n个操作的序列的最坏情况下花费的总时间为T(n)。因此在最坏情况下，每个操作的平均代价，或摊还代价为T(n)/n。 摊还操作可以看作是不带概率计算的平均情况分析。因为概率不好计算。概率什么时候好计算过了 此摊还代价适用于每个操作，即使序列中有多种类型的操作也是如此。 算法导论上给出的示例为增加了MULTIPOP的栈操作和二进制计数器递增问题，简单概括一下二者的共同点： 需要分析复杂度的操作由连续的n个操作构成 每个单步操作的时间复杂度难以确定为与n有关的表达式，与当前状态密切相关 对每个单步操作取最坏情况得出的上界过于宽松，浪费时间 n个连续操作的总时间复杂度比较容易求得 大致感觉就是，使用摊还分析可以给这些操作一个清白，它们事实上没有那么慢。 核算法核算法就是对不同的操作赋予不同的信用，这个信用值可能会多于或少于实际消耗的代价。实际操作时采用多退少补的原则，保证总信用（支付的代价-实际的代价）始终非负即可。 一般用于解决不同操作间具有依赖关系的问题，例如聚合分析中提到的栈操作问题（出栈操作次数上界即为进栈操作次数）和二进制计数器递增问题（复位操作次数依赖于置位操作次数）。 势能分析势能分析看上去更加数(wu)学(li)一点，与核算法有点类似，不同之处势能分析为每一个状态都设置了一个对应的势能，即势能函数。虽然在操作过程中势能可能有升有降，但只要最终势能是增加的，就可以证明代价的上界。 选择势能函数应该是比较困难的。产生的摊还代价依赖于选择的势能函数。具体根据需要证明的上界来选择适度的势能函数，毕竟最优势能函数不是那么好找的。 动态表这个有丶玄学，是势能分析的综合应用，建议看书。 睡觉了，先更到这里，明天继续更","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"amortized analysis","slug":"amortized-analysis","permalink":"https://mengzelev.github.io/tags/amortized-analysis/"}]},{"title":"算法导论学习笔记-贪心算法","slug":"clrs-16greedy","date":"2018-09-17T02:53:05.000Z","updated":"2018-09-18T03:10:20.626Z","comments":true,"path":"2018/09/17/clrs-16greedy/","link":"","permalink":"https://mengzelev.github.io/2018/09/17/clrs-16greedy/","excerpt":"","text":"前一篇dp写得又乱又烂简直不想看。但愿自己能坚持下去吧。可是这依然改变不了搬运和截图多于实际内容的事实 基础理论贪心算法可以看做是动态规划的弱化版，处理某一类特殊的具有最优子结构的问题。 在每个贪心算法之下，几乎总有一个更繁琐的动态规划算法。 算法设计步骤 将最优化问题转化为这样的形式：对其作出一次选择后，只剩下一个子问题需要求解【子问题削减】 证明作出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的【安全性证明：替换法】 证明作出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构【确认最优子结构】 贪心选择性质贪心选择性质是指，当进行选择时，我们直接作出在当前问题中看来最优的选择，而不必考虑子问题的解【鼠目寸光】 贪心起来不太方便的时候，可以改进贪心选择，例如做一些预处理（活动选择问题中按照结束时间对活动进行排序） 最优子结构证明：子问题最优解 + 贪心选择 = 原问题最优解隐含地使用了数学归纳法 两种背包问题 0-1背包问题 分数背包问题 共同的条件是有一堆不同价值、重量的东西，用一个有一定承重量的背包去装，求装得的最大价值。不同在于，0-1背包问题中每个东西要么拿要么不拿，而分数背包问题中可以拿分数个东西。 前者无法用贪心算法求解，但后者可以，主要区别在于考虑0-1背包问题中是否将一个商品装入背包时，必须比较包含此商品的子问题的解和不包含此商品的子问题的解。简单来说就是，空闲空间的存在非常讨厌。只能使用动态规划来求解 活动选择问题问题描述 最优子结构通俗地说，对于某一个活动$a_k$，在它开始之前结束的所有活动，和在它结束之后开始的所有活动，这两个集合都应该取到最优解，可以使用剪切-粘贴发得到证明。因为如果子问题存在更优解，只需替换即可得到原问题的最优解，与原问题已经是最优解矛盾。 严谨化表述可以描述为： 其中，$S{ij}$表示在$ai$结束后开始、在$aj$开始前结束的活动的集合；c[i,j]表示集合$S{ij}$的最优解。贪心选择———————————抛开各种分析直接来看这个问题，或者说和一个不知道动态规划的人谈起这个问题，很容易（大概）有这样一种想法：对于每一次选择，都取不冲突的、最早结束的活动，感觉应该能够得到最优解。事实上这个想法是对的，可以使用替换法进行证明。 这样每次做选择的时候就只剩下了一个子问题。 递归实现贪心算法可以自顶向下实现。 迭代实现 其中Q是一个单调队列。如果用最小堆实现，则该算法的时间复杂度为O(nlgn)。 时间复杂度如果直接使用dp，状态转移是O(n)的，子问题总数为O(n^2)，因此总时间复杂度为O(n^3)。 而如果使用贪心策略，压缩了解空间，限制了解的范围，从伪代码可以看出每个$a_{i}$都被检查且只被检查了一次，因此时间复杂度是O(n)的。 如果输入数据是无序的那么还需要一个O(nlgn)的排序时间，总体的时间复杂度为O(nlgn)。 赫夫曼编码问题描述解释起来有点麻烦，提供STFW快捷入口 百度百科-哈夫曼编码 wikipedia-Huffman coding 简单概括一下： 用变长编码压缩编码长度 Huffman树的叶结点与码字的编码一一对应 字符的二进制码字用从根结点到该字符对应的叶结点的简单路径表示 代价的定义： 伪代码 正确性证明这一块设计很多数学推导，难度比较大，此处指概括大致思路，配合算法导论原书食用风味更佳 主要是需要证明两个引理。 引理2旨在说明在单步选择下，贪心能得到是最优解。用的是替换法。从假想出一个抽象的最优解T，经过某些变换得到根据贪心选择构造出的解T’’，运用数学手段证明这两个解具有相等的代价。此处采用的是相减得到大于等于关系，与最优解天然具有的小于等于构造解相结合，证明等价。 引理3旨在证明该问题的最优子结构。采用了喜闻乐见的的剪切-粘贴法，也使用了一定的数学手段导出了矛盾。 引理2+引理3能证明上文的贪心算法可以生成一个最优前缀码。 课程要求暂时只需要看前三章","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"https://mengzelev.github.io/tags/greedy-algorithm/"}]},{"title":"面向OJ的Java学习","slug":"startjava","date":"2018-09-16T05:34:22.000Z","updated":"2018-09-17T15:49:24.661Z","comments":true,"path":"2018/09/16/startjava/","link":"","permalink":"https://mengzelev.github.io/2018/09/16/startjava/","excerpt":"","text":"各路ddl原因本文目前还处于混乱状态，十分丢人，谨慎阅读源代码为了防止查重，在OJ截止后会附上，也十分丢人 准备工作下载安装IDE本UI警察使用的是JetBrains的IntelliJ IDEA，可以直接从官网下载，用学生邮箱注册可以免费获得Utilmate版，下载后安装即可。安装时会安利一些插件，根据个人需要选择安装。 下载后打开IJ，选择新建一个工程，这时候会提醒你选择JDK，只需要点击Download JDK直接在官网上下载即可。（这一步忘记截图了） 下载并安装完JDK之后，可以先对编辑器进行设置(File -&gt; Settings 或 Ctrl + Alt +S)，选择自己喜欢的字体和配色风格。我使用的是默认的Darcula配色和Monaco字体。 &lt;img src = “startjava/font.png”, height=300&gt; 大致效果如下（我jio得非常好看（请无视xjb乱写的第一个java程序 &lt;img src = “startjava/a+b.png”, height=300&gt; 创建新项目由于暂时用于应付oj，以下步骤非常不严谨，不适合开发相关，只确保能正常完成oj作业，欢迎随时指出不严谨之处 点击File -&gt; New -&gt; Project，新建一个项目，其他东西可以暂时不用管，在新的项目中找到src文件夹，右键选择New -&gt; Java class，注意命名规范 之后会得到一个有模板的.java代码文件（球球无视一切xjb命名） &lt;img src = “startjava/newclass.png”, height=300&gt; 移动光标就可以开始敲代码啦！装了IdeaVim插件的童鞋别忘了用vim的相关快捷键啊~某捷列傻直接Ctrl-C+Ctrl-V半天没有反应 编译运行拷贝了一下poj上a + b问题的源代码，之后就要来尝试编译运行了。IJ并没有像dev一样的一键运行，但是如果做oj题的话还是比较方便的，直接右击左边项目列表的该.java文件选择Run &#39;Main.main()&#39;(快捷键Ctrl + Shift +F10)就可以在屏幕下方的运行窗口里得到运行结果并输入数据进行验证。 &lt;img src = “startjava/runa+b.png”, height=130&gt; 某捷列傻可是等了半天的黑框框的 开始编程基本工作都做好了以后可以开始学习一点基础的语法应付oj了，大佬们推荐了Thinking in Java这本书（可以下载到pdf），比较适合系统学习Java，但是萌捷列夫的ddl迫在眉睫，所以只能采用简易一点的菜鸟教程 Java的语法总体与C语言是比较相似的，而且默认本教程读者已有一定的C/C++编程基础，萌捷列夫在学的时候大致按照和C一样放心使用和和C不一样了两大类进行了整理，以供参考 时间原因暂时不能贴出比较简洁易懂的示例代码，可以参考上文的菜鸟教程中的代码，本文最后也会贴出本次OJ所有题的题解代码以供参考。 头文件写C程序的时候，第一件事肯定是#inlcude&lt;xxxx&gt;，在Java里也需要头文件，但稍有区别。 Java中的头文件分为package和import两类。package语句用于表示一个类定义在某个包中，包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。这个我们写oj暂时用不到我就先晾这儿了。 import语句的作用类似于C的inlcude，用来提供一个合理的路径，使编译器可以找到某个类。poj的a+b程序源码中有 import java.io.*; 就是用于让命令编译器载入java_installation/java/io路径下的所有类，从名称可以看出这些类与输入输出有关。特别地，IJ提供自动补全import语句的功能，萌捷列夫在手动赋值a+b源码的时候IJ自动将POJ上的import替换为了 import java.util.Scanner; 一样可以正常运行。 头文件命名要遵循的规范： 如果一个类定义在某个包中，那么package语句应该在源文件的首行 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明 各种声明写C的时候敲完所有头文件，差不多就该int main()了，（当然还有全局变量和函数声明），Java也有类似的主方法入口： public static void main(String []args) 所有Java程序都是从这个入口开始执行的。 Java里也有变量的概念，但声明不是从变量开始的，而是从类开始的，充分贯彻了OOP的思想。类声明类似于用C++进行OOP编程，有public和private之别，还有其他一些特殊的类，写oj暂时用不到。类中可以定义变量和方法。 类与对象类的声明遵循以下规范： 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java 同C++一样，类也可以添加不同的访问修饰词 public:表示公开的类和变量，既所有的类都可以引入使用的 protected：表示受保护的类，只有子孙类和本类可以引入使用 private：表示私人的，只有在本类中可以引入使用 啥都不加（默认）：表示同包中和本类中可以引入使用。 定义了类之后可以使用new关键字创建属于这个类的对象。对象是类的实例化，大致需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 变量Java中的变量有三种： 局部变量： 定义在方法、构造方法或者语句块之中，变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。例如循环变量i 成员变量： 定义在类中、方法体之外，表示类的某种属性，在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问，例如人的身高、体重数据 类变量：声明在类中、方法体之外，但必须声明为static类型，为属于该类的所有对象所共有，不会因为对象的个体差异而改变。例如Student类中可以定义一个类变量n来统计学生的总人数，不会因为是不同的学生而不同。 数据类型Java的内置数据类型基本同C，char,short,int,long,float,double,boolean都可以放心使用，默认值都是相应类型下的0。相比于C多出来一个byte，表示8位、有符号的，以二进制补码表示的整数。 Java还有一类引用数据类型变量，类似于C的指针，引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型，所有引用类型的默认值都是null。一个引用变量可以用来引用任何与之兼容的类型。e.g.Site site = new Site(&quot;Runoob&quot;) 方法构造方法：每个类都需要一个构造方法。如果没有显示定义，编译器会提供一个默认构造方法（这点同C）。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法 输入声明完乱七八糟一堆东西之后，一般会从输入入手。Java输入需要调用Scanner这个类，包含在“头文件”import java.util.Scanner中。 先要创建Scanner对象 Scanner cin = new Scanner(System.in) 读入整数，其中nextInt()是指输入中的下一个整数，类似的也可以有空白的next() int a = cin.nextInt(); Java命名规范首先，切记：Java是大小写敏感的 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写，例如myFirstJavaMethod 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java（如果文件名和类名不相同则会导致编译错误） Java所有的组成部分都需要名字，类名、变量名以及方法名都被称为标识符。标识符的命名规范与C/C++基本相同（不同之处已标出）： 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始 首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合 关键字不能用作标识符 标识符是大小写敏感的 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary 相关整理和C一样放心使用 注释语法 枚举语法enum 变量类型，如int,string,void等 和C不一样了 没有指针大快人心哈哈哈哈","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Java","slug":"Java","permalink":"https://mengzelev.github.io/tags/Java/"},{"name":"programming","slug":"programming","permalink":"https://mengzelev.github.io/tags/programming/"}]},{"title":"做pa的时候可能会用到的操作","slug":"pa-inspirations","date":"2018-09-12T11:39:56.000Z","updated":"2018-09-15T10:12:52.850Z","comments":true,"path":"2018/09/12/pa-inspirations/","link":"","permalink":"https://mengzelev.github.io/2018/09/12/pa-inspirations/","excerpt":"","text":"当做笔记随便写写的，希望能帮到一些人吧。毕竟作为一名优秀的bug maker，别人遇到的问题我基本都能遇到的。 vim和tmux另外写了教程： vim初探 使用tmux变身炫酷程序猿(x 持续更新中 语言规范 这名字很中二…但其实就是个人写文章的时候一点习惯用的表示，和别人的可能不一样，很可能非常不标准，注意区分就好 []方括号表示需要自定义的内容，括起来的只是你应该输入的东西的名字 在整个目录下查找代码 在某个文件里看到某个函数或者宏或者变量的定义的时候经常会好奇在哪里、怎么使用过，除了用/+(搜索内容)靠vim的功能在文件内搜索外，还可以 $ grep &quot;搜索内容&quot; -r &lt;目录&gt; e.g. $ grep &quot;CPU_state&quot; -r . 其中-r表示递归搜索，可以搜索整个目录下所有的文件 一键跳转定义处 创建接口的时候经常需要查看某些函数、宏、结构体的定义，于是被某位nb的学长安利了ctags神器，可以一键跳转至定义处并一键调回，先贴上自己查到的教程 首先需要安装ctags，一般来说直接apt就好了，但是莫名不行，可能是镜像源的问题 $ sudo apt install ctags 于是我选择了从ctags官网手动下载ctags-5.8.tar.gz 如果是在host里下载的，下载后通过自己的共享方式扔到虚拟机里面，进行解压缩 $ cd [压缩包所在目录] $ tar jxvf [文件名].tar.bz 解压后手动安装 $ cd ctags-5.8 $ ./configure $ make $ make install 安装完成后测试一下是否安装成功 $ whereis ctags 你应该能看到让你觉得成功的提示信息。 安装成功后，为源码生成tags文件，在需要使用ctags的目录下(所有子目录都可以享受到)运行 $ ctags -R 为了使得字段补全有效，在生成tags时需要一些额外的参数，推荐的c语言（c处可以替换成其他语言）参数主要是： $ ctags -R --c-kinds=+px --fields=+iaS --extra=+q 其中，fileds 用于指定每条标记的扩展字段域，extra 选项用于增加额外的条目，f表示每个文件增加一个条目，q为每个类增加一个条目 之后配置vim，就不用每次都手动设置 $ vim ~/.vimrc 在.vimrc 中加入如下内容 set tags=[path]/tags set tags=./tags,tags;$HOME 第二行我暂时也不知道是干什么的，但是不加上去好像用不起来（小声 然后用vim编辑你需要的代码文件，当光标落到你想查询定义的函数上时使用Ctrl + ]跳转到定义处（其实明明是两键跳转对不对），然后Ctrl + o或者Ctrl + t返回跳转前的位置。 参考教程原地址","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"},{"name":"Linux","slug":"Linux","permalink":"https://mengzelev.github.io/tags/Linux/"}]},{"title":"使用tmux变身炫酷程序猿(x","slug":"tmux","date":"2018-09-12T01:59:29.000Z","updated":"2018-09-15T09:46:34.113Z","comments":true,"path":"2018/09/12/tmux/","link":"","permalink":"https://mengzelev.github.io/2018/09/12/tmux/","excerpt":"","text":"以前看电影里面的程序猿都是屏幕上花花绿绿键盘噼里啪啦根本不用鼠标的觉得太炫酷了，学了cs以后以为希望破灭了，直到被pa讲义安利了tmux…… 本文只是一个备忘笔记，方便日后查阅 更新中未完待续 按键前缀默认是Ctrl-b，大部分话教程会修改成离得比较近的Ctrl-a 修改方法：打开tmux配置文件 $ vim ~/.tmux.conf 添加如下代码： unbind C-b set -g prefix C-a 分割窗口因为是针对pa才学的tmux，所以要用的操作都非常基本 从terminal进入tmux，直接在命令行里输入tmux即可 $ tmux 然后进行分屏 水平分屏: prefix + % 垂直分屏：prefix + &quot; 我一般都使用左1+右2的形式【暂时忘了截图下次贴】 关闭该窗口：prefix + &amp; 会询问是否确定关闭，按y即可 切换窗口：prefix +方向键 使用tmux操作时，先按住Ctrl再按前缀键，然后可以稍微停一下再按下一个功能键 以上操作目前做pa已经够用了，以后遇到新的问题再另寻解决方法并更新该文 他山之玉忙着赶作业来不及写完所以先贴篇别人整理的 tmux多窗口操作","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"linux","slug":"linux","permalink":"https://mengzelev.github.io/tags/linux/"},{"name":"tmux","slug":"tmux","permalink":"https://mengzelev.github.io/tags/tmux/"}]},{"title":"vim初探","slug":"vim","date":"2018-09-06T15:06:23.000Z","updated":"2018-09-12T12:08:57.915Z","comments":true,"path":"2018/09/06/vim/","link":"","permalink":"https://mengzelev.github.io/2018/09/06/vim/","excerpt":"","text":"网上类似的教程已经有很多了，只是在玩耍vimtutor过程中的一点笔记。 同时开markdownPad和vim输入的后果就是在精神分裂的边缘试探.jpg 然而关键还是多用，这些破整理并没有卵用。（不知道我能坚持用vim到什么时候 在学的过程中不断出现的提示： 光标移动方向键：j↓ k↓ h← l→ （两边左右，中间下上） 所以h这篇文l章里j突然出现一些hjkl也不奇怪了呢 光标向前移动n个单词:1w,2w,3w... 光标向前移动至第n个单词的末尾：1e,2e,3e... 移动至行首：0 移动至文末：G 移动至文章开始：gg Ctrl-G配合G使用风味更佳（跳转到某一行） 选中：v+光标移动 模式切换Normal mode: ESC 进入输入模式:i（要操作时记得按esc退出） 保存退出不保存并退出：:q! 保存并退出：:wq 另存为：:w [filename] 删除删除字符：x 删除单词：dw(光标需移动到单词的开头 删除至行末：d$ 删除至词末:dw 用count进行删除：d2w,d1e... 删除整行：dd，2dd,... 从此dd具有了全新的意思 用dd删除的行被放入了寄存器中，p可在上方恢复 撤销撤销最后一步操作:u 撤销整行所有的操作：U 恢复撤销：Ctrl+R 修改改写单个字符（rewrite）：r+(the right character) 改写多个字符：R+(right characters) 改写至词尾：ce（记得esc退出输入模式） 改写至行尾：c$ 整词替换： :s/old/new //替换第一个 :s/old/new/g //在光标所在单行内将&quot;old&quot;全部替换为&quot;new&quot; \\#,#old/new/g //在\\#标记出的行数范围内进行替换 :%s/old/new/g //在全文范围内进行替换 :%s/old/new/gc //在全文范围内查找并询问是否需要替换 插入插入某个文件的内容：:r+[filename] 插入某个命令行函数的返回值:e.g.:r !dir 在光标上方新建一行：o 在光标下方新建一行：O 从词末开始输入：a 从行末开始输入：A（Append） 复制：y(yank) yw可以复制一整个单词 粘贴：p(paste) 查找查找内容：/+（查找内容） 正向查找：n 反向查找：N 从文末开始查找：?+(查找内容) 返回查找前的地方：ctrl-o 是字母O不是数字0 括号匹配：% 忽略大小写：:set ic(ignore case) 关闭忽略大小写::set noic 查找内容高亮：:set hls/hlsearch 关闭高亮：:nohlsearch 部分查找：:set is/incsearch (incsearch) 分屏看到一篇不错的教程，就不复述了 vim分屏功能总结 暂时无法分组指令输入命令行指令::!+(命令行指令) 帮助：F1 or help 指令补全：Ctrl-D配合Tab","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"vim","slug":"vim","permalink":"https://mengzelev.github.io/tags/vim/"}]},{"title":"算法导论学习笔记-动态规划","slug":"clrs-15dp","date":"2018-08-31T08:37:42.000Z","updated":"2018-09-05T02:12:40.869Z","comments":true,"path":"2018/08/31/clrs-15dp/","link":"","permalink":"https://mengzelev.github.io/2018/08/31/clrs-15dp/","excerpt":"","text":"基本原理以下是大段算法导论原句搬运。 只有带下划线的句子才是自己总结的。 最优化问题 动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们成这样的解为问题的一个最优解，而不是最优解。 算法设计步骤 刻画一个最优解的结构特征 递归地定义最优解的值 计算最优解的值，通常采用自底向上的方法 利用计算出的信息构造一个最优解（有时不需要） 动态规划求解最优化问题应该具备的两个要素：最优子结构和子问题重叠。 简单来说就是，能根据原问题得到一个递推式（最优子结构），但是在这个递推式的计算过程中会出现大量重复计算的时候（子问题重叠），可以使用动态规划。 最优子结构性质 问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。 在发觉最优子结构性质的过程中，实际上遵循了如下的通用模式：1.证明问题最优解的第一个组成部分是做出一个选择；2.对于一个给定问题，在其可能的第一步选择中，你假定已经知道哪种选择才会得到最优解。3.给定可获得的最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；4.利用“剪切-粘贴”技术证明：作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解（反证法）：假设子问题存在更优解，将子结构从整体中删除替换为更优解，与最优假设矛盾。 保持子问题空间尽可能简单，只在必要时才扩展它。（e.g.矩阵链乘法问题必须允许子问题在“两端”都可变） 可以用子问题的总数和每个问题需要考察多少种选择这两个因素的乘积来粗略肥西动态规划算法的运行时间。 具有最优子结构的问题子问题之间是无关，同一个原问题的一个子问题的解不影响另一个子问题的解。e.g.无权最短路径vs无权最长路径 子问题重叠如果递归方法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。与之相对的，利用分治方法求解的问题通常在递归的每一步都生成全新的子问题。 重构最优解：用另一个数组来记录最优解 实现 自顶向下的备忘算法 自底向上的动态规划算法一般自底向上的动态规划算法会比较快（没有递归调用开销，表的维护开销也更小） 如果子问题空间中的某些子问题完全不必求解，备忘方法就会体现出优势 钢条切割问题问题描述某公司出售一段长度为i英寸的钢条的价格为$p_i(i=1,2,…,$单位为美元）。给定一段长度为n英寸的钢条和一个价格表$p_i(i=1,2,…,n)$，求切割钢条方案，使得销售收益$r_n$最大。 分析长度为n英寸的钢条共有$2^{n-1}$中不同的切割方案。 如果一个最优解将钢条切割为k段$(1\\le k\\le n$)，那么最优切割方案$$ n=i_1+i_2+…+i_k$$ 将钢条切割为长度分别为$i_1,i_2,…,i_k$的小段，得到最大收益$$ r_n=p_{i_1}+p_{i_2}+…+p_{i_k}$$ 对于$r_n\\ge 1$，我们可以用更短的钢条的最优切割收益来描述：$$r_n=max(p_n,r_1+r_{n-1},r_2+r_{n-2},…,r_{n-1}+r_1)$$ 更简单的，我们将钢条从左边切割下长度为$i$的一段，只对右边剩下的长度为$n-i$的一段继续进行切割（递归求解），对左边的一段则不再进行切割。可以得到$$r_n=max\\limits_{1\\le i\\le n}(p_i+r_{n-i})$$这样原问题只包含一个相关子问题的解而不是两个。 复杂度时间复杂度：$\\Theta(n^2)$ 子问题图 矩阵链乘法懒得写了。 最优子结构 对子问题的分析发现必须是子问题必须是两头可动的（i.e.一维数组是不够的） 伪代码为什么原书是分页的我还得手敲一遍不能忍 MATRIX-CHAIN-ORDER(p) //自底向上的动态规划实现 n=p.length-1 let m[1..n,1..n] and s[1..n-1,2..n] be new tables for i=1 to n m[i,i]=0 for l=2 to n for i=1 to n-l+1 j=i+l-1 m[i,j]=\\infty for k=i to j-1 q=m[i,k]+m[k+1,j]+p[i-1]*p[k]*p[j] if q&lt;m[i,j] m[i,j]=q s[i,j]=k return m and s 最长公共子序列（LCS）问题定义先略 最优子结构 伪代码 最优二叉搜索树和矩阵链乘法类似 也懒得抄了 一份毫无营养的学习笔记就完成了","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://mengzelev.github.io/tags/dynamic-programming/"}]},{"title":"汇编语言复习笔记（二）","slug":"asm2","date":"2018-08-30T08:37:42.000Z","updated":"2018-08-30T08:42:36.625Z","comments":true,"path":"2018/08/30/asm2/","link":"","permalink":"https://mengzelev.github.io/2018/08/30/asm2/","excerpt":"","text":"数据传送数据传送指令格式： mov S(源操作数), D(目标操作数) mov &nbsp;&nbsp; 一般传送指令 movs &nbsp;&nbsp; 符号扩展传送 movz &nbsp;&nbsp; 零扩展传送 push &nbsp;&nbsp; 压栈，等价于sub+mov pop &nbsp;&nbsp; 退栈，等价于mov+add 按源操作数的长度加上b,w,l后缀，分别表示1、2、4字节。(movz,movs需要双后缀) 见leal与movl的区别 指令后缀、操作数长度、目标寄存器宽度必须要一致！！ 操作数类型 立即数 Imm &nbsp;&nbsp; 整型常量，加$前缀，e.g.$233, $0x66FFCC 寄存器 Reg &nbsp;&nbsp; 加%前缀，e.g.%eax,%ebx,%esp 存储器 Mem &nbsp;&nbsp; 寻址操作 不能在一条指令里实现存储器到存储器的传送！！要实现存储器间的传送必须经过寄存器。 寄存器 所有寄存器都可以单独读取低16位 只有%eax,%ecx,%edx,%ebx可以读取低8位（x字辈） 地址运算指令格式: leal S,D S是复杂寻址地址形式的表达式，将表达式表示的值写入D，其中D一定是寄存器 用途： 直接计算地址的值 e.g.p=&amp;x 执行简单的算数运算 leal与mov操作的区别： leal不会对寻址表达式解引用 e.g. //R[%edx]=x movl 7(%edx,%edx,4),%eax //R[%eax]=M[5x+7] leal 7(%edx,%edx,4),%eax //R[%eax]=5x+7 算术和逻辑操作看表 ※使用时也需要根据操作数长度添加后缀 特殊操作imull &nbsp;&nbsp; 带符号乘法指令，只有一个操作数时，另一个乘数隐含在%eax中，乘积的高32位放入%edx,低32位存入%eax idivl &nbsp;&nbsp; 带符号除法指令，只有一个操作数时，%edx-%eax为被除数，操作数为除数，商存入%eax,余数存入%edx 还有无符号版本mull和divl cltd 符号扩展指令，将%eax中的数符号扩展至%edx成为64位,经常用于idivl的准备工作 关于imul 操作数个数 格式 操作 结果存放 1 imul src src*R[%eax]，完全乘法（自己取的名字） %edx-%eax 2 imul src dst src*dst,高位截断，只保留低位 dst 3 imul reg src imm R[reg]=src*imm，只保留低位 reg 具体还是看老师ppt截图吧（侵权删） 条件控制指令比较与测试 cmp和test指令实际上是用减法和按位与操作实现的。 注意两个操作数的先后顺序与实际是相反的 条件置位指令setXsetX指令根据相应的条件标志位将某一位置0或置1。 有符号数的大小关系用greater/less表示，无符号数的用above/below表示。 条件跳转指令jmpX基本同setX 间接跳转：跳转的目标是从寄存器或存储器中读取的，e.g.jmp *%eax表示跳转至R[%eax]存储的地址位置 跳转地址分为绝对地址和相对地址(PC-relative addressing)。 绝对地址即4个字节直接指定的目标地址。 PC-relative addressing程序计数器的值是跳转指令后的那条指令的地址，而非跳转指令本身的地址 实际跳转到的地址=下一条指令的地址+右边的操作数（小端补码表示） e.g. 804828f: 74 05 je XXXXXXX 8048291: e8 1e 00 00 00 call 80482b4 XXXXXXX=0x8048291+0x05=0x8048296 条件传送指令cmovX满足某个条件时执行mov操作 ※必须与cmp操作连用，比较的不是cmov指令的两个操作数而是cmp的两个操作数 条件分支语句的编译if-else语句通常按goto方式执行 一般翻译思路为: if (test-expr) then-statement else else-statement 会被翻译为 if(!test-expr) goto false then-statement goto done false:else-statement done: 可以参考下图中示例： 循环控制语句do-while循环一般循环语句都最终翻译成do-while的形式 do body-statement while(test-expr) 会被翻译为 loop: body-statement if(test-expr) goto loop; while循环while(test-expr) body-statement 会被翻译为 if(!test-expr) goto done; loop: body-statement if(test-expr) goto loop; done: for循环for(init-expr; test-expr; update-expr) body-statement 会被翻译为 init-expr; if(!test-expr) goto done; loop: body-statement update-expr if(test-expr) goto loop; done: switch语句跳跃表跳跃表是一个数组，其中每个下标i对应一个代码段的地址 好处：执行一个switch语句的时间和case的数量无关跳跃表一般被存放在内存的某个位置，可以调用gdb查看 一大波截图预警 作业二的教训 1.几个指令的名称对应功能要背熟 2.确定数据类型：确定长度+有无符号 3.别忘了指针也是一种数据类型 4.jmp指令的第二个操作数是小端补码表示 5.模拟汇编控制流就是要把代码拆分成简单语句（注意运算优先级） 6.分清andl和addl 7.补充C代码的时候就不要再写8x这样意义不明的东西了，是8*x啊老兄","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Assembly Language","slug":"Assembly-Language","permalink":"https://mengzelev.github.io/tags/Assembly-Language/"},{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"}]},{"title":"汇编语言复习笔记（一）","slug":"asm-notes","date":"2018-08-29T05:11:42.000Z","updated":"2018-08-30T03:32:00.252Z","comments":true,"path":"2018/08/29/asm-notes/","link":"","permalink":"https://mengzelev.github.io/2018/08/29/asm-notes/","excerpt":"","text":"前言本文为学校课程面向考试复习笔记，参考内容为老师的课堂讲义&amp;深入理解计算机系统，依据这两者做了一些个人的整理便于复习。然而浪了一个假期在退课的边缘试探 信息的表示数值的表示 原码：这个很直观的 反码：这个几乎不用的 补码：$D’=R^n-D$ / 按位取反加1； 移码：见浮点数 补码 相当于取模操作 着重区分基数的值(R)和补码位表示的实际的值(D) R与D的相对大小一致 $R=D+D_{w-1}\\cdot 2^w$ C语言中的整数 无符号数：在数后加U或u 同时有无符号数和带符号数，编译器将带符号数强制转换为无符号数 int的最大正值为2147483647，最大负值为-2147483648 比较时要特别注意是按什么规则进行的 数据的存放 小端：最低有效字节存放在最小地址 大端：最低有效字节存放在最大地址 浮点数编码表示分3个字段 符号s &nbsp; 0正1负 阶码E &nbsp; k位阶码字段exp 尾数M &nbsp; n位小数字段frac &nbsp; 表示的是a/2^n float &nbsp; k=8,n=23 double &nbsp; k=11,n=52 三种表示情况 1.规格化 &nbsp;&nbsp;阶码部分既不全0也不全1 采用偏置形式：E=e-Bias 其中，E为阶码实际的值，e为位模式下的无符号数，偏置Bias= $2^{k-1}-1$ float:127, double:1023 指数范围： float: -126~+127; double -1022~1023 尾数 M=f+1 &nbsp; 其中 0&lt;=f&lt;1; 1&lt;=M&lt;2 非规格化 &nbsp;&nbsp;阶码全0 阶码E=1-Bias 尾数M=f 存在意义：提供了0的表示方法，逐渐溢出 &nbsp; （否则[0,$2^{-n})范围内的数都无法表示） 特殊值 &nbsp;&nbsp;阶码全1 尾数全0：正负无穷大 尾数非全0： NaN 浮点数加减运算步骤：对阶→加减→规格化（→舍入） 对阶：小阶向大阶看齐，小阶尾数右移（带上隐含的1） 整数运算位运算没什么好说的。 移位运算 左移x&lt;&lt;k 丢弃最高k位，在右端补k个0 右移x&gt;&gt;k 丢弃最低k为，在右端补k个0/符号位 移位运算是向下取整 整数加减法发生在n位带标志加法器中 ###条件标志位计算t=a+b eflag 中文名称 有效条件 OF 溢出标志 a,b同号但t与a,b异号 SF 符号标志 t&lt;0 ZF 零标志 t==0 CF 进位标志 (unsigned)t&lt;(unsigned)a 比较大小相当于做减法 无符号数： CF==0 $\\Leftrightarrow$ a&gt;b 有符号数： OF==SF $\\Leftrightarrow$ a&gt;b 整数乘法乘数中有常数时：采用移位(左移)+加减法相结合的形式 整数除法默认朝0方向舍入：，即正数商取比自身小的最接近整数，负数商取比自身大的最接近整数 用移位代替除法时需要负数需要加上一个偏移量 除数为2的幂次时，采用右移运算，得到朝0方向舍入的结果 无符号数、有符号正整数： 移出的地位直接丢弃 有符号负整数： ：加偏移量 (2^k-1) ，然后再右移k位，低位截断 作业一的教训1.~按位取反 和 ！全部取反要区分清楚 2.非按位运算操作符非0的都视为true 3.浮点数的转化要好好看一下，把转化公式写好 4.移位是向下取整","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Assembly Language","slug":"Assembly-Language","permalink":"https://mengzelev.github.io/tags/Assembly-Language/"},{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"}]},{"title":"胡言乱语的大一总结","slug":"freshman","date":"2018-08-18T13:27:02.000Z","updated":"2018-08-18T15:46:17.255Z","comments":true,"path":"2018/08/18/freshman/","link":"","permalink":"https://mengzelev.github.io/2018/08/18/freshman/","excerpt":"","text":"&emsp;&emsp;生日兼七夕窝在家里无聊于是开了这样一篇文章写了整整两天，都是些碎碎念。本来并没有写这种东西的习惯的(:з」∠)但是既然开了个人blog总要写点什么的于是就写吧！试图掩盖写不出教程的事实将来过好几年来看可能会很有回忆的感觉。 学习篇刚进大学的时候，军训期间闲得蛋疼去考了计拔居然还被录取了，txp他老人家眼光真的没问题吗，于是就开始了贼船之旅。大一上第一个国庆长假就只能窝在家里写作业写了好久堪称心理阴影，大一上被问求这门神奇的课给吓尿了，动不动就为了赶作业修仙到两点。其实还是有在疯狂补小排球的 到了大一下觉得大一上还是很空闲的，起码不用搭面包板，也不用抄大物作业。大二上可能会觉得大一下很轻松吧，笑着活下去.jpg 大一上课表大一下课表 随便说说几门课给我的感受。 微积分早有耳闻，学起来没有觉得很难，可能也是托了qlz的福，这样有主见有原则的老师我超级赞赏的，上课还会讲故事，最重要的是他给分高啊！ 本来和害怕数学的我渐渐也能感受到数学的美了吧，大概。 微电子，浪费生命的水课，课听了，作业做了，考试考了但是感觉毫无收获。 大物实验，水课，求求来个人告诉我实验报告怎样才能拿到优。 大物，不明觉厉，学学物理其实挺好玩的，但是ldx这本书为什么这么…【无fuck说.jpg】果然xmw这种老师还是早点辞退比较好 xw是真的很卖力啊但是为什么我还是听不懂，对不起他。虽然物理课每节都有在听但是经常忍不住水群导致错过了好多，下学期请务必全神贯注，不然电磁学要GG了。 思修， 军理， 马原， 水课三连，马原老师讲的哲学还有那么点意思，可惜全在写oj了没认真听。军理部分老师太sb了请立刻辞退 数电 嘛，还挺有意思的，搭面包板有点抓狂但是比比大班就有心里安慰了。还有wgs真的好帅啊！！！ 英语， 我喜欢，大一上的视听说拍视频很开心，虽然我只是个压榨组员的主催。大一下的配音和演讲超有意思的，演讲做了啊你妹相关的虽然很花时间但还是超开心的。Ruth的读写课天下第一好，我吹爆她！第一学期的时候就猜对了一个谜语而已她居然觉得我很厉害还送了我一个史迪仔期末还给了我满分，真的只是非洲人突然偷渡入欧而已…总之超级感谢的…第二学期结课的时候Ruth还哭了…能跟学生交心的老师是真的难得啊qwq 问求， 终于到了这门让我百感交集无fuck说的课。大一上:卧槽我在学什么；大一下：卧槽这题该怎么做。大一上作业不算难但是量炒鸡大，期末考试也莫名其妙。大一下，作业不多但是好多不会做的，其他课作业又比较多只能出卖灵魂与网络上的算法导论参考答案签订契约成为期末挂科烧酒（雾）。OJ…别提了…我只是题解的搬运工…期末mj查什么重啊…您出题出这么难不找题解还怎么做啊…把OJ当acm校队选拔吗… 汇编，一定要告诫学弟学妹，千万别听whj讲课，看csapp自学效率最高。whj讲课听不懂催眠效果还极好。实验部分装装Linux调调gdb还是挺好玩的，作业也还行，做下来对CPU的工作方式算是有了个全新的认识。【然而汇编笔记的文章还是没有产出来】拆炸弹是真的很有意思，每拆完一个phase都超有成就感，我应该是走火入魔了，连着3个晚上没睡好觉，闭眼就是寄存器，然后被自己炸醒。拆了三天也是够慢的，自卑.jpg.马上开学要考试了完全不想复习，在退课的边缘试探，，， 通识, 感觉这一年里还是太忙于专业课的学习了，通识课上下来并没有太大的收获，基本都是上课不听埋头写作业或者沉迷水群，期末论文之类的也是东拼西凑的学术垃圾。和进大学之前想的完全不一样唉…悦读经典emmmmm论理想与现实的差距，目前为止选的三本书没有哪一本是认真看过的，我什么时候能中《呐喊》、《彷徨》呢？即使中了，在专业课重压之下真的会好好看吗？ 课外学习的话，平时在校根本挤不出时间，总是带着不到ddl不写作业的惰性思维，这一点希望能改啊，可是既然有时间难道不应该优先看番吗。暑假龟速自学了git和markdown，其实都不是很有技术含量的东西，接下来的时间看看能不能学…你数学建模相关还一点没看呢吧…吧…美赛还没报名呢吧…咕掉了校内培训和选拔的严重后果…总之，加油吧。 也一度因为周围的人都去打acm迷茫过要不要去打，但是高中三年noip下来其实也不是太愉快，貌似不太喜欢这种过于理论、过于数学的题目，可能也是一种逃避现实的借口吧。嘛，既然决定了不打acm就一定要认真科研啊。不过现在学得太少真的不敢妄下定论自己喜欢什么。西瓜书，请。 还有既然决定要出国了，请认真背单词。 这个人真的不是精神分裂吗 社团活动篇说到大学必须得有社团活动哒！上大学之前幻想了很多的，进了大学为生活所迫也就活跃了几个地方。 吉协是早就想去的，结果实际上也就大一上去上了弹唱提高班。老师还挺好的吧，至少比家这里的好，还稍微入门了一下指弹。之后的活动完全没有参加了orz什么时候才能把曲子练到能上台表演的水平呢… 辩队还是有好好待的！虽然是被学姐忽悠进去的还只打了两场正式比赛全是输给冠军的一轮游。在辩队一年还从来没赢过一场，太惨了。每次比赛前讨论真的好花时间。一开始写一辩稿还好，后来开始被钦定打三辩稿子都是开场前30min写的了简直丢人。受了信管那边的学长学姐好多照顾（包括wrc)，除了辩论技巧还被拖着玩了狼人杀，所以，传火吧，骚年！ CAC音乐部每天水水群约约饭很开心der!还认识了一帮宅友！好多会玩乐器的、唱歌超好听的小哥哥小姐姐！还有豹跳如雷的海豹们两个月四对的传说！还有每次交作业被33处刑…去过大活楼梯间约歌（一次），线上歌会（两次），107（等末子姐姐拍照一次），完美错过所有线下约k。也算是遗憾比较大的一个地方，当初大一上觉得自己作业太多了没去Monge，乐队的锅也没接。现在Monge都凉了，大二上更不可能有空了。仔细想想大一上其实能好好安排时间的话完全是有空的，但是刚进大学谁能想到呢？还是太求稳了缺少逼自己一把的勇气吧。为才能不足而自卑.jpg。接了vocal团的锅希望表达一点愧疚之意吧。你们的(副)团长是全团最不会唱歌的人。 流跡是在你群水群聊骨头社意外被33拉进去的。之前完全没想过还有这么硬核的探讨宅话题的地方。一开始什么都看不懂（现在依然是），但是以此为契机了解了不少其实也不多啊你妹制作相关的知识。后来进来的玄枝爷爷讲了好多叙事学的东西，很厉害的样子但是完全没听懂自卑.jpg。自从能在流跡吹水新番之后感觉自己的追番越来越勤快了，经各位的安利看番面也越来越广了。和各位的约饭也非常愉快。英语pre做了动画制作流程相关的内容以及现在补《白箱》都和流跡脱不了干系，想快点变得pro能和各位聊起来啊qwq 排队是恶补了小排球之后才加的，虽然没有小排球里那么刺激也没有那么多可爱的男孩子但是打排球真的好开心！在场边加油很晒应该没晒黑多少吧(bushi)学姐们都好厉害！一路打进了院系杯四强！技术不足还不足以成为战力下个学期要好好加油了！ 除此之外开学乱加的几个早就为作业所迫咕掉了。比如校会学创啊，信管乒队什么的。（你真的会打乒乓吗）大二上也不敢对社团活动有所奢望了，好好在辩队带带小孩、vocal团的工作做做好，流跡快点把制作流程产出，我就满足了。你看又开始求稳没有拼劲了 生活篇大学生活的第一年吗…总体还算平稳的吧。 宿舍不是太愉快。烦心事也就不多提了，忘掉最好。 一年来基本都靠食堂过日子，叫外卖的次数屈指可数。大一上基本没出过几次校门，大一下逐渐开始放浪形骸。 寒假鼓起勇气买了人生第一套jk制服，月野家的奶油黄基础款冬服，到快入夏的时候才到的，也就穿了一次。之后入了优马家的绀金和红酒雪梨，燕子家的白五本，从此走上攒钱买衣服的不归路。优马大小姐的定金已经下了，最近出了那么多问题…等浅色的出货爱咋滴咋地吧。代码定金也下了，坐等出货，我也想穿着代码敲代码！ es军训的时候还在肝rock，开学后尝到了生活的艰辛，尤其是在做人情肝了一发节分守门两小时作业一笔未动修仙勉强做完后，从此es脱坑。现在极其想把手头的谷子都卖掉，忘记我这个出坑的人渣吧。fgo军训无聊稍微玩了一下，总之是不想过靠肝和欧生活的日子了，这月就不登了。 大一下开始学车，暑假的时候留校一个多礼拜把科三给考了，过得超惊险。大二上要在上课和作业的夹缝中学科二了。 补番篇就不一一列举了这一年里补/追过的番了，类似于推荐的形式挑几部印象深刻的写吧。 小排球 强推！吹爆！运动番天花板！剧情作画配乐都堪称一流！看到停不下来！一般深夜补番的我多次因为小排球亢奋到睡不着。好久没看这么从头正到尾的番了，既有很现实的设定（及川大王和影山）也有理想的处理（日向和乌野的大家）。不会气活牛顿的科学运动番，唯一不现实的地方是现实中的小男孩哪有这么可爱。看完甚至开始打排球的我不是一个人。心情不好的时候看看小排球就能马上开心起来。有生之年能遇到这样的番真是太好了。 三月的狮子 对上电波的慢节奏番，吹爆羽海野老师和新房！！零酱超可爱！！（摸摸）很喜欢这种有关人生与成长的题材，零酱和三姐妹经历的困难特殊而普遍，仿佛能看到自己的过去。身世悲惨的他们也时常享有寻常的幸福，这种强烈对比大概就是三狮的动人之处。岛田大师兄、小胖、老师等配角刻画得也很好。虽然将棋部分的内容完全看不懂但也不妨碍其成为一部佳作。 超自然九人组 志仓千代丸的作品，剧情，尤其是开头和中间展开很精彩，节奏飞快，收尾略显仓促，不少坑挖了没填，听说游戏表现得反而没有动画好有点可惜。佐仓这回治好了我的巨乳控！ 宅男腐女恋爱难 太甜了！一部刷新我恋爱观的番！我萌捷列夫就是饿死，死外边，也不会看狗粮番的——真香！ 其他看过的番bangumi上都有记录了就不作赘述了。顺便贴上我的bangumi。 恋爱篇您是不是一上来就通过目录索引跳这儿来了？哈哈！对不起！毛都没有！ …… 没有对象但还是想说说恋爱观的，毕竟之前也没有认真思考过这个问题，就大一上拒了俩然后被吓到了发表了一堆独身主义宣言现在想想全tm是黑历史啊好想删说说。其实也没有那么抗拒了啦首先你得...只是自己不是那种想随便玩玩的人，所以想尽可能抱着认真谨慎的心态来对待这么重要的事情首先你得...不过话说回来还是作业太多了，客观上不想再多加一件需要操心的事情了首先你得...没有空间里那些对象怪那么迫切，还是很享受单身的自由生活的，只要管好自己就行了，想喜欢谁就喜欢谁做个dd不好吗？也就是出去玩找不到小伙伴的时候会稍微有点寂寞（）。各有各的生活方式吧。总之，这么看缘分的事情还是随缘吧… 嗯？您问有没有喜欢的人了？这篇文章没加密我当然不会说啦！(doge)","categories":[{"name":"Diary","slug":"Diary","permalink":"https://mengzelev.github.io/categories/Diary/"}],"tags":[{"name":"freshman","slug":"freshman","permalink":"https://mengzelev.github.io/tags/freshman/"},{"name":"college life","slug":"college-life","permalink":"https://mengzelev.github.io/tags/college-life/"}]},{"title":"Markdown test","slug":"test-md","date":"2018-08-12T13:27:02.000Z","updated":"2018-08-12T13:35:34.586Z","comments":true,"path":"2018/08/12/test-md/","link":"","permalink":"https://mengzelev.github.io/2018/08/12/test-md/","excerpt":"","text":"这是标题君这是副标题君我知道这篇文章看起来很沙雕，因为作者就是一个沙雕 列表非常有趣 这是第一项 这是第二项 这是第三项 有时候会有需要强调的内容。 插入代码是一件非常爽的事情： printf(&quot;%s&quot;,&quot;Hello world!\\n&quot;); 突然发现自己不会用printf真是太丢人了。 有时候需要插入链接，这里贴一个百度。 有时候又需要插入图片 看张血小板冷静一下吧（图源网络） 图片的尺寸可以用命令进行修改 暂时先写这么多吧，敬请关注后面几期，计划中将会有 汇编课程相关学习笔记 日本动画制作流程及《白箱》观后感整理 大一回顾与总结 但愿到时候不要鸽（小声）评论功能等我明天再来开不要问我这里为什么是引用格式，看不出来我只是在试试吗","categories":[{"name":"Diary","slug":"Diary","permalink":"https://mengzelev.github.io/categories/Diary/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://mengzelev.github.io/tags/markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-28T06:23:10.175Z","updated":"2017-10-28T00:39:58.000Z","comments":true,"path":"2018/07/28/hello-world/","link":"","permalink":"https://mengzelev.github.io/2018/07/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}