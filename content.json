{"meta":{"title":"Mengzelev's blog","subtitle":null,"description":"nothing to write","author":"Mengzelev","url":"https://mengzelev.github.io"},"pages":[{"title":"Welcome to Enmeng Liu's Personal Page","date":"2020-12-19T16:00:00.000Z","updated":"2020-12-21T14:29:58.324Z","comments":true,"path":"about/index.html","permalink":"https://mengzelev.github.io/about/index.html","excerpt":"","text":"Enmeng Liu (刘恩萌) My Selfie :) Basic Information Senior Undergraduate National Elite Program of Computer Science Dept. of Computer Science and Technology Nanjing University, ChinaGPA: 4.60/5.00 (ranking top 3%) TOEFL: 107GRE:327 Email: enmeng-liu@outlook.com About MeI am an undergraduate student of Dept. of Computer Science and Technology in Nanjing University, China. I am a member of the National Elite Program of Computer Science. I am expected to receive my Bachelor of Science degree in June, 2021. Here is my CV. I am now seeking for a thesis-based master/Ph.D. position in Fall 2021. If you are interested in hiring me, please feel free to contact me anytime. Research InterestI am currently interested in the field of Software Engineering. I am eager to explore the “magics” of software development infrastructures. My goal is to help as many developers as I can with my own knowledge. More specific research interests are to be discovered during my graduate study. Research ExperienceUnderstanding Compilation Errors Among Novice Software Developers (Working in Progress) Supervisor: Dr. Yanyan Jiang My supervisor has collected a large-scale dataset of auto-traced git-logs in students’ programming assignments. My job is to analyze the causes and fixing patterns of the compile errors (CE) made by the students, typical representatives of novice programmers. I built a tool to visualize each CE case. I have manually checked about 100 CEs using this tool and found some really interesting cases. Now I am trying to figure out a way to classify these CEs automatically. I am also looking for a formal way to represent different kinds of CEs. I hope the findings of this work will provide more insights into the enhancement of the readability of today’s programming tutorials and compilers’ error messages. Working ExperienceMicrosoft STCA Software Engineer Intern July.2020 - Oct.2020 M365 Insights Group Suzhou, Jiangsu, China Selected ProjectsTime-away Add-on for Microsoft Teams (Intern Project) Implemented front-end components for booking a time away based on Microsoft Teams Client (TypeScript/LESS/React) More details can be obtained from the review slides. x86 Full System Emulator (Course Project) Implemented Ring 0/3 x86 instructions with interrupt/exception, paged virtual memory, and emulated devices Mini Operating System Kernel (Course Project) Completed a multi-core operating system kernel with threads, a virtual file system, and a process scheduler C– Compiler (Course Project) Included lexical, syntactic and semantic analysis, intermediate representation and MIPS instruction generation Selected Awards 2020, First Prize, National Elite Program Scholarship 2019, Second Prize, National Elite Program Scholarship 2019, Honorable Mention, Interdisciplinary Contest In Modeling (ICM) 2019, 3rd place, HKUST-NJU Academic Competition (Computer Science) 2018, Second Prize, National Elite Program Scholarship HobbiesI love Japanese anime and manga. I sometimes draw pictures for my favorite characters.Currently I am obsessed with Jujutsu Kaisen (呪術廻戦).Visit me in bangumi."},{"title":"友情链接","date":"2019-01-16T09:40:48.000Z","updated":"2019-01-16T11:29:37.225Z","comments":true,"path":"friends/index.html","permalink":"https://mengzelev.github.io/friends/index.html","excerpt":"","text":"My Friends Link Marukohe Ricky-Ting Doowzs Fancy Michael Yan kuangsl congee"}],"posts":[{"title":"软件分析课程期末复习笔记","slug":"static-program-analysis","date":"2021-01-07T07:50:36.000Z","updated":"2021-01-07T07:54:10.546Z","comments":true,"path":"2021/01/07/static-program-analysis/","link":"","permalink":"https://mengzelev.github.io/2021/01/07/static-program-analysis/","excerpt":"","text":"软件分析-期末复习课程主页 感谢两位老师的精彩教学！ 参考标准：每节课最后的The X You Need To Understand in This Lecture 中文为主，中英文使用纯看心情 Introduction 静态分析与动态分析的区别 在运行程序$P$之前就知道它是否满足某些性质 理解soundness, completeness, false positive/negative 想象3个圆：sound &gt; truth &gt; complete false positive = sound-truth false negative = truth-complete 为什么静态分析一般选择soundness 对于重要的应用方面来说更加关键（e.g. 编译优化、程序验证 在bug detection中，soundness意味着能找到更多bug static analysis：保证soundness，在precision和speed之间做trade-off 每一种静态分析算法都是在保证safe的基础上，在precision和efficiency之间做trade-off 如何理解abstraction &amp; over-approximation abstraction: 把具体问题的domain映射到抽象的domain上 over-approximation: transfer function定义了如何用abstract values计算不同的程序语句，不可能穷尽所有的可能性因此会损失精度，如flow merging 中间代码表示 编译器与静态分析器之间的关系 发生在IR生成后、机器代码生成前，一般用于进行代码优化 理解三地址码（3AC）和它的common form (in IR Jimple) 如何在IR的基础上构建基本块 如何在基本块的基础上构建控制流图(CFG) 三地址码（3AC） 右侧至多只能有一个操作符 每条指令至多只能有3个地址；地址可以是：变量名/常数/临时变量 构建基本块 输入：程序$P$的三地址码序列 输出：一系列基本块 算法： 决定基本块的leader：程序的第一条指令、跳转语句的目标语句、跳转语句的下一条语句 根据leader划分基本块 构建CFG 基本块之间连边条件 存在从A的结尾到B的开头的跳转语句 在原来的执行顺序中B紧跟在A的后面，并且A不能以无条件跳转结束 再加上ENTRY和EXIT 数据流分析-应用 理解三种数据流分析：到达定值、活跃变量、可用表达式 能够说出三种数据流分析的异同 理解迭代算法并且能说出它为什么能终止 一图流 到达定值 活跃变量 可用表达式 Domain Set of definitions Set of variables Set of expressions Direction Forward Backward Forward May/Must May May Must Boundary OUT[ENTRY]=$\\emptyset$ IN[EXIT]=$\\emptyset$ OUT[ENTRY]=$\\emptyset$ Initialization OUT[B]=$\\emptyset$ IN[B]=$\\emptyset$ OUT[B]=$U$ Transfer Function OUT=gen$\\cup$IN-kill OUT=gen$\\cup$IN-kill OUT=gen$\\cup$IN-kill Meet $\\cup$ $\\cup$ $\\cap$ 到达定值 一个definition能不被kill掉地到达某一点 Data Flow Values/ Data Facts: the definitions of all the variables in a program (Abstraction) transfer function: gen：被定值 kill：定值被覆盖 活跃变量 活跃变量：某一个变量在之后可能会被用到 transfer function（可以画图理解）在基本块内 先use再def：gen 先def再use：kill 可用表达式 可用表达式：从程序开始到当前程序点的每一条路径都计算了这个表达式，并且计算之后表达式每个分量的值都没有被覆盖（意味着在该程序点，可以把求值换成该表达式上一次求值的结果） transfer function gen: 计算了这个表达式 kill：表达式的分量的值被覆盖 数据流分析-基础 理解迭代算法的函数视角 lattice和complete lattice的定义 理解不动点定理 如何在lattice上总结may/must分析 MOP与迭代算法解的关系 常量传播 Worklist算法 函数观点看迭代算法 CFG中$k$个结点的data flow values可以看成一个k-tuple 变量 每一次迭代就相当于将函数$F: V^k\\to V^k$作用在这个k-tuple上 迭代终止条件：$X=F(X)$，没有数据流值发生变化，即到达函数的不动点 格 偏序：自反+反对称+传递 最小上界（lub）：$\\sqcup S$； 最小下界（glb）：$\\sqcap S$ 当只有两个元素时，$a\\sqcup b$表示$a$和$b$的最小上界 (join)；$a\\sqcap b$表示$a$和$b$的最大下界 (meet) 格：偏序集中任意两个元素都存在lub和glb，那么这个偏序集就是一个格 Complete Lattice：偏序集中任意一个子集$S$内的元素都存在lub和glb，那么这个偏序集就是一个complete lattice Complete lattice 都有最大元素$\\top$ (top) 和最小元素$\\bot$ (bottom) 有限格一定是complete lattice Product Lattice：一系列格的笛卡尔积 如果每个格都是complete lattice，那么它们的product lattice也是complete lattice 数据流分析&amp;格 数据流分析框架$(D,L,F)$ $D$：分析方向（Forward/Backward） $L$：格，所有data flow values的集合$V$+ meet/join operator $F$：transfer function $V\\to V$ 数据流分析可以看成：在格的values上迭代地应用transfer function和meet/join operation 单调性+最优性：不一定只有一个不动点，但迭代算法能得到解且得到的是最优解 不动点定理：给定一个complete lattice $(L, \\sqsubseteq)$，如果满足：函数$f:L\\to L$单调且$L$有限，那么 $L$的最小不动点可以通过迭代$f(\\bot), f(f(\\bot))\\ldots ,f^k(\\bot)$至达到不动点得到 $L$的最大不动点可以通过迭代$f(\\top),f(f(\\top)),\\ldots,f^k(\\top)$至达到不动点得到 关联数据流分析框架与不动点定理 每次迭代得到的结果都在一个product lattice中 函数=transfer function + join/meet : 单调 transfer function本身单调，因为gen和kill是固定的 join/meet单调：$\\forall x,y,z\\in L, x\\sqsubseteq y\\Rightarrow x\\sqcup z\\sqsubseteq y\\sqcup z$ 终止性：迭代算法一定能终止吗？ 格的height为$h$（从$\\top$到$\\bot$的最长路径长度），CFG结点数为$k$，则从$\\bot$出发至多走$h*k$步可以到达$\\top$（$k$个格，每个格走$h$步） 一图流 一点说明（以MAY-analysis为例） Unsafe为bottom，trivially safe为top Truth在这之间，truth之下为unsafe results，之上为safe results Dataflow analysis从bottom开始往上走，越过truth（分析算法的设计本身保证走的方向一定是向上+能走过truth），到达某一个fixed point Fixed points都位于truth上方，dataflow analysis到达的一定是位于最下方的最小fixed point 越往上走precise越差，因为最上面的top是最不precise的结果 Meet-Over-All-Paths Solution (MOP) MOP：用所有路径meet/join的结果作为最终结果 v.s. Ours：单纯对结点进行meet/join处理 MAY-analysis而言，MOP: $F(x)\\sqcup F(y)$; Ours: $F(x\\sqcup y)$ 根据单调性，有$F(x)\\sqcup F(y)\\sqsubseteq F(x\\sqcup y)$, 这说明MOP更precise一些 当$F$ distributive时，上式取等号，两者结果相同； 之前的三个dataflow analysis都是distributive的（Bit-vector, gen-kill都是distributive的） 但也存在不distributive的dataflow analysis，如常量传播 常量传播 $x$在某个程序点是否一定具有某个常量值 Forward Must-analysis Top: UNDEF, Bottom: NAC meet function： NAC $\\sqcap$ $v$ = NAC UNDEF $\\sqcap$ $v$ = UNDEF $c$ $\\sqcap$ $c$ = $c$ $c_1$ $\\sqcap$ $c_2$ = NAC transfer function: for assignment, kill=${x, _}$ x = c: gen=${(x,c)}$ x = y: gen=${(x, val(y))}$ x = y op z: if $val(y),val(z)$ are constants, gen=${(x, val(y)\\; op\\; val(z)}$ if $val(y)=$NAC or $val(z)=$NAC, gen=${(x, \\text{NAC})}$ otherwise, gen=${(x, \\text{UNDEF})}$ —— 这么设计是为了满足单调性 For non-assignment statements, transfer function is the identity function Worklist算法（以Forward analysis为例） 1234567891011OUT[ENTRY] &#x3D; \\emptysetfor each Basic Block B\\ENTRY: OUT[B] &#x3D; \\emptysetWL &#x3D; [all basic blocks]while WL is not empty: B &#x3D; pick a Basic Block from WL old_OUT &#x3D; OUT[B] IN[B] &#x3D; meet all predecessors of B OUT[B] &#x3D; gen + (IN[B] - kill) if OUT[B] !&#x3D; old_OUT: add all successors of B to WL 维护一个Worklist 初始化将所有Basic Block都放进去 每次从里面取一个Basic Block进行迭代 如果该Basic Block的结果发生改变，则把后继都加入Worklist中 过程间分析 如何通过CHA建立call graph 过程间CFG的概念 过程间数据流分析的概念 过程间常量传播 Call Graph 程序中调用关系的一种表示 从call-site到target methods (callee)的call edges的集合 Class Hierachy Analysis (CHA) Java中的函数调用类型 | | Static call | Special call | Virtual call || —————- | ————– | ———————————————————— | —————————– || 指令 | invokestatic | invokespecial | invokeinterface/invokevirtual || Receiver Object | × | √ | √ || Target Methods | Static methods | Constructor; Private instance methods; Superclass instance methods; | Other instance methods || # Target Methods | 1 | 1 | &gt;=1 (多态) || Determinacy | Compile-time | Compile-time | Run-time | 对Virtual Call的处理是OOP语言建立call graph的关键 函数签名 函数签名=class type + 函数名 + descriptor descriptor = return type + parameter type e.g. &lt;C: T foo(P, Q, R)&gt; 运行时方法分配Dispatch($c,m$) $c$: receiver object的class type $m$: 待分配的method call 如果$c$类中含有与$m$函数名descriptor都一致的非抽象方法，则返回该方法；否则在$c$的superclass中继续Dispatch CHA 需要类间的等级信息（继承结构） 基于callsite上的receiver variable的declared type来分析virtual call 假设属于某一个类的receiver variable可能指向它自己以及它的所有子类 CHA - Call Resolution 12345678910111213Resolve(cs): T &#x3D; &#123;&#125; &#x2F;&#x2F; 所有可能被调用的方法集合 m &#x3D; method signature at cs if cs is a static call: T &#x3D; &#123;m&#125; if cs is a special call: c^m &#x3D; class type of m T &#x3D; &#123;Dispatch(c^m, m)&#125; if cs is a virtual call: c &#x3D; declared type of receiver variable at cs for each c&#39; is c itself or a subclass (direct&#x2F;indirect) if c: add Dispatch(c&#39;, m) to T return T 静态方法：它自己 special call：直接去方法所在的类Dispatch virtual call：去receiver variable对应的类本身、所有直接或间接子类都找一遍 快而不准 快：只考虑receiver variable的类型和继承结构；忽略了数据流和控制流信息 不准：容易引入伪目标 用CHA建立Call Graph12345678910111213BuildCallGraph(m^entry): WL&#x3D;[m^entry], RM&#x3D;&#123;&#125;, CG&#x3D;&#123;&#125; while WL is not empty: remove m from WL if m not in RM: add m to RM foreach call site cs in m: T &#x3D; resolve(cs) foreach target method m&#39; in T: add cs -&gt; m&#39; in CG add m&#39; to WL return CG 对Worklist中每一个新加入的方法进行Resolve、将得到的所有可能的目标方法加边并加入Worklist中 过程间CFG (ICFG) ICFG = CFG + call edge + return edge call edge: call site - entry node of callees return edge: return statement - return site (call site的下一条语句) 原CFG中call site - return site之间的边保留：为了不让数据流信息去国外兜一圈 transfer function = node transfer + edge transfer call edge transfer: 传递参数值 return edge transfer: 传递返回值 node transfer: 与过程内基本相同 + 需要kill掉LHS变量，如$b=f(a)$要kill掉$b$ 指针分析 什么是指针分析 理解指针分析的key factors 理解指针分析的分析对象 什么是指针分析 分析每个指针可能指向哪块内存地址 对于OOP语言而言：分析每个变量/field可能指向哪个对象 May-analysis (over-approximation) 别名分析（alias analysis）：两个指针能否指向同一个对象 和PTA不是同一个问题，但PTA的结果可以回答这个问题 Key Factors 堆抽象 Heap Abstraction 如何对堆进行建模（如何表示不同的对象） 把无穷的实际对象抽象为有限的抽象对象 最常用的：Allocation-site Abstraction. 用创建点给对象命名，在同一个创建点创建的对象就是同一个对象 上下文敏感性 Context Sensitivity 如何对上下文进行建模 上下文不敏感：合并一个方法的所有上下文，一个方法只需要分析一次——可能会损失精度 上下文敏感：区别同一个方法不同的上下文，每个上下文分析一次 流敏感性 Flow Sensitivity 如何对控制流进行建模 流敏感：保留语句执行顺序，在每个点维护一个points-to relation的map 流不敏感：把整个程序看成语句的集合，整个程序只维护一个points-to relation map 分析范围 Analysis Scope 分析程序的哪些部分 Whole program v.s. Demand-driven 分析对象 只关心会影响指向关系的语句（pointer-affecting statements） Java中的指针：局部变量、静态域、实例域（instance field）、数组（课程只关心local variable &amp; instance field） 影响指针的语句（5种）：New, Assign, Store, Load, Call 上下文不敏感的指针分析 理解指针分析的rules，包括method call 理解pointer flow graph 理解过程间指针分析的算法 理解on-the-fly的call graph construction 过程内指针分析Rules 定义域与符号标记 Variables: $x,y\\in V$ Fields: $f,g\\in F$ Objects: $o_i, o_j\\in O$ Instance fields: $o_i.f, o_j.g\\in O\\times F$ Pointers: Pointer$=V\\cup (O\\times F)$ Points-to relation: $pt: \\text{Pointer}\\to\\mathcal{P}(O)$ Kind Statement Rule New i: x = new T() $$\\frac{}{o_i\\in pt(x)}$$ Assign x = y $$\\frac{o_i\\in pt(y)}{o_i\\in pt(x)}$$ Store x.f = y $\\frac{o_i\\in pt(x)\\quad o_j\\in pt(y)}{o_j\\in pt(o_i.f)}$ Load y = x.f $\\frac{o_i\\in pt(x)\\quad o_j\\in pt(o_i.f)}{o_j\\in pt(y)}$ 实现 实现关键：当$pt(x)$发生改变时，需要将改变的部分传播到和$x$有关的指针上 PFG：表示指针间的关联关系，将改变部分传播到一个指针的所有后继 表达了对象如何在指针间流动的有向图 Nodes: Pointer Edge: Pointer $\\to$ Pointer $x\\to y$: $x$指向对象会流向$y$，$y$也会指向$x$指向的对象 建立PFG和在PFG上传递指向关系是互相依赖的——PFG是动态更新的 过程内指针分析-算法伪代码略，见过程间指针分析的算法 准备工作 为所有的New语句创建对象并加入WL 为所有的Assign语句加边 主循环： 迭代WL中的&lt;目标指针，待传播对象&gt;二元组 先对该二元组进行差量传播 如果目标指针是变量而非instance field，就迭代所有待传播对象和该变量的所有Load/Store语句，进行加边操作 AddEdge($s,t$) 加边操作 判断要加的边是否已经存在，如果是新的边再进行后续操作 在PFG中加上这条边（唯一会修改PFG的操作） 如果边的起点已经有一些指向对象，就放入WL中，方便后续把这些对象传播到终点上 Propagate($n, pts$) 传播操作 如果待传播的对象集合是空集，就什么都不做 把待传播的对象集合加到目标指针$n$的$pt$集中（唯一会修改$pt$集合的操作） 把目标指针的后继和待传播对象都加入WL，以便后续传递 差量传播：减少冗余信息的传递。一个指针如果已经在某个结点的$pt$集中，就不用进行二次传播了 过程间指针分析Rules对于语句l: r = x.k(a1, ..., an)$$\\frac{o_i\\in pt(x),\\quad m=\\text{Dispatch}(o_i, k)\\o_u\\in pt(a_j),\\; 1\\le j\\le n\\o_v\\in pt(m_{ret})}{o_i\\in pt(m_{this})\\o_u\\in pt(m_{p_j}),\\; 1\\le j\\le n\\o_v\\in pt(r)}$$ 规则做了三件事： 传递this变量的对象 传递参数的对象 传递返回值的对象 PFG加边 对应参数间：实参$\\to$形参 返回值间：方法返回值$\\to$LHS variable receiver object到$m_{this}$间不加边，否则会损失精度 Call Graph的建立：从入口方法开始逐渐探索可达世界——到不了的都是死代码，提升精度和速度 过程间指针分析-算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Solve(m_entry): WL&#x3D;[], RM&#x3D;&#123;&#125;, PFG&#x3D;&#123;&#125;, CFG&#x3D;&#123;&#125;, S&#x3D;&#123;&#125; AddReachable(m_entry) while WL is not empty: remove &lt;n, pts&gt; from WL delta &#x3D; pts - pt(n) Propogate(n, delta) if n represents a variable x: foreach o_i in delta: foreach x.f &#x3D; y in S: AddEdge(y, o_i.f) foreach y &#x3D; x.f in S: AddEdge(o_i.f, y) ProcessCall(x, o_i)AddEdge(s, t): if s-&gt;t not in PFG: add s-&gt;t to PFG if pt(s) not empty: add &lt;t, pt(s)&gt; to WLPropogate(n, pts): if pts not empty: pt(n) +&#x3D; pts foreach n-&gt;s in PFG: add &lt;s, pts&gt; to WL AddReachable(m): if m not in RM: add m to RM S +&#x3D; S_m foreach i: x &#x3D; new T() in S_m: add &lt;x, &#123;o_i&#125;&gt; to WL foreach x &#x3D; y in S_m: AddEdge(y, x) ProcessCall(x, o_i) foreach l: r &#x3D; x.k(a1, ..., an) in S: m &#x3D; Dispatch(o_i, k) add &lt;m_this, o_i&gt; to WL if l-&gt; m not CG: add l-&gt;m in CG AddReachable(m) foreach parameter p_j of m: AddEdge(a_j, p_j) AddEdge(m_ret, r) 准备工作 初始化Worklist($WL$), 可达方法集合$RM$, PFG, CFG, 所有语句的集合$S$ 将入口方法标记可达 主循环（基本同过程内，多了一步ProcessCall） 迭代WL里所有的&lt;目标指针，待传播对象&gt;二元组 对目标指针做差量传播 如果目标指针是个变量，就迭代所有待传播对象：对所有Load/Store语句，进行加边操作；处理该变量的所有方法调用 AddReachable($m$) 标记可达 如果该方法已经在可达集合内，就什么都不做 将该方法加入可达集合 将该方法的所有语句加入语句集合 处理该方法内的所有New语句和Assign语句，同过程间分析的准备工作，New加WL，Assign加边 ProcessCall($x, o_i$) 处理某个变量的所有方法调用 迭代该变量的所有方法调用，迭代Dispatch出的所有目标方法 将当前对象与目标方法的this变量加入WL，以便后续传播 如果调用点至目标方法的边($l\\to m$)已经在CG中，就什么也不做 更新调用关系：将调用边加入CG；将$m$标记可达；参数和返回值间PFG加边（注意方向） 上下文敏感的指针分析 上下文敏感的概念（C.S.） 上下文敏感堆的概念（C.S.heap） 为什么C.S.和C.S.heap能提升精度 上下文敏感指针分析的rules 上下文敏感指针分析的算法 常见的context sensitivity variants 不同variants的区别和关系 上下文敏感 上下文不敏感：不同的数据流通过参数和返回值被merge到了一起，造成不准 上下文敏感：通过区分不同上下文的不同数据流来建模calling context clone-based上下文敏感 方法被不同的context复制成多份 变量也被不同的context复制成多份 上下文敏感的堆抽象： 抽象对象也区分不同的上下文（成为堆上下文） 堆上下文一般直接使用分配时所在方法的上下文 Rules 定义域与符号 所有元素都会被上下文修饰（field挂靠在对象上，对象已经被上下文修饰，所以field不需要额外的修饰） Context: $c, c’, c’’\\in C$ Context-sensitive methods: $c:m\\in C\\times M$ Context-sensitive variables: $c:x, c’:y\\in C\\times V$ Context-sensitive objects: $c:o_i, c’:o_j\\in C\\times O$ Fields: $f,g\\in F$ Context-sensitive instance fields: $c:o_i.f, c’:o_j.g\\in C\\times O\\times F$ Context-sensitive pointers: CSPointer=$(C\\times V)\\cup (C\\times O\\times F)$ Points-to relations: $pt: \\text{CSPointer}\\to \\mathcal(C\\times O)$ Kind Statement Rule New i: x = new T() $$\\frac{}{c:o_i\\in pt(c:x)}$$ Assign x = y $$\\frac{c’:o_i\\in pt(c:y)}{c’:o_i\\in pt(c:x)}$$ Store x.f = y $\\frac{c’:o_i\\in pt(c:x)\\quad c’’:o_j\\in pt(c:y)}{c’’:o_j\\in pt(c’:o_i.f)}$ Load y = x.f $\\frac{c’:o_i\\in pt(c:x)\\quad c’’:o_j\\in pt(c’:o_i.f)}{c’’:o_j\\in pt(c:y)}$ Call: l: r = x.k(a1, ..., an)$$\\frac{c’:o_i\\in pt(c:x),\\m=Dispatch(o_i,k),\\quad c^t=Select(c,l, c’:o_i)\\c’’:o_u\\in pt(c:a_j),\\; 1\\le j\\le n\\c’’’:o_v\\in pt(c^t:m_{ret})}{c’:o_i\\in pt(c^t:m_{this})\\c’’:o_u\\in pt(c^t: m_{pj}),\\; 1\\le j\\le n\\c’’’:o_v\\in pt(c: r)}$$ 上下文敏感指针分析-算法只在不敏感算法的基础上加上了上下文，以及ProcessCall的时候多了一步创建上下文的Select 初始上下文为空（[]） 注意Call Graph也是带有上下文的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Solve(m_entry): WL&#x3D;[], RM&#x3D;&#123;&#125;, PFG&#x3D;&#123;&#125;, CFG&#x3D;&#123;&#125;, S&#x3D;&#123;&#125; AddReachable([]:m_entry) while WL is not empty: remove &lt;n, pts&gt; from WL delta &#x3D; pts - pt(n) Propogate(c:n, delta) if n represents a variable c:x: foreach c&#39;:o_i in delta: foreach x.f &#x3D; y in S: AddEdge(c:y, c&#39;:o_i.f) foreach y &#x3D; x.f in S: AddEdge(c&#39;:o_i.f, c:y) ProcessCall(c:x, c&#39;o_i)AddEdge(s, t): if s-&gt;t not in PFG: add s-&gt;t to PFG if pt(s) not empty: add &lt;t, pt(s)&gt; to WLPropogate(n, pts): if pts not empty: pt(n) +&#x3D; pts foreach n-&gt;s in PFG: add &lt;s, pts&gt; to WL AddReachable(c:m): if c:m not in RM: add c:m to RM S +&#x3D; S_m foreach i: x &#x3D; new T() in S_m: add &lt;c:x, &#123;c:o_i&#125;&gt; to WL foreach x &#x3D; y in S_m: AddEdge(c:y, c:x) ProcessCall(c:x, c&#39;:o_i) foreach l: r &#x3D; x.k(a1, ..., an) in S: m &#x3D; Dispatch(o_i, k) c^t &#x3D; Select(c, l, c&#39;:o_i) add &lt;c^t: m_this, &#123;c&#39;:o_i&#125;&gt; to WL if c:l-&gt; c^t:m not CG: add c:l-&gt; c^t:m in CG AddReachable(c^t:m) foreach parameter c^t:p_j of m: AddEdge(c:a_j, c^t:p_j) AddEdge(c^t:m_ret, c:r) Context Sensitivity VariantsC.I.可以看成一种特殊的上下文 k-limiting 保证context有限，程序可以终止（递归警告） 防止context过大原地爆炸 设置context长度上限为k，只保留最后k个context k一般取小数字（$\\le 3$ 方法上下文和堆上下文的$k$可以不同 Call-site sensitivity context: a list of call sites (call chain) callee context: 把call site加到caller context的末尾 又称k-CFA Object sensitivity context: a list of abstract objects callee context: 把receiver object加到caller context的末尾 Type sensitivity context: a list of types callee context: 在caller context的末尾加上包含receiver object的allocation site的方法的类型（注意不是receiver object本身的类型） 三者比较 统一来说没有哪种最好 在Java这样的OOP语言中，$k$相同时 精度：Object&gt; Type &gt; Call-site 效率：Type &gt; Object &gt; Call-site 静态分析for Security 信息流安全性的概念 Confidentiality（保密性）and integrity （完整性） Explicit flow（明流） and covert channels（隐藏信道） 使用污点分析来检测不想要的信息流 Information Flow Security Security：考虑对手存在的情况下达到某些目的 信息流 信息流$x\\to y$: 变量$x$中的信息会传播到变量$y$ 把程序中的变量分成不同security level，最基本的模型是2-level policy (high/low security) 安全等级可以建模成格 Information Flow policy 限制了信息流如何在不同的security level之间流动 Noninterference policy: high-security变量中的信息不能流动到low-security变量中，否则就可能通过观测low变量反推出high变量 保证了信息流在格中只能向上（高机密性方向）流动 保密性与完整性 保密性 阻止重要信息的泄露 不能让高的写入低的 读保护 完整性： 阻止危险信息进来 不能让低的写入高的 写保护 二者是对偶关系 完整性——广义定义 Correctness 正确性：对于信息流完整性而言，就是上面的侠义定义，关键数据不能被危险数据污染 Completeness: e.g. 数据库系统应该完整地存储所有数据 Consistency: e.g. 文件交换系统需要确保收发端的文件保持一致 Explicit flow &amp; covert channels Expilict flow: 通过直接拷贝（赋值）传递信息流 Covert channels 隐藏信道 信道：mechanisms for signaling information through a computing system 隐藏信道：主要目的并非传播信息的信道 e.g. implicit flows (通过控制流泄露机密信息), termination channels (观察循环是否会终止), Timing channels (观察程序执行时间), Exceptions (观察程序是否会抛出异常), 用电量，cache命中率，……. 能泄露的信息有限+攻击难度大，所以一般不去专门预防 污点分析 把程序中的数据分为两类 Tainted data 污点数据：给关心的数据打上标签，就像同位素标记一样 其他数据：不关心的数据 Sources 源：污点数据来的地方，一般是某些方法的返回值 污点分析关注污点数据在程序内流动的方式，会不会留到某些关心的地方（sink），sink一般是一些敏感的方法 应用： 保密性：Source: 秘密数据的来源； Sink：泄露部位 完整性：Source: 不信任的数据来源；Sink：关键的计算步骤 与指针分析： 把tainted data看成一个抽象对象 Source: 看成Allocation site 使用指针分析来传播数据 定义域与符号 比指针分析多了一个Tainted data: $t_i, t_j\\in T\\subset O$ $t_i$指来自$i$这个call site的污点数据 输入输出 输入： Source: 一系列会返回污点数据的方法 Sink: 一系列sink methods，污点数据一旦流进这些方法就意味着违反了security policy 输出： Taintflows: 一系列&lt;污点数据，sink method&gt;二元组，表示污点数据可能会流动到这个sink method Rules 指针分析rules + 对Source和Sink的处理 Source rule: l: r = x.k(a1, ..., an)$$\\frac{l\\to m\\in CG\\m\\in Sources}{t_l\\in pt(r)}$$ Sink rule: l: r = x.k(a1, ..., an)$$\\frac{l\\to m\\in CG\\m\\in Sinks\\\\exists i, 1\\le i\\le n, t_j\\in pt(a_i)}{\\langle t_j, m\\rangle\\in TaintFlows}$$ 一些特殊的API（如String的拷贝赋值）需要特殊处理 注意：给指针添加污点数据的时候别忘了把正常的指向对象也加进去 基于Datalog的程序分析 Datalog language 如何用Datalog实现指针分析 如何用Datalog实现污点分析 Datalog Datalog是一种命令式的逻辑编程语言，是Prolog的子集 Datalog = data + logic: 无副作用、无函数、无控制流；因此不是图灵完备的 Predicate (Data) relation, a set of statements a table of data Atoms Datalog的基本元素是relational atom，是一类具有如下形态的Predicate：P(X1, X2, ... Xn)，其中P为Predicate的名称，X1,... Xn是Argument(Term) Term可以是变量或者常数 e.g. Age(person, age), Age(&quot;Xiaoming&quot;, 18) P(X1, X2, ..., Xn)求值为true当且仅当表P包含元组(X1, X2,..., Xn) Datalog也有arithmetic atom, e.g. age &gt;=18 Datalog Rules Rule用来表达逻辑的推里关系 Rule的形式为H &lt;- B1, B2, ..., Bn. H: Head, 结果，是一个Atom B1, B2, ..., Bn：Body, 前件，每个Bi都是一个Atom，是subgoal 含义：head is true if body is true 逗号表示逻辑与，Body里每一个subgoal都为true时才能推出Head为true e.g. Adult(person) &lt;- Age(person, age), age &gt;= 18. Rule的解读：H(X1, X2) &lt;- B1(X1, X3), B2(X2, X4), ..., Bn(Xm). 枚举所有变量可能的取值的组合 如果某种变量取值的组合能使subgoals全部为true，则在这个取值组合下Head也为true Head Predicate包含了所有true atoms，也是一张表 EDB &amp; IDB Prdicates Datalog Program = Facts + Rules = EDB + IDB + Rules EDB (extensional database): 提前准备好的谓词；不可变（虽然有些Datalog的实现中也许可变）；可以看成程序输入；相当于给定的Facts IDB (internal database): 通过Rules推断出来的谓词，可以看成程序输出； 对于一条Rule来说，Head必须是IDB，Body里的subgoals可以时EDB也可以是IDB 逻辑或 Head相同的不同规则可以表示逻辑或 分号也可以用来表示逻辑或，e.g. Otaku(person) &lt;- Suki(person, anime); Suki(person, manga); Suki(person, galgame) 逻辑与的优先级更高（仿佛是什么业界共识） 否定 Body里的Subgoal可以是否定形式，表示为!B(...) e.g. MakeupExamStd(student) &lt;- Student(student), !PassedStd(student) 递归rules IDB predicate可以我推我自己（直接或间接） e.g. 12Reach(from, to) &lt;- Edge(from, to).Reach(from, to) &lt;- Reach(from, node), Edge(node, to). 递归让datalog可以表示复杂的程序分析问题 Rule Safety 当每一个变量都至少出现在一个非否定形式的relational atom中，一条规则才是安全的 有无限表项的Predicate是unsafe的 Datalog只会允许safe rules 递归和否定必须分开，不然会出现自相矛盾的rules，e.g. A(x) &lt;- B(x), !A(x) Datalog Program的执行 Datalog Engine从EDB开始推断所有能推断的facts，直到没有新facts为止 Datalog Rules的单调性和facts的有限性确保了程序一定能终止 Datalog实现指针分析 EDB：程序语句 New(x: V, o: O) Assign(x: V, y: V) Store(x: V, f: F, y: V) Load(y: V, x: V, f: F) IDB：指针的指向关系 VarPointsTo(v: V, o: O) FieldPointsTo(oi: O, f: F, o: O) Rules：直接翻译就完事了 | Kind | Statement | Rule | DataLog Rule || —— | —————- | ——————————————————— | ———————————————————— || New | i: x = new T() | $$\\frac{}{o_i\\in pt(x)}$$ | VarPointsTo(x, oi) &lt;- New(x, oi) || Assign | x = y | $$\\frac{o_i\\in pt(y)}{o_i\\in pt(x)}$$ | VarPointsTo(oi, x) &lt;- Assign(x, y), VarPointsTo(oi, y) || Store | x.f = y | $\\frac{o_i\\in pt(x)\\quad o_j\\in pt(y)}{o_j\\in pt(o_i.f)}$ | FieldPointsTo(oi, f, oj) &lt;- Store(x, f, y), VarPointsTo(x, oi), VarPointsTo(y, oj) || Load | y = x.f | $\\frac{o_i\\in pt(x)\\quad o_j\\in pt(o_i.f)}{o_j\\in pt(y)}$ | VarPointsTo(y, oj) &lt;- Load(y, x, f), VarPointsTo(x, oi), FieldPointsTo(oi, f, oj) | Method Call Domains: Statements - S, Methods - M EDB 调用语句 VCall(l: S, x: V, k: M) Dispatch(x: V, k: M, m: M) ThisVar(m: M, this: V) Argument(l: S, i: N, ai: V) Parameter(m: M, i: N, pi: V) MethodReturn(m: M, ret: V) CallReturn(l: S, r: V) IDB Reachable(m: M) CallGraph(l: S, m: M) Rules: 分三条表述 1234567891011121314151617181920212223242526272829&#x2F;&#x2F; 处理调用关系和this变量VarPointsTo(this, o),Reachable(m),CallGraph(l, m) &lt;- VCall(l, x, k), Dispatch(x, k, m), ThisVar(m, this), VarPointsTo(x, o).&#x2F;&#x2F; 处理参数VarPointsTo(pi, o) &lt;- CallGraph(l, m), Argument(l, i, ai), Parameter(m, i, pi), VarPointsTo(ai, o). &#x2F;&#x2F; 处理返回值VarPointsTo(r, o) &lt;- CallGraph(l, m), MethodReturn(m, ret), CallReturn(l, r), VarPointsTo(ret, o).&#x2F;&#x2F; 额外增加（修改）&#x2F;&#x2F; 入口规则Reachable(m) &lt;- EntryMethod(m).&#x2F;&#x2F; 阻止分析不可达方法VarPointsTo(x, o) &lt;- Reachable(m), New(x, o, m). 利弊 利 简洁易读 容易实现 受益于现成的Datalog Engine 弊 表达能力有限 不理解内部实现，无法控制performance Datalog实现污点分析在指针分析的基础上加一点东西就可以了 EDB Source(m: M) Sink(m: M) Taint(l: S, t: T)：把taint data和call site联系起来 IDB TaintFlow(t: T, m: M) Rules 123456789101112VarPointsTo(r, t) &lt;- CallGraph(l, m), CallReturn(l, r), Source(m), Taint(l, t).TaintFlow(t, m) &lt;- CallGraph(l, m), Sink(m), Argument(l, _, ai), VarPointsTo(ai, t), Taint(_, t). Soundiness 理解soundiness的动机和概念 理解为什么Java的反射机制和native code难以分析 Soundiness-动机 现实中很难实现Soundness，因为存在很多hard language features(静态分析难以处理的feature) 实际分析时，一般指关心sound core，对hard language features采取不处理或简略处理的态度——可能会误导读者——所以提出了Soundiness Soundiness-概念 Soundy analysis：mostly true + well-defined unsound treatments to hard/specific language features Soundness, soundiness, unsound sound: 捕捉所有的动态行为 soundy: 尽量捕捉所有动态行为，一些hard language feature在合理限度内unsound unsound：出于某些目的忽略掉一些行为 Java 反射机制 为什么难分析：哪个类、哪个方法完全是Run-time决定的 当前解决方法 String Constant Analysis + PTA Type Inference + String Analysis + PTA 动态分析（不sound，结果取决于实际执行路径） Java Native Code Java Native Interface (JNI): JVM的一个模块，允许Java与Native C/C++ code进行交互 为什么难分析：对于Java的分析器来说，你不知道native code里面发生了什么（自己写的） 当前解决方法：替换成功能相同的java code CFL-Reachability 理解CFL-Reachability 理解IFDS的基本思想 理解IFDS能解决什么样的问题 CFL-Reachability Realizable path: return和call相匹配的路径 不一定会执行到，但unrealizable path一定不会执行到（所有路径 &gt; 可执行路径 &gt; 实际执行路径） 识别出Realizable path，防止Unrealizable path污染结果 —— 括号匹配问题 CFL-Reachability A到B可达，仅当A到B存在一条路径，该路径上所有边的label拼起来构成给定的CFG中一个合法的单词 在call/return匹配这里，合法的单词就是正常匹配的左右括号$$\\begin{align}realizable &amp;\\to matched\\quad realizable\\&amp;\\to (_i\\quad realizable\\&amp;\\to \\varepsilon\\matched &amp;\\to (_i\\quad matched \\quad)_i\\&amp;\\to e\\&amp;\\to \\varepsilon\\&amp;\\to matched\\quad matched\\end{align}$$ IFDS 基于图可达性的一个程序分析框架 Interprocedural, finite, distributive, subset MRP (Meet-over-all-realizable-path) solution Path function可以看成路径上的flow function复合后的结果 MRP就是把所有可行路径的path function meet/join起来 Overview: 给定程序$P$和分析问题$Q$ 为程序$P$建立supergraph $G^$, 基于$Q$定义$G^$中边上的flow function 通过把flow function转换成representation relations(graph), 建立exploded supergraph $G^#$ $Q$可以通过应用Tabulation algorithm解决图可达性问题来解决 Supergraph 每个方法首位加上入口节点和出口节点，所有方法调用拆成调用点和返回点，根据调用关系连接起来 Flow function: possibly-unintialized variables, 在某个程序点上可能未被初始化的变量，用lambda函数的形式表示 Exploded Supergraph 每个flow function都可以用2(D+1)个结点的图来表示，D是dataflow facts的有限集合 Representation relation of flow function $f$: $R_f\\in (D\\cup 0)\\times (D\\cup 0)$$$\\begin{align}R_f=&amp;{(0,0)}\\cup {(0,y)\\mid y\\in f(\\emptyset)}\\cup{(x,y)\\mid y\\in f(x)\\wedge y\\notin f(\\emptyset)}\\end{align}$$ 0-&gt;0边：为了让data facts能传递下去 Tabulation Algorithm 求解从&lt;$s_{main}, 0$&gt; 到&lt;$n,d$&gt;是否存在可行路径，若存在则$d\\in MRP_n$ $O(ED^3)$ 当处理出口结点时开始进行call-to-return matching Distributivity: flow function必须要满足Distributivity，诸如$x\\wedge y$这样的需要依赖多个变量的关系表达不出来，因此IFDS不能用来实现CP或者PTA（别名关系无法表达）","categories":[],"tags":[{"name":"Notes; Programming Languages;","slug":"Notes-Programming-Languages","permalink":"https://mengzelev.github.io/tags/Notes-Programming-Languages/"}]},{"title":"MIT公开课——如何演讲","slug":"MIT-how-to-speak","date":"2020-12-27T15:57:40.000Z","updated":"2020-12-27T16:14:03.423Z","comments":true,"path":"2020/12/27/MIT-how-to-speak/","link":"","permalink":"https://mengzelev.github.io/2020/12/27/MIT-how-to-speak/","excerpt":"","text":"MIT公开课——如何演讲最近又是毕业论文报告开题，又是申请季面试，需要向人介绍自己的研究经历。被导师推荐了这个视频，不愧是大牛，不失幽默的同时句句在理，受益匪浅。决定整理成功笔记供今后反复学习。因为是写给自己看的takeaway notes，所以会比较随意。 开场鸡汤成功的程度取决于：说话的能力，写作的能力和思想的质量 上述三点的质量取决于：知识&gt;实践&gt;天赋 基础技巧How to start 不推荐joke，因为观众还没有习惯你的声音和说话方式 给观众一个promise，告诉他们在接下来的一段时间内他们能学到什么 启发性建议 Cycle on the subject: 反复重复你的主题，确保观众可以记住 Build a fence around your idea: 举几个“反例”，说出你的观点和他人观点是如何的不同，以免观众混淆你的观点与他人的观点 Verbal punctuation: 观众有时候可能会lost，你需要提供一些landmark，让他们随时都能中途再上车；同时也能体现你的演讲的层次感 Ask a question: 等待回答的标准时间是7s 演讲的时间和地点 Perfect time: 11 a.m. 地点：光线良好（不要考虑ppt的问题） 去场地踩点，提前为一些可能的意外情况做准备（想象座位上做的都是disinterested farm animals) 合理安排的坐席：到座率一半以上 板书，道具和slides","categories":[],"tags":[]},{"title":"西蒙·波伏娃《第二性》读书笔记","slug":"Le-Deuxieme-Sexe","date":"2020-06-27T08:31:07.000Z","updated":"2020-06-27T12:42:13.632Z","comments":true,"path":"2020/06/27/Le-Deuxieme-Sexe/","link":"","permalink":"https://mengzelev.github.io/2020/06/27/Le-Deuxieme-Sexe/","excerpt":"","text":"《第二性》读书笔记书籍简介（摘自中文维基百科词条)） 《第二性》（法语：Le Deuxième Sexe）是一部关于存在主义和女性主义的散文，在作者西蒙·波娃41岁时，1949年创作并出版。整部作品分为上下两卷，被公认为是一部哲学著作。波伏娃选择从存在主义角度出发展开论述。也正因如此，她的这部作品不仅仅是简单地论述了妇女在二战之后的状况，总的来说，这是一部哲学作品，从文学、历史、社会学、生物学和医学多方面进行丰富地举例和分析。整部作品通篇所想传达的理念是没有一个女人的命运是计划好的。排除人类的决定论，对于女性弱势这一事实以及导致这一事实的与生俱来的原因这两点，波伏娃在作品中都加以关注和论述。对于这个问题，存在主义暗示了整个人类的责任：波伏娃不仅控诉男人对于女人的歧视、卑鄙甚至有时残忍的所作所为，同时也指出了女人对于自己弱势地位的造成也有不可推卸的责任，波伏娃认为她们被动、屈服、缺乏雄心。作者因此认为女性解放的成功唯有依靠男性与女性的共同的坚定意志才能实现。在波伏娃看来，女性获得解放必须依靠以下两个途径：对于生育与否的自我决定权以及工作。《第二性》被译成各种语言，全球销量超过几百万册，时至今日，仍是女权哲学的“圣经”。 各章节摘抄与批注第一部 命运第一章 生物学论据 生命只有超越自身才能得到维持，只有在得到维持的条件下才能超越自身；这两个时刻总是一起完成的，企图分开它们是空想。 无论在蚂蚁、蜜蜂、白蚁中，还是在蜘蛛或螳螂中，都不能说磁性奴役和吞噬雄性：是物种通过不同的途径吞噬两者。……将雌性当做奴隶的物种要处罚雄性，雄性想逃避物种，便被物种残暴地消灭。 不过，在哺乳动物的雄性和雌性之间的根本区别是，在迅速掠过的同一时刻，雄性的生命通过精子在他者身上超越自己，精子变成与之不相干，脱离其身体；因此，正当雄性超越自身个体性时，却重新封闭在其中。相反，卵子成熟时脱离了滤泡，落入输卵管内，开始与雌性分离；而被一个外来配子侵入的卵子安顿在子宫里：雌性显示被侵犯，随后被异化。……雌性越是像一个分离的个体，生命的延续就越是在分离之外威严地确立下来。 在雌性摆脱母性制约的时候，有时能同雄性并驾齐驱：母马同种公马跑得一样快，母猎狗同公狗嗅觉一样灵敏，雌猴在接收试验时，表现出同雄猴一样聪明。只不过这种个体性没有得到表现机会：雌性由于物种要求让位而让位。 当机体的个体性进一步确立时，性别的对抗并不减弱：恰恰相反。雄性找到越来越多种多样的道路，以便消耗它掌握的力量；雌性则越来越感到收到奴役；在它自身的利益和植根于它身上的生殖力的利益之间的冲突加剧了。 在所有雌性哺乳动物中，女人是受到异化程度最高的，并且最激烈地拒绝这种异化；任何雌性哺乳动物，机体对生殖职能的从属都没有如此迫切，接受起来也没有如此困难：青春期和更年期的危机，每月的“诅咒”，长时间而困难的妊娠，痛苦的、有时危险的分娩，疾病、事故，是女人的特点：可以说，因为她要确定自身为个体，要起来反抗命运，所以她的命运显得更为悲苦。如果将女人与男人相比较，男人便显得无比地具有特权：男人的生殖力不与他的个人生存相冲突；这是以持续的方式进行的，没有危机，一般来说没有事故。 这些生物学论据极为重要，它们在女人的历史中起着头等重要的作用，是女人处境的一个本质因素，……但我们拒绝这种观点：它们对女人而言构成固定不变的命运。它们不足以确定性别的等级；它们不能解释女人为什么是他者；它们不能将女人判定为永远扮演从属的角色。 只有根据人给自身提出的目的、人所掌握的工具和人制定的法则，“弱点”才显现为弱点。 生理学并不能建立价值：更确切地说，生物学论据具有生存者赋予它的价值。 女人对物种的屈从、她个人能力的局限，是极其重要的事实；女人的身体是她在世界上所占处境的基本因素之一，但并非这一点就足以界定女人；这个因素只有通过行动和在一个社会内部被意识承担起来，才具有体验过的实在；生物学不足以对我们关注的问题提供答案：为什么女人是他者？要知道的是，在女人身上，在历史过程中，自认怎样被攫取了；要知道的是，人类把女性变成了什么。 这一章中作者通过考查各种各样的生物探究了性别的生物学本源，从生物学观点上否认了任何一种性别的被动性以及过往的一些哲学中性别的既定性观点和对性别的偏见。通过分析不同物种的交配与繁殖方式，得出结论：两性都或多或少收到物种的制约，在高级的生命形式中，雌性收到的来自物种的制约比雄性更大。但作者反对任何仅从生物学角度就对人类社会中两性成功机会是否相同与何者对物种起着更重要作用进行回答。要回答序言中所提出的“女人为什么是他者”的问题，还需要进行更多社会学方面的考量。 第二章 精神分析观点感觉自己缺乏很多基础知识，这一章没有怎么看懂，故先不做摘抄评论 以下摘自维基百科 波伏娃从心理分析学角度出发提出两个论点：首先，对于那些一味效仿男人的女人，并不是她要讨论的；第二个论点建立在某些先决条件上，例如父权统治，这使在男人和女人身上产生某种决定论。这一理论与存在主义是相对的，后者认为人可以自发选择自己的命运和价值。宿命论无法解释存在在男性与女性之间的不平等。 第三章 历史唯物主义观点 恩格斯在《家庭、私有制和国家的起源》中描述了女人的历史：这历史本质上取决于技术史。……“从前保证妇女在家中占统治地位的同一原因——妇女只限于从事家务劳动——现在却保证男子在家中占统治地位；妇女的家庭劳动同男子谋取生活资料的劳动比较起来失去了意义——男子的劳动就是一切，妇女的劳动是无足轻重的附属品。”……“妇女的解放，只有在妇女可以大量地、社会规模地参加生产，而家务劳动只占她们极少的工夫的时候，才有可能。而这只有依靠现代大工业才能办到，现代大工业不仅容许大量的妇女劳动，而且是真正要求这样的劳动……” ……性别的劳动分工本来可以称为友好的联合。如果男人与他的同类的原始关系仅仅是友谊关系，就不能解释任何类型的奴役：这个现象是人竭力在客观上获得主宰地位的意识扩张的结果。 在阶级分化中没有任何生物学的基础；在劳动中，努力意识到自身与主人的差别；无产者总是在反抗自身状况，重新称为本质，对剥削者构成一种威胁；其追求的是作为阶级消失。……女人身上没有任何革命的愿望，她不会作为性别自我消失：她仅仅要求取消某些性别特殊化的后果。更为严重的是，人们不会不带自欺地把女人只看做劳动者；无论在社会经济还是在个人生活中，她的生育作用和她的生产能力是同样重要的。在某些时代，生孩子比扶犁更有用。……消灭家庭不一定能解放妇女：斯巴达和纳粹政权的例子证明，直接依附于国家，女人并不会少受男性的压迫。 人们不会强迫女人生孩子：所能做的是，把她紧闭在某种处境中，怀孕对她来说是唯一的出路：法律和风俗把婚姻强加给她，禁止避孕措施和人工流产，禁止离婚。 ……不可能把女人仅仅看做一种生产力：她对于男人来说是一个性伙伴，一个生儿育女者，一个性欲对象，一个他者，通过她，男人寻找自己。 作者在一定程度上肯定了历史唯物主义对女性受到压迫原因的解释，即私有制的产生，但并非完全认同。她认为历史唯物主义过分地将原因归结于经济，而忽视了人渴望获得主宰地位的意识扩张。妇女同无产者是不同的，妇女除了生产能力还拥有着生育能力，有些时候国家和社会觊觎着妇女的生育能力，因此消灭阶级和家庭只能将妇女从家庭劳动中解放出来，但生育问题的存在使这并不能够真正解放妇女。作者拒绝了恩格斯的经济一元论，“推销”自己的存在主义观点，“只有存在主义的基础能够让人从整体理解生命这种特殊形式”。（存在主义是什么还没有看懂","categories":[],"tags":[]},{"title":"面向对象设计原则-课程笔记","slug":"OOP-design-patterns","date":"2020-06-24T06:48:28.000Z","updated":"2020-06-24T06:49:17.332Z","comments":true,"path":"2020/06/24/OOP-design-patterns/","link":"","permalink":"https://mengzelev.github.io/2020/06/24/OOP-design-patterns/","excerpt":"","text":"OOP设计原则单一职责原则（SRP） 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中 e.g.矩形的绘制方法（图形意义上的矩形）和矩形的求面积方法（数学意义上的矩形）分开，分别实现在Rectangle类和GeometricRectangle类中 开放-封闭原则（OCP） “向扩展开放，向修改关闭” 不修改源代码实现对实体功能的扩展（继承） e.g.图形类声明Draw()方法，方形圆形等作为子类扩展父类的Draw()方法 里氏替换原则（LSP） 所有引用基类的地方必须能透明地使用其子类对象 规定了继承关系的形式 相当于更弱的precondition和更强的postcondition e.g.正方形不能成为长方形的一个子类，因为调用长方形设置长宽的方法的地方，替换成正方形的设置长宽的方法会导致程序状态于原来不一致 依赖倒置原则（DIP） 高层模块不应该依赖底层模块（传统设计模式），应该都依赖抽象。 在高层与低层之间设置Adapter（抽象层），Adapter规定了模块间通信的抽象。这样高层可以更换不同的低层实现，提高复用性。 接口隔离原则（ISP） 客户端不应该依赖那些它不需要的接口。 把太大的接口（胖接口）分割成一些更细小的接口。 合成/聚合复用原则（CARP） 优先使用对象组合，而不是继承来达到复用目的 聚合：拥有关系，整体与部分的关系（汽车和引擎） 合成：更强的拥有关系，部分离不开整体，部分和整体的生命周期是一样的（脸和嘴） Coad法则：什么时候使用继承 Is-A关系：继承；Has-A关系：聚合 永远不要出现需要将子类替换成另外一个类的子类的情况 子类不能大量置换超类行为 分类学角度上有意义（这啥 不要从工具类继承 迪米特法则（LoD） 最少知识原则（LKP） 每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位 e.g.将界面中各种控件都只与一个mediator(中间者)依赖，而不互相依赖 设计模式创建型模式简单工厂模式 Simple Factory 定义：定义一个工厂类，它可以根据不同的参数返回不同的实例，被创建的实例通常都具有共同的父类 用于创建实例的方法通常为静态工厂方法 目的：由一个工厂对象决定创建出哪一种产品类的实例 动机：负责将大量有共同接口的类实例化 要点：只需传入一个正确的参数就可以获取所需对象，而无需知晓实现细节 实现：一堆if-else语句 1234567if(arg.equalsIgnoreCase(&quot;Apple&quot;)) &#123; return new Apple();&#125;else if(arg.equalsIgnoreCase(&quot;Banan&quot;)) &#123; return new Banana();&#125;else if ... 参与者 Product：定义产品共同拥有的接口 Concrete Product：具体产品，实现Product接口 Creator(工厂类)：创建产品对象 简化：将抽象产品类和工厂类合并，静态工厂方法转移到抽象产品类中 Java创建对象的方式 new 反射机制 程序运行时获取已知名称的类或已有对象的相关信息的一种机制,包括类的方法、属性、父类等信息,还包括实例的创建和实例类型的判断等 ```JavaClass c=Class.forName(“java.lang.String”);Object obj=c.newInstance();return obj; 123456789+ 配置文件：可以将类名存储在配置文件中,例如具体工厂类的类名 &#96;&#96;&#96;xml &lt;!— config.xml --&gt; &lt;?xml version&#x3D;&quot;1.0&quot;?&gt; &lt;config&gt; &lt;className&gt;designpatterns.factorymethod.FileLoggerFactory&lt;&#x2F;className&gt; &lt;&#x2F;config&gt; 克隆方法 工厂类 SRP：将对象的创建和使用分离。两个类的关系只能是A创建B或A使用Ｂ。 不符合OCP原则 优缺点与适用环境： 优点 实现了对象创建和使用的分离 客户端无须知道所创建的具体产品类的类名,只需要知道具体产品类所对应的参数即可 通过引入配置文件,可以在不修改任何客户端代码的情况下更换和增加新的具体产品类,在一定程度上提高了系统的灵活性 缺点 工厂类集中了所有产品的创建逻辑,职责过重,一旦不能正常工作,整个系统都要受到影响 增加系统中类的个数(引入了新的工厂类),增加了系统的复杂度和理解难度 系统扩展困难,一旦添加新产品不得不修改工厂逻辑 由于使用了静态工厂方法,造成工厂角色无法形成基于继承的等级结构,工厂类不能得到很好地扩展 适用环境 工厂类负责创建的对象比较少,由于创建的对象较少,不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数,对于如何创建对象并不关心 不需要工厂的情况：很简单且不存在太多变化的类 工厂方法模式 定义：定义一个用于创建对象的接口,让子类决定实例化哪一个类。使一个类的实例化延迟到其子类。 工厂父类负责定义创建产品对象的公共接口,而工厂子类则负责生成具体的产品对象 参与者： Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂 工厂方法的隐藏 目的：进一步简化客户端的使用 实现:在工厂类中直接调用产品类的业务方法,客户端 无须调用工厂方法创建产品对象，直接使用工厂对象可调用所创建的产品对象中的业务方法 优缺点与适用环境 优点 工厂方法用来创建客户所需要的产品,同时还向客户隐藏了哪种具体产品类将被实例化这一细节 能够让工厂自主确定创建何种产品对象,而如何创建这个对象的细节则完全封装在具体工厂内部 在系统中加入新产品时,完全符合开闭原则 缺点 系统中类的个数将成对增加,在一定程度上增加了系统的复杂度,会给系统带来一些额外的开销 增加了系统的抽象性和理解难度 适用环境 客户端不知道它所需要的对象的类(客户端不需要知道具体产品类的类名,只需要知道所对应的工厂即可,具体产品对象由具体工厂类创建) 抽象工厂类通过其子类来指定创建哪个对象 抽象工厂模式 定义：提供一个创建一系列相关或相互依赖对象的接口,而无须指定它们具体的类。 目的：提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类 – 客户端不必指定产品的具体类型,创建多个产品族中的产品对象 （相较于工厂模式）一个工厂可以生产一系列产品(一族产品),极大减少了工厂类的数量 当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时,抽象工厂模式比工厂方法模式更为简单、更有效率 产品等级结构与产品族 产品等级结构：产品等级结构即产品的继承结构，e.g.空调——海信空调、海尔空调 产品族:产品族是指由同一个工厂生产的,位于不同产品等级结构中的一组产品，e.g海尔空调，海尔冰箱 动机 当系统所提供的工厂生产的具体产品并不是一个简单的对象,而是多个位于不同产品等级结构、属于不同类型的具体产品时 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式 开闭原则的倾斜性 对于增加新的产品族,抽象工厂模式很好地支持了开闭原则 对于增加新的产品等级结构,需要修改所有的工厂角色,包括抽象工厂类,在所有的工厂类中都需要增加生产新产品的方法,违背了开闭原则 优缺点 优点： 隔离了具体类的生成,使得客户端并不需要知道什么被创建 当一个产品族中的多个对象被设计成一起工作时,它能够保证客户端始终只使用同一个产品族中的对象 增加新的产品族很方便,无须修改已有系统,符合开闭原则 缺点 增加新的产品等级结构麻烦,需要对原有系统进行较大的修改,甚至需要修改抽象层代码，违背了开闭原则 适用环境 一个系统不依赖于产品类实例如何被创建、组合和表达的细节 系统中有多于一个的产品族,但每次只使用其中某一产品族 属于同一个产品族的产品将在一起使用,这一约束必须在系统的设计中体现出来 产品等级结构稳定,在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构 建造者模式 定义：将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示。 应用：游戏角色的创建，需要创建外形、皮肤、技能等 将客户端与包含多个部件的复杂对象的创建过程分离,客户端无须知道复杂对象的内部组成部分与装配方式,只需要知道所需建造者的类型即可 关注如何逐步创建一个复杂的对象,不同的建造者定义了不同的创建过程 角色 Builder(抽象建造者) ConcreteBuilder(具体建造者) Product(产品) Director(指挥者)：指挥产品构建与组装方法 OCP：当需要增加新的具体角色建造者时,只需将新增具体角色建造者作为抽象角色建造者的子类,然后修改配置文件即可,原有代码无须修改,完全符合开闭原则 简化 省略指挥者：与Builder合并，Construct方法写入Builder类中 通过钩子方法来控制产品的构建 钩子方法：返回类型通常为boolean类型,方法名一般为isXXX()。 12345//通过钩子方法来控制产品的构建//isBareheaded可以在需要光头的类里覆盖声明if(!ab.isBareheaded()) &#123;ab.buildHairstyle();&#125; 优缺点与适用环境 优点 客户端不必知道产品内部组成的细节,将产品本身与产品的创建过程解耦,使得相同的创建过程可以创建不同的产品对象 每一个具体建造者都相对独立,与其他的具体建造者无关,因此可以很方便地替换具体建造者或增加新的具体建造者,扩展方便,符合开闭原则 可以更加精细地控制产品的创建过程 缺点 建造者模式所创建的产品一般具有较多的共同点,其组成部分相似,如果产品之间的差异性很大,不适合使用建造者模式,因此其使用范围受到一定的限制 如果产品的内部变化复杂,可能会需要定义很多具体建造者类来实现这种变化,导致系统变得很庞大,增加了系统的理解难度和运行成本 适用环境 需要生成的产品对象有复杂的内部结构,这些产品对象通常包含多个成员变量 需要生成的产品对象的属性相互依赖,需要指定其生成顺序 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类,将创建过程封装在指挥者类中,而不在建造者类和客户类中 隔离复杂对象的创建和使用,并使得相同的创建过程可以创建不同的产品 原型模式 定义：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。 将一个原型对象传给要发动创建的对象（即客 户端对象），这个要发动创建的对象通过请求原型对象复 制自己来实现创建过程 创建新对象（也称为克隆对象）的工厂就是原型类自身， 工厂方法由负责复制原型对象的克隆方法来实现 通过克隆方法所创建的对象是全新的对象，它们在内存中 拥有新的地址，每一个克隆对象都是独立的 角色 Prototype（抽象原型类） ConcretePrototype（具体原型类） Client（客户类） 浅克隆与深克隆 浅克隆(Shallow Clone)：当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制 在Java语言中，提供了一个clone()方法用于实现浅克隆，该方法使 用起来很方便，直接调用super.clone()方法即可实现克隆(public ConcretePrototype implements Cloneable) 深克隆(Deep Clone)：除了对象本身被复制外，对象 所包含的所有成员变量也将被复制 原型管理器 定义：将多个原型对象存储在一个集合中供客户端使用，一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象， 如果需要某个原型对象的一个克隆，可以通过复制集 合中对应的原型对象来获得 优缺点与适用环境 优点 简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率 扩展性较好 提供了简化的创建结构，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品 可以使用深克隆的方式保存对象的状态，以便在需要的时候使用，可辅助实现撤销操作 缺点 需要为每一个类配备一个克隆方法，而且该克隆方法位于 一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦 适用环境 创建新对象成本较大，新对象可以通过复制已有对象 来获得，如果是相似对象，则可以对其成员变量稍作修改 系统要保存对象的状态，而对象的状态变化很小 需要避免使用分层次的工厂类来创建分层次的对象 Ctrl + C $\\to$ Ctrl + V 相关 Prototype与Abstract Factory往往是相互竞争的，但是它们也可以一起使用。Abstract Factory可以存储一个被克隆的原型的集合，并且返回产品对象 单例模式 定义：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。 某个类只能有一个实例 必须自行创建这个实例 必须自行向整个系统提供这个实例 角色： Singleton（单例） 12345678910public class Singleton &#123; private static Singleton instance=null; //静态私有成员变量 //私有构造函数 private Singleton() &#123; &#125; //静态公有工厂方法，返回唯一实例 public static Singleton getInstance() &#123; if(instance==null) instance=new Singleton(); return instance; &#125;&#125; 饿汉式与懒汉式 饿汉式：一开始（装载时）就实例化 ```Javapublic class EagerSingleton { private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123; &#125; public static EagerSingleton getInstance() &#123; return instance; &#125; }12345678910111213141516 + 基于 classloader 机制避免了多线程的同步问题;没有加锁，执行效率会提高 + 类加载时就初始化，浪费内存+ 懒汉式（线程不安全）：使用时才实例化(延迟加载) + &#96;&#96;&#96;Java public class Singleton &#123; private static Singleton instance&#x3D;null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance&#x3D;&#x3D;null) instance&#x3D;new Singleton(); return instance; &#125; &#125; 懒汉式（线程安全）： ```Javasynchronized public static LazySingleton getInstance(){…} //锁方法synchronized (LazySingleton.class) { instance = new LazySingleton(); } //锁代码段 //双重检查锁定public class Singleton { private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; //第一重检查 synchronized (Singleton.class) &#123; //锁定 if (singleton == null) &#123; //第二重检查 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 + 使用静态内部类实现单例模式 + 比较： + 饿汉式单例类：无须考虑多个线程同时访问的问题； 调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长 + 懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行 控制，将导致系统性能受到一定影响+ 优缺点与适用环境 + 优点 + 提供了对唯一实例的受控访问 + 可以节约系统资源，提高系统的性能 + 允许可变数目的实例（多例类） + 缺点 + 扩展困难（缺少抽象层） + 单例类的职责过重、一定程度上违背单一职责原则 + 由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失 + 适用环境 + 系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象 + 客户调用类的单个实例只允许使用一个公共访问点， 除了该公共访问点，不能通过其他途径访问该实例 + 相关 + Singleton与其他创建型模式并不矛盾，可以用Singleton 来实现其他模式中的对象。包括Abstract Factory、Builder、 Prototype等+ 补充：单例模式的继承（见视频）## 结构型模式+ 关注如何将现有类或 对象组织在一起形成更加强大的结构 + 分为类结构型模式和对象结构型模式 + 类结构型模式：关心类的组合，一般只存在继承关系和实现关系+ 对象结构型模式：关心对象的组合，通过关联关系### 适配器模式+ 定义：将一个类的接口转换成客户希望的另一个接口，让那些接口不兼容的类可以一起工作 + 别名包装器（Wrapper）模式 + 接口是广义的接口，可以表示一 个方法或者方法的集合+ 结构 + Target（目标抽象类） + Adapter（适配器类） + 类适配器(java不支持多继承) &#96;&#96;&#96;java public class Adapter extends Adaptee implements Target &#123; public void request() &#123; super.specificRequest(); &#125; &#125; 对象适配器 123456789public class Adapter extends Target &#123; private Adaptee adaptee; //维持一个对适配者对象的引用 public Adapter(Adaptee adaptee) &#123; this.adaptee=adaptee; &#125; public void request() &#123; adaptee.specificRequest(); //转发调用 &#125;&#125; Adaptee（适配者类） 优缺点与适用环境 优点 目标类和适配者类解耦 增加了类的透明性和复用性，同一 适配者类可以在多个不同的系统中复用 灵活性和扩展性非常好 类适配器模式：置换一些适配者的方法很方便（继承覆盖） 对象适配器模式：可以把多个不同的适配者适配到同一个目标， 还可以适配一个适配者的子类 缺点 类适配器模式： (1) 一次最多只能适配一个适配者类，不能同时适配多个适配者； (2) 适配者类不能为最终类； (3) 目标抽象类只能为接口，不能为类 对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦 适用环境 系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码 创建一个可以重使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作 缺省适配器模式 定义：不想实现一个接口的所有方法时，先设计一个抽象类实现该接口，每个方法提供一个默认实现（空方法）。该抽象类的子类选择性覆盖父类中的方法。又称单接口适配器模式。 实现 12345public abstract class AbstractServiceClass implements ServiceInterface &#123; public void serviceMethod1() &#123; &#125; //空方法 public void serviceMethod2() &#123; &#125; //空方法 public void serviceMethod3() &#123; &#125; //空方法&#125; 双向适配器 12345678910111213141516public class Adapter implements Target,Adaptee &#123; private Target target; private Adaptee adaptee; public Adapter(Target target) &#123; this.target = target; &#125; public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void request() &#123; adaptee.specificRequest(); &#125; public void specificRequest() &#123; target.request(); &#125;&#125; 桥接模式 定义：将抽象部分与它的实现部分解耦，使得两者都能够独立变化 又被称为柄体(Handle and Body)模式或接口(Interface) 模式 用抽象关联取代了传统的多层继承 将类之间的静态继承关系转换为动态的对象组合关系 结构 Abstraction（抽象类）：引用实现类接口（桥） RefinedAbstraction（扩充抽象类） ：继承抽象类 Implementor（实现类接口） ConcreteImplementor（具体实现类）：实现实现类接口 桥接模式与适配器模式的联用 桥接模式：用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化 适配器模式：当发现系统与已有类无法协同工作时 优缺点与适用环境 优点 分离抽象接口及其实现部分 可以取代多层继承方案，极大地减少了子类的个数 提高了系统的可扩展性，在两个变化维度中任意扩展 一个维度，不需要修改原有系统，符合开闭原则 缺点 会增加系统的理解与设计难度，由于关联关系建立在 抽象层，要求开发者一开始就针对抽象层进行设计与编程 正确识别出系统中两个独立变化的维度并不是一件容 易的事情 适用环境 需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系 抽象部分和实现部分可以以继承的方式独立扩展而互不影响 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展 不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统 组合模式 定义：组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。 又称为“部分-整体”(Part-Whole)模式 将对象组织到树形结构中，可以用来描述整体与部分 的关系 e.g. 文件系统中的文件与目录 结构 Component（抽象构件） ：抽象类，叶子构建和容器构建都继承抽象类 Leaf（叶子构件） Composite（容器构件） 优缺点与适用环境 优点 可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控 制 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码 增加新的容器构件和叶子构件都很方便，符合开闭原则 为树形结构的面向对象实现提供了一种灵活的解决方案 缺点 在增加新构件时很难对容器中的构件类型进行限制 适用环境 在具有整体和部分的层次结构中，希望通过一种方式 忽略整体与部分的差异，客户端可以一致地对待它们 在一个使用面向对象语言开发的系统中需要处理一个树形结构 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型 透明组合模式 抽象构件Component中声明了所有用于管理成员对象 的方法，包括add()、remove()，以及getChild()等方法 在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象 缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的 安全组合模式 抽象构件Component中没有声明任何用于管理成员对 象的方法，而是在Composite类中声明并实现这些方 法 对于叶子对象，客户端不可能调用到这些方法 缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件 装饰模式 定义 动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。 以对客户透明的方式动态地给一个对象附加上更多的责任 可以在不需要创建更多子类的情况下，让对象的功能得以扩展 结构 Component（抽象构件） ConcreteComponent（具体构件） ：继承或实现抽象构建类 Decorator（抽象装饰类） ：继承自抽象构件类 12345678public class Decorator extends Component &#123; private Component component; //维持一个对抽象构件对象的引用 //注入一个抽象构件类型的对象 public Decorator(Component component) &#123; this.component=component; &#125; public void operation() &#123; component.operation(); //调用原有业务方法 &#125;&#125; ConcreteDecorator（具体装饰类）：继承抽象装饰类 1234567891011public class ConcreteDecorator extends Decorator &#123; public ConcreteDecorator(Component component) &#123; super(component); &#125; public void operation() &#123; super.operation(); //调用原有业务方法 addedBehavior(); //调用新增业务方法 &#125; //新增业务方法 public void addedBehavior() &#123; …… &#125;&#125; 实例 图形界面构件库：原有窗体、文本框等，用装饰类可以实现带滚动条的文本框、带黑色边框的窗体、既带滚动条又带黑色边框的列表框等 优缺点与适用环境 优点 比继承更加灵活，不会导致类的个数急剧增加 通过一种动态的方式来扩展一个对象的功能（通过配置文 件可以在运行时选择不同的具体装饰类，从而实现不同的行为 ） 可以对一个对象进行多次装饰 具体构件类与具体装饰类可以独立变化，用户可以根据需要增 加新的具体构件类和具体装饰类，且原有类库代码无须改变， 符合开闭原则 缺点 使用装饰模式进行系统设计时将产生很多小对象，占用更多的系统资源，影响程序性能 比继承更加易于出错，排错也更困难 透明装饰器模式 定义： 客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型 要求客户端完全针对抽象编程，具体构件对象和具体装饰对象没有任何区别 优点 可以让客户端透明地使用装饰之前的对象和装饰之后 的对象，无须关心它们的区别 可以对一个已装饰过的对象进行多次装饰 缺点 无法在客户端单独调用新增业务方法 半透明装饰器模式 定义： 用具体装饰类型来定义装饰之后的对象，而具体构件使用抽象构件类型来定义 具体构件类型无须关心，是透明的； 但是具体装饰类型必须指定，这是不透明的 优点 可以给系统带来更多的灵活性，设计相对简单，使用 起来也非常方便 客户端可以单独调用新增的业务方法 缺点 不能多次装饰同一个对象（存疑） 客户端有区别地对待装饰前后的对象 外观模式 定义 为子系统中的一组接口提供一个统一的入口。（类似于餐厅服务员） 又称为门面模式 是迪米特法则（最少知识原则）的一种具体实现 子系统是一个广义的概念，它可以是一个类、 一个功能模块、系统的一个组成部分或者一个完整的 系统 结构 Facade（外观角色） SubSystem（子系统角色） 抽象外观类 如果需要增加、删除或更换与外观类交互的子系统类，可以通过继承和配置文件实现替换不同的外观类，符合OCP 外观类也可以同时使用单例模式 优缺点与适用环境 优点 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象 数目，并使得子系统使用起来更加容易 实现了子系统与客户端之间的松耦合关系，这使得子系统的 变化不会影响到调用它的客户端，只需要调整外观类即可 一个子系统的修改对其他子系统没有任何影响，而且子系统的内部变化也不会影响到外观对象 缺点 不能很好地限制客户端直接使用子系统类，如果对客 户端访问子系统类做太多的限制则减少了可变性和灵活性 如果设计不当，增加新的子系统可能需要修改外观类 的源代码，违背了开闭原则 适用环境 要为访问一系列复杂的子系统提供一个简单入口 客户端程序与多个子系统之间存在很大的依赖性 在层次化结构中，可以使用外观模式的定义系统中每 一层的入口，层与层之间不直接产生联系，而是通过 外观类建立联系，降低层之间的耦合度 享元模式 定义 运用共享技术有效地支持大量细粒度对象的复用。 内部状态(Intrinsic State)：存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享 （例如：字符的内容） 外部状态(Extrinsic State)：随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端 保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的（例如：字符的颜色和大小） 结构 Flyweight（抽象享元类） ConcreteFlyweight（具体享元类） 1234567891011public class ConcreteFlyweight extends Flyweight &#123; //内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的 private String intrinsicState; public ConcreteFlyweight(String intrinsicState) &#123; this.intrinsicState = intrinsicState; &#125; //外部状态extrinsicState在使用时由外部设置，不保存在享元对象中， 即使是同一个对象，在每一次调用时可以传入不同的外部状态 public void operation(String extrinsicState) &#123; //实现业务方法 &#125; &#125; UnsharedConcreteFlyweight（非共享具体享元类） FlyweightFactory（享元工厂类） 123456789101112131415public class FlyweightFactory &#123; //定义一个HashMap用于存储享元对象，实现享元池 private HashMap flyweights = new HashMap(); public Flyweight getFlyweight(String key) &#123; //如果对象存在，则直接从享元池获取 if (flyweights.containsKey(key)) &#123; return (Flyweight)flyweights.get(key); &#125; //如果对象不存在，先创建一个新的对象添加到享元池中，然后返回 else &#123; Flyweight fw = new ConcreteFlyweight(); flyweights.put(key,fw); return fw; &#125; &#125;&#125; Java的String类使用了享元模式：创建时内容相同的字符串会共享一个字符串对象 优缺点和适用环境 优点 可以减少内存中对象的数量，使得相同或者相似的对 象在内存中只保存一份，从而可以节约系统资源，提 高系统性能 外部状态相对独立，而且不会影响其内部状态，从而 使得享元对象可以在不同的环境中被共享 缺点 使得系统变得复杂，需要分离出内部状态和外部状态， 这使得程序的逻辑复杂化 为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长 适用环境 一个系统有大量相同或者相似的对象，造成内存的大量耗费 对象的大部分状态都可以外部化，可以将这些外部状 态传入对象中 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，在需要多次重复使用享元对象时才值得使用享元模式 单纯享元模式 所有的具体享元类都是可以共享的，不存在非共享具 体享元类 复合享元模式 将一些单纯享元对象使用组合模式加以组合 如果希望为多个内部状态不同的享元对象设置相同的外部状态， 可以考虑使用复合享元模式 代理模式 定义 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问 引入一个新的代理对象 ，代理对象在客户端对象和目标对象之间起到中介的作用 ，可以去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务 结构 Subject（抽象主题角色） Proxy（代理主题角色） ：维持一个对真实主题对象的引用，调用真实主题对象的方法 RealSubject（真实主题角色） 几种常见的代理模式 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中， 远程代理又称为大使(Ambassador) 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示， 真实对象只在需要时才会被真正创建 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果 智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等 优缺点与适用环境 优点 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性 远程代理：可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率 虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销 缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间 保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限 缺点 由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢 （例如保护代理） 实现代理模式需要额外的工作，而且有些代理模式的 实现过程较为复杂（例如远程代理） 适用环境 当客户端对象需要访问远程主机中的对象时可以使用远程代理 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理 当需要控制对一个对象的访问，为不同用户提供不同级别 的访问权限时可以使用保护代理 • 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理 远程代理 客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速地响 应并处理客户端的请求 可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在 客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络 通信工作，并负责对远程业务方法的调用 虚拟代理 对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理（桌面快捷方式） 在真实对象创建成功之前虚拟代理扮演真实对象的替身， 而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象 使用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能 Java动态代理 动态代理(Dynamic Proxy)可以让系统在运行时根据实际需要来动态创建代理类，让同一个代理类能够代理多个不同的真实主题类而且可以代理不同的方法 Proxy类 InvoationHandler接口 具体使用方法略 行为型模式 行为型模式(Behavioral Pattern)关注系统中对象之间 的交互，研究系统在运行时对象之间的相互通信与 协作，进一步明确对象的职责 职责链模式 定义 避免将一个请求的发送者与接收者耦合在一 起，让多个对象都有机会处理请求。将接收请求的对象连接 成一条链，并且沿着这条链传递请求，直到有一个对象能够 处理它为止。 将请求的处理者组织成一条链，并让请求沿着链传递， 由链上的处理者对请求进行相应的处理 客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上，将请求的发送者和请求的处理者解耦 职责链不一定是链式结构，也可以是环状的或者树状的 结构 Handler（抽象处理者） 123456public abstract class Handler &#123; //维持对下家的引用 protected Handler successor; public void setSuccessor(Handler successor) &#123; this.successor=successor; &#125; public abstract void handleRequest(String request);&#125; ConcreteHandler（具体处理者） 1234567891011public class ConcreteHandler extends Handler &#123; public void handleRequest(String request) &#123; if (请求满足条件) &#123; //处理请求 &#125; else &#123; this.successor.handleRequest(request); //转发请求 &#125; &#125; &#125; 客户端负责创建职责链和发送请求 纯与不纯 纯的职责链模式 一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家 一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况 不纯的职责链模式 允许某个请求被一个具体处理者部分处理后向下传递，或者一 个具体处理者处理完某请求后其后继处理者可以继续处理该请求 一个请求可以最终不被任何处理者对象所接收并处理 优缺点与适用环境 优点 使得一个对象无须知道是其他哪一个对象处理其请求， 降低了系统的耦合度 可简化对象之间的相互连接 给对象职责的分配带来更多的灵活性 增加一个新的具体请求处理者时无须修改原有系统的 代码，只需要在客户端重新建链即可 缺点 不能保证请求一定会被处理 对于比较长的职责链，系统性能将受到一定影响，在进行代码调试时不太方便 如果建链不当，可能会造成循环调用，将导致系统陷 入死循环 适用环境 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求 • 动态指定一组对象处理请求 命令模式 定义 将一个请求封装为一个对象，从而可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志， 以及支持可撤销的操作。 类比：同样的开关可以接到不同的电器上 对请求进行封装 ，一个请求对应于一个命令，请求的一方不必知道接收请求的一方的接口 结构 Command（抽象命令类） ConcreteCommand（具体命令类） Invoker（调用者） ：通过配置文件决定引用哪个具体命令类 Receiver（接收者） 延申 命令队列 有不止一个请求接收者产生响应，逐个执行业务方法 增加一个CommandQueue类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者 记录请求日志 将请求的历史记录保存下来，通常以日志文件(Log File)的形式永久存储在计算机中 ：为系统提供一种恢复机制 ，可以用于实现批处理，防止因为断电或者系统重启等原因造成请求丢失， 而且可以避免重新发送全部请求时造成某些命令的重复执行 实现：将发送请求的命令对象通过序列化写到日志文件中 ，命令类必须实现接口Serializable 实现单步撤销 在抽象命令类中增加Undo()方法，继承时需要实现该方法 宏命令（可用于实现多步撤销） 组合模式和命令模式联用 宏命令是一个具体命令类，它拥有一个集合，在该集合中包含 了对其他命令对象的引用 当调用宏命令的execute()方法时，将递归调用它所包含的每个 成员命令的execute()方法 优缺点与适用环境 优点 降低系统的耦合度 （请求方与接收方的解耦） 新的命令可以很容易地加入到系统中，符合开闭原则 可以比较容易地设计一个命令队列或宏命令（组合命令） 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案 缺点 可能会导致某些系统有过多的具体命令类（针对每一个对请求接收者的调用操作都需要设计 一个具体命令类） 适用环境 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互 系统需要在不同的时间指定请求、将请求排队和执行请求 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作 系统需要将一组操作组合在一起形成宏命令 解释器模式 定义 给定一个语言，定义它的文法的一种表示， 并定义一个解释器，这个解释器使用该表示来解释语言中的 句子。 （编译原理再放送）自顶向下语法分析，每个符号一个类，类中实现分析方法 用于描述如何使用面向对象语言构成一个简单 的语言解释器 结构 AbstractExpression（抽象表达式） TerminalExpression（终结符表达式） NonterminalExpression（非终结符表达式） Context（环境类） 用于存储一些全局信息，例如变量名与值的映射关系 (key/value)等，用于在执行具体的解释操作时从中获取相关信息（符号表警告） 在环境类中增加一些所有表达式解释器都共有的功能，以 减轻解释器的职责 当系统无须提供全局公共信息时可以省略环境类，根据实际情 况决定是否需要环境类 优缺点与适用环境 优点 易于改变和扩展文法：由于在解释器模式中使用类表 示语言的文法规则，因此可以通过继承等机制来改变 或扩展文法。 可以方便地实现一个简单的语言：每一条文法规则都 可以表示为一个类。 实现文法较为容易（有自动生成工具）。 增加新的解释表达式较为方便，符合开闭原则。 缺点 对于复杂文法难以维护：太多文法 规则，类的个数会急剧增加 执行效率较低：大量的循环和递归 适用环境 可以将一个需要解释执行的语言中的句子表示为一 棵抽象语法树 一些重复出现的问题可以用一种简单的语言来进行 表达 一个语言的文法较为简单 执行效率不是关键问题 迭代器模式 定义 提供一种方法顺序访问一个聚合对象中各个 元素，且不用暴露该对象的内部表示 类似Python的迭代器 可以根据需 要很方便地增加新的遍历方式（如从前往后遍历和从后往前遍历 结构 Iterator（抽象迭代器） ConcreteIterator（具体迭代器） Aggregate（抽象聚合类） 123public interface Aggregate &#123; Iterator createIterator(); //返回抽象迭代器&#125; ConcreteAggregate（具体聚合类） 扩展 增加新的具体聚合类和具体迭代器，都不需要修改原有代码，符合开闭原则 在迭代器中增加新的方法，需要修改原有代码，违背开闭原则。 优缺点与适用环境 优点 支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式 简化了聚合类 由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，符合开闭原则 缺点 在增加新的聚合类时需要对应地增加新的迭代器类， 类的个数成对增加，这在一定程度上增加了系统的复杂性 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是一件很容易的事情 适用环境 访问一个聚合对象的内容而无须暴露它的内部表示 需要为一个聚合对象提供多种遍历方式 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式， 而客户端可以一致性地操作该接口 白箱聚集 v.s. 黑箱聚集 宽窄接口 宽接口：聚合类提供了修改聚集元素的接口 窄接口：聚合类没有提供修改聚集元素的接口 白箱聚集 聚集对象对外一律提供宽接口 迭代子可以从外部控制元素的迭代（一个游标） 有点语法糖的感觉（？），就是本来不可以这么做，但是这么做了会很方便 外禀迭代子 黑箱聚集 聚集对象对迭代子提供宽接口，对其余对象提供窄接口 实现：迭代子实现为聚集对象的内部类 内禀迭代子 中介者模式 定义 定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且让你可以独立地改变它们之间的交互 迪米特法则的一个典型应用 对象之间多对多的复杂关系转化为相对简单的一对多关系（例如星型结构） 结构 Mediator（抽象中介者） ConcreteMediator（具体中介者） Colleague（抽象同事类） 维持一个抽象中介者的引用 定义依赖方法，与中介者进行通信 ConcreteColleague（具体同事类） 应用 e.g.图形界面元素的变化，比如从列表里删除一项元素时combobox中同样的元素也需要相应地删除 如果某个组件类需要与新的组件进行交互，无须修改 已有组件类的源代码，只需修改中介者或者对现有中介者进行扩展即可，系统具有更好的灵活性和可扩展性 优缺点与适用环境 优点 简化了对象之间的交互，它用中介者和同事的一对多交互代替 了原来同事之间的多对多交互，将原本难以理解的网状结构转 换成相对简单的星型结构 可将各同事对象解耦 可以减少子类生成，中介者模式将原本分布于多个对象间的行 为集中在一起，改变这些行为只需生成新的中介者子类即可， 这使得各个同事类可被重用，无须直接对同事类进行扩展 缺点 在具体中介者类中包含了大量的同事之间的交互细节， 可能会导致具体中介者类非常复杂，使得系统难以维护 适用环境 系统中对象之间存在复杂的引用关系，系统结构混乱 且难以理解 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象 想通过一个中间类来封装多个类中的行为，又不想生成太多的子类 备忘录模式 定义 在不破坏封装的前提下，捕获一个对象的内 部状态，并在该对象之外保存这个状态，这样就可以在以后 将对象恢复到原先保存的状态 撤销与重做 结构与实现 Originator（原发器） 12345678910public class Originator &#123; private String state;//以某种方式存储的状态信息（不一定是String public Originator()&#123;&#125; //创建一个备忘录对象 public Memento createMemento() &#123; return new Memento(this); &#125; //根据备忘录对象恢复原发器状态 public void restoreMemento(Memento m) &#123; state = m.state; &#125; public void setState(String state) &#123; this.state=state; &#125; public String getState() &#123; return this.state; &#125;&#125; Memento（备忘录) 1234567//备忘录类，默认可见性，包内可见 class Memento &#123; private String state; Memento(Originator o) &#123; state = o.getState(); &#125; void setState(String state) &#123; this.state=state; &#125; String getState() &#123; return this.state; &#125;&#125; Caretaker（负责人） 12345public class Caretaker &#123; private Memento memento; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento=memento; &#125;&#125; 只允许生成该备忘录的原发器访问备忘录的内部状态 java实现：将Memento类与Originator类定义在同一个包 (package)中来实现封装，使用默认可见性定义 Memento类，即保证其在包内可见 或 将备忘录类作为原发器类的内部类 多次撤销： 在负责人类中定义一个集合来存储多个备忘录（栈可能比较优雅 优缺点与适用环境 优点 提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤 实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动 缺点 资源消耗过大，如果需要保存的原发器类的成员变量 太多，就不可避免地需要占用大量的存储空间，每保 存一次对象的状态都需要消耗一定的系统资源 适用环境 保存一个对象在某一个时刻的全部状态或部分状态， 这样以后需要时能够恢复到先前的状态，实现撤销操作 防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象 观察者模式 定义 定义对象之间的一种一对多依赖关系，使得 每当一个对象状态发生改变时，其相关依赖对象都得到通知 并被自动更新。 结构和实现 Subject（被观察目标） 12345678910public abstract class Subject &#123; //定义一个观察者集合用于存储所有观察者对象 protected ArrayList observers&lt;Observer&gt; = new ArrayList(); //注册方法，用于向观察者集合中增加一个观察者 public void attach(Observer observer) &#123; observers.add(observer); &#125; //注销方法，用于在观察者集合中删除一个观察者 public void detach(Observer observer) &#123; observers.remove(observer); &#125; //声明抽象通知方法 public abstract void notify();&#125; ConcreteSubject（具体被观察目标） 123456789public class ConcreteSubject extends Subject &#123; //实现通知方法 public void notify() &#123; //遍历观察者集合，调用每一个观察者的响应方法 for(Object obs:observers) &#123; ((Observer)obs).update(); &#125; &#125; &#125; Observer（观察者） 1234public interface Observer &#123; //声明响应方法 public void update(); &#125; ConcreteObserver（具体观察者） 实现响应方法 Java事件处理 事件源对象充当观察目标角色，事件监听器充当抽象观察者角色，事件处理对象充当具体观察者角色 MVC 模型(Model)，视图(View)和控制器(Controller) 模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者 当模型层的数据发生改变时，视图层将自动改变其显示内容 优缺点与适用环境 优点 可以实现表示层和数据逻辑层的分离 在观察目标和观察者之间建立一个抽象的耦合 支持广播通信，简化了一对多系统设计的难度 符合开闭原则，增加新的具体观察者无须修改原有系统代码， 在具体观察者与观察目标之间不存在关联关系的情况下，增 加新的观察目标也很方便 缺点 将所有的观察者都通知到会花费很多时间 如果存在循环依赖时可能导致系统崩溃 没有相应的机制让观察者知道所观察的目标对象是怎 么发生变化的，而只是知道观察目标发生了变化 适用环境 一个抽象模型有两个方面，其中一个方面依赖于另一个方 面，将这两个方面封装在独立的对象中使它们可以各自独 立地改变和复用 一个对象的改变将导致一个或多个其他对象发生改变，且 并不知道具体有多少对象将发生改变，也不知道这些对象 是谁 需要在系统中创建一个触发链 状态模式 定义 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 否则图形学elif警告 用于解决系统中复杂对象的状态转换以及不同状态下 行为的封装问题， 客户端无须关心对象状态的转换以及对象 所处的当前状态 结构与实现 Context（环境类） 1234567891011public class Context &#123; private State state; //维持一个对抽象状态对象的引用 private int value; //其他属性值，该属性值的变化可能会导致对象的 状态发生变化 public void setState(State state) &#123; this.state = state; &#125; public void request() &#123; // ... state.handle(); //调用状态对象的业务方法 // ... &#125;&#125; State（抽象状态类） 1234public abstract class State &#123; //声明抽象业务方法，不同的具体状态类可以有不同的实现 public abstract void handle(); &#125; ConcreteState（具体状态类） 具体实现业务方法 状态转换 实现在环境类中： 对于客户端而言，无须关心状态类，可以为环境类设 置默认的状态类，将状态的转换工作交给环境类（或 具体状态类）来完成，具体的转换细节对于客户端而 言是透明的 123456public void changeState() &#123; //判断属性值，根据属性值进行状态转换 if (value == 0) &#123; this.setState(new ConcreteStateA()); &#125; else if (value == 1) &#123; this.setState(new ConcreteStateB()); &#125; //...... &#125; 实现在具体状态类中 123456public void changeState(Context ctx) &#123; //根据环境对象中的属性值进行状态转换 if (ctx.getValue() == 1) &#123; ctx.setState(new ConcreteStateB()); &#125; else if (ctx.getValue() == 2) &#123; ctx.setState(new ConcreteStateC()); &#125; //...... &#125; 共享状态 多个环境对象可能需要共享同一个状态 ，将这些状态对象定义为环境类的静态成员对象 优缺点与适用环境 优点 封装了状态的转换规则，可以对状态转换代码进行集中管理，而不是 分散在一个个业务方法中 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的 状态对象即可使环境对象拥有不同的行为 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件 语句块，可以避免使用庞大的条件语句来将业务方法和状态转换代码 交织在一起 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数 缺点 会增加系统中类和对象的个数，导致系统运行开销增大 结构与实现都较为复杂，如果使用不当将导致程序结构和代 码混乱，增加系统设计的难度 对开闭原则的支持并不太好，增加新的状态类需要修改负责 状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需要修改对应类的源代码 适用环境 对象的行为依赖于它的状态（例如某些属性值），状 态的改变将导致行为的变化 在代码中包含大量与对象状态有关的条件语句，这些 条件语句的出现会导致代码的可维护性和灵活性变差， 不能方便地增加和删除状态，并且导致客户类与类库 之间的耦合增强 策略模式 定义 定义一系列算法，将每一个算法封装起来，并 让它们可以相互替换。策略模式让算法可以独立于使用它的 客户变化。 结构与实现 Context（环境类） 1234567891011public class Context &#123; private Strategy strategy; //维持一个对抽象策略类的引用 //注入策略对象 public void setStrategy(Strategy strategy) &#123; this.strategy= strategy; &#125; //调用策略类中的算法 public void algorithm() &#123; strategy.algorithm(); &#125;&#125; Strategy（抽象策略类） 123public abstract class Strategy &#123; public abstract void algorithm(); //声明抽象算法 &#125; ConcreteStrategy（具体策略类） 12345public class ConcreteStrategyAextends Strategy &#123; //算法的具体实现 public void algorithm() &#123; //算法A &#125; &#125; 客户端 12345Context context = new Context(); Strategy strategy; strategy = new ConcreteStrategyA(); //可在运行时指定类型，通过配置 文件和反射机制实现 context.setStrategy(strategy); context.algorithm(); 优缺点与适用环境 优点 提供了对开闭原则的完美支持，用户可以在不修改原有系统的 基础上选择算法或行为，也可以灵活地增加新的算法或行为 提供了管理相关的算法族的办法 提供了一种可以替换继承关系的办法 可以避免多重条件选择语句 提供了一种算法的复用机制，不同的环境类可以方便地复用策 略类 缺点 客户端必须知道所有的策略类，并自行决定使用哪一 个策略类 将造成系统产生很多具体策略类 无法同时在客户端使用多个策略类 适用环境 一个系统需要动态地在几种算法中选择一种 避免使用难以维护的多重条件选择语句 不希望客户端知道复杂的、与算法相关的数据结构， 提高算法的保密性与安全性 模板方法模式 定义 定义一个操作中算法的框架，而将一些步 骤延迟到子类中。模板方法模式使得子类不改变一个算法的 结构即可重定义该算法的某些特定步骤。 结构与实现 AbstractClass（抽象类） 定义一系列方法和这些方法调用的顺序 ConcreteClass（具体子类） 实现/覆盖抽象类中的某些方法 模板方法 具体方法 抽象方法(Abstract Method) 具体方法(Concrete Method) 钩子方法(Hook Method)：一般返回一个bool值，用来判断某个操作是否要执行（e.g. isdigit 优缺点与适用环境 优点 在父类中形式化地定义一个算法，而由它的子类来实现细节的 处理，在子类实现详细的处理算法时并不会改变算法中步骤的 执行次序 提取了类库中的公共行为，将公共行为放在父类中，而通过其 子类来实现不同的行为 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决 定某一特定步骤是否需要执行 更换和增加新的子类很方便，符合单一职责原则和开闭原则 缺点 需要为每一个基本方法的不同实现提供一个子类，如 果父类中可变的基本方法太多，将会导致类的个数增 加，系统会更加庞大，设计也更加抽象（可结合桥接模式） 适用环境 一次性实现一个算法的不变部分，并将可变的行为留 给子类来实现 各子类中公共的行为应被提取出来，并集中到一个公 共父类中，以避免代码重复 需要通过子类来决定父类算法中某个步骤是否执行， 实现子类对父类的反向控制 访问者模式 定义： 表示一个作用于某对象结构中的各个元素的 操作。访问者模式让你可以在不改变各元素的类的前提下定 义作用于这些元素的新操作。 不同的访问者访问不同的元素 结构与实现 Visitor（抽象访问者） 1234567public abstract class Visitor &#123; public abstract void visit(ConcreteElementAelementA); public abstract void visit(ConcreteElementB elementB); public void visit(ConcreteElementC elementC) &#123; //元素ConcreteElementC操作代码——所有访问者对C的访问操作是一样的 &#125;&#125; ConcreteVisitor（具体访问者） 12345678public class ConcreteVisitor extends Visitor &#123; public void visit(ConcreteElementAelementA) &#123; //元素ConcreteElementA操作代码 &#125; public void visit(ConcreteElementB elementB) &#123; //元素ConcreteElementB操作代码 &#125;&#125; Element（抽象元素） 123public interface Element &#123; public void accept(Visitor visitor); &#125; ConcreteElement（具体元素） 12345678public class ConcreteElementAimplements Element &#123; public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public void operationA() &#123; //业务方法 &#125;&#125; ObjectStructure（对象结构） 123456789101112131415161718public class ObjectStructure &#123; private ArrayList&lt;Element&gt; list = new ArrayList&lt;Element&gt;(); //定义一个集 合用于存储元素对象 //接受访问者的访问操作 public void accept(Visitor visitor) &#123; Iterator i=list.iterator(); while(i.hasNext()) &#123; ((Element)i.next()).accept(visitor); //遍历访问集合中的每一个元素 &#125;&#125; public void addElement(Element element) &#123; list.add(element); &#125; public void removeElement(Element element) &#123; list.remove(element); &#125;&#125; 双重分派机制 ConcreteElementA.accept(visitor) -&gt; ConcreteVisitorA.visit(element) -&gt; ConcreteElementA.operation() 客户端：具体访问者类的对象作为参数，调用具体元素类的accept()方法 具体元素类的accept()方法：以当前元素类对象(this)为参数，调用传入的访问者对象的visit()方法 访问者对象的visit()方法执行中还能调用具体元素类的业务方法 优缺点和适用环境 优点 增加新的访问操作很方便 将有关元素对象的访问行为集中到一个访问者对象中， 而不是分散在一个个的元素类中，类的职责更加清晰 让用户能够在不修改现有元素类层次结构的情况下， 定义作用于该层次结构的操作 缺点 增加新的元素类很困难 破坏了对象的封装性：元素类在accept()方法传入了自己 适用环境 一个对象结构包含多个类型的对象，希望对这些对象实施 一些依赖其具体类型的操作 需要对一个对象结构中的对象进行很多不同的且不相关的 操作，并需要避免让这些操作“污染”这些对象的类，也 不希望在增加新操作时修改这些类 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作","categories":[],"tags":[]},{"title":"我做过的项目","slug":"my-projects","date":"2020-06-17T07:21:55.000Z","updated":"2020-06-19T03:31:36.540Z","comments":true,"path":"2020/06/17/my-projects/","link":"","permalink":"https://mengzelev.github.io/2020/06/17/my-projects/","excerpt":"","text":"感觉面试会用到所以就统一整理一下。 PA（ICS2018）概述一个x86全系统模拟器，分为nemu（x86模拟器），nexus-am（提供运行时环境），nanos-lite（简易操作系统）三大模块。 为课程《计算机系统基础》的课程实验，分为5个必做阶段+1个不算分的选做阶段： PA0：安装环境 PA1：实现基础设施（调试器） PA2：实现模拟指令执行 PA3：实现批处理操作系统 PA4：实现分时多任务 PA5（选做）：实现浮点运算与性能优化 各阶段简述PA3和4部分有待细化 PA0：安装环境略 PA1：调试器 带有打印寄存器和内存、表达式计算、单步执行、添加监视点等功能 表达式计算：朴素的递归分治策略 监视点：普通的链表 PA2：指令执行 对于每一条指令，分为“取指令、译码、执行”三个阶段。 每种指令对应一个译码函数和执行函数，保存在名为opcode_entry的结构体中。同时有一张opcode_table用来索引指令码对应的译码函数和执行函数。 执行函数依靠一些封装好的rtl（寄存器传输语言）函数简化实现 这一阶段的工作就相当于填空题 AM：bare-metal运行时环境 通过将运行程序所需的公共要素（如程序的终止退出）封装成API（库），使得同一份程序可以运行在不同的架构上 AM根据程序需求把库划分成以下模块： TRM（图灵机）：最简单的运行时环境, 为程序提供基本的计算能力 IOE（输入/输出扩展）：为程序提供输出输入的能力 CTE（上下文扩展）：为程序提供管理上下文的能力 VME（虚存扩展）：为程序提供虚存管理的能力 MPE（多处理器扩展）：为程序提供多处理器通信的能力 实现常用库函数： 包括一些字符串处理与打印的库函数 diff-test：将程序看做状态机，与标准实现qemu对比每一步执行过后的状态（这一部分讲义引导较多，具体原理有待深挖） 输入输出 端口映射与内存映射（NEMU都实现了） 设备 包含串口、时钟、键盘与VGA PA3：批处理系统 将上下文管理抽象成CTE 定义“事件”数据结构 当事件被触发时，cpu保存上下文，（x86）查阅相应的IDT，然后将事件打包给操作系统处理；操作系统处理完毕后恢复上下文 加载用户程序：实现loader 实现简易文件系统（建议观看oslab3） PA4：分时多任务 进程调度（建议观看oslab2） 虚拟存储 实现页表 当NEMU遇到访存指令时需要增加地址查找动作 分时多任务（进程调度） OSLab(2018)各阶段简述L0: amgame 一个运行在裸机上的游戏，略。 L1: 多处理器内核上的物理内存管理（pmm）要点：内存块的组织方式与并发安全 内存块组织 2018的OSLab性能尚未被纳入考量范围，因此我采用了最trivial的链表实现，分配策略为first-fit（返回第一块满足要求的内存块），且对每次kalloc与kfree操作上锁。 每一块内存之前有一段存储元数据的header，用于标识当前内存是否空闲、存放前后指针等 分配内存时将大块分裂为小块，回收内存时将相邻的小块合并为大块 比较好的实现是层状分配（我自己取的名字，改日查查term）。 一开始维护一些大的内存块（e.g. 16MB）。当需要分配的内存较小时，如果已经存在小的内存块时就优先选用小的，否则将大的内存块不断一分为二为小的内存块，直到刚好能装得下需要的空间。 回收时遇到相邻的小内存块就合并为大内存块。 L2：多处理器内核上的线程管理 (kmt)要点：自旋锁与信号量，进程的创建和销毁，进程上下文的保存与切换 自旋锁：参考xv6 自旋锁的数据结构：locked，持有的cpu和名称 上锁：lock xchgl原子地将1付给锁的locked变量 通过pushcli和popcli处理多次关中断，只有当一个cpu的cli数目清零后才能打开中断sti 判断一个cpu是否持有锁：需要push和pop cli 释放锁：与上锁相反 信号量：通过资源实现 进程 略 L3：文件系统实现 (vfs)要点：文件系统API的实现 文件系统主要分为ufs, devfs和procfs，后两者可以直接硬编码实现 ufs是建立在设备 sda (磁盘) 上的持久数据结构，因此是基于磁盘上的block fs实现的。 需要在block上维护inode信息 文件和目录都有inode，但只有文件占有具体的块。 inode在磁盘头部区域单独管理 通过调用block fs提供的API实现文件和目录的创建、读写与删除等操作 编译原理实验","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Interview","slug":"Interview","permalink":"https://mengzelev.github.io/tags/Interview/"}]},{"title":"LeetCode刷题笔记","slug":"leetcode-notes","date":"2020-05-15T12:33:29.000Z","updated":"2020-06-29T07:25:46.331Z","comments":true,"path":"2020/05/15/leetcode-notes/","link":"","permalink":"https://mengzelev.github.io/2020/05/15/leetcode-notes/","excerpt":"","text":"LeetCode刷题笔记解法与注意点整理 题目序号 题目描述 大致解法 注意点 2. 两数相加 两个链表存储的整数，求加起来的数的链表表示 遍历链表，处理相加与进位 不要递归；进位善后；一数到底的处理； 3.无重复字符的最长字符串 给定一个字符串，找出其中不含有重复字符的最长子串的长度。（不是子序列） 滑动窗口。双指针实现。当字串中无重复元素时向右移动右指针，否则向右移动左指针，直到无重复为止。 注意开始条件（长度为1和2的字符串） 4. 寻找两个正序数组的中位数 给定两个排好序的数组，找出这两个数组中的数的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 二分。法一：转换为寻找第k小的数。每次检查A[k/2-1]和B[k/2-1]，若A[k/2-1]&lt;=B[k/2-1]，说明比A[k/2-1]小的数最多只有k-2个，因此可以删去A[0:k/2-1]的数；反之同理。当范围缩小到只剩一个数组或为k为1时返回。法二：转换为寻找最大的i，满足A[i-1]&lt;=B[(m+n+1)/2 -i]即可（此处有复杂数学证明） 难。中位数的本质：第n/2小的数（奇数个数）或 一个划分标准，使得一半的数比它小，另一半的数比它大； 9. 回文数 判断输入数是否为回文数 法一：转成字符串，直接比较/双指针比较；法二：使用运算反转数字的一半（while x &gt; reverse_x），比较x==reverse_x（偶数位数）或reverse_x//10 == x（奇数位数） Python的整除是双斜杠；Python反转字符串s[::-1] 14. 最长公共前缀 找出输入的一组字符串的最长公共前缀 法一：无脑模拟。可以在前缀为空时提前退出。法二：二分分治。对strs数组进行分治查找。 41. 缺失的第一个正数 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。要求时间复杂度为$O(n)$，空间复杂度为$O(1)$ 哈希表。长度为$n$的数组最多包含正整数1~$n$，1~$n$中的缺的那个就是答案，不缺答案就是$n+1$。因此将数组中每个正整数哈希到$n$个桶中然后找空的桶即可。通过原地哈希来降低时间复杂度，如将输入数组中被哈希到数的位置的数取负。 时间空间要求苛刻时可以先考虑差一些的版本，然后思考怎么优化；优化空间复杂度可以用原地操作代替开新数组 70.爬楼梯 每次可以爬 1 或 2 个台阶。有多少种不同的方法可以爬到n阶楼梯楼顶 DP。dp[i]=dp[i-1]+dp[i-2] (i &gt;= 2)，即斐波那契数。 可以用矩阵快速幂或通项公式优化为$O(\\log n)$ 125. 验证回文串 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 双指针。注意非数字字母的字符和字母大小写的处理。 Python有isalnum()函数判断一个字符是否是字母或数字；Python的lower()函数对字母返回小写，对其他字符返回自身 209. 长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。 滑动窗口。每轮迭代窗口向右扩张一格，同时删去左端多余的数，记录此时窗口的长度并更新答案。 注意滑动窗口的实现方法； 215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。 排序后直接输出。可以使用不排序的快速排序或者堆优化。（然而优化不了多少 990. 等式方程的可满足性 给定一系列变量不等或相等关系，判断是否存在一种赋值使这些关系被全部满足 并查集。第一次遍历将相等的变量合并到用一个并查集中；第二次遍历查找是否有不等但处于同一个并查集中的变量。 并查集的非递归写法；由于题意要求变量全是小写字母故最多26个变量（使用ord(var)-ord(&#39;a&#39;)索引变量）；时间复杂度$O(n+ClogC)` 1014.最佳观光组合 给定一个数组A，寻找一对i,j(i&lt;j)使得A[i]+A[j]+i-j最大 优化枚举。维护目前最大的a[i]+i，对每个j计算a[j]-j+max(a[i]+i) 可以将一个属性递推维护来减少枚举的维度 1028. 从先序遍历还原二叉树 在遍历中的每个节点处，输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。给出遍历输出 S，还原树并返回其根节点 root。 栈。某个节点只可能是：上个节点的左孩子（当前节点深度=栈顶节点深度的+1） 或 从根到该节点的路径上的某个节点的有孩子（当前节点深度&lt;栈顶节点深度）。 1300. 转变数组后最接近目标值的数组和 给定一个整数数组 arr 和一个目标值 target ，返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近 target （最接近表示两者之差的绝对值最小）。优先返回最小的解。 双重二分。1. 在[0, max(arr)]二分搜索出一个value，使得sum(arr, val)&lt;=target&lt;=sum(arr, val+1)；2. 计算sum(arr, val)时，先将arr排序，然后找到第一个比val的大的数的下标id，则sum(arr, val)=prefix_sum[id] + (n-id)*val Python可以使用bisect.bisect_left(arr, x)二分查找并返回第一个比x大的数的下标；二分搜索模板。（见涨姿势部分）注意value对target的递增作用；差的绝对值最小化+递增：求个大一点的和小一点的，然后比谁的绝对值更小 1465. 一次编辑 给定两个字符串a和b，判断是否能通过一次编辑（增删改）由a得到b 双指针逐个遍历字符，不相同时比较该字符之后的字符串 1476.旋转矩阵 在不用额外的空间将矩阵（正方形）旋转90° 每一层四周交换或水平翻转+对角翻转 下标数量关系需要现场推导 1477.零矩阵 若M × N矩阵中某个元素为0，则将其所在的行与列清零 第一次扫描标记需要清零的位置，第二次扫描清零 必须分两次扫描 1482.分割链表 给定链表和数x，返回新链表，前半部分都是比x小的数，后半部分都是不小于x的数 双头链表，小的插前面，大的插后面 1583.重建二叉树 给出二叉树的前序遍历和中序遍历，重建二叉树 法一：递归。在preorder中找到根，然后拆分遍历结果，递归重建左右子树；法二：迭代。栈结构存储preorder中的根及左子树节点，遇到第一个右子树节点时退栈 注意空二叉树；递归和迭代都可以 1489.堆盘子 多个栈，一个栈放满了就放进下一个栈；要求push和pop和一个栈时表现相同，且可以指定pop哪个栈的内容 模拟。闭着眼睛写 pop指定栈时一个栈pop空了要将它删去 1498.节点间通路 给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。 DFS/BFS。输入的邻接矩阵转化为邻接链表，然后dfs/bfs 先将输入的邻接矩阵转换成邻接链表 1502.合法二叉搜索树 检查一棵二叉树是否为二叉搜索树 1.中序遍历，对每个节点维护上下界并判断节点值是否处于上下界之间；2.中序遍历成数组，判断数组是否升序排列 1505.二叉搜索树序列 给定一个由不同节点组成的BST，输出所有可能生成此树的数组。 队列。根必须出现在其所有子节点之前；用一个队列维护某个时刻能够成为下个节点的所有数值（即当根进队后将其子节点压入队列），循环输出所有可能的数组。 用队列维护可行的下个节点 面试题19.正则表达式匹配 判断字符串s是否与包含&#39;. &#39;和&#39;*&#39;的正则表达式p相匹配 dp。用f[i][j]表示s的前i位与p的前j位是否匹配。若s[i-1]==p[j-1] or p[j-1]==&#39;.&#39;，则f[i][j]=f[i-1][j-1]；若p[j-1]==&#39;*&#39;，如果之前的字符只出现0次，只需去掉最后两个字符（f[i][j]=f[i][j-2]），否则回溯s串考察该字符是否出现了多次，即if(s[i-1]==p[j-2] or p[j-2]==&#39;.&#39;) f[i][j] or= f[i-1][j] 动态规划；边界条件 面试题12.矩阵中的路径 判断在一个矩阵中是否存在一条包含某字符串所有字符的路径，同一个格子不可重复走 dfs（因为只要找到一条路径所以不是bfs）+剪枝；二重循环遍历寻找开始点，当开始点邻域内存在下个相应的字符时继续往下遍历；不存在下个字符时或路径长度超过字符串长度时返回。 回退时将走过的格子访问状态还原；标记访问状态可以不开数组直接在原矩阵内操作 面试题13.机器人的运动范围 m行n列的方格，从左上角到右下角，只能走坐标数位和不超过k的格子，求可达格子数 dfs/bfs。由于数位和的增减特性，可以只向右、下两个方向搜索。 面试题16. 数值的整数次方 实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 快速幂。 注意快速幂的板子。 面试题26.树的子结构 输入两棵二叉树A和B，判断B是不是A的子结构 双重dfs。第一重：寻找A中可以作为B的根节点的点；第二重：判断从该点开始是否存在与B相同的结构。 A可以有多余的子节点，只需要包含B即可；对节点为空的处理 1613.栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，判断第二个序列是否为该栈的弹出顺序 模拟。根据出入栈序列模拟栈的行为，若能模拟成功即为合法出栈序列。模拟方法：入栈直到栈顶元素为当前出栈序列中被指向的元素，无元素可入栈但出栈序列未过完时模拟失败。 模拟只要$O(N)$，数学判断要$O(N^3)$；写py多用for elem in list 而非 for i in range(0, len): list[i] 1614.从上到下打印二叉树 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印 BFS。 对树bfs得到的就是“从上到下、从左到右”的输出顺序；注意处理空树；deque的双端插入删除操作更快 面试题32-3.从上到下打印二叉树 III 之字形顺序打印二叉树 BFS+奇偶分别判断。bfs的队列用deque。以层为单位进行出队和入队（二重循环，每次里层循环开始时bfs队列中只有同一层的节点，将这一层的节点按照层数奇偶性正序或倒序放入输出队列，然后把这些节点的子节点加入bfs队列。保证里层循环进行的次数为循环开始前bfs队列的大小。） 空树。 面试题29.顺时针打印矩阵 按照从外向里以顺时针的顺序依次打印出矩阵中的每一个数字。（螺旋打印） 模拟。注意前进方向的维护即可。 面试题33. 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。 1.递归：递归判断某一段序列是否满足“比根小”（左子树）+“比根大（右子树）”+根。2. 辅助栈还原BST：遇到递减节点（左子树节点）前将所有节点作为候选根节点压栈，遇到递减节点就退栈直到栈顶为当前子树的根。若能还原成功就满足要求。 一步能做完的事尽量不要靠递归；BST与栈； 面试题34. 二叉树中和为某一值的路径 打印出二叉树中节点值的和等于输入整数的所有路径。（根→叶子算路径） dfs所有路径，满足要求的加入输出 路径节点值可能为负数，不能剪枝 面试题35. 复杂链表的复制 深拷贝。复杂链表：每个节点除了next还有random（随机指向一个节点或null） 哈希表存放深拷贝前后节点的映射关系。（优化：拷贝的节点放在原节点的next，这样可以直接通过next访问对应的拷贝节点） 链表遍历一定要写node = node.next！！！！ 面试题36.BST与双向链表 把BST改成双向循环链表。左孩子指针指向前驱，右孩子指针指向后继。 中序遍历。因为中序遍历的顺序就是排序的顺序，使用全局变量记录一个前驱pre。对于每个节点先遍历左子树，然后将前驱的右指针改为当前节点，当前节点的左指针改为前驱。全部遍历完后将首尾相接形成循环。 Python中可以使用self.xx当成全局变量；强化记忆：BST的中序遍历就是排序序列 面试题37. 序列化二叉树 实现两个函数，分别用来序列化和反序列化二叉树。（序列化：把数据结构变成字符串） BFS。序列化和反序列化都通过队列保存候选根节点，BFS遍历整棵树。不必须序列化成leetcode的规范。 Python字符串格式化合并join与分割split；使用if x判断x非空时注意x可能会有非空但值为0的情况；（leetcode规范）反序列化时注意右子树可能无； 面试题38.字符串的排列 输出给定字符串的全排列。（同样的字符视为同一个如”aab”前两个”a”视为相同） 回溯。递归确定每一位上的字符，已经在该位上出现过的字符不再考虑（使用set）。当确定了前len(s)-1位时记录答案并返回。 注意相同字符去重；python有itertools.permutations() 面试题41. 数据流中的中位数 设计一个支持“插入元素”与“返回所有元素中位数”操作的数据结构。 堆。维护两个堆，小堆A维护较大的一半元素，大堆B维护较小的一半元素（奇数个元素时A多一个）。插入元素：若AB大小相等，则向A插入元素（先向B插入元素，然后将B的堆顶弹出插入A中）；否则向B插入元素（方法同前）。返回中位数：根据AB大小，返回A的堆顶或AB堆顶的平均数。 Python的list的insert操作不是O(1)的；插入元素时要先插入另一个堆中然后迁移堆顶； 面试题43.1出现的次数 输入n，求出1~n十进制整数中1在数位上出现的次数。 模拟（？）。迭代计算1在每个数位上出现的次数。维护基数base和低位数low。每次循环判断n的最低位，至少ans+=(n/10)*base；若最低位为1则ans+=(low+1)；若最低位大于1则ans+=base。然后更新使low=low+base*(n%10), base*=10, n/=10。 注意low的更新；注意最低位为1的情况； 面试题44. 数字序列中某一位的数字 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，如第5位（从下标0开始计数）是5，第13位是1，第19位是4 模拟（找规律）。先求出目标数位属于几位数的范畴，然后计算出目标数位是这个区间的第几个数的第几位。 注意下标从0开始。 面试题45. 把数组排成最小的数 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 排序。比较规则：对于数$a,b$，$a$应带排在$b$前面当且仅当$\\overline{ab}&lt;\\overline{ba}$。 Python3里使用sorted(str_list, key=functools.cmp_to_key(cmp))实现自定义排序。 面试题46.把数字翻译成字符串 数字0~25编码为字符a~z，给定一串数字，求编码成字符串的方案数 DP。dp[i]表示[0..i]位的数的编码方案数。转移方程：$dp[i]=dp[i-1]+dp[i-2]$ if $10n{i-1}+n[i]\\in [10,25]$; $dp[i-1]$ o.w.。由于只用到前两位的信息因此计算过程中可以只维护两个变量、 0的处理，00不表示字母a； 面试题47. 礼物的最大价值 给定一个矩阵，求从左上角走到右下角（只能向下和向右）经过路线上数字之和的最大值 DP。dp[i][j]表示走到坐标为(i,j)的点经过路线上数字之和的最大值。非边界情况递推式：dp[i][j]=max(dp[i-1][j] +dp[i][j-1])。边界情况为i=0或j=0的情况。 记忆化搜索会超时，因为只需要考虑向右和向下的路径所以可以dp；可以直接在输入list上做dp 面试题49.丑数 丑数是质因子只有2,3,5的数。1是第一个丑数，求第$n$个丑数。 DP。dp[i]表示第i+1个丑数。递推式形式为dp[i]=min(dp[a]*2, dp[b]*3, dp[c]*5)。a,b,c在之前的递推中维护，当dp[j]&gt;=dp[a]*2时，a=j。（3和5同理）初始条件dp[0]=1, a=b=c=0 此题递推时同时需要维护； 面试题51. 数组中的逆序对 求给定数组中逆序对的个数。 法一：归并排序。当右侧指针移动时走过的就是逆序对。法二：树状数组。将输入数组离散化，用一个桶统计每个数出现的次数。反向扫描原数组，某数被扫描到时在桶中的前缀和就是以该数为首的逆序对的个数。（这个数之后比它小的数的个数） 离散化：排序后使用二分法为每个数分配一个Index，之后使用index代表这个数。Python树状数组实现见涨姿势部分。 面试题56 - I. 数组中数字出现的次数 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 位运算（异或）。如果只有一个数字只出现一次，整个数组的异或和就是答案。此时有两个只出现一次的数字，因此需要将数组分组。分组依据为取整个数组的异或中为1的某位，然后根据该位是否为1将整个数组分成两组分别求异或和，就能得到答案。 异或和可以用来寻找只出现了一次的数；Python求异或和可以使用functools.reduce 面试题56 - II. 数组中数字出现的次数 II 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。找出那个只出现一次的数字。 位运算。对于出现3次的数，其每个二进制位上1出现的次数为3的倍数，因此只要找出1出现次数模3余1的位即可。实现采用状态机思想，可以推出状态（two, one）转移方程为one=one^n&amp;~two, two=two^n&amp;~one。 可以通过观察二进制某一位上1出现的次数来确定一个数出现的次数。 面试题63. 股票的最大利润 把某股票的价格按照时间先后顺序存储在数组中，求买卖该股票一次可能获得的最大利润。（找出一前一后两个数差值最大） DP。（优化到不像dp）遍历价格数组，使用变量min_price存储前i天中的最低价格并维护，更新当前最大利润ans=max(ans, prices[i]-min_price)，然后更新min_price=min(min_price, prices[i]) 面试题64.求1+2+…+n 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 法一：求和公式。无法使用循环和分支所以用位运算代替乘法：(b&amp;1) &amp;&amp; ans += a; b &lt;&lt;= 1; a &gt;&gt;= 1;。$n$最大为10000(14位)，故手动展开14次即可。法二：迭代。禁止循环，改为递归。用bool运算的短路实现条件分支，(n &gt; 1) &amp;&amp; sum(n-1); ans += n; bool运算的短路可以实现条件分支（编译实验白写了） 面试题67. 把字符串转换成整数 造轮子。 没什么特别的算法，直接写就行了。 涨姿势 abs(str1.size()-str2.size())会报错，因为C++string类的size()函数为了不同平台上的兼容性返回的是string::size_type的类型。而abs()函数可以接受多种参数，但编译时无法确定应该使用哪个abs()所以会报ambiguous。——使用string类的size()函数先确定类型 C++的new [struct name]返回的是指针（就相当于C的malloc），我怎么连这个都不知道…… C++的bool表达式勤加括号 C++定义动态大小的二维数组： 1vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt;(m, 0)); Python定义动态大小的二维数组 1a = [[0 for _ in range(n)] for _ in range(m)] 在访问任何对象的成员前检查对象是否非空 python实现队列和栈时优先使用deque，因为两端的插入和删除操作都是$O(1)$，而普通的List是$O(N)$ Python设置最大值：float(&quot;+inf&quot;) 借助栈可以将遍历序列还原为BST Python反转字符串s[::-1] Python同时迭代元素和下标：for i, x in enumerate(a) Python自定义排序： 定义一个函数cmp(a, b)，满足a排在b前面时返回-1（任意负数）,否则返回1（任意正数） 对待排序列表使用sorted(list_to_sort, key=functools.cmp_to_key(cmp)) 原理cmp_to_key(cmp)里面定义了一个类，该类的__lt__()方法返回True当且仅当cmp(self.obj, other.obj)&lt;0 二分搜索模板（+1-1傻傻分不清） 12345678# find the largest &#x27;x&#x27; that f(x) &lt;= targetwhile l &lt; r: m = (l + r + 1) // 2 if f(m) &lt;= target: l = m else: r = m - 1return l # return r is the same Python树状数组模板 class BIT: def __init__(self, n): self.n = n self.tree = [0] * (n + 1) @staticmethod def lowbit(x): return x &amp; (-x) def query(self, x): ret = 0 while x &gt; 0: ret += self.tree[x] x -= BIT.lowbit(x) return ret def update(self, x, delta): while x &lt;= self.n: self.tree[x] += delta x += BIT.lowbit(x) Python语言相关全局解释器锁GIL Python的多线程程序并不能利用多核CPU的优势，如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行 GIL只会影响到那些严重依赖CPU的程序（比如计算型的）。 如果你的程序大部分只会涉及到I/O，比如网络交互，那么使用多线程就很合适，因为它们大部分时间都在等待 线程不是专门用来优化性能的。优化性能应该：优化底层算法，性能瓶颈代码移到C语言扩展模块（操作数组使用Numpy），Pypy使用JIT编译器优化执行效率 解决： 进程池（multiprocessing.Pool()）。进程池在另一个进程中启动一个单独的Python解释器工作 C扩展：计算密集型任务转移给C，在C代码中释放GIL。Cpython的ctypes库会在调用C时自动释放GIL","categories":[],"tags":[]},{"title":"计算机网络-期末复习","slug":"network-review","date":"2019-12-29T02:37:19.000Z","updated":"2020-01-01T12:22:44.694Z","comments":true,"path":"2019/12/29/network-review/","link":"","permalink":"https://mengzelev.github.io/2019/12/29/network-review/","excerpt":"","text":"Ch1 计算机网络和因特网1.1 什么是因特网1.1.1 具体构成描述 因特网：世界范围的计算机网络，一个互联了遍历全世界的数以亿计的计算设备的网络。 连接到因特网的设备一般称为主机（host）或端系统（end system），端系统通过通信链路（communication link）和分组交换机（packet switch）连接到一起。 链路的传输速率以比特/秒度量（bit/s或bps） 分组（packet）是发送端系统将数据分段，并为每段加上首部字节，由此形成的信息包。 路由器（router）和链路层交换机（link-layer switch）是两种著名的分组交换机，它们朝着最终目的地转发分组。 路径（route或path）：从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机。 端系统通过因特网服务提供商（Internet service provider，ISP）接入因特网。 TCP（传输控制协议）和IP（网际控制协议）协议是因特网中两个最为重要的协议，后者定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为TCP/IP。 因特网标准由因特网工程任务组（IETF）研发，IETF的标准文档称为请求评论（RFC） 1.1.2 服务描述 分布式应用程序：涉及多台相互交换数据的端系统的应用程序。 套接字接口：与因特网相连的端系统提供，规定了端系统上的程序 请求因特网基础设施 向另一个端系统上程序 交付数据的方式 1.1.3 协议 协议（protocol）定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/或接收一条报文或其它事件所采取的动作。 1.2 网络边缘 因特网的边缘：端系统（=主机） 主机可以划分为客户和服务器两类 P2S模型 客户端: 发送请求, 接受服务 服务器: 响应请求, 提供服务, 始终在线, 性能更强 P2P模型 无专用服务器, 每设备既是客户端也是服务器 1.2.1 接入网 接入网：将端系统物理连接到其边缘路由器的网络 边缘路由器：端系统到任何其他端系统的路径上的第一台路由器 家庭接入：DSL、电缆、FTTH、拨号和卫星（Maxwell更详细） 宽带住宅接入：数字用户线（DSL）和电缆 DSL：用户的本地电话公司也是它的ISP；调制解调器使用现有电话线；FDM；下行信道比上行信道快； 电缆因特网接入：利用有线电视公司现有基础设施；电缆调制解调器；下行信道比上行信道快；重要特征：共享广播媒体 光纤到户（FTTH）：从本地中心局直接到家庭提供一条光纤路径；主动光纤网络AONv.s.被动光纤网络PON 卫星链路：超过1Mbps 拨号：电话线接入ISP，慢的一比（56kbps） 企业(家庭)接入 LAN 介质: 双绞线 拓扑: 设备接入以太网交换机, 通过路由器接入因特网 速率: 10Mbps 100Mbps, 1Gbps, 10Gbps WiFi(802.11b/g/ac) 11Mbps, 54Mbps, 100Mbps+ 用户需位于接入点的几十米范围内 广域无线接入: 通信运营商 应用与蜂窝移动电话相同的无线基础设施，蜂窝网提供商运营的基站 与WiFi的不同：用户仅需要距离基站数万米内 3G: 1Mbps 4G LTE（长期演进） / WiMAX(淘汰): 10Mbps+ 5G: 20Gbps? 1.2.2 物理媒体 物理媒体（physical medium）传播电磁波或光脉冲来发送比特。 分为两类：导引型媒体和非导引型媒体 导引型媒体：电波沿固体媒体前行，如光缆、双绞铜线（最便宜且使用最为普遍）或同轴电缆（导引型共享媒体） 非导引型媒体：在空气或外层空间中传播，如无线局域网或数字卫星频道。陆地无线电信道、卫星无线电信道。 1.3 网络核心 网络核心：由互联因特网端系统的分组交换机和链路构成的网状网络。 分组以等于该链路最大传输速率的速度传输通过通信链路。若某源端系统或分组交换机经过一条链路发送一个L比特的分组，链路的传输速率为R比特/秒，则传输该分组的时间为L/R秒。 分组交换：多数分组交换机在链路的输入端使用存储转发传输（store-and-forward transmission）机制。在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。通过由$N$条速率均为$R$的链路组成的路径（即从源到目的地有$N-1$台路由器），从源到目的地发送一个分组，端到端时延为d_{端到端}=N\\frac{L}{R} 排队时延和分组丢失：对于每条相连的链路，分组交换机具有一个输出缓存，用于存储路由器准备发往那条链路的分组。除了存储转发时延，分组还要承受输出缓存的排队时延。因为缓存空间大小有限，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下，将出现分组丢失（丢包）（package lost），到达的分组或已经排队的分组之一将被丢弃。 转发表和路由选择协议：每个端系统具有一个称为IP地址的地址。当源主机要向目的端系统发送一个分组时，源在该分组的首部中包含了目的地的IP地址。每台路由器具有一个转发表（forwarding table），用于将目的地址映射成为输出链路。 通过网络链路和交换机移动数据的两种基本方法：电路交换和分组交换。 电路交换网络中，预留了端系统间通信沿路径所需要的资源（缓存、链路传输速率），而分组交换网络中不预留。当网络创建这种电路时，它也在连接期间在该网络链路上预留了恒定的传输速率，如此发送方能够以恒定速率向接收方传送数据。 链路中的电路通过频分复用FDM或时分复用TDM来实现。FDM中链路的频谱由跨越链路创建的所有连接所共享。在连接期间链路为每条连接专用一个频段，该频段的宽度称为带宽。对于一条TDM链路，时间被分为固定区间的帧，每帧被划分为固定数量的时隙。 分组交换不适合实时服务如电话和视频会议，因为它的端到端时延是可变而不可预测的。分组交换比电路交换有更好的带宽共享，比电路交换更简单，实现成本更低。 对比 电路: 时延固定，恒定速率，没有拥塞； 分组: 时延不可预测, 共享带宽更高, 更简单有效成本低 电路预先分配, 分组按需分配 1.4 分组交换网中的时延、丢包和吞吐量 结点总时延 = 结点处理时延 + 排队时延 + 传输时延 + 传播时延 处理时延：检查分组首部和决定将该分组导向何处、检查比特级别的差错等所需要的时间。处理结束后，路由器将该分组引向通往路由器B链路之前的队列。 排队时延：分组在链路上等待传输，取决于先期到达的正在排队等待向链路传输的分组数量。 传输时延：当该分组到达队首时，设L比特表示该分组的长度，用R bps表示从路由器A到路由器B的链路传输速率。传输时延是L/R。这是将所有分组的比特推向链路所需的时间。 传播时延：一个比特从链路的起点到路由器B传播所需的时间。等于两台路由器之间的距离除以传播速率，即d/s。 刻画排队时延可以用流量强度（traffic intensity）。设所有分组由L比特组成，a表示分组到达队列的平均速率，R表示传输速率即从队列中推出比特的速率。则流量强度为La/R。流量工程中有一条金科玉律：设计系统时流量强度不大于1，否则队列无穷增加。随着流量强度接近1，平均排队长度变得越来越长。见P28图1-18。 假定在源主机和目的主机之间有N-1台路由器，此时网络无阻塞，在每台路由器和源主机上的处理时延为$d{proc}$，每台路由器和源主机的输出速率为$R$ bps，每条链路的传播时延为$d{prop}$，则端到端时延为d_{end-end} = N(d_{proc} + d_{trans} + d_{prop})其中有$d_{trans} = L/R$。 从主机A到主机B跨越计算机网络传送一个大文件，在任何时间瞬间的瞬时吞吐量是主机B接收到该文件的速率。若该文件由F比特组成，主机B接收到所有F比特用了T秒，则文件传送的平均吞吐量为F/T。 1.5 协议层次及服务模型 因特网协议栈层次：物理层、链路层、网络层、运输层、应用层。 应用层：网络应用程序及它们的应用层协议存留的地方。位于应用层的信息分组称为报文（message） 运输层：在应用程序端点之间传送应用层报文。运输层分组称为报文段（segment） 网络层：负责将称为数据报（datagram）的网络层分组从一台主机移动到另一台主机 链路层：将分组从一个结点移动到下一个结点。在每个结点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一结点。下个结点，链路层将数据报上传给网络层。链路层分组称为帧（frame） 物理层：将帧中的一个个比特从一个结点移动到下一个结点。 OSI模型：应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。表示层：使通信的应用程序能够解释交换数据的含义。会话层：提供数据交换定界和同步功能，包括建立检查点和恢复方案的方法。 主机实现所有五个层次，链路层交换机实现第一层和第二层，路由器实现了一到三层。 1.6 面对攻击的网络 攻击个人电脑 恶意软件 大多数都是自我复制的 病毒: 需要某种形式的用户交互来感染用户设备 蠕虫: 无需任何明显用户交互就能进入设备 木马: 伪装成无害程序, 吸引用户点击 后门: 绕过授权验证 广告软件: 访问弹出广告 间谍软件: 收集用户的输入, 记录用户活动 攻击服务器和网络基础设施 拒绝服务攻击DoS 使得服务不能由合法用户使用 弱点攻击: 针对易受攻击的程序或操作系统, 引发停止运行或崩溃 带宽洪泛: 大量发送分组到目标, 使链路拥塞 连接洪泛: 创建大量半开或全开的TCP连接, 耗尽资源 分布式DoS(DDoS) 攻击者控制多个源 僵尸网路: 攻击者用恶意软件控制大量计算机, 作为DDoS的源头等 嗅探分组 分组嗅探器: 记录每个流经的分组副本的被动接收机 防范: 加密 伪装 IP欺骗: 将具有虚假源地址的分组注入因特网 重放攻击 中间人攻击 连接劫持 解决方案: 加密, 数字签名, MAC 第三章Ch3 运输层运输层为运行在不同主机上的应用程序之间提供了逻辑通信功能。通过逻辑通信，运行不同进程的主机好像直接相连一样。应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些报文的物理基础设施的细节。 运输层只工作在端系统中。在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（即网络层）。运输层能够提供的服务常常受制于底层网络协议的服务模型（带宽时延等），但底层网络协议不可靠、非机密性的情况下，运输层也能提供可靠性和机密性。 UDP和TCP最基本的责任是：将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为运输层的多路复用与多路分解网络层：主机$\\Leftrightarrow$主机运输层：进程$\\Leftrightarrow$进程 多路复用和多路分解进程使用套接字作为与网络交互数据的门户，运输层将数据交付给套接字。每个套接字有唯一标识符，标识符格式取决于它是UDP还是TCP套接字。 每个运输层报文段中具有几个字段。多路分解：（拆包）将运输层报文段中的数据交付到正确的套接字多路复用：（打包）从源主机的不同套接字中收集数据块，并为每个数据块封上首部信息从而生成报文段，然后将报文段传递到网络层 套接字要有唯一标识符、每个报文段有特殊字段来只是该报文段所要交付到的套接字，特殊字段即源端口号字段&amp;目的端口号字段 端口号 16比特数，大小在0~65535 0~1023称为周知端口号，保留给注入HTTP（80）和FTP（21）之类的周知应用层协议 开发新应用程序时必须为其分配一个端口号 UDP的多路复用与多路分解创建套接字时，端口号有两种产生方式： 运输层自动为套接字分配一个端口号，从1024~65535内选择一个当前未被该主机中任何其他UDP端口使用的号 通过套接字bind()(Python)方法为这个UDP套接字关联一个特定的端口号通常应用程序自动，服务器手动 一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号。因此只要两个UDP报文段具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。 源端口号用于接收方发回给发送方 TCP的多路复用与多路分解TCP套接字由四元组（源IP地址、源端口号、目的IP地址、目的端口号）来标识与UDP不同，两个不同源IP和或源端口号的TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求 TCP服务器应用程序有一个“欢迎套接字”，在某个特定端口上等待来自TCP客户的连接建立请求 TCP客户创建一个套接字并发送一个连接建立请求报文段 一条连接建立请求只不过是一个目的端口号为12000，TCP首部的特定“连接建立位”置位的TCP报文段，这个报文段也包含一个由客户选择的源端口号 当运行服务器进程的计算机的主机操作系统接收到具有目的端口号为12000的入连接请求报文段后，它就定位服务器进程，该进程正在端口号12000等待接收连接。该服务器进程会创建一个新的套接字。 新创建的报文设置好4个标识符，之后的报文段按照这4个标识符来定向。 服务器主机支持很多并行的TCP套接字，每个套接字与一个进程相联系。 连接套接字与进程之间并非总是有着一一对应的关系（线程 无连接运输：UDP发送方和接收方的运输层实体之间没有握手——无连接的 e.g.DNS通常使用UDP应用层协议 UDP的优点 关于发送什么数据以及何时发送的应用层控制更为精细。 实时应用通常要求最小发送速率，不希望过分地延迟报文段的传送，且能容忍一些数据丢失 无须连接建立，不会引入建立连接的时延 无连接状态，节约存储空间，可以支持更多活跃用户。 分组首部开销小，TCP20字节，UDP8自己 UDP报文段结构 源端口号/目的端口号（各16比特） 长度（16比特）：首部+数据的字节数 检验和 应用数据 UDP检验和实际包括一些IP首部字段，此处忽略 16比特字的反码运算，求和时遇到的任何溢出都被回卷（加到末尾去）详见作业题CH6 P3 端到端原则：如果端到端传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测“与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的” 不进行差错恢复，只能丢弃/交给应用程序并发出警告 面向连接的运输：TCPTCP连接两个进程在发送数据之前必须先相互“握手”，即它们必须互相发送某些预备报文段，以建立确保数据传输的参数 TCP连接是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中，中间网络元素不会维持TCP连接状态。 全双工服务（full-duplex service）：如果进程A与进程B存在一条TCP连接，则应用层数据可以在这两台主机间双向流动 点对点：单个发送方与单个接收方之间的连接 发起连接的称为客户进程，另一个进程被称为服务器连接 客户进程通过套接字（该进程之门）传递数据流，TCP将这些数据引导到该连接的发送缓存里 TCP会时不时从发送缓存里取出一块数据，并将数据传递到网络层 TCP可放入报文段的最大数据数量受限于最大报文段长度(MSS) MSS通常根据最初确定的由本地发送主机的最大链路层帧长度（最大传输单元MTU）来设置 MSS要保证一个TCP报文段+TCP/IP首部长度（通常40字节）小于等于单个链路层帧长度 MSS指报文段里应用层数据的最大长度，不包括首部 TCP在另一端接收到报文段后，该报文段的数据就被放入该TCP连接的接收缓存中 TCP连接组成包括：两台主机上的缓存、变量与进程连接的套接字 TCP报文段结构 源端口号和目的端口号（各16比特） 序号和确认号（各32比特）：用来实现可靠数据传输服务 接收窗口字段（16比特）：用于流量控制，表示接收方 愿意接收的字节数量 首部长度字段（4比特）：指示了以32比特为单位的TCP首部长度。TCP首部长度可变，但通常是20字节。 标志字段（6比特）：一些flag ACK：用于指示确认字段中的值是有效的 RST、SYN、FIN：用于连接的建立和拆除 CER、ECE：明确拥塞通告中使用 PSH：指示接收方应该立即将数据交给上层 URG：指示报文段里存在着被发送端的上层实体置为“紧急的数据”，紧急数据指针指出紧急数据的最后一个字节。当紧急数据存在并给出紧急数据指针时，TCP必须通知接收端的上层实体。 因特网检验和（16比特） 可选与变长的选项字段：用于发送方与接收方协商MSS，或在高速网络环境下用作窗口调节因子 序号和确认号TCP把数据看成无结构的、有序的字节流。一个报文段的序号是该报文段首字节的字节流编号。 主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。 TCP只确认流中至第一个丢失字节为止的字节，这个称为提供累计确认。 主机在一条TCP连接中收到失序报文段视为UB。 一条TCP连接的双方均可随机地选择初始号。 和（16比特） 可选与变长的选项字段：用于发送方与接收方协商MSS，或在高速网络环境下用作窗口调节因子举例：Telnet的回显 （解释见书p157) 对客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段，这种确认被称为是被捎带在服务器到客户的数据报文段中的。 往返时间估计与超时 报文段的样本RTT(SampleRTT)：从某报文段被发出大多数TCP仅在某个时刻做一次SampleRTT测量 在任意时刻，仅为一个已发送但目前尚未被确认的报文段估计SampleRTT，从而产生一个接近每个RTT值的新SampleRTT TCP绝不为已被重传的报文段计算SampleRTT，仅为传输一次的报文段测量 EstimatedRTT：TCP维护的SampleRTT的均值，为了应对SampleRTT的波动 一旦获得新的SampleRTT，更新公式为 \\text{EstimatedRTT}=(1-\\alpha)\\cdot\\text{EstimatedRTT}+\\alpha\\cdot\\text{SampleRTT}，$\\alpha$的推荐值为0.125(1/8) EstimatedRTT是对SampleRTT的指数加权移动平均（EWMA，Exponential Weighted Moving Average），指一个给定的SampleRTT的权值在更新过程中呈指数型快速衰减 DevRTT：RTT偏差，用于估算SampleRTT一般会偏离EstimatedRTT的程度 计算公式为\\text{DevRTT}=(1-\\beta)\\cdot\\text{DevRTT}+\\beta\\cdot|\\text{SampleRTT}-\\text{EstimatedRTT}|，$\\beta$的推荐取值为0.25 超时间隔TimeoutInterval：EstimatedRTT加上一定余量，与SampleRTT的波动正相关 计算公式为\\text{TimeoutInterval}=\\text{EstimatedRTT}+4\\cdot\\text{DevRTT} 推荐的TimeoutInterval的初始值为1s 当出现超时后，TimeoutIntetval将加倍，以免即将被确认的后继报文段过早出现超时。 只要收到报文段并更新EstimatedRTT，就更新TimeoutInterval 可靠数据传输TCP的差错恢复机制是GBN和SR的混合体 发送方：switch(事件) 从上面应用程序接收到数据 生成具有序号NextSeqNum的TCP报文段 如果定时器没有运行，启动定时器 向IP传递报文段 NextSeqNum=NextSeqNum+length(data) 定时器超时 重传具有最小序号但仍未应答的报文段 超时间隔超级加倍 启动定时器 收到ACK，ACK字段值为y 如果 y&gt;SendBase，则该ACK是在确认一个或多个先前未确认的报文段 更新SendBase 如果当前有未被确认的报文段， 重新启动定时器 如果 y&lt;=SendBase，则该ACK是对已经确认的报文段的一个冗余ACK 如果累计收到相同ACK值的3个冗余ACK（累计4个相同ACK），则重新发送具有序号y的报文段（快速重传） 接收方： 超时间隔加倍提供了一个形式受限的拥塞控制，因为定时器过期很可能是网络拥塞引起的。 快速重传冗余ACK：再次确认某个报文段的ACK 当TCP接收方接收到一个序号大于下一个所期望按序报文段的报文段时，就说明有报文段丢失，因此会产生一个冗余ACK对已经收到的最后一个按序字节数据进行重复确认。 如果发送方接收到对相同数据的3个冗余ACK，就将其视为一种指示，说明这个被确认了3次的报文段之后的报文段已经被丢失。发送方会进行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。 流量控制接收方如果读数据不够快，就会导致接收缓存溢出。TCP提供了流量控制服务以消除发送方使接收方缓存溢出的可能性。（区分流量控制与拥塞控制） TCP发送方维护一个称为接收窗口的变量，指示接收方还有多少可用空间，需要满足 \\text{LastByteRcvd}-\\text{LastByteRead}\\le \\text{RcvBuffer} 接收窗口长度用rwnd表示，\\text{rwnd}=\\text{RcvBuffer}-[\\text{LastByteRcvd}-\\text{LastByteRead}] \\text{LastByteSent}-\\text{LastByteAcked}\\le\\text{rwnd} 人话：主机Ａ发送但未被确认的数据大小 不会超过 主机Ｂ接收缓存的剩余可用空间 为了防止主机A被阻塞，当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存开始清空，并且确认报文里包含一个非0的rwnd值。 TCP连接管理建立TCP连接：三次握手 第一步：客户端的TCP向服务器的TCP发送一个SYN报文段。首部中SYN标志位被置为1。客户随机选择一个初始序号（client_isn），并将此序号放置于SYN报文段的序号字段。该报文段不包含应用层数据。 第二步：服务器主机收到该TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段（SYNACK报文段）。该报文段不包含应用层数据。SYN比特被置为1。首部确认号字段为client_isn+1。服务器选择自己的初始序号（server_isn），并将其放到序号字段中。 第三步：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机向服务器发送另一个报文段，将server_isn+1放到首部的确认字段，来对服务器的允许连接的报文段进行确认。连接已经建立了，所以SYN比特被置为0，且之后的每一个报文段的SYN比特都为0。该报文段可以携带应用层数据。 关闭TCP连接 客户进程发出一个关闭连接命令，引起客户TCP向服务器进程发送一个特殊的TCP报文段。该报文段首部FIN比特被置为1。 服务器接收到该报文段后，向发送方回送一个ACK报文段。 然后，服务器发送自己的终止报文段，FIN置为1。 最后，客户对这个服务器的终止报文段进行确认。此时，两台主机上用于该连接的所有资源都被释放了。 TCP状态 如果一台主机接收到的一个TCP报文段端口号或源IP地址与该主机上进行中的套接字都不匹配，则该主机向源发送一个特殊重置报文段，RST标志被置为1。（“我没有那个报文段的套接字，请不要再发了。”） nmap端口扫描工具nmap对目标主机的某个端口发送一个特殊的TCP SYN数据报，有3种可能 源主机从目标主机接收到一个TCP SYNACK报文段。这意味着目标主机上一个应用程序使用该TCP端口运行，nmap返回“打开”。 源主机从目标主机接收到一个TCP RST报文段。这意味着目标主机上没有一个应用程序使用该TCP端口运行，但至少发送向该端口的报文段没有被防火墙阻拦。 源什么也没有收到。防火墙GG。 TCP拥塞控制让每一个发送方根据所感知到的网络拥塞成都来限制其发送流量的速率。 发送方TCP跟踪一个拥塞窗口变量cwnd，它对一个TCP发送方能向网络中发送流量的速率进行了限制。 \\text{LastByteSent}-\\text{LastByteAcked}\\le\\min\\{\\text{cwnd},\\text{rwnd}\\}发送方的速率大概是cwnd/RTT字节/秒。 丢包事件：出现超时，或收到来自接收方的3个冗余ACK。此时发送方认为出现了拥塞指示。 自计时：TCP使用收到的ACK（或计时）增大它的拥塞窗口长度。 TCP拥塞控制算法具体看图 慢启动 当一条TCP连接开始时，cwnd通常设为一个MSS的较小值，初始发送速率大约为MSS/RTT。 每当传输的报文段首次被确认，cwnd增加一个MSS（指数增长 结束方式 当cwnd==ssthresh时，结束慢启动并转移到拥塞避免模式。cwnd最多只能取到ssthresh，即使不是2的幂次 超时丢包（拥塞）：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2 检测到3个冗余ACK：执行一次快速重传并进入快速恢复状态 拥塞避免 每个RTT只将cwnd的值增加MSS。一种通用实现方法：发送方无论何时收到一个新的确认，就将cwnd增加一个$\\text{MSS}\\frac{\\text{MSS}}{\\text{cwnd}}$字节。 结束方式 超时：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2 3个冗余ACK：cwnd减半，对收到的3个冗余ACK再加上3个MSS；将ssthresh的值改为cwnd/2；进入快速恢复状态 快速恢复 对于引起TCP进入快速恢复状态的缺失报文段，对每个收到的冗余ACK，cwnd增加一个MSS 当最终对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态 超时：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2，进入慢启动状态 忽略慢启动，TCP的拥塞控制：每个RTT内线性增加1MSS，出现3个冗余ACK时cwnd减半——加性增，乘性减（AIMD） 吞吐量一条连接的平均吞吐量=\\frac{0.75\\times W}{\\text{RTT}} $W$：丢包事件发生时的窗口长度 TCP的发送速率大约是$w/RTT$,$w$为窗口长度 TCP的传输速率在$W/(2\\times\\text{RTT})$和$W/\\text{RTT}$之间线性变化 考虑丢包率（$L$）和MSS，一条连接的平均吞吐量=\\frac{1.22\\times\\text{MSS}}{\\text{RTT}\\sqrt{L}} 公平性如果每条连接都得到相同份额的带宽，则认为该拥塞控制机制是公平的。 实际情况下具有较小RTT的连接能够更快地抢到可用带宽。 UDP是无法无天的，并行TCP连接是“作弊” CH4 网络层：数据平面概述数据平面：从输入链路向输出链路转发数据报控制平面：协调本地的每个路由器的转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送 转发 路由选择 将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作 分组从源到目的地所采取的端到端路径的网络范围 时间尺度短(ns) 时间尺度长(s) 通常硬件实现 通常软件实现 路由选择算法决定插入该路由器转发表的内容 软件定义网络(SDN): 路由选择设备仅执行转发，远程控制器计算并分发转发表(软件实现) 网络服务模型：尽力而为服务 路由工作原理假设：转发决定仅基于分组的目的地址，而非基于通用的分组首部字段 路由器组成部分：输入端口，交换结构、输出端口、路由选择处理器 输入端口处理数据报-&gt;线路端接-&gt;数据链路处理(协议、拆封)-&gt;查找、转发、排队-&gt;交换结构 使用转发表查找输出端口，转发表由路由选择处理器计算和更新，从路由选择处理器经过独立总线复制到线路卡。使用每个输入端口的影子副本，转发决策能在每个输入端口本地做出，无须基于每个分组调用集中式路由选择处理器，避免集中式处理的瓶颈。 转发表：前缀匹配，最长前缀匹配规则 在某些设计中，一个分组可能会在进入交换结构时被暂时阻塞 查找外必须采取许多其他动作 必须出现物理层和链路层处理 必须检查分组的版本号、检验以及寿命字段，并且重写后两个字段 必须更新用于网络管理的计数器 “匹配加动作” 交换 经内存交换 类似传统计算机 在CPU(路由选择处理器)的直接控制下完成 输入与输出端口的功能像传统I/O设备 分组到达输入端口-&gt;中断-&gt;分组被复制到处理器内存-&gt;CPU提取目的地址，在转发表中找到适当的输出端口-&gt;CPU将分组复制到输出端口的缓存中 若内存带宽为$B$个分组/秒，则总的转发吞吐量必然小于$B/2$ 不能同时转发两个分组 经总线交换 输入端口经共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预 输入端口为分组预先计划一个交换机内部标签(首部)，指示本地输出端口-&gt;分组能被所有输出端口收到，但只有标签匹配的端口才能保存分组-&gt;标签在输出端口被去除 一次只有一个分组能跨越总线，因此多个分组同时到达路由器时，除了一个分组外其他都必须等待 经互联网络交换 纵横式交换机：$2N$条总线，连接$N$个输入端口和$N$个输出端口 交缠点通过交换结构控制器实现开启闭合 分组到达输入端口-&gt;交叉点-&gt;输出端口 非阻塞：能够并行转发多个分组 多级交换元素 输出端口处理交换结构-&gt;排队(缓存管理)-&gt;数据链路处理(协议，封装)-&gt;线路端接-&gt; 排队丢包：排队导致路由器的缓存空间耗尽 输入排队 线路前部(HOL)阻塞：在一个输入队列中排队的分组必须等待通过交换结构发送(即使输出端口是空闲的)，因为它被位于线路前部的另一个分组所阻塞 — 对纵横式交换结构而言 输出排队 主动队列管理：在缓存填满之前丢弃一个分组（或在首部加上标记），可以向发送方提供一个拥塞信号 缓存数量$B$与平均往返时延$RTT$、链路容量$C$、TCP流$N$的关系：$B=RTT\\cdot C$, ($N$较大时)$B=RTT\\cdot C/\\sqrt{N}$ 分组调度 FIFO 优先权排队 有多个优先权类，分开排队 每次选择非空的最高优先权类队列中的分组进行传输 非抢占式优先权排队：一旦分组开始传输就不能打断 循环排队 没有服务优先权，循环调度器在类之间轮流提供服务 保持工作排队规则：在有分组排队等待传输时不允许链路保持空闲—当寻找给定类的分组但没有找到时立即检查下一个类 加权公平排队(WFQ) 循环方式 每个类在任何时间间隔都可能收到不同数量的服务，每个类$i$被分配一个权$w_i$ 第$i$类 将确保接收到的服务部分等于$w_i/(\\sum w_i)$ 最坏情况下第$i$类也能分得上述那么多带宽 IPv4数据报格式 版本号：4比特，规定了数据报的IP协议版本，不同IP版本使用不同的数据报格式。 首部长度：4比特，IPv4数据报包含可变数量的选项，所以需要确定首部长度。大多数IP数据报不包含选项，所以一般具有20字节的首部。 服务类型(TOS)：8比特，使不同类型的IP数据报能相互区别开来。 数据报长度：16比特，IP数据报首部+数据的总长度，单位字节。理论最大长度为65535字节，但实际上很少有超过1500的。这个长度使得IP数据报能容纳最大长度以太网帧的载荷字段。 标识、标志、片偏移：与IP分片有关。 寿命(TTL)：确保数据报不会永远（如由于长时间的路由选择环路）在网络中循环。每当一台路由器处理时该字段的值-1，为0时自动丢弃。 协议：仅当到达最终目的地时才会有用，指示了IP数据报需要交给哪个特定的运输层协议。协议号是将网络层与运输层绑定到一起的黏合剂。（端口号是将运输层和应用层绑定到一起的黏合剂） 首部检验和：首部中的每两个字节当成一个数，用反码算术求和。每台路由器上必须重新计算检验和并再次存放到远处，因为TTL字段以及可能的选项字段会改变。【为什么TCP/IP都执行差错检测？—因为TCP和IP可以分别运行在不同的协议栈上 源和目的地IP地址：源主机通过DNS查找来决定目的地址。 选项：允许IP首部被扩展，很少使用。 数据(有效载荷)：大多数时候承载运输层报文，也可承载其他类型的数据,e.g.ICMP报文 20字节IP首部+20字节TCP首部=40字节数据报首部 数据报分片原因：发送方与目的地路径上的每段链路可能使用不同的链路层协议最大传送单元(MTU)：一个链路层帧能承载的最大数据量每个较小的数据报称为片(fragment) 发送主机将发送的每个数据报的标识号+1 路由器对数据报分片时，每个片具有初始数据报的源地址、目的地址和标识号 目的地主机能够检查数据报的标识号以确定哪些数据报实际上是同一较大数据报的片 IP是不可靠服务—初始数据报的最后一篇标志比特为0，其他片为1 为了让目的主机确定是否丢了一个片且按正确顺序组装片，使用偏移字段制定该片应该放在初始IP数据报的哪个位置 编址一台主机通常只有一条链路连接到网络，主机与物理链路之间的边界叫作接口。路由必须拥有多条链路与之相连接，路由器与它任意一条链路之间的边界也叫作接口。一个IP地址与一个接口相关联。 IP地址长32比特，采用点分十进制记法书写格式：$a.b.c.d/x$ 子网掩码：32位中前$x$比特全取1 最高$x$比特构成了网络部分，也称前缀 组织内部的设备的IP共享相同的前缀 减少了子网外路由器中转发表的长度 子网：分开主机和路由器的每个接口，产生几个隔离的网络孤岛，使用接口端接这些隔离的网络的端点。这些隔离的网络中的每一个都叫作一个子网。在给定子网上的所有设备都具有相同的子网地址。因特网地址的分配策略称为无类别域间路由选择(CIDR, Classless Interdomain Routing)寻址：最长前缀匹配，选择与目的地址相匹配的最长地址前缀IP广播地址：255.255.255.255，当报文的目的地址是广播地址时会被交付给同一个网络中的所有主机，路由器也会有选择地向临近的子网转发该报文 获取一块地址ISP从自己的大地址块中提供一些地址给组织IP地址由因特网名字和编号分配机构(ICANN)管理，ICANN还管理DNS根服务器 获取主机地址：DHCP 动态主机配置协议(DHCP)允许主机获取一个IP地址，还允许主机得知子网掩码、第一跳路由器地址(默认网关)、本地DNS服务器的地址 即插即用协议/零配置协议 客户-服务器协议 每个子网将具有一台DHCP服务器 如果某子网中没有DHCP服务器，则需要一个DHCP中继代理（通常是一台路由器），这个代理用于知道该网络的DHCP服务器的地址 DHCP协议4步 DHCP服务器发现 使用DHCP发现报文 源地址：0.0.0.0(“本主机”)，目的地址：255.255.255.255(广播地址) 用于一个新到达的主机发现一个要与其交互的DHCP服务器 DHCP服务提供 DHCP服务器收到DHCP发现报文后对客户做出响应 使用DHCP提供报文，包含发现报文的事物ID、向客户推荐的IP地址、网络掩码、IP地址租用期(即IP地址的有效时间量，通常为几小时或几天) 源地址：自己的IP地址，目的地址：255.255.255.255(广播地址) 子网中可能存在多个DHCP服务器，客户需要选择一个 DHCP请求 客户向选中的服务器提供DHCP请求报文进行响应，回显配置的参数 源地址：0.0.0.0.，目的地址:255.255.255.255 DHCP ACK 服务器用DHCP ACK报文对DHCP请求报文进行响应，证实所要求的参数 源地址：DHCP服务器自己的地址，目的地址:255.255.255.255 客户收到DHCP ACK后交互完成 不能维持与远程应用之间的TCP连接 网络地址转换(NAT) NAT使能路由器 4个接口具有相同的网络地址10.0.0/24 地址空间10.0.0.0/8是在RFC 198中保留的三部分IP地址空间之一，用于家庭网络等专用网络或具有专用地址的地域，仅在给定的网络中才有意义 NAT使能路由器对外界的行为如同一个具有单一IP地址的单一设备 所有流向外界/进入家庭的报文都拥有同一个源/目的IP地址 NAT使能路由器对外界隐藏了家庭网络的细节 NAT转化表 NAT收到家庭主机发送向外界的数据报后，为其生成一个新的源端口号，将源IP替代为其广域网一侧接口的IP地址，且将源端口号替换为新生成的端口号 端口号字段16字节，NAT协议可支持超过60000个并行使用路由器广域网一侧单个IP地址的连接 路由器中的NAT在其NAT转换表中增加一个表项，记录WAN端和LAN段IP地址及端口的对应关系 IPv6数据报格式 定长40字节(320比特)首部 版本(4比特)：标识IP版本号，IPv6将其设置为6 设置为4不能得到合法的IPv4数据报 流量类型(8比特)：与IPv4的TOS类似，使不同类型的IP数据报能相互区别开来 流标签(20比特)：标识一条数据报的流 对一条流中的某些数据报给出优先权 也能够用来对来自某些应用的数据报给出更高的优先权 有效载荷长度(16比特无符号整数)：定长40字节数据报首部后的字节数量 下一个首部(8比特)：表示数据报中的内容要交付给哪个协议(e.g.TCP or UDP)，取值同IPv4 跳限制(8比特)：相当于IPv4的TTL，转发的每台路由器对该字段的值-1，到0自动丢弃 源地址和目的地址(各128比特) 数据 相对IPv4的变化新增了： 扩大的地址容量 地址长度：32 bits -&gt; 128 bits 引入任播地址：可以使数据报交付给一组主机中的任意一个 流定义 删去了： 分片/重新组装：因为太耗时了 如果路由器收到的IPv6数据报太大不能转发到出链路上的话，路由器只需丢弃该数据报，并向发送方发回一个“分组太大”的ICMP差错报文 大大加快了IP转发速度 首部检验和：因为太耗时了，而且多余 选项：不属于首部的一部分，但没有消失，可能出现在“下一个首部”指出的位置上 使得IPv6的首部是定长的 IPv4到IPv6的迁移建隧道 隧道：两台IPv6路由器之间的中间IPv4路由器集合 隧道发送端的IPv6节点(B)将整个IPv6数据报放到一个IPv4数据报中,将源地址设为自己，目的地址设为隧道接收端的IPv6节点(E) 中间的IPv4路由器照常转发IPv4数据报 隧道接收端通过观察IPv4数据报中协议号字段是41确定该数据报含有一个IPv6数据报，并将其取出 CH5 网络层：控制平面路由选择算法目的：从发送方到接收方的过程中确定一条通过路由器网络的好的路径(等价于路由) 集中式路由选择算法：具有全局状态信息的算法，必须知道每条链路的开销，常被称为链路状态(LS)算法 分布式路由选择算法：以迭代、分布式的方式计算最小开销路径，每个节点只有与其相邻节点的信息 静态路由选择算法：路由随时间变化缓慢 动态路由选择算法：随着网络流量负载或拓扑发生变化而改变路由选择路径 负载敏感算法：链路开销会动态地变化反映出底层链路的当前拥塞水平 负载迟钝算法 链路状态路由选择算法输入：让每个节点向网络中所有其他节点广播链路状态分组——链路状态广播算法Dijksra算法最差情况下复杂性为$O(n^2)$ 问题：链路开销非对称，即链路开销对应于承载的流量会出现振荡：所有的流量都被导向同一个方向路由器的自同步：即使它们在初始时以同一周期但在不同时刻执行算法，算法执行时机最终会在路由器上变为同步并保持解决方案：让每台路由器发送链路通告的时间随机化 距离向量(DV)路由选择算法分布式的、迭代的（能自我终止）、异步的距离向量：$\\bf{D}_x$$=\\left[D_x(x), D_x(y), D_x(z) \\right]$Bellman-Ford算法Bellman-Ford方程：$d_x(y)=\\min_v{c(x,v)+d_v(y)}$ 每个节点等待来自任何邻居的更新，当接收到一个更新时计算它的新距离向量并向它的邻居分布其新距离向量 当一个节点检测到从它自己到邻居的链路开销发生变化时，它就更新其距离向量——可能会出现路由选择环路：y通过z到x，同时z通过y到x因为开销改变的链路在其他节点的距离表中的信息仍没有被抹去 链路开销的增加会导致坏消息传播得很慢——无穷计数问题 毒性逆转：撒谎设置$D_z(x)=\\infty$，这样y就永远不会试图经由z路由选择到xWiki: In computer networking, split-horizon route advertisement is a method of preventing routing loops in distance-vector routing protocols by prohibiting a router from advertising a route back onto the interface from which it was learned.(从哪里学习来的，就拒绝发回到哪里去)依然无法解决无穷计数问题 比较 维度 LS DV 报文复杂性 发送$O(\\ NE\\ )$个报文，每次改变向所有节点发送新开销 每次迭代邻居间交换报文 收敛速度 还行(?)，多项式时间 收敛较慢，且会出现路由选择环路 健壮性 路由器某种程度上分离 一个不正确节点的计算值会扩散到整个网络 因特网自治系统内部的路由选择：OSPF规模(无穷计数)和管理自治(ISP按自己意愿运行路由器)问题——解决：自治系统(AS)每个AS由一组通常处在相同管理控制下的路由器组成一个自治系统由其全局唯一的AS号(ASN)所标识，ASN由ICANN区域注册机构发放 OSPF：开放最短路优先，Open Shortest Path First开放：公众可用LS协议，使用洪泛链路状态信息和Dijkstra最短路径算法各条链路开销为网络管理员手动配置 路由器向AS内所有其他路由器广播路由选择信息 每当一条链路状态发生变化时，路由器就会广播链路状态信息；即使未变化，也会至少每隔30min一次广播链路状态——增加鲁棒性 OSPF报文由IP承载，对上层协议的值为89，因此OSPF协议必须自己实现诸如可靠报文传输、链路状态广播等功能。 还要检查链路正在运行(通过向邻居发送HELLO报文)，并允许OSPF路由器获得相邻路由器的网络范围链路状态的数据库 优点： 安全：能鉴别和加密(简单的orMD5) 支持选择多条相同开销的路径 对单播与多播路由选择的综合支持 支持在单个AS中的层次结构 区域边界路由器：为流向该区域以外的分组提供路由选择 主干区域：为该AS中其他区域之间的流量提供路由选择，所有区域边界路由器+一些非边界路由器 AS间的路由选择协议：BGPBGP：边界网关协议, Broder Gateway Protocol分布式、异步分组不是路由到特定地址，而是路由到CIDR化的前缀，每个前缀表示一个子网或一个子网的集合 BGP为每台路由器提供了一种完成以下任务的手段： 从邻居AS获得前缀的可达性信息 确定到该前缀的“最好的”路由 通告BGP路由信息对于每个AS，每台路由器要么是一台网关路由器，要么是一台内部路由器。网关路由器：位于AS边缘，直接连接到在其他AS中的路由器内部路由器：仅连接在它自己AS中的主机和路由器 每对路由器通过使用179端口的半永久TCP连接交换路由选择信息。每条直线连接以及所有通过该连接发送的BGP报文，称为BGP连接跨越两个AS的BGP连接称为外部BGP连接(eBGP)在相同AS中的两台路由器之间的BGP称为内部BGP连接(iBGP)直接连接在不同AS中的网关路由器的每条链路通常有一条eBGP连接，在每个AS中的路由器之间还有多条iBGP连接，iBGP连接不总是与物理链路对应 前缀中包含一些BGP属性前缀+其属性称为路由 AS-PATH属性：包含了通告已经通过的AS的列表 当一个前缀通过某AS时，该AS将其ASN加入AS-PATH的现有列表 BGP路由器还使用AS-PATH属性来检测和防止通告环路，如果一台路由器在路径列表中看到了包含它自己的AS，则它将拒绝该通告 NEXT-HOP属性：AS-PATH起始路由器接口的IP地址（到达前缀$x$路径上的第一台路由器的地址 热土豆路由选择实际上明明是烫手山芋 从所有可能的路由中选择到开始该路由的NEXT-HOP路由器具有最小开销的路由路由器尽可能快地将分组送出其AS，而不担心AS外部到目的地的余下部分的开销对于在相同AS中的两台路由器，可能对相同前缀选择两条不同的AS路径 路由选择算法输入：到某前缀的所有路由的集合 当有多条路由时，顺序调用以下消除规则： 路由被指派一个本地偏好值属性。该属性为策略决定，取决于网管，高的被优先选择（可能会有多条）。 从余下的路由中选择具有最短AS-PATH的路由。如果这是唯一路由选择规则，使用DV算法决定路径，其中距离测度为AS跳的跳数。 从余下的路由中使用热土豆路由选择，即最靠近NEXT-HOP路由器的路由 如果仍留下多条路由，使用BGP标识符来选择路由 IP任播通常用于DNS中DNS服务器为多台服务器指派相同的IP地址，并且使用标准的BGP从这些服务器来通告该IP地址。当某台BGP路由器收到对于该IP地址的多个路由通告，它将这些通告处理为对相同的物理位置提供不同的路径。当配置其路由表时，每台路由器将本地化地使用BGP路由选择算法来挑选到该IP地址的“最好的”路由。无论客户位于何处，当想向DNS服务器的某个IP地址发送一个请求时，因特网路由器则向那个“最近的”服务器转发该请求分组，最近的服务器是有BGP路由选择算法所定义的。 路由选择策略多宿接入ISP：经由两个不同的ISP连接到网络的其余部分的经验法则：任何穿越某ISP主干网的流量必须是其源或目的（或两者）位于该ISP的某个客户网络中 5.6 ICMP因特网控制报文协议 ICMP报文 用于主机和路由器彼此沟通网络层信息 承载在IP分组中 类型字段+编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8个字节 ping 发送一个ICMP类型8编码0（回显请求）到指定主机 目的主机发回一个类型0编码0的ICMP回显应答 traceroute 跟踪从一台主机到世界上任意一台主机之间的路由 源主机发送一些列数据报，每个都携带一个具有不可达UDP端口号的UDP报文段，且第$n$个数据报的TTL为$n$ 第$n$台路由器丢弃该数据报并发送一个ICMP告警报文（类型11编码0）给源主机 目的主机会向源主机发送一个端口不可达的ICMP报文（类型3编码3），源主机收到时就知道不需要再发送另外的探测分组。 Ch6 链路层和局域网6.3 多路访问链路和协议 点对点链路：单个发送方和单个接收方 广播链路：多个发送方和多个接收方，连接到相同、单一、共享的信道上 多路访问协议：节点通过这些协议来规范它们在共享的广播信道上的传输行为 信道划分协议、随机接入协议、轮流协议 碰撞：节点同时收到多个帧 多路访问协议特性： 当仅有一个节点发送数据时，该节点具有$R$ bps的吞吐量 当有$M$个节点发送数据时，每个节点的平均传输速率为$R/M$ bps 协议是分散的：不会因为某主节点故障而使整个系统崩溃 协议是简单的，使实现不昂贵 6.3.1 信道划分协议 时分多路复用（TDM） 将时间划分为时间帧，每个时间帧划分为$N$个时隙 优点：消除碰撞；非常公平 缺点：节点被限制于$R/N$的平均速率；节点必须总是等待它在传输系列中的轮次 频分多路复用（FDM） 将$R$bps信道划分为$N$个不同的频段，每个频段的带宽为$R/N$ 优点：避免碰撞；带宽公平划分 缺点：限制一个节点的带宽； 码分多址（CDMA） 对每一个节点分配一种不同的代码 优点（特性）：不同节点能够同时传输，接收方仍能正确接收 6.3.2 随机接入协议 一个传输节点总是以信道全部速率发送，有碰撞时等待一个随机时延后反复重发。 时隙ALOHA 有新帧要发送时等在下一个时隙开始传输，发生碰撞则之后每个时隙以概率$p$重传 有ACK 假设：一个时隙=一帧的传输时间，节点只在时隙起点开始传输，节点同步，节点在时隙结束之前能检测到碰撞 优点：唯一活跃节点独享带宽；高度分散，每个节点独立决定重传时机（但是需要同步时隙） 缺点：有多个节点时，效率为$Np(1-p)^{N-1}$（$N\\to\\infty$时为$1/e$) 效率定义：当有大量活跃节点且每个节点总有大量的帧要发送时，长期运行中成功时隙（刚好只有一个节点传输的时隙）的份额 ALOHA 帧首次到达节点立刻传输；若发生碰撞立刻以概率$p$重传，如未重传则在接下来每一个帧传输时间以概率$p$重传 有ACK，非时隙、完全分散 一个给定节点成功传输一次的概率$p(1-p)^{2(N-1)}$，$N\\to\\infty$时为$1/2e$（完全分散的代价） 载波侦听多路访问（CSMA） （说话之前先听）节点等待直到检测到一小段时间没有传输才开始传输 （如果与他人同时开始说话，停止说话）检测到另一个节点在传输干扰帧就停止传输 端到端信道传播时延（信号从一个节点到另一个节点所花费的时间）是决定性能的关键；时延越大检测不到另一个节点开始传输的机会越大。 具有碰撞检测的载波侦听多路访问（CSMA/CD） 碰撞检测：如果检测到其他适配器的信号能量，停止传输，等待一个随机时间量后重新开始侦听信道空闲。 无ACK，不同步 二进制指数后退：经历了一连串$n$次碰撞后，随机选择整数$K\\in[0, 2^n-1]$，以太网中一个节点等待的实际时间量为$512K$比特时间（发送512比特进入以太网所需时间的$K$倍），$n\\le 10$。 $K$的选择集合随着碰撞次数呈指数增长，满足碰撞节点越多，时间间隔越长的需求。 不考虑近期过去的时间内可能已经发生的任何碰撞。 效率：大量节点大量帧，帧在信道中无碰撞地传输那部分时间在长期运行时间中所占份额。 效率近似为 \\frac{1}{1+5d_{prop}/d_{trans}} $d{prop}$：信号能量在任意两个适配器中所占份额；$d{trans}$：传输一个最大长度的以太网帧的时间 具体过程（By Maxwell） 监听: 监听信道是否空闲, 空闲时才开始传输；传输前要等96比特时间（最小帧间隔） 传输: 传输时也不断监听是否有其他结点的信号能量 成功: 未发现其他能量, 认为发送成功 失败: 发现其他能量, 立刻停止; 发送48bit干扰信号 等待(非持续): 等待一个随机时间, 回到”监听”重传 回退(p持续): 之后的时间当中以概率p重传 回退(1持续, 以太网): 使用二进制指数后退：经历过了$n$次碰撞, 就从$[0,\\ldots,2^n-1]$中选一个$K$值, 等待$512K$个比特时间；$n$最大为10；最多尝试16次发送 最小帧长: 检测冲突的时长不超过端到端传播时延的2倍, 取这一值为最小帧长（不然还没检测到碰撞一帧就发完了 ALOHA和CSMA具备特性一（独占信道），不具备特性二（平均信道） 6.3.3 轮流协议 轮询协议 主节点循环轮询每个节点，告诉每个节点最多能够传输帧的数量（主节点能观察信道上是否缺乏信号来决定一个节点何时完成了帧的发送） 优点：消除碰撞和空时隙，效率高 缺点：引入轮询时延（通知一个节点可以传输所需的时间），不满足特性一；不分散，主节点挂了全挂 令牌传递协议 没有主节点，一个称为令牌的小的特殊帧在节点间以某种固定次序交换 当一个节点收到令牌时，仅当它有一些帧要发送时，它持有令牌并发送最大数目的帧，发完后将令牌转发给下一个节点；没有帧要发送就立即将令牌转发给下一个节点。 优点：分散的，效率高 缺点：一个节点故障可能会使这个信道崩溃；一个节点忘了释放令牌就需要调用某些恢复步骤；令牌传播时延 6.4 交换局域网6.4.1 链路层寻址和ARP MAC地址 每个适配器（网络接口）都具有链路层地址，即LAN地址、物理地址或MAC地址。（路由器有多个接口就有多个MAC地址） 链路层交换机的任务：在主机与路由器之间承载数据报，因此不具有MAC地址，主机和路由器也不必明确地将帧寻址到其间的交换机 MAC地址通常为6字节，十六进制表示，e.g.MAC广播地址：FF-FF-FF-FF-FF-FF 扁平结构：每台适配器的MAC地址都不同，且不会因为在哪里而改变 发送适配器将MAC地址插入发送的帧；适配器接收到帧使检查是否与本机MAC地址匹配，不匹配则丢弃 地址解析协议：在网络层地址和链路层地址之间进行转换的协议 主机中的ARP模块：取在相同子网上的任何IP地址作为输入，然后返回相应的MAC地址 每台主机和路由器都维护ARP表：包含IP地址到MAC地址的映射关系，每个表项都有寿命（TLL） 解析不在表中的地址：发送方广播ARP查询分组（广播帧）$\\to$所有适配器检查自身IP地址，匹配者返回一个响应ARP分组（标准帧）$\\to$查询方更新ARP表 ARP表即插即用，自动建立 发送数据报到子网外 主机获得的子网外IP的MAC地址是子网内路由器接口的MAC地址（直接发的数据报会到达数据报天国） 路由器在网络层查询转发表，将数据报转发到正确的接口，此时目的MAC地址是最终目的地的MAC地址 6.4.2 以太网 集线器（hub）：物理层设备，当一个比特到达接口时重新生成该比特，并向其他所有接口传出去——采用星形拓扑的以太网也是广播局域网 以太网帧结构 前同步码|目的地址|源地址|类型|数据|CRC 前同步码（8）：前7字节10101010用于唤醒接收适配器并同步接收方和发送方的时钟；最后一字节10101011，最后两比特警告接收适配器 目的地址（6）：目的地址是自己的MAC地址或广播地址就直接将数据字段内容传递给网络层；否则丢弃 源地址（6） 类型（2）：允许以太网复用多种网络层协议。 数据（46~1500）：承载IP数据报；最小长度46（不够就填充），最大1500（多了就分片）；网络层使用IP数据报首部中的长度字段除去填充部分。 CRC（4）：出错的帧直接丢弃 无连接服务：不需要握手 不可靠服务：无ACK和NACK——简单和便宜，数据报流可以有间隙 以太网技术 命名: [速率]BASE[距离 或 介质], T指铜双绞线, FX/SX/BX指光纤 10Mbps: 10BASE[%d], 距离, 使用同轴电缆 100Mbps: 100BASE-TX/T4/T2双绞线, -FX/SX/BX光纤 1000Mbps: 1000BASE-T等, 又名802.3z, 双绞线, 兼容旧标准, 点对点(交换机)信道全双工, 另有广播(集线器) 10Gbps: 10GBASE-T 6.4.3 链路层交换机 交换机对于子网中的主机和路由器是透明的 交换机输出接口设有缓存 交换机转发和过滤 过滤：决定帧转发到某个接口还是丢弃 转发：决定帧被导向哪个接口 交换机表（地址-接口-时间） 工作过程：（帧从接口$x$来） 对于没有的表项，交换机向$x$之外所有接口广播 存在表项将目的地址与$x$对应，直接丢弃 存在正常的目的地址对应接口，放到对应输出缓存里 自学习 交换机表初始为空 对于每个接口收到的每个入帧，存储（源地址-接口-当前时间） 在老化期后，交换机没有收到这个地址发来的帧就删除这个地址 即插即用、双工（同时发送和接收） 链路层交换机的性质（优点） 消除碰撞：绝不会在网段上同时传输多于一个帧，不浪费带宽；最大聚合带宽=所有接口速率之和 异质链路：不同链路能以不同速率运行在不同的媒体上 管理：能检查并断开异常适配器 交换机v.s.路由器 路由器网络层，交换机链路层 交换机 优点：即插即用；相对高的分组过滤和转发速率； 缺点：交换网络活跃拓扑限制为一颗生成树（防止广播帧循环）；对广播风暴不提供保护措施 路由器 优点：网络寻址分层，分组不会循环（除非路由表配错了），不会限制于生成树；对链路层广播风暴提供防火墙保护 缺点：不即插即用；处理分组响应时间长；争论单词发音 网桥（From ppt， By Maxwell） 功能: 读取A网(总线)的所有帧, 在B(总线)上重发每个帧; B-&gt;A同理 特点: 不更改帧, 原样转发; 带缓存; 路由寻址能力(基于MAC, 只转发需要转发的帧) 协议体系 层次: 数据链路层 - MAC层 链接模式 局域网 - 网桥 - 局域网, 原样转发 局域网 - 网桥 - [网络或链路] - 网桥 - 局域网, 需要适当封装, 但原始MAC帧不修改 固定路由选择 每对点均有一条选定的路由, 跳数最少, 仅在拓扑变化时改变(生成树算法) 生成树方法 帧转发 x收到帧 检查目的地址: 若在某一端口的列表中, 且非阻塞, 发送; 不在任何列表, 则x除以外的端口全部转发 地址探索: 同交换机 收到帧, 则帧源地址MAC与此端口关联, 加入此端口数据库 数据库项带计时器, 超时删除 最小生成树算法: Prim Prim算法流程 选取起始点(根网桥), 加入集合S 对于S中所有点(网桥), 在他们所有邻居里面找离S中点最短的距离, 把这个邻居加入S, 这条边(网桥间的最短距离)加入生成树 直到所有点都加入S, 边集合构成生成树 网桥阻塞规则 选择根网桥: ID最小的网桥 为每个网桥选择root port: 到根网桥最低开销的端口 为每个LAN指定网桥: 拥有到根网桥最低开销路径的, 与这个LAN相连的网桥 Designated port: 这个指定网桥与这个LAN相连的端口 Designated port 和 root port 不阻塞, 别的都阻塞 6.4.4 虚拟局域网 树形（等级结构）局域网的缺点 缺乏流量隔离：广播无法隔离，拉低局域网性能，缺乏安全隐私保护 交换机无效使用：分组造成交换机端口浪费，单一交换机不能提供流量隔离 管理用户：用户在组间移动时需要改变物理布线 虚拟局域网（VLAN）： 支持VLAN的交换机允许经一个单一的物理局域网定义多个虚拟局域网 交换机端口由网管划分为组，每个组构成一个VLAN，在每个VLAN中的端口形成一个广播域 交换机维护端口-VLAN映射表 跨VLAN通过路由器实现通讯 VLAN干线连接：属于所有VLAN，发送到任何VLAN都经干线链路转发到其他交换机 以太网帧格式802.1Q，在源地址与类型字段间加入标签协议标识符（2）、标签控制信息（2） Ch7 无线网络和移动网络7.1 概述（非考点，By hyc） 无线主机：运行应用程序的端系统设备，如便携机、掌上机、智能手机或桌面计算机 无线链路：连接无线主机或基站或另一台无线主机的链路 基站：无线网络基础设施的一个关键部分，负责向与之关联的无线主机发送数据和从主机那里接收数据，负责协调与之相关联的多个无线主机的传输。 相关联：该主机位于该基站的无线通信覆盖范围内；该主机使用该基站中继它和更大网络之间的数据。 无线网络的分类依据：是否跨越了一个无线跳或多个无线跳；网络中是否有诸如基站这样的基础设施。 单跳，基于基础设施：802.11网络、3G蜂窝网络 单跳，无基础设施：蓝牙网络、具有自组织模式的802.11网络 多跳，基于基础设施：无线传感网络、无线网状网络 多跳，无基础设施：移动自组织网络（如车载自组织网络） 7.3 WiFi:802.11 无线LAN7.3.1 802.11体系结构 基本服务集（Basic Service Set，BSS）：802.11体系结构的基本构件模块，一个BSS包含一个或多个无线站点和一个称为接入点（Access Point，AP）的中央基站，AP可以连接到互联设备（如交换机或路由器）并连接到因特网中。 信道与关联 在802.11中每个无线站点在能够发送或者接收网络层数据之前，必须与一个AP相关联。 当安装一个AP时，网管会给该AP分配一个单字或双字的服务集标识符（Service Set Identifier，SSID），和一个信道号。 每个AP周期性地发送信标帧（beacon frame），每个信标帧包括该AP的SSID和MAC地址，一个无线站点扫描11个信道找出可能来自该区域的信标帧。通过信标帧了解到可用AP，选择一个与之关联。这个过程被称为被动扫描。主动扫描是通过向位于无线主机范围内的所有AP广播探测帧。 在选定与之关联的AP后，无线主机向AP发送一个关联请求帧，并且该AP以一个关联响应帧进行回应。 WiFi丛林：一个任意物理位置，在这里无线站点能从两个或多个AP中收到很强的信号 7.3.2 802.11MAC协议 站点：无线设备或AP 使用带碰撞避免的CSMA（CSMA/CA）。不使用碰撞检测，一旦站点开始发送就不会停下来了（奥尔加狂喜） 不同于以太网，使用链路层确认/重传方案（ARQ） 目的站点收到一个通过CRC校验的帧后等待一个短帧间间隔（SIFS），然后发回一个确认帧。 如果发送站点在给定时间内未收到ACK就重传，使用CSMA/CA协议访问该信道 若干固定次重传后仍无确认就丢弃该帧 不实现碰撞检测的原因： 检测碰撞的能力要求站点具有同时发送和接收的能力，制造这样的硬件代价较大； 隐藏终端问题和衰减问题导致适配器无法检测到所有的碰撞。 CSMA/CA协议 如果站点最初监听到信道空闲，在一个分布式帧间间隔（DIFS）后发送该帧 否则选取一个随机回退值，并在信道空闲时递减该值，信道忙时保持不变。 计数值减为0时发送整个数据帧并等待确认 如果收到确认，从第二步重新开始（等待一个随机回退值）；否则从一个更大的范围选取随机回退值并进入第二步中的回退阶段。 在倒计数时抑制传输的原因：无论如何尽可能避免高代价碰撞 处理隐藏终端RTS和CTS 隐藏终端：两个无线站点在AP信号覆盖范围内，但彼此之间无法信号覆盖 请求发送（RTS）控制帧和允许发送（CTS）控制帧来预约对信道的访问 发送方首先向AP发送RTS帧，指示传输数据帧和ACK帧需要的总时间；AP收到后广播一个CTS帧作为响应（给发送方明确的发送许可+只是其他站点在预约期内不要发送）；其他站点在CTS期内将抑制发送 优点：解决隐藏终端问题；RTS和CTS较短，涉及这两者的碰撞持续较短，只要正确传输，后续的数据和ACK都能无碰撞发送。 缺点：引入了时延，消耗了信道资源。 实际无线站点会设置RTS门限值，超过该值的帧才使用RTS/CTS序列。 使用802.11作为一个点对点链路 定向天线, 没其他站点, 相当于是AP与站点的点对点 7.3.3 IEEE 802.11帧【p353图7-13】 有四个地址字段。第四个地址在自组织模式中互相转发时使用。地址1：接收该帧的无线站点的MAC地址；地址2:传输该帧的站点的MAC地址；地址3:包含路由器接口的MAC地址。 序号用于区分新传输的帧和以前帧的重传 类型和子类型用于区分关联、RTA、CTS、ACK和数据帧 To, From字段用于定义不同地址字段的含义 WEP字段指示了是否使用加密 7.3.5 802.11中的高级特色 速率自适应：原理类似于TCP拥塞控制 功率管理：一个结点能够明显地在睡眠和唤醒状态之间交替 7.3.6蓝牙和ZigBee 蓝牙（IEEE 802.15.1）：小范围、低功率、低成本，自组织网络，有一个主结点控制皮可网并确定时钟 ZigBee（IEEE 802.14.5） Ch9 多媒体网络支持多媒体的网络提供多种类型的服务链路调度规则：选择在链路上传输排队分组的方式 监管：漏桶3个准则：平均速率、峰值速率、突发长度 漏桶由一个能容纳$b$个令牌的桶组成 新令牌总是以每秒$r$个速率产生 当产生一个令牌时，如果桶中少于$b$个令牌，则新产生的令牌加入到桶中，否则忽略 一个分组向网络传输之前，必须首先从令牌桶中去除一个令牌，如果令牌桶是空的，分组必须等待一个令牌。 漏桶监管的流的最大突发长度是$b$个分组，任何长度为$t$的时间间隔内能够进入网络中的最大分组数目为$rt+b$（平均速率） 在原漏桶下方再加一个令牌产生速率为$p$漏桶可以实现限制峰值速率到$p$ 漏桶+加权公平排队=队列中可证明的最大时延d_{max}=\\frac{b_i}{R\\cdot \\frac{w_i}{\\sum w_j}}","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://mengzelev.github.io/tags/notes/"}]},{"title":"托福首考日记","slug":"tofel-1st-exp","date":"2019-11-03T03:38:49.000Z","updated":"2019-11-03T07:07:09.895Z","comments":true,"path":"2019/11/03/tofel-1st-exp/","link":"","permalink":"https://mengzelev.github.io/2019/11/03/tofel-1st-exp/","excerpt":"","text":"考场情况听别人安利选了南京大学鼓楼校区C考场就在天津路校门口，地铁出去最近的一个小门进去就是计算中心虽然楼在外面看上去挺破的，但是里面还行C考场里面是一人一个小隔间这样子，感觉挺安心的，虽然戴上耳机还是能听到其他人的听力和口语声音，但是音量调到最大我个人感觉就完全没有影响了总体觉得考场还不错 考试流程上路六点起床，七点出发从南大仙林校区叫了辆出租车，三个人拼车打了82大洋，还行吧，至少比考场房便宜很多了 进场进场前有个工作人员在发一张纸让你填个人信息，声称是“学校要填的”，但那张单子非常随便，而且ETS已经有我的全部报名信息了，很显然是像把我们的个人信息卖给什么留学机构的，所以我就拒绝了，她也没有纠缠不过被“忽悠”了填的同学真的很多诶，大家对自己个人信息的保护意识也太差了吧www 八点不到就开始放人进去了，在一楼门口就要把身上的东西掏得只剩吃的、喝的、身份证，女孩子的话卫生巾也是可以带的，餐巾纸和药（我当天带了止痛药）是不让带的。 剩下的东西都要装到一个标有序号的大麻袋(x)里面去，大麻袋的钥匙可以（而且必须）带走 然后就是搜身，要把口袋里东西都掏出来全身金属探测器一下。我穿的衣服上金属饰品太多了让工作人员很无语hhhh姨妈巾拿多了还被勒令最多带一个，求了一下情才能带俩进去（中场休息换一个不是合情合理吗）。工作人员还让我把扎头发的大蝴蝶结摘下来（我觉得也不是很大啊），这也太严格了….. 搜完身之后就要填一个保密协议单，桌子上有模板，照着填就行了（我一开始还没注意到模板的存在 填完之后带着单子上三楼。水杯和吃的都要放在一张大桌子上（姨妈巾也要），要上厕所的话赶紧现在去上一个。之后就要去排队等拍照，拍完照就不能碰吃的喝的，也不能上厕所了，直接进考场坐下 以上就是南大鼓楼考场的进场流程了，我8点10分进的楼，中间出了不少小意外，等拍照的时候前面也正好人有点多，所以是8点40左右才进的考场，索性不影响考试 开考前开考前，考场里的监考老师会说一堆注意事项，我虽然都听了，但是考试时候还是没有全记起来，大概有以下几点： 草稿纸和两只铅笔用完了要换，但是要保证桌上只有3张草稿纸。草稿纸要两面都用完了才给换 有事举手的时候举高一点，因为没人一个隔间老师可能会看不见 中场休息一定要看见倒计时了再出去 中场休息只有十分钟，女厕所坑位比较少，所以一定要先去上厕所，最好提早一点回来，因为还要拍照什么的 中场休息倒计时还剩二三十秒的时候就要叫监考老师来输入密码开锁，不然可能会自动生成缺考报告（我就忘了，多亏老师发现orz 阅读instruction的时间有时候也算在考试时间里面的，基本模考时候都看过了就不要管了(x) 休息走的时候要把门带上，因为每个人结束上半场的时间不一样 P.S.在考场里脱衣服的话老师会过来把你的衣服收走，你冷了还得举手要，所以不是特别热就尽量自己忍忍吧(那我怀疑夏天去考觉得空调冷了还要举手问老师要外套) 阅读老师输完密码解锁后第一项就是阅读 我这次考试的阅读难度感觉有个别（3道左右）比较难，对应原文读不太懂，也可能是因为上考场有点简单。TPO里的阅读题还是偏简单的。 还有我最后一大题真的很薄弱orz选的三项里都至少有一项很不确定 还有考试环境里竟然都不能鼠标选中高亮，不像在网页上模考那样，经常看看题目就忘了自己考到哪了。这阅读考试也太反人类了，更别说高考那套记号系统完全废了。 我的时间分配大概是19+18+16+1min检查，因为第一篇还没进入状态，比较紧张，读起来很慢。不过可能也是依赖于二三难度比一低一点，不然可能要时间地狱了www 索性阅读没被加试 听力这次听力总体来说感觉好难，刷TPO我基本能控制到最多2题没印象，但是这次没印象的题比例特别高，感觉是不是出题点出现偏移了，导致我留意的没考到，考到的没留意orz(给自己菜找借口ing) 我听力被加试了，1对话+1授课，11min 听力时候由于每个section是紧连着的，我草稿纸写完了，点了下一题下一篇听力直接开始了，结果忘了举手换草稿纸了，唉…最后一题真的是插空式到处搜刮空间记笔记，记得七零八落的，下次一定要记得 我听到答案的题基本都是秒选，不确定的题最多纠结1分钟，时间还是比较充裕的。大家安排时间的时候最好把找老师换纸的时间算进去呀 中场休息要把身份证带走，一会儿还要拍照女厕果然排队我上个厕所回来喝了两口水吃了点东西再拍照回去，就已经只剩40s了，时间还是有点局促的呀sb如我忘了在计时器还剩几十秒的时候叫老师解锁了，幸好老师发现了 口语本来对这部分就没什么信心… Task1独立口语问的是….我忘了orzTask2是想让学生和老师的食堂合并起来。这里有个奇怪的地方是，main speaker第一个理由是赞同的，觉得这样可以腾出空间缓解拥挤，因为老师不怎么吃食堂；第二个理由却说学生会在吃饭时被老师问学习，老师可能也不想和学生聊天，反而有点反对的意思了Task3大概是生态大坝，很常规的题目。可惜我没控制好时间，没说完（自卑Task4也很典型，没什么印象了…. 总的来说感觉自己一旦专注于内容就顾及不了语音语调了，还是缺乏练习，二刷之前要专攻口语了 写作综合写作也很常规，关于天然气，阅读说它不好，听力说好，没太大问题 综合写作这次的题目我佛了考前准备了很多个人与社会方面的常用论点，身体健康、社会平等什么的，结果这次给我来了一个名人该不该表明自己的政治观点我怎么觉得这个好针对啊，N*A的事情才刚刚过去，好吧其实国外也是这样的透露着出题组满满的恶意……我是写了不应该，一个是会煽动无知群众，一个是会造成表达政治立场蹭热度的风气（这个好难写），不可否认的是对宣传好的主张有帮助。然后，突然想不起来主张怎么说(自裁)时间还是紧，有一段没写完草草收尾了，也没来得及检查拼写(再次自裁) 写作也是下次来之前要恶补的项目了…… 考完我是十二点多出考场的，考试时间缩短还是好（嘿嘿出考场才意识到自己有点饿了，要是跟原来一样考到一点估计要饿瘫了在新街口浪了一整天（其实只有大半天 总结总之感觉就是非常严格，高考都相形见绌，看来天朝还是比老美相信自己人的(雾)考场里不让喝水real难受，思考很消耗水分的啊kora本来有把握的阅读听力没发挥好，口语写作又不出所料的烂，这次就权当体验生活了，上交2k大洋下次再来","categories":[],"tags":[]},{"title":"计算机网络-课程笔记","slug":"network-notes","date":"2019-10-12T03:25:20.000Z","updated":"2020-01-01T10:22:45.880Z","comments":true,"path":"2019/10/12/network-notes/","link":"","permalink":"https://mengzelev.github.io/2019/10/12/network-notes/","excerpt":"","text":"【工事中】 Introduction ISP：因特网服务提供商 协议：定义了两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接受一条报文或其他事件所采取的动作 主机=端系统 以太网：以太网交换机-机构路由器-ISP WiFi:接入点-企业网-有限因特网 分组交换 分组交换机：路由器/链路交换机 存储转发传输：交换机能够开始向输出链路传输该分组的第一个比特钱，必须接收到整个分组 时延：$2L/R$，不存储是$L/R$ 通过$N$条速率均为$R$的链路组成的路径，端到端时延$d_{\\text{端到端}}=N\\frac{L}{R}$ 输出缓存/输出队列：链路上进入交换机前分组等待的地方 排队时延，丢包 转发表：将目的地址（或一部分）映射为输出链路 路由选择协议：自动设置转发表 电路交换 预留资源，按需使用 频分复用FDM，时分复用TDM 带宽：频分复用的宽度 时延 处理时延$d_{proc}$：检查分组首部决定讲该分组导向何处所需要的时间 也包括检查比特级别的差错需要的时间 微秒或更低数量级 排队时延$d_{queue}$：在队列中，分组在链路上等待传输的时间 取决于先期到达的正在排队等待向链路传输的分组数量 到达分组期望发现的分组数量是到达该队列的流量的强度和性质的函数 毫秒到微秒量级 传输时延$d_{trans}$：将所有分组的比特推向链路所需要的时间 毫秒到微秒量级 传播时延$d_{prop}$：一个比特从该链路的起点到路由器B的传播所需要的时间 不需要等推完了再上路，有一个比特传一个比特 两台路由器之间的距离/传播速率 毫秒量级 节点总时延$d{nodal}=d{proc}+d{queue}+d{trans}+d_{prop}$ 时延成分所起的作用可能会有很大不同 排队时延 $a$:分组的到达队列的平均速率(pkt/s) 流量强度=$La/R$ $La/R&gt;1$：到达得比传输得快，队列无限增加，排队时延趋向无穷大 流量强度越大，丢包的比例越大 假设没有排队时延的端到端时延：$d{end-to-end}=N(d{proc}+d{trans}+d{prop})$ 吞吐量 瓶颈链路 吞吐量取决于数据流过的链路的传输速率 吞吐量：每秒能够传送的数据量 协议分层服务模型：向上一层提供的服务协议栈：各层的所有协议、 应用层 网络应用程序及它们的应用层协议存留的地方 一个端系统的应用程序与另一个端系统中的应用程序交换信息分组 HTTP,SMTP,FTP,DNS 报文(message) 运输层 在应用程序端点之间传送应用层报文 TCP, UDP 报文段(segment) 网络层 将数据报从一台主机移动到另一台主机 数据报(datagram) 网际协议IP 链路层 将分组从一个节点(主机或路由器)移动到路径上的下一个节点 以太网、WiFi、电缆接入网DOCSIS、PPP 帧(frame) 物理层 将帧中的一个个比特从一个节点移动到下一个节点 协议是链路相关的，并进一步与实际传输媒体相关 OSI模型运输层和应用层之间多了表示层和会话层 表示层：使通信的应用程序能够解释交换数据的含义 数据压缩、数据加密、数据描述 会话层：数据交换的定界和同步功能 建立检查点和恢复方案 封装 链路交换机只实现链路层和物理层 路由器只实现网络层、链路层和物理层 路由器能实现IP协议，链路交换机不行 分组=首部字段+有效载荷字 网络攻击 恶意软件：进入设备干坏事 僵尸网络：受害设备网络 病毒：需要某种形式的用户交互来感染用户设备的恶意软件 蠕虫：无须任何明显用户交互就能进入设备的恶意软件 DoS：拒绝服务攻击 弱点攻击、带宽洪泛、连接洪泛 分布式Dos:DDoS 嗅探分组：分组嗅探器（被动接收机 IP哄骗：将具有虚假源地址的分组注入因特网 Ch6 链路层和局域网节点：运行链路层协议的任何设备链路：沿着相邻结点的通信信道 服务 成帧：把网络层数据报封装成链路层帧 链路接入：媒体访问控制(MAC)协议 可靠交付：确认和重传 差错检测和纠正 实现：网络适配器（网络接口卡），硬件实现 差错检测和纠正技术EDC：差错检测和纠正比特 奇偶校验 二位奇偶校验：可以纠正单比特错，可检测但不能纠正两个比特错 前向纠错FEC:接收方检测和纠正差错的能力 Internet checksum 将数据的字节作为16比特的整数对待并求和:进位加法，最高位进位需要加到末尾 相对弱的差错保护 循环冗余检测CRC 又称多项式编码：将发送的比特串看成多项式系数 $D\\cdot 2^r \\text{ XOR } R = nG$$D\\cdot 2^r=nG \\text{ XOR } R$$R=\\text{remainder}\\frac{D\\cdot 2^r}{G}$ 转自阿姨博客的表示方法： \\frac{X^{n-k}D(X)}{P(X)}=Q(X)+\\frac{R(X)}{P(X)}T(X)=X^{n-k}D(X)+R(X)其中，$X$是二进制串对应的多项式，如$P=11001, P(X)=X^4+X^3+1$接收方用$T/P$，如果不能整除，说明存在差错。 $P\\to G$ 位数：$P/G: n-k+1, D:k, T:n-k$ 可以检测小于$r+1$比特的错($r=|R|$) 多路访问链路和协议 点对点链路 广播链路 碰撞：多个节点同时传输帧导致所有节点同时接到多个帧 多路访问协议的特性(p294) 当仅有一个节点发送数据时，该节点具有$R$ bps的吞吐量 当有$M$个节点发送数据时，每个节点的吞吐量为$R/M$ bps 协议是分散的：不会因为某主节点故障而使整个系统崩溃 协议是简单的，使实现不昂贵 信道划分协议 TDM：将时间划分为时间帧，并进一步划分每个时间帧喂$N$个时隙(slot) FDM：将$R$ bps信号划分为不同的频段，并把每个频率分给$N$个节点中的一个 CDMA(码分多址)：对每个节点分配一种不同的编码，不同的节点能够同时传输，并且各自接收方能正确接收 随机接入协议 传输节点总是以信道的全部速率进行发送 当有碰撞时，涉及碰撞的每个节点反复地重发它的帧 重发之前等待一个随机时延 时隙ALOHA 所有节点要同步传输 如果有碰撞，该节点以概率$p$在后续的每个时隙中重传它的帧，直到无碰撞地传出去 时隙多路访问协议的效率：当有大量的活跃节点且每个节点总有大量的帧要发送时，长期运行中成功时隙的份额 效率：$Np(1-p)^{N-1}$, 最大$1/e$ ALOHA 一个给定节点成功传输一次的概率是$p(1-p)^{2(N-1)}$ 在$[t_0-1,t_0]$和$[t_0, t_0+1]$时间段内都不可以有别的节点传输 最大效率$1/2e$ CSMA(载波侦听多路访问) 载波侦听：说话之前先听，如果其他人正在说话，等到他们说完为止 碰撞检测：如果与他人同时开始说话，停止说话 广播信道的端到端信道传播时延在决定性能方面起到关键作用 越大，XSMA节点不能侦听到另一个节点已经开始传输的机会越大 CSMA/CD(具有碰撞检测的载波侦听多路访问) 如果适配器在传输时检测到来自其他适配器的信号能量，就中止传输，并随机等待一个随机时间量再次传输 期望：碰撞节点数较少时，时间间隔较短；反之亦然 二进制指数后退算法：经历了一连串的$n$次碰撞后，节点随机地从${0,1,2,\\cdots,2^n-1}$中选择一个$K$值，$n$最大为10 不考虑近期过去时间内可能已经发生的任何碰撞 效率$= n\\frac{1}{1+5d{prop}/d{trans}}$ 轮流协议轮询协议 主节点轮询告诉每个节点能够传输的帧的最多数量 缺点：引入了轮询时延、主节点坏了就全坏了 令牌传递协议 一个称为令牌(token)的小的特殊帧在节点之间以某种固定的次序进行交换 一个节点收到令牌时，仅当它有一些帧要传输，它才持有这个令牌，否则立即向下一个节点转发该令牌 有帧要传输时，发送最大数目的帧数，然后把令牌转发给下一个节点 缺点：一个节点坏了就全坏了，一个节点忘了释放令牌 交换局域网MAC地址 链路层地址 6个字节，$2^48$个可能，每个字节表示为一堆十六进制数 没有两块适配器具有相同的地址—IEEE管理 地址解析协议ARP ARP表：包含IP地址到MAC地址的映射关系 TTL寿命值：表示从表中删除每个映射的时间 ARP分组：包含发送和接受IP地址及MAC地址 查询分组：询问子网上所有其他主机和路由器，以确定对应于要解析的IP地址的那个MAC地址 响应分组 查询分组和响应分组格式相同 查询 ARP在广播帧中发送，响应ARP在标准帧中发送 ARP即插即用，不需要手动配置 过程 发送方向其适配器发送一个ARP查询分组 适配器在链路层帧中封装这个ARP分组，并讲该帧传输进子网中 （广播地址）每个适配器把在该帧中的ARP分组向上传递给ARP模块，每个ARP模块检查它的IP地址是否与ARP分组中的目的IP地址相匹配，与之相匹配的一个给查询主机发送回一个带有所希望映射的响应ARP分组 查询主机更新ARP表，并发送IP数据报 以太网 集线器(hub)：物理层设备，作用于比特，放大收到的比特的能量强度并向其他所有借口传输出去 广播局域网：无论何时集线器从它的一个接口接收到一个比特，它向所有其他接口发送该比特的副本 碰撞：某集线器同时从两个不同的接口接收到帧，将出现一次碰撞，生成该帧的节点必须重新传输该帧 交换机(switch)代替hub 帧结构1前同步码|目的地址|源地址|类型|数据|CRC 数据字段：承载IP数据报，最小长度46字节，最大长度1500字节 目的地址：目的适配器的MAC地址。是自己的地址/广播地址就丢给网络层，否则直接丢弃 源地址：顾名思义 类型字段：允许以太网复用多种网络层协议 CRC 前同步码 前7字节都是10101010，最后一个字节为10101011 发送方的额定速率会产生漂移，所以前7字节用来同步接收方的时钟 最后两个字节用于警告接收方重要的东西要 来 了 以太网技术向网络层提供的服务： 无连接：没有事先握手 不可靠：接收方不发送确认帧和否定确认帧，只丢弃没通过校验的帧 链路层交换机交换机的任务：接收入链路层帧并将它们转发到出链路交换机对于子网中的主机和路由器是透明的交换机输出接口设有缓存 交换机表转发和过滤借助于交换机表实现过滤：决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能转发：决定一个帧应该被导向哪个接口，并把该帧移动到哪些接口 一个表项包括： 一个MAC地址 通向该MAC地址的交换机接口 表项放置在表中的时间 工作过程 对于没有目的地址的表项，交换机广播该帧 存在到达接口与目标地址相联系的表项，丢弃该帧（过滤） 存在非到达接口与目标地址相联系的表项，交换机将帧放到目标接口的输出缓存完成转发功能 自学习 交换机表初始为空 对于每个接口接收到的每个入帧，该交换机在其表中存储 在一段时间(老化时间)后交换机没有接受到以该地址作为源地址的帧，就在表中删除这个帧 优点 即插即用 消除碰撞 绝不会在网段上同时传输多于一个帧 最大聚合带宽：该交换机所有接口速率之和（交换机间的接口不算 异质链路 能够以不同速率运行并且能够在不同的介质上运行 便于管理 缺点 活跃拓扑限制为一棵生成树 对于广播风暴不提供保护措施 特性 集线器 路由器 交换机 流量隔离 × √ √ 即插即用 √ × √ 优化路由 × √ × 虚拟局域网CH7 无线网络和移动网络无线$\\neq$移动 无线主机：到处都是 无线链路：主机通过无线通信链路连接到一个基站或者另一台无线主机； 覆盖区域和链路速率 基站：负责向与之关联的无线主机发送数据和从主机那里接收数据，协调与之相关联的多个无线主机的传输；e.g.蜂窝网络中的蜂窝塔、无限LAN中的接入点AP 基础设施模式 无线链路和网络特征有线和无线网络的主要区别在链路层，网络层及以上都是相同的 递减的信号强度：距离$\\uparrow$,信号强度$\\downarrow$ 来自其他源的干扰 多径传播：使得接收方收到的信号变得模糊 信噪比(SNR) 单位分贝(dB) 收到的信号的振幅与噪声的振幅的以10为敌的对数的比值 较大的SNR是接收方更容易从背景噪声中提取传输的信号 对于给定的调制方案，SNR越高，BER(比特差错)越低 CDMA 码分多址信道划分协议 要发送的每个比特都通过乘以一个信号(编码)的比特来进行编码，这个信号的变化速率(码片速率)比初始数据比特序列的变化速率快很多 CDMA工作假设：干扰的传输比特信号是加性的 划分编码空间 WiFi: 802.11无线LAN基本服务集(BSS): 802.11体系结构的基本构建模块，包含一个或多个无线站点和一个称为AP的中央基站每个无线站点具有一个6字节的MAC地址 信道与关联网络管理员安装AP时 为AP分配一个单字或双字的服务及标识符(SSID) 分配一个信道号 WiFi丛林：任意一个物理位置，在这里无线站点能从两个或多个AP中收到很强的信号关联：无线站点在自身和AO之间创建一个虚拟线路 被动扫描 每个AP周期性地发送信标帧 每个信标帧包括该AP的SSID和MAC地址 无线站点扫描11个信道，找出可能位于该区域的AP所发出的信标帧 主动扫描 无线主机向位于其范围内的所有AP广播探测帧 选定与之关联的AP后，无线主机向AP发送一个关联请求帧，并且该AP以一个关联响应帧进行响应 需要二次请求/响应握手 主机通常将通过关联的AP向该子网发送一个DHCP发现报文，以获取在该子网中的一个IP地址 用户名和口令 AP与一个鉴别服务器进行通信 一个鉴别服务器可以服务于多个AP CH4 网络层：数据平面概述数据平面：从输入链路向输出链路转发数据报控制平面：协调本地的每个路由器的转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送 转发 路由选择 将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作 分组从源到目的地所采取的端到端路径的网络范围 时间尺度短(ns) 时间尺度长(s) 通常硬件实现 通常软件实现 路由选择算法决定插入该路由器转发表的内容 软件定义网络(SDN): 路由选择设备仅执行转发，远程控制器计算并分发转发表(软件实现) 网络服务模型：尽力而为服务 路由工作原理假设：转发决定仅基于分组的目的地址，而非基于通用的分组首部字段 路由器组成部分：输入端口，交换结构、输出端口、路由选择处理器 输入端口处理数据报-&gt;线路端接-&gt;数据链路处理(协议、拆封)-&gt;查找、转发、排队-&gt;交换结构 使用转发表查找输出端口，转发表由路由选择处理器计算和更新，从路由选择处理器经过独立总线复制到线路卡。使用每个输入端口的影子副本，转发决策能在每个输入端口本地做出，无须基于每个分组调用集中式路由选择处理器，避免集中式处理的瓶颈。 转发表：前缀匹配，最长前缀匹配规则 在某些设计中，一个分组可能会在进入交换结构时被暂时阻塞 查找外必须采取许多其他动作 必须出现物理层和链路层处理 必须检查分组的版本号、检验以及寿命字段，并且重写后两个字段 必须更新用于网络管理的计数器 “匹配加动作” 交换 经内存交换 类似传统计算机 在CPU(路由选择处理器)的直接控制下完成 输入与输出端口的功能像传统I/O设备 分组到达输入端口-&gt;中断-&gt;分组被复制到处理器内存-&gt;CPU提取目的地址，在转发表中找到适当的输出端口-&gt;CPU将分组复制到输出端口的缓存中 若内存带宽为$B$个分组/秒，则总的转发吞吐量必然小于$B/2$ 不能同时转发两个分组 经总线交换 输入端口经共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预 输入端口为分组预先计划一个交换机内部标签(首部)，指示本地输出端口-&gt;分组能被所有输出端口收到，但只有标签匹配的端口才能保存分组-&gt;标签在输出端口被去除 一次只有一个分组能跨越总线，因此多个分组同时到达路由器时，除了一个分组外其他都必须等待 经互联网络交换 纵横式交换机：$2N$条总线，连接$N$个输入端口和$N$个输出端口 交缠点通过交换结构控制器实现开启闭合 分组到达输入端口-&gt;交叉点-&gt;输出端口 非阻塞：能够并行转发多个分组 多级交换元素 输出端口处理交换结构-&gt;排队(缓存管理)-&gt;数据链路处理(协议，封装)-&gt;线路端接-&gt; 排队丢包：排队导致路由器的缓存空间耗尽 输入排队 线路前部(HOL)阻塞：在一个输入队列中排队的分组必须等待通过交换结构发送(即使输出端口是空闲的)，因为它被位于线路前部的另一个分组所阻塞 — 对纵横式交换结构而言 输出排队 主动队列管理：在缓存填满之前丢弃一个分组（或在首部加上标记），可以向发送方提供一个拥塞信号 缓存数量$B$与平均往返时延$RTT$、链路容量$C$、TCP流$N$的关系：$B=RTT\\cdot C$, ($N$较大时)$B=RTT\\cdot C/\\sqrt{N}$ 分组调度 FIFO 优先权排队 有多个优先权类，分开排队 每次选择非空的最高优先权类队列中的分组进行传输 非抢占式优先权排队：一旦分组开始传输就不能打断 循环排队 没有服务优先权，循环调度器在类之间轮流提供服务 保持工作排队规则：在有分组排队等待传输时不允许链路保持空闲—当寻找给定类的分组但没有找到时立即检查下一个类 加权公平排队(WFQ) 循环方式 每个类在任何时间间隔都可能收到不同数量的服务，每个类$i$被分配一个权$w_i$ 第$i$类 将确保接收到的服务部分等于$w_i/(\\sum w_i)$ 最坏情况下第$i$类也能分得上述那么多带宽 IPv4数据报格式 版本号：4比特，规定了数据报的IP协议版本，不同IP版本使用不同的数据报格式。 首部长度：4比特，IPv4数据报包含可变数量的选项，所以需要确定首部长度。大多数IP数据报不包含选项，所以一般具有20字节的首部。 服务类型(TOS)：8比特，使不同类型的IP数据报能相互区别开来。 数据报长度：16比特，IP数据报首部+数据的总长度，单位字节。理论最大长度为65535字节，但实际上很少有超过1500的。这个长度使得IP数据报能容纳最大长度以太网帧的载荷字段。 标识、标志、片偏移：与IP分片有关。 寿命(TTL)：确保数据报不会永远（如由于长时间的路由选择环路）在网络中循环。每当一台路由器处理时该字段的值-1，为0时自动丢弃。 协议：仅当到达最终目的地时才会有用，指示了IP数据报需要交给哪个特定的运输层协议。协议号是将网络层与运输层绑定到一起的黏合剂。（端口号是将运输层和应用层绑定到一起的黏合剂） 首部检验和：首部中的每两个字节当成一个数，用反码算术求和。每台路由器上必须重新计算检验和并再次存放到远处，因为TTL字段以及可能的选项字段会改变。【为什么TCP/IP都执行差错检测？—因为TCP和IP可以分别运行在不同的协议栈上 源和目的地IP地址：源主机通过DNS查找来决定目的地址。 选项：允许IP首部被扩展，很少使用。 数据(有效载荷)：大多数时候承载运输层报文，也可承载其他类型的数据,e.g.ICMP报文 20字节IP首部+20字节TCP首部=40字节数据报首部 数据报分片原因：发送方与目的地路径上的每段链路可能使用不同的链路层协议最大传送单元(MTU)：一个链路层帧能承载的最大数据量每个较小的数据报称为片(fragment) 发送主机将发送的每个数据报的标识号+1 路由器对数据报分片时，每个片具有初始数据报的源地址、目的地址和标识号 目的地主机能够检查数据报的标识号以确定哪些数据报实际上是同一较大数据报的片 IP是不可靠服务—初始数据报的最后一篇标志比特为0，其他片为1 为了让目的主机确定是否丢了一个片且按正确顺序组装片，使用偏移字段制定该片应该放在初始IP数据报的哪个位置 编址一台主机通常只有一条链路连接到网络，主机与物理链路之间的边界叫作接口。路由必须拥有多条链路与之相连接，路由器与它任意一条链路之间的边界也叫作接口。一个IP地址与一个接口相关联。 IP地址长32比特，采用点分十进制记法书写格式：$a.b.c.d/x$ 子网掩码：32位中前$x$比特全取1 最高$x$比特构成了网络部分，也称前缀 组织内部的设备的IP共享相同的前缀 减少了子网外路由器中转发表的长度 子网：分开主机和路由器的每个接口，产生几个隔离的网络孤岛，使用接口端接这些隔离的网络的端点。这些隔离的网络中的每一个都叫作一个子网。在给定子网上的所有设备都具有相同的子网地址。因特网地址的分配策略称为无类别域间路由选择(CIDR, Classless Interdomain Routing)寻址：最长前缀匹配，选择与目的地址相匹配的最长地址前缀IP广播地址：255.255.255.255，当报文的目的地址是广播地址时会被交付给同一个网络中的所有主机，路由器也会有选择地向临近的子网转发该报文 获取一块地址ISP从自己的大地址块中提供一些地址给组织IP地址由因特网名字和编号分配机构(ICANN)管理，ICANN还管理DNS根服务器 获取主机地址：DHCP 动态主机配置协议(DHCP)允许主机获取一个IP地址，还允许主机得知子网掩码、第一跳路由器地址(默认网关)、本地DNS服务器的地址 即插即用协议/零配置协议 客户-服务器协议 每个子网将具有一台DHCP服务器 如果某子网中没有DHCP服务器，则需要一个DHCP中继代理（通常是一台路由器），这个代理用于知道该网络的DHCP服务器的地址 DHCP协议4步 DHCP服务器发现 使用DHCP发现报文 源地址：0.0.0.0(“本主机”)，目的地址：255.255.255.255(广播地址) 用于一个新到达的主机发现一个要与其交互的DHCP服务器 DHCP服务提供 DHCP服务器收到DHCP发现报文后对客户做出响应 使用DHCP提供报文，包含发现报文的事物ID、向客户推荐的IP地址、网络掩码、IP地址租用期(即IP地址的有效时间量，通常为几小时或几天) 源地址：自己的IP地址，目的地址：255.255.255.255(广播地址) 子网中可能存在多个DHCP服务器，客户需要选择一个 DHCP请求 客户向选中的服务器提供DHCP请求报文进行响应，回显配置的参数 源地址：0.0.0.0.，目的地址:255.255.255.255 DHCP ACK 服务器用DHCP ACK报文对DHCP请求报文进行响应，证实所要求的参数 源地址：DHCP服务器自己的地址，目的地址:255.255.255.255 客户收到DHCP ACK后交互完成 不能维持与远程应用之间的TCP连接 网络地址转换(NAT) NAT使能路由器 4个接口具有相同的网络地址10.0.0/24 地址空间10.0.0.0/8是在RFC 198中保留的三部分IP地址空间之一，用于家庭网络等专用网络或具有专用地址的地域，仅在给定的网络中才有意义 NAT使能路由器对外界的行为如同一个具有单一IP地址的单一设备 所有流向外界/进入家庭的报文都拥有同一个源/目的IP地址 NAT使能路由器对外界隐藏了家庭网络的细节 NAT转化表 NAT收到家庭主机发送向外界的数据报后，为其生成一个新的源端口号，将源IP替代为其广域网一侧接口的IP地址，且将源端口号替换为新生成的端口号 端口号字段16字节，NAT协议可支持超过60000个并行使用路由器广域网一侧单个IP地址的连接 路由器中的NAT在其NAT转换表中增加一个表项，记录WAN端和LAN段IP地址及端口的对应关系 IPv6数据报格式 定长40字节(320比特)首部 版本(4比特)：标识IP版本号，IPv6将其设置为6 设置为4不能得到合法的IPv4数据报 流量类型(8比特)：与IPv4的TOS类似，使不同类型的IP数据报能相互区别开来 流标签(20比特)：标识一条数据报的流 对一条流中的某些数据报给出优先权 也能够用来对来自某些应用的数据报给出更高的优先权 有效载荷长度(16比特无符号整数)：定长40字节数据报首部后的字节数量 下一个首部(8比特)：表示数据报中的内容要交付给哪个协议(e.g.TCP or UDP)，取值同IPv4 跳限制(8比特)：相当于IPv4的TTL，转发的每台路由器对该字段的值-1，到0自动丢弃 源地址和目的地址(各128比特) 数据 相对IPv4的变化新增了： 扩大的地址容量 地址长度：32 bits -&gt; 128 bits 引入任播地址：可以使数据报交付给一组主机中的任意一个 流定义 删去了： 分片/重新组装：因为太耗时了 如果路由器收到的IPv6数据报太大不能转发到出链路上的话，路由器只需丢弃该数据报，并向发送方发回一个“分组太大”的ICMP差错报文 大大加快了IP转发速度 首部检验和：因为太耗时了，而且多余 选项：不属于首部的一部分，但没有消失，可能出现在“下一个首部”指出的位置上 使得IPv6的首部是定长的 IPv4到IPv6的迁移建隧道 隧道：两台IPv6路由器之间的中间IPv4路由器集合 隧道发送端的IPv6节点(B)将整个IPv6数据报放到一个IPv4数据报中,将源地址设为自己，目的地址设为隧道接收端的IPv6节点(E) 中间的IPv4路由器照常转发IPv4数据报 隧道接收端通过观察IPv4数据报中协议号字段是41确定该数据报含有一个IPv6数据报，并将其取出 通用转发和SDN链路层和路由器的中间盒(e.g.防火墙、NAT、深度分组检测DPI等)过多，需要一个统一的设备来提供功能——分组交换机 匹配加动作表(在OpenFlow中称为流表) 远程控制器计算、安装和更新 包括：首部字段值的集合、计数器集合(当分组与流表项匹配是更新计数值)、匹配时所采取的动作集合 匹配 (据说不考，先不抄了) CH5 网络层：控制平面路由选择算法目的：从发送方到接收方的过程中确定一条通过路由器网络的好的路径(等价于路由) 集中式路由选择算法：具有全局状态信息的算法，必须知道每条链路的开销，常被称为链路状态(LS)算法 分布式路由选择算法：以迭代、分布式的方式计算最小开销路径，每个节点只有与其相邻节点的信息 静态路由选择算法：路由随时间变化缓慢 动态路由选择算法：随着网络流量负载或拓扑发生变化而改变路由选择路径 负载敏感算法：链路开销会动态地变化反映出底层链路的当前拥塞水平 负载迟钝算法 链路状态路由选择算法输入：让每个节点向网络中所有其他节点广播链路状态分组——链路状态广播算法Dijksra算法最差情况下复杂性为$O(n^2)$ 问题：链路开销非对称，即链路开销对应于承载的流量会出现振荡：所有的流量都被导向同一个方向路由器的自同步：即使它们在初始时以同一周期但在不同时刻执行算法，算法执行时机最终会在路由器上变为同步并保持解决方案：让每台路由器发送链路通告的时间随机化 距离向量(DV)路由选择算法分布式的、迭代的（能自我终止）、异步的距离向量：$\\bf{D}_x$$=\\left[D_x(x), D_x(y), D_x(z) \\right]$Bellman-Ford算法Bellman-Ford方程：$d_x(y)=\\min_v{c(x,v)+d_v(y)}$ 每个节点等待来自任何邻居的更新，当接收到一个更新时计算它的新距离向量并向它的邻居分布其新距离向量 当一个节点检测到从它自己到邻居的链路开销发生变化时，它就更新其距离向量——可能会出现路由选择环路：y通过z到x，同时z通过y到x因为开销改变的链路在其他节点的距离表中的信息仍没有被抹去 链路开销的增加会导致坏消息传播得很慢——无穷计数问题 毒性逆转：撒谎设置$D_z(x)=\\infty$，这样y就永远不会试图经由z路由选择到xWiki: In computer networking, split-horizon route advertisement is a method of preventing routing loops in distance-vector routing protocols by prohibiting a router from advertising a route back onto the interface from which it was learned.(从哪里学习来的，就拒绝发回到哪里去)依然无法解决无穷计数问题 比较 维度 LS DV 报文复杂性 发送$O(\\ NE\\ )$个报文，每次改变向所有节点发送新开销 每次迭代邻居间交换报文 收敛速度 还行(?)，多项式时间 收敛较慢，且会出现路由选择环路 健壮性 路由器某种程度上分离 一个不正确节点的计算值会扩散到整个网络 因特网自治系统内部的路由选择：OSPF规模(无穷计数)和管理自治(ISP按自己意愿运行路由器)问题——解决：自治系统(AS)每个AS由一组通常处在相同管理控制下的路由器组成一个自治系统由其全局唯一的AS号(ASN)所标识，ASN由ICANN区域注册机构发放 OSPF：开放最短路优先，Open Shortest Path First开放：公众可用LS协议，使用洪泛链路状态信息和Dijkstra最短路径算法各条链路开销为网络管理员手动配置 路由器向AS内所有其他路由器广播路由选择信息 每当一条链路状态发生变化时，路由器就会广播链路状态信息；即使未变化，也会至少每隔30min一次广播链路状态——增加鲁棒性 OSPF报文由IP承载，对上层协议的值为89，因此OSPF协议必须自己实现诸如可靠报文传输、链路状态广播等功能。 还要检查链路正在运行(通过向邻居发送HELLO报文)，并允许OSPF路由器获得相邻路由器的网络范围链路状态的数据库 优点： 安全：能鉴别和加密(简单的orMD5) 支持选择多条相同开销的路径 对单播与多播路由选择的综合支持 支持在单个AS中的层次结构 区域边界路由器：为流向该区域以外的分组提供路由选择 主干区域：为该AS中其他区域之间的流量提供路由选择，所有区域边界路由器+一些非边界路由器 AS间的路由选择协议：BGPBGP：边界网关协议, Broder Gateway Protocol分布式、异步分组不是路由到特定地址，而是路由到CIDR化的前缀，每个前缀表示一个子网或一个子网的集合 BGP为每台路由器提供了一种完成以下任务的手段： 从邻居AS获得前缀的可达性信息 确定到该前缀的“最好的”路由 通告BGP路由信息对于每个AS，每台路由器要么是一台网关路由器，要么是一台内部路由器。网关路由器：位于AS边缘，直接连接到在其他AS中的路由器内部路由器：仅连接在它自己AS中的主机和路由器 每对路由器通过使用179端口的半永久TCP连接交换路由选择信息。每条直线连接以及所有通过该连接发送的BGP报文，称为BGP连接跨越两个AS的BGP连接称为外部BGP连接(eBGP)在相同AS中的两台路由器之间的BGP称为内部BGP连接(iBGP)直接连接在不同AS中的网关路由器的每条链路通常有一条eBGP连接，在每个AS中的路由器之间还有多条iBGP连接，iBGP连接不总是与物理链路对应 前缀中包含一些BGP属性前缀+其属性称为路由 AS-PATH属性：包含了通告已经通过的AS的列表 当一个前缀通过某AS时，该AS将其ASN加入AS-PATH的现有列表 BGP路由器还使用AS-PATH属性来检测和防止通告环路，如果一台路由器在路径列表中看到了包含它自己的AS，则它将拒绝该通告 NEXT-HOP属性：AS-PATH起始路由器接口的IP地址（到达前缀$x$路径上的第一台路由器的地址 热土豆路由选择实际上明明是烫手山芋 从所有可能的路由中选择到开始该路由的NEXT-HOP路由器具有最小开销的路由路由器尽可能快地将分组送出其AS，而不担心AS外部到目的地的余下部分的开销对于在相同AS中的两台路由器，可能对相同前缀选择两条不同的AS路径 路由选择算法输入：到某前缀的所有路由的集合 当有多条路由时，顺序调用以下消除规则： 路由被指派一个本地偏好值属性。该属性为策略决定，取决于网管，高的被优先选择（可能会有多条）。 从余下的路由中选择具有最短AS-PATH的路由。如果这是唯一路由选择规则，使用DV算法决定路径，其中距离测度为AS跳的跳数。 从余下的路由中使用热土豆路由选择，即最靠近NEXT-HOP路由器的路由 如果仍留下多条路由，使用BGP标识符来选择路由 IP任播通常用于DNS中DNS服务器为多台服务器指派相同的IP地址，并且使用标准的BGP从这些服务器来通告该IP地址。当某台BGP路由器收到对于该IP地址的多个路由通告，它将这些通告处理为对相同的物理位置提供不同的路径。当配置其路由表时，每台路由器将本地化地使用BGP路由选择算法来挑选到该IP地址的“最好的”路由。无论客户位于何处，当想向DNS服务器的某个IP地址发送一个请求时，因特网路由器则向那个“最近的”服务器转发该请求分组，最近的服务器是有BGP路由选择算法所定义的。 路由选择策略多宿接入ISP：经由两个不同的ISP连接到网络的其余部分的经验法则：任何穿越某ISP主干网的流量必须是其源或目的（或两者）位于该ISP的某个客户网络中 5.6 ICMP因特网控制报文协议 ICMP报文 用于主机和路由器彼此沟通网络层信息 承载在IP分组中 类型字段+编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8个字节 ping 发送一个ICMP类型8编码0（回显请求）到指定主机 目的主机发回一个类型0编码0的ICMP回显应答 traceroute 跟踪从一台主机到世界上任意一台主机之间的路由 源主机发送一些列数据报，每个都携带一个具有不可达UDP端口号的UDP报文段，且第$n$个数据报的TTL为$n$ 第$n$台路由器丢弃该数据报并发送一个ICMP告警报文（类型11编码0）给源主机 目的主机会向源主机发送一个端口不可达的ICMP报文（类型3编码3），源主机收到时就知道不需要再发送另外的探测分组。 CH3 运输层运输层为运行在不同主机上的应用程序之间提供了逻辑通信功能。通过逻辑通信，运行不同进程的主机好像直接相连一样。应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些报文的物理基础设施的细节。 运输层只工作在端系统中。在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（即网络层）。运输层能够提供的服务常常受制于底层网络协议的服务模型（带宽时延等），但底层网络协议不可靠、非机密性的情况下，运输层也能提供可靠性和机密性。 UDP和TCP最基本的责任是：将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为运输层的多路复用与多路分解网络层：主机$\\Leftrightarrow$主机运输层：进程$\\Leftrightarrow$进程 多路复用和多路分解进程使用套接字作为与网络交互数据的门户，运输层将数据交付给套接字。每个套接字有唯一标识符，标识符格式取决于它是UDP还是TCP套接字。 每个运输层报文段中具有几个字段。多路分解：（拆包）将运输层报文段中的数据交付到正确的套接字多路复用：（打包）从源主机的不同套接字中收集数据块，并为每个数据块封上首部信息从而生成报文段，然后将报文段传递到网络层 套接字要有唯一标识符、每个报文段有特殊字段来只是该报文段所要交付到的套接字，特殊字段即源端口号字段&amp;目的端口号字段 端口号 16比特数，大小在0~65535 0~1023称为周知端口号，保留给注入HTTP（80）和FTP（21）之类的周知应用层协议 开发新应用程序时必须为其分配一个端口号 UDP的多路复用与多路分解创建套接字时，端口号有两种产生方式： 运输层自动为套接字分配一个端口号，从1024~65535内选择一个当前未被该主机中任何其他UDP端口使用的号 通过套接字bind()(Python)方法为这个UDP套接字关联一个特定的端口号通常应用程序自动，服务器手动 一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号。因此只要两个UDP报文段具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。 源端口号用于接收方发回给发送方 TCP的多路复用与多路分解TCP套接字由四元组（源IP地址、源端口号、目的IP地址、目的端口号）来标识与UDP不同，两个不同源IP和或源端口号的TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求 TCP服务器应用程序有一个“欢迎套接字”，在某个特定端口上等待来自TCP客户的连接建立请求 TCP客户创建一个套接字并发送一个连接建立请求报文段 一条连接建立请求只不过是一个目的端口号为12000，TCP首部的特定“连接建立位”置位的TCP报文段，这个报文段也包含一个由客户选择的源端口号 当运行服务器进程的计算机的主机操作系统接收到具有目的端口号为12000的入连接请求报文段后，它就定位服务器进程，该进程正在端口号12000等待接收连接。该服务器进程会创建一个新的套接字。 新创建的报文设置好4个标识符，之后的报文段按照这4个标识符来定向。 服务器主机支持很多并行的TCP套接字，每个套接字与一个进程相联系。 连接套接字与进程之间并非总是有着一一对应的关系（线程 无连接运输：UDP发送方和接收方的运输层实体之间没有握手——无连接的 e.g.DNS通常使用UDP应用层协议 UDP的优点 关于发送什么数据以及何时发送的应用层控制更为精细。 实时应用通常要求最小发送速率，不希望过分地延迟报文段的传送，且能容忍一些数据丢失 无须连接建立，不会引入建立连接的时延 无连接状态，节约存储空间，可以支持更多活跃用户。 分组首部开销小，TCP20字节，UDP8自己 UDP报文段结构 源端口号/目的端口号（各16比特） 长度（16比特）：首部+数据的字节数 检验和 应用数据 UDP检验和实际包括一些IP首部字段，此处忽略 16比特字的反码运算，求和时遇到的任何溢出都被回卷（加到末尾去）详见作业题CH6 P3 端到端原则：如果端到端传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测“与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的” 不进行差错恢复，只能丢弃/交给应用程序并发出警告 可靠数据传输原理可靠数据传输协议服务抽象：数据通过可靠信道传输，传输数据比特不会受到损坏或丢失，而且所有数据都是按照其发送顺序进行交付 前提假设：底层信道不会对分组重排序 构造可靠数据传输协议肯定确认(ACK), 否定确认(NAK)自动重传请求(ARQ)停等协议：除非发送方确信接收方已经正确接收当前分组，否则发送方将不会发送一块新数据一个ACK丢失、或者只是该分组或ACK过度延时，发送方都进行重传比特交替协议：rdt3.0 流水线可靠数据传输协议 停等协议：发送方利用率低 U_{\\text{sender}}=\\frac{L/R}{RTT+L/R}流水线：不以停等方式运行，允许发送放发送多个分组而无须等待确认 回退N步（GBN）$N$：在流水线中未确认分组数的最大允许数 base：最早未确认分组的序号 nextseqnum: 最小的未使用序号（即下一个待发分组的序号 GBN也称滑动窗口协议，$N$也被称为窗口长度 分组序号用$k$位表示，所有涉及序号的运算采用模$2^k$运算 GBN发送方必须响应三种类型的事件： 上层的调用 收到一个ACK。 累积确认 超时事件。发送方重传所有已发送单未被确认过的分组。 GBN接收方： 如果正确接到一个按序分组，则为该分组发送一个ACK 否则丢弃该分组，并为最近按序接收的一个分组重新发送ACK 丢弃所有失序分组 发送方维护窗口的上下边界及nextseqnum在该窗口中的位置 接收方维护下一个按序接收的分组的序号(expectedseqnum) 问题：单个分组的差错就能引起重传大量分组，许多分组根本没有必要重传 选择重传（SR）发送方： 从上层收到数据。检查下一个可用于该分组的序号，如果序号位于发送方窗口内，则将数据打包发送。 超时。每个分组有自己的逻辑定时器，超时发生后只发送一个分组。 收到ACK。如果收到ACK的序号在窗口内，则SR发送方将那个被确认的分组标记为已接收。如果该分组序号等于send base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。 接收方： 序号在$[$rcv_base, rcv_base+$N$-1$]$内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，一个选择ACK被会送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号，则该分组以及以前缓存的序号连续的分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。 序号在$[$rcv_bas-$N$, rcv_base-1$]$内的分组被正确收到。必须产生一个ACK，即使该分组是接收方以前已确认过的分组。（如果不确认，则发送窗口将永远不能向前滑动） 其他情况。忽略该分组。 SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组皆被收到为止。 SR协议对于哪些分组已经被正确接收，哪些没有，发送方和接收方并不总是能看到相同的结果。发送方和接收方的窗口并不总是一致。 窗口长度必须小于等于序号空间大小的一半。 考虑分组重排 当连接两端的信道是一个网络时会发生 信道可以看成基本上是在缓存分组，并在将来任意时刻自然地释放出这些分组。 通过假定一个分组在网络中“存活”的时间不会超过某个固定最大时间量来做到这一点。 面向连接的运输：TCPTCP连接两个进程在发送数据之前必须先相互“握手”，即它们必须互相发送某些预备报文段，以建立确保数据传输的参数 TCP连接是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中，中间网络元素不会维持TCP连接状态。 全双工服务（full-duplex service）：如果进程A与进程B存在一条TCP连接，则应用层数据可以在这两台主机间双向流动 点对点：单个发送方与单个接收方之间的连接 发起连接的称为客户进程，另一个进程被称为服务器连接 客户进程通过套接字（该进程之门）传递数据流，TCP将这些数据引导到该连接的发送缓存里 TCP会时不时从发送缓存里取出一块数据，并将数据传递到网络层 TCP可放入报文段的最大数据数量受限于最大报文段长度(MSS) MSS通常根据最初确定的由本地发送主机的最大链路层帧长度（最大传输单元MTU）来设置 MSS要保证一个TCP报文段+TCP/IP首部长度（通常40字节）小于等于单个链路层帧长度 MSS指报文段里应用层数据的最大长度，不包括首部 TCP在另一端接收到报文段后，该报文段的数据就被放入该TCP连接的接收缓存中 TCP连接组成包括：两台主机上的缓存、变量与进程连接的套接字 TCP报文段结构 源端口号和目的端口号（各16比特） 序号和确认号（各32比特）：用来实现可靠数据传输服务 接收窗口字段（16比特）：用于流量控制，表示接收方 愿意接收的字节数量 首部长度字段（4比特）：指示了以32比特为单位的TCP首部长度。TCP首部长度可变，但通常是20字节。 标志字段（6比特）：一些flag ACK：用于指示确认字段中的值是有效的 RST、SYN、FIN：用于连接的建立和拆除 CER、ECE：明确拥塞通告中使用 PSH：指示接收方应该立即将数据交给上层 URG：指示报文段里存在着被发送端的上层实体置为“紧急的数据”，紧急数据指针指出紧急数据的最后一个字节。当紧急数据存在并给出紧急数据指针时，TCP必须通知接收端的上层实体。 因特网检验和（16比特） 可选与变长的选项字段：用于发送方与接收方协商MSS，或在高速网络环境下用作窗口调节因子 序号和确认号TCP把数据看成无结构的、有序的字节流。一个报文段的序号是该报文段首字节的字节流编号。 主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。 TCP只确认流中至第一个丢失字节为止的字节，这个称为提供累计确认。 主机在一条TCP连接中收到失序报文段视为UB。 一条TCP连接的双方均可随机地选择初始号。 和（16比特） 可选与变长的选项字段：用于发送方与接收方协商MSS，或在高速网络环境下用作窗口调节因子举例：Telnet的回显 （解释见书p157) 对客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段，这种确认被称为是被捎带在服务器到客户的数据报文段中的。 往返时间估计与超时 报文段的样本RTT(SampleRTT)：从某报文段被发出大多数TCP仅在某个时刻做一次SampleRTT测量 在任意时刻，仅为一个已发送但目前尚未被确认的报文段估计SampleRTT，从而产生一个接近每个RTT值的新SampleRTT TCP绝不为已被重传的报文段计算SampleRTT，仅为传输一次的报文段测量 EstimatedRTT：TCP维护的SampleRTT的均值，为了应对SampleRTT的波动 一旦获得新的SampleRTT，更新公式为 \\text{EstimatedRTT}=(1-\\alpha)\\cdot\\text{EstimatedRTT}+\\alpha\\cdot\\text{SampleRTT}，$\\alpha$的推荐值为0.125(1/8) EstimatedRTT是对SampleRTT的指数加权移动平均（EWMA，Exponential Weighted Moving Average），指一个给定的SampleRTT的权值在更新过程中呈指数型快速衰减 DevRTT：RTT偏差，用于估算SampleRTT一般会偏离EstimatedRTT的程度 计算公式为\\text{DevRTT}=(1-\\beta)\\cdot\\text{DevRTT}+\\beta\\cdot|\\text{SampleRTT}-\\text{EstimatedRTT}|，$\\beta$的推荐取值为0.25 超时间隔TimeoutInterval：EstimatedRTT加上一定余量，与SampleRTT的波动正相关 计算公式为\\text{TimeoutInterval}=\\text{EstimatedRTT}+4\\cdot\\text{DevRTT} 推荐的TimeoutInterval的初始值为1s 当出现超时后，TimeoutIntetval将加倍，以免即将被确认的后继报文段过早出现超时。 只要收到报文段并更新EstimatedRTT，就更新TimeoutInterval 可靠数据传输TCP的差错恢复机制是GBN和SR的混合体 发送方：switch(事件) 从上面应用程序接收到数据 生成具有序号NextSeqNum的TCP报文段 如果定时器没有运行，启动定时器 向IP传递报文段 NextSeqNum=NextSeqNum+length(data) 定时器超时 重传具有最小序号但仍未应答的报文段 超时间隔超级加倍 启动定时器 收到ACK，ACK字段值为y 如果 y&gt;SendBase，则该ACK是在确认一个或多个先前未确认的报文段 更新SendBase 如果当前有未被确认的报文段， 重新启动定时器 如果 y&lt;=SendBase，则该ACK是对已经确认的报文段的一个冗余ACK 如果累计收到相同ACK值的3个冗余ACK（累计4个相同ACK），则重新发送具有序号y的报文段（快速重传） 接收方： 超时间隔加倍提供了一个形式受限的拥塞控制，因为定时器过期很可能是网络拥塞引起的。 快速重传冗余ACK：再次确认某个报文段的ACK 当TCP接收方接收到一个序号大于下一个所期望按序报文段的报文段时，就说明有报文段丢失，因此会产生一个冗余ACK对已经收到的最后一个按序字节数据进行重复确认。 如果发送方接收到对相同数据的3个冗余ACK，就将其视为一种指示，说明这个被确认了3次的报文段之后的报文段已经被丢失。发送方会进行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。 流量控制接收方如果读数据不够快，就会导致接收缓存溢出。TCP提供了流量控制服务以消除发送方使接收方缓存溢出的可能性。（区分流量控制与拥塞控制） TCP发送方维护一个称为接收窗口的变量，指示接收方还有多少可用空间，需要满足 \\text{LastByteRcvd}-\\text{LastByteRead}\\le \\text{RcvBuffer} 接收窗口长度用rwnd表示，\\text{rwnd}=\\text{RcvBuffer}-[\\text{LastByteRcvd}-\\text{LastByteRead}] \\text{LastByteSent}-\\text{LastByteAcked}\\le\\text{rwnd} 人话：主机Ａ发送但未被确认的数据大小 不会超过 主机Ｂ接收缓存的剩余可用空间 为了防止主机A被阻塞，当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存开始清空，并且确认报文里包含一个非0的rwnd值。 TCP连接管理建立TCP连接：三次握手 第一步：客户端的TCP向服务器的TCP发送一个SYN报文段。首部中SYN标志位被置为1。客户随机选择一个初始序号（client_isn），并将此序号放置于SYN报文段的序号字段。该报文段不包含应用层数据。 第二步：服务器主机收到该TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段（SYNACK报文段）。该报文段不包含应用层数据。SYN比特被置为1。首部确认号字段为client_isn+1。服务器选择自己的初始序号（server_isn），并将其放到序号字段中。 第三步：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机向服务器发送另一个报文段，将server_isn+1放到首部的确认字段，来对服务器的允许连接的报文段进行确认。连接已经建立了，所以SYN比特被置为0，且之后的每一个报文段的SYN比特都为0。该报文段可以携带应用层数据。 关闭TCP连接 客户进程发出一个关闭连接命令，引起客户TCP向服务器进程发送一个特殊的TCP报文段。该报文段首部FIN比特被置为1。 服务器接收到该报文段后，向发送方回送一个ACK报文段。 然后，服务器发送自己的终止报文段，FIN置为1。 最后，客户对这个服务器的终止报文段进行确认。此时，两台主机上用于该连接的所有资源都被释放了。 TCP状态 如果一台主机接收到的一个TCP报文段端口号或源IP地址与该主机上进行中的套接字都不匹配，则该主机向源发送一个特殊重置报文段，RST标志被置为1。（“我没有那个报文段的套接字，请不要再发了。”） nmap端口扫描工具nmap对目标主机的某个端口发送一个特殊的TCP SYN数据报，有3种可能 源主机从目标主机接收到一个TCP SYNACK报文段。这意味着目标主机上一个应用程序使用该TCP端口运行，nmap返回“打开”。 源主机从目标主机接收到一个TCP RST报文段。这意味着目标主机上没有一个应用程序使用该TCP端口运行，但至少发送向该端口的报文段没有被防火墙阻拦。 源什么也没有收到。防火墙GG。 拥塞控制原理情况1：两个发送方和一台具有无穷大缓存的路由器 图一为每连接的吞吐量（接收方每秒接收的字节数）与该连接发送速率之间的函数关系。上限$R/2$是由共享链路容量造成的。 图二为时延与发送速率的关系。当发送速率接近$R/2$时，平均时延就会越来越大。当发送速率超过$R/2$，路由器中 的平均排队分组数就会无限增长。 当分组到达的速率接近链路容量时，分组会经历巨大的排队时延。 情况2：两个发送方和一台具有有限缓存的路由器 $\\lambda_{in}$（字节/秒）：应用程序将初始数据发送到套接字的速率 $\\lambda_{in}’$：运输层想网络中发送报文段（初始+重传）的速率，又称供给载荷 图a为主机A成精，仅当路由器缓存空闲时发送分组的理想情况，平均速率不会超过$R/2$ 图b为发送方仅当在确定了一个分组已经丢失时才重传的情况。$R/3$是术师数据，$R/2-R/3=R/6$是重传数据。说明拥塞时发送方必须执行重传以补偿因为缓存溢出而丢失的分组。 图c为发送方提前发生超时并重传未被丢失的分组。由于每个分组被转发两次，当其供给载荷接近$R/2$时，吞吐量接近$R/4$。说明拥塞时发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。 情况3:4个发送方和具有有限缓存的多台路由器及多跳路径 对于较小的$\\lambda{in}$，$\\lambda{in}$的增大会导致$\\lambda_{out}$的增大 当$\\lambda_{in}$很大的时候，不同路径的流量会在同一个路由器上为有限缓存空间竞争，导致一条路径成功通过的流量越来越少。 在极限重载情况下，端到端吞吐量会趋近于0。 当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量全部木大了。 拥塞控制方法 端到端拥塞控制：网络没有为运输层拥塞控制提供显示支持 网络辅助的拥塞控制：路由器发送方提供关于网络中拥塞状态的显示反馈信息。可以用拥塞分组直接反馈给发送方，或通过标记接收方来的分组来通知发送方。 TCP拥塞控制让每一个发送方根据所感知到的网络拥塞成都来限制其发送流量的速率。 发送方TCP跟踪一个拥塞窗口变量cwnd，它对一个TCP发送方能向网络中发送流量的速率进行了限制。 \\text{LastByteSent}-\\text{LastByteAcked}\\le\\min\\{\\text{cwnd},\\text{rwnd}\\}发送方的速率大概是cwnd/RTT字节/秒。 丢包事件：出现超时，或收到来自接收方的3个冗余ACK。此时发送方认为出现了拥塞指示。 自计时：TCP使用收到的ACK（或计时）增大它的拥塞窗口长度。 TCP拥塞控制算法具体看图 慢启动 当一条TCP连接开始时，cwnd通常设为一个MSS的较小值，初始发送速率大约为MSS/RTT。 每当传输的报文段首次被确认，cwnd增加一个MSS（指数增长 结束方式 当cwnd==ssthresh时，结束慢启动并转移到拥塞避免模式。cwnd最多只能取到ssthresh，即使不是2的幂次 超时丢包（拥塞）：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2 检测到3个冗余ACK：执行一次快速重传并进入快速恢复状态 拥塞避免 每个RTT只将cwnd的值增加MSS。一种通用实现方法：发送方无论何时收到一个新的确认，就将cwnd增加一个$\\text{MSS}\\frac{\\text{MSS}}{\\text{cwnd}}$字节。 结束方式 超时：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2 3个冗余ACK：cwnd减半，对收到的3个冗余ACK再加上3个MSS；将ssthresh的值改为cwnd/2；进入快速恢复状态 快速恢复 对于引起TCP进入快速恢复状态的缺失报文段，对每个收到的冗余ACK，cwnd增加一个MSS 当最终对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态 超时：cwnd重置为1并重新开始慢启动过程，ssthresh(慢启动阈值)变为cwnd/2，进入慢启动状态 忽略慢启动，TCP的拥塞控制：每个RTT内线性增加1MSS，出现3个冗余ACK时cwnd减半——加性增，乘性减（AIMD） 吞吐量一条连接的平均吞吐量=\\frac{0.75\\times W}{\\text{RTT}} $W$：丢包事件发生时的窗口长度 TCP的发送速率大约是$w/RTT$,$w$为窗口长度 TCP的传输速率在$W/(2\\times\\text{RTT})$和$W/\\text{RTT}$之间线性变化 考虑丢包率（$L$）和MSS，一条连接的平均吞吐量=\\frac{1.22\\times\\text{MSS}}{\\text{RTT}\\sqrt{L}} 公平性如果每条连接都得到相同份额的带宽，则认为该拥塞控制机制是公平的。 实际情况下具有较小RTT的连接能够更快地抢到可用带宽。 UDP是无法无天的，并行TCP连接是“作弊” CH9 多媒体网络多媒体网络应用 视频的性质 最显著的特点：高比特率 能被压缩。在视频质量与比特率间折中 音频的性质 脉冲编码调制(PCM)：数字信号速率=每秒的采样个数×每个样本的表示比特数 多媒体网络应用的性质 流式存储音频和视频 流：边看边接收后续部分 相互作用：暂停、快进、快退 连续播放：减少帧停滞或帧跳过 实时会话式语音 因特网电话，IP语音（VoIP） 定时考虑很重要，高度时延敏感 容忍丢包：偶尔的丢失只会在音频视频回放时出现干扰信号 流式实况音频视频（直播） 类似流式存储 流式存储视频三种形式的视频流，共同特点：广泛使用了客户端应用缓存，以此来缓解端到端时延的变化和服务器和客户之间可用带宽量的影响。 客户缓存的优点： 能够吸收服务器到客户端时延中的波动 如果服务器到客户端带宽暂时低于视频消耗速率，用户能够继续享受连续的播放，只要客户缓存没有耗尽 UDP流服务器通过UDP以一宗稳定的速率记录下视频块，用于客户的视频消耗速率相匹配的速率传输视频。UDP流通常使用很小的客户端缓存，空间维持小于1s视频就够了。服务器和客户间还并行地维护一个单独的控制连接，客户可发送有关会话状态变化的命令（暂停、重开、重定位等）。 不足： 可用带宽变化且无法预测，恒定速率UDP流不能够提供连续的播放。 要求如RTSP服务器一样的媒体控制服务器，增加了部署的总体成本和复杂性。 许多防火墙和NAT阻塞UDP流量 HTTP流视频直接作为具有一个特定URL（统一资源定位符）的普通文件存储在HTTP服务器上。用户要看视频时，客户和服务器之间建立一个TCP连接，并且发送一个对该URL的HTTP GET请求，服务器尽可能快地发送该视频文件；客户端把字节收集在一个客户应用缓存中。一旦缓存数量超过预先设定的阈值就开始播放。 预取视频：客户能够尝试以高于消耗速率的速率下载视频，预取将来会被消耗的视频帧。 客户端应用缓存和TCP缓存： 暂停期间，客户缓存会变满，对服务器造成“反向压力”。服务器被阻塞，直到用户恢复该视频。因此服务器发送速率不能比客户端视频消耗速率更高。一个满的客户应用缓存间接地对服务器到客户能够发送的视频速率增加了限制。 流式视频的分析 $B$：客户端应用缓存的长度（比特）；$Q$：客户应用缓存开始播放之前必须被缓存的比特数量；$r$：视频消耗速率；$x$：服务器发送速率 初始缓存时延$t_p=Q/x$ 客户应用缓存变慢时间$t_f$：显然。 视频的早期中止和定位 利用HTTP GET请求报文中的HTTP字节范围首部：指示了客户当前要从所希望的视频中获取的字节范围。 当用户重新定位到一个新位置时，客户发送一个新的HTTP请求，用字节范围首部指出服务器应当从文件的哪个字节起发送数据 预取的数据没看会导致网络带宽和服务器资源的浪费，因此许多流系统仅使用长度适当的客户应用缓存或者限制字节范围首部预取的视频数量。 IP语音尽力而为的服务限制什么时候播放一个块&amp;如何处理一个丢失块 丢包TCP的重传机制增加了端到端时延，拥塞控制可能导致“缓存饥饿”，因此所有现有的VoIP应用默认运行在UDP上 端到端时延时延超过某阈值的分组等效于丢弃 分组时延抖动时延抖动：不同的分组端到端时延可能会有波动通常可以通过序号、时间戳和播放时延来消除 在接收方消除音频的时延抖动通常结合以下两种机制： 每个块预先计划一个时间戳 在接收方延迟播放块 固定播放时延接收方试图在块产生正好$q$ms后播放它如果端到端时延经常发生比较大的变化，用一个大的$q$更好；如果时延很小并且时延变化也很小，用一个较小的、可能小于150ms的$q$更好 适应性延迟播放目标：播放时延最小化，使丢包低于一定的百分比估计网络时延和变化，在每个话音突峰期的开始相应地调整播放时延 $t_i$：第$i$个分组的时间戳，该分组在发送方产生的时间 $r_i$：分组$i$被接收方接收的时间 $p_i$：分组$i$在接收方播放的时间 $di=(1-u)d{i-1}+u(r_i-t_i)$：接收到第$i$分组时的平均网络时延的估计值，$u$为固定的常数 $vi=(1-u)v{i-1}+u|r_i-t_i-d_i$：与估计平均时延的绝对偏差的估计值 $p_i=t_i+d_i+Kv_i$ 在一个话音突峰期中任何后续分组的播放点被计算为相对于这个话音突峰期第一个分组播放时间点的偏移 类似TCP的拥塞控制 从丢包中恢复前向纠错（FEC）基本思想：给初始分组增加冗余信息第一种机制：每发送$n$个块之后发送一个冗余编码的块（前$n$个块的异或和）。增加了播放时延。第二种机制：发送一个较低分辨率的音频作为冗余信息。接收方在播放前只需接收两个分组，因此增加的时延小，且传输速率的额外增加并不大。 交织 优点：能够明显提高音频流可感觉到的质量；不增加流的带宽要求缺点：增加了时延 差错掩盖为丢失的分组产生一个替代物（如重复）音频信号呈现出大量的短期自相似性适合于工作在相对小的丢包率和小分组的情况 实时会话式应用的协议此处懒得抄 支持多媒体的网络提供多种类型的服务链路调度规则：选择在链路上传输排队分组的方式 监管：漏桶3个准则：平均速率、峰值速率、突发长度 漏桶由一个能容纳$b$个令牌的桶组成 新令牌总是以每秒$r$个速率产生 当产生一个令牌时，如果桶中少于$b$个令牌，则新产生的令牌加入到桶中，否则忽略 一个分组向网络传输之前，必须首先从令牌桶中去除一个令牌，如果令牌桶是空的，分组必须等待一个令牌。 漏桶监管的流的最大突发长度是$b$个分组，任何长度为$t$的时间间隔内能够进入网络中的最大分组数目为$rt+b$（平均速率） 在原漏桶下方再加一个令牌产生速率为$p$漏桶可以实现限制峰值速率到$p$ 漏桶+加权公平排队=队列中可证明的最大时延d_{max}=\\frac{b_i}{R\\cdot \\frac{w_i}{\\sum w_j}}口嗨考题 IPv4的首部的哪些字段经过中间路由器的时候不会被修改？考虑NAT和不考虑NAT。（以前出过，可能还会考到 (ppt p28)SYNj 5道大题*20分 TCP拥塞控制 路由表 划重点第一章好好看看 第二章不考 第三章 3.2,3.3：看看概念 3.4：不考 3.5~7: 注意一下 第四章4.2,4.3 第五章 5.2， 5.3 5.4：基本概念 5.6：简单知道ping和traceroute怎么用 第六章 6.3（6.3.4除外） 以太网，CSMA/CD 第七章7.3：主要是概念，不会考太细，CSMA/CA 第九章QoS","categories":[],"tags":[]},{"title":"数字图像处理课程笔记","slug":"dip-notes","date":"2019-10-11T12:31:15.000Z","updated":"2019-12-27T02:30:55.576Z","comments":true,"path":"2019/10/11/dip-notes/","link":"","permalink":"https://mengzelev.github.io/2019/10/11/dip-notes/","excerpt":"","text":"期末考试 题型：选择（不定选）、判断、问答、计算 Ch01 数字图像处理简介图像采样、图像量化基本问题：如何将现实物理信号离散化、数字化采样：用有限的样本数目去近似无限的现实物理信号（有限近似无限）量化：用离散计算机表示去近似连续的现实物理信号（离散近似连续） 采样数量越多，图像越清晰（10241024$\\to$ 1616）量化级别越高，图像越真实（256灰度级$\\to$4灰度级，低灰度级会出现伪轮廓） 图像有M*N个像素，每个像素有$Q$个灰度级别。M,N,Q通常总是取为2的整数幂。$Q=2^b$，称为图像的b bit量化，或称$Q$级灰度。存在量化误差，b越大重建图像失真越小。 有大量细节的图，需要的量化级数较少 最佳量化：使量化误差（均方误差测度）最小的量化方法均方误差$\\delta^2=\\sum\\limits{k=1}^{K}\\int{Zk}^{Z{k+1}}(Zk-q_k)^2p(Z)dZ$取$q_k=\\frac{1}{2}(Z_k+Z{k+1})$达到最佳量化 Ch02 空间域图像增强（Part 1）考点：灰度变换、直方图 基本灰度变换三类基本函数：线性、对数、幂律 线性函数 可以实现图像反转$s=L-1-r$——增强嵌入在暗区域中的白色或灰色细节 对数变换$s=c\\log(1+r)$ $1+r$：函数图像经过原点，对数值恒大于0 低灰度值拉伸，高灰度值压缩 还可以把超大的数字变小，变换后可以看到图像更多的细节 幂律变换$s=cr^\\gamma$ 低灰度值压缩，高灰度值拉伸 伽马参数减小，细节增加，对比度降低；反之亦然 分段线性函数 只拉伸某些灰度级上的对比度 阈值处理$r_1=r_2$ 灰度级分层：突出特定灰度范围的亮度 比特平面分层 突出特定比特的作用 8个比特可认为由8个1比特平面组成 高阶比特平面包含视觉上的重要数据，低阶比特平面贡献了更精细的灰度细节 应用：确定量化该比特数的充分性；图像压缩可能会导致伪轮廓 直方图处理灰度直方图 图像中每种灰度级的像素个数 灰度直方图的横坐是灰度级，纵坐标表示该灰度级出现的频率 阈值面积函数$A(D)$：连续图像中具有灰度级$\\ge D$的轮廓线所包围的面积A(D)=\\int_{D}^{\\infty}H(p)dp 概率密度函数$PDF$：归一化到单位面积的直方图（每种灰度值出现的概率密度函数） PDF=P(D)=\\frac{1}{A_0}H(D) 累计分布函数$CDF$：归一化后灰度级$\\le D$的轮廓线所包围的面积 CDF=P(D)=\\int\\limits_0^D p(u)du=\\frac{1}{A_0}\\int\\limits_{0}^{D}H(u)du $H(D)=A(D)-A(D+1)$ 实现图像具有$L$级灰度，大小为$M*N$的灰度图像$f(x,t)$的灰度直方图$hist[0,\\ldots L-1]$的算法 初始化$hist[k]=0$ 统计$hist[f(x,y)]$ 归一化$hist[f(x,y)]/(M*N)$ 应用 图像快速检测：判断一幅图像是否合理利用率全部被允许的灰度范围，从而及早发现数字化中出现的问题 分割前景背景：以直方图双峰之间的谷地$T$为阈值来确定边界，可以把图像分为前景背景两部分 面积计算：背景灰度大体一致且背景与物体对比度很强时$\\int\\limits_{D_1}^{\\infty}H(D)dD=$物体的面积 Ch03 直方图处理考点：直方图均衡 理论直方图呈均匀分布时，对比度会有明显增加。通过灰度变换函数，将原图像直方图的分布均衡化，这一过程称为直方图均衡化 输出图像的概率密度p_s(s)=p_r(T^{-1}(s))\\frac{1}{|T'(T^{-1}(s))|}若$s=T(r)$为单调递增函数： p_s(s)=p_r(r)\\frac{dr}{ds}($r$用$s$表示) e.g. $s=T(r)=ar+b$,即$r=\\frac{s-b}{a}$，则有$p_s(s)=\\frac{1}{a}p_r(\\frac{s-b}{a})$. 直方图均衡化变换函数： s=T(r)=(L-1)\\int_{0}^{r}p_r(w)dw离散近似： p_r(r_k)=\\frac{n_k}{MN}s_k=T(r_k)=(L-1)\\sum\\limits_{j=0}^{k}p_r(r_j)=\\frac{(L-1)}{MN}\\sum\\limits_{j=0}^{k}n_j步骤： 给定$L$和$p_r(r_k),k=0,1,\\ldots, L-1$ 用上述公式计算$s_k$ 将$s_k$四舍五入取整 计算$p_s(s_k)$——均衡后的 把$r_k$一一替换成$s_k$得到新图像 Ch04 空间滤波、算数操作增强考点： 空间相关/卷积：区别和联系，怎么算（计算题 平滑/锐化空间滤波器：特点，干啥用 锐化拉普拉斯梯度算子大概知道 算术操作，大概知道加减乘除有什么道理 相关和卷积都是对应点相乘然后把所有乘积加起来 相关 平移计算模板，计算每个位置乘积之和 补零、计算、滑动、裁剪 符号：☆ 卷积 与相关类似，但滤波器要旋转180度 旋转、补零、计算、滑动、裁剪 符号：$\\star$ 平滑空间滤波器平滑线性滤波器 均值滤波器 附近9格的均值，先求和再归一化 优点：降低噪声 缺点：边缘模糊 加权线性滤波器 非均匀权重 降低模糊 统计排序滤波器非线性滤波器：对滤波器覆盖的像素排序，用排序决定的值替代中心像素 中值滤波器：中位数 最大值滤波器 最小值滤波器 锐化空间滤波器数学基础 一阶导数 二阶导数 在恒定灰度区域为0 在恒定灰度区域为0 在突变（斜坡、台阶）的起点非0 在突变的的起点和终点非0 沿着斜坡非0 沿着恒定斜率斜坡为0 $f(x+1)-f(x)$ $f(x+1)+f(x-1)-2f(x)$ 产生较粗的边缘 产生两个有间距的双边缘（由0分开，单像素宽） - 增强细节方面更好 拉普拉斯算子\\nabla^2f=\\frac{\\partial^2f}{\\partial x^2}+\\frac{\\partial^2f}{\\partial y^2}离散化 \\frac{\\partial^2f}{\\partial x^2}=f(x+1,y)+f(x-1,y)-2f(x,y)\\frac{\\partial^2f}{\\partial x^2}=f(x,y+1)+f(x,y-1)-2f(x,y)注意减的是2倍的 \\nabla^2f=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)还有对角线形式的 拉普拉斯算子结果叠加到图像中 g(x,y)=f(x,y)+c[\\nabla^2f(x,y)] 采用负的中心系数，$c=-1$ 采用正的中心系数，$c=1$ 非锐化掩蔽原图像-非锐化版本 模糊原图像 从原图像减去模糊图像得到模板 将模板加到原图像 具体公式 g_{mask}(x,y)=f(x,y)-\\overline{f}(x,y)g(x,y)=f(x,y)+kg_{mask}(x,y)非锐化掩蔽$k=1$；高提升滤波$k&gt;1$ 使用一阶导数锐化图像利用梯度的大小 M(x,y)=\\sqrt{(\\frac{\\partial f}{\\partial x})^2+(\\frac{\\partial f}{\\partial y})^2}近似计算 M(x,y)=|g_x|+|g_y| sobel算子（实验写过） 算数操作增强 加法 多次曝光：将不同时间曝光照片进行得加，得到一张具有特殊效果的照片 加法运算常用于减少图像中的随机噪声 对$M$幅加性噪声图形进行平均，可以使图像的平方信噪比提高$M$倍，信噪比定义见后面 减法 作差后对比度会增强，提取轮廓（指纹），强调细节 负数规范化：$y=(x+255)/2$或$y=(x-min)/(max-min)*255$ 乘法 掩模运算 除法 归一化 Ch05 集合逻辑操作、空间操作、灰度内插考点： 仿射变换：什么，特点 灰度内插：最近邻，线性，双线性 仿射变换包括了旋转、伸缩、平移、倾斜等变换 x=t_{11}v+t_{21}w+t_{31}y=t_{12}v+t_{22}w+t_{32} $t{31},t{32}$刻画了平移量 $t{11},t{22}$刻画了伸缩比例 $t{12},t{21}$刻画了倾斜程度 整体组合刻画了平移、旋转角度、倾斜程度 优点： 保持共线性（共线的点变换后依然共线） 保持距离比例（线的中心变换后仍然是线的中心） 几种常见仿射变换 恒等变换 伸缩变换：$x=c_xv, y=c_yw$ 旋转变换：$x=v\\cos\\theta-w\\sin\\theta, y=v\\sin\\theta+w\\cos\\theta$ 平移变换：$x=v+t_x, y=w+t_y$ （垂直）倾斜变换：$x=v+s_vw, y=w$ （水平）倾斜变换：$x=v,y=s_hv+w$ 复杂仿射变换：一系列仿射变换操作（因为仿射变换的组合还是仿射变换）逆仿射变换：对矩阵求逆（基本变换矩阵都是可逆矩阵） 灰度内插 前向映射 通过输入图像限速位置，计算输出图像对应的像素位置 将该位置像素的灰度值分配给其相邻四个网格位置 反向映射 用过输出图像像素位置，计算输入图像中涉及到所有对应的像素位置 根据输入图像四个像素的灰度值计算该位置的像素的灰度值 最近邻内插取离得最近的值作为自己的值e.g. $f(0)=10, f(1)=12, f(0.4)=f(0), f(0.6)=f(1)$ 线性内插连接相邻两点的直线e.g. $f(0)=10, f(1)=12, f(x)=10+2x, x\\in[0,1]$，i.e.$f(0.4)=10.8$. 或写成$f(x)=(1-x)f(0)+(x-0)f(1)$ 双线性内插 用附近4个点的值来表示$P$点的值 Ch06 傅里叶变换考点： 傅里叶变换：基本知识，概念 卷积定理和采样定理 背DFT和IDFT的公式 原理东西掌握 傅里叶变换基本知识冲激与采样连续：在0点值特别大，其余点为0，$[0,1]$上积分为1离散：在0点值为1，其余点为0，$(-\\infty,+\\infty)$上的级数和为1 采样性质： \\int_{-\\infty}^{\\infty}f(t)\\delta(t-t_0)dt=f(t_0)\\sum\\limits_{x=-\\infty}^{\\infty}f(x)\\delta(x-x_0)=f(x_0)冲激串：无穷个以$\\Delta T$为间距的周期性冲激之和 傅里叶级数：周期为$T$的连续函数$f(t)$可以表示为正弦和余弦函数的加权之和 卷积定理 空间域卷积的傅里叶变换$\\Leftrightarrow$傅里叶变换在频率域的乘积 f(t)\\star h(t)\\Leftrightarrow H(\\mu)F(\\mu) 空间域乘积的傅里叶变换$\\Leftrightarrow$傅里叶变换在频率域的卷积 f(t)h(t)\\Leftrightarrow H(\\mu)F(\\mu) 采样定理连续函数采样：把冲激串与原函数相乘 \\tilde{f}(t)=f(t)s_{\\Delta T}(t)=\\sum\\limits_{n=-\\infty}^{\\infty}f(t)\\delta(t-n\\Delta T)\\tilde{F}(\\mu)=F(\\mu)\\star S(\\mu), S(\\mu)=\\frac{1}{\\Delta T}\\sum\\limits_{n=-\\infty}^{\\infty}\\delta(\\mu-\\frac{n}{\\Delta T})采样值$f_k=f(k\\Delta T)$ 采样定理：如果以超过函数最高频率的两倍采样率来获得样本，连续的带限函数可以完美地从它的样本集来恢复。即如果 \\frac{1}{2\\Delta T}>\\mu_{\\max}\\Leftrightarrow \\frac{1}{\\Delta T}>2\\mu_{\\max}就可以从$\\tilde F(\\mu)$中分离出$F(\\mu)$. $2\\mu_{\\max}$称为奈奎斯特频率。二维采样定理：在两个维度上都要满足一维采样定理 混淆 欠采样：以低于奈奎斯特频率采样。无法分离，无法补救。 采样是有限的，所以实际中难以避免混淆。 一个带限函数一定是从$-\\infty$扩展到$\\infty$，没有有限持续时间的函数是带限的。有限长度的采样，混淆是不可避免的。 抗混淆： 事先防止或减轻混淆 平滑输入函数，减少高频分量 有限长度采样 采样时间限制在$[0,T]$，可以写成一个只在$[0,T]$为1其余地方为0的函数$h(t)$ $f(t)\\Rightarrow f(t)h(t)\\Leftrightarrow H(\\mu)\\star F(\\mu)$ 由样本恢复原函数 f(t)=\\sum\\limits_{n=-\\infty}^{\\infty}f(n\\Delta T)sinc[(t-n\\Delta T)/\\Delta T] 函数内插：无限个样本的内插，实际中只能近似 $t=k\\Delta T, f(t)=f(k\\Delta T)$ 离散傅里叶变换一维DFTDFT： F(u)=\\sum\\limits_{n=0}^{M-1}f(x)e^{-j2\\pi ux/M}, u=0,1,2,\\ldots, M-1IDFT: f(x)=\\frac{1}{M}\\sum\\limits_{u=0}^{M-1}F(u)e^{j2\\pi ux/M}， x=0,1,2\\ldots M-1$x$是整数$\\mu=\\frac{m}{M\\Delta T}$ 对 $\\tilde{F}(\\mu)$ 的一个周期 $[0,1/\\Delta T]$采集$M$个样本 离散卷积 f(x)\\star h(x)=\\sum\\limits_{m=0}^{M-1}f(m)h(x-m) 周期函数，也被称为循环卷积 与之前的卷积不一样，主要区别是$x$（之前的卷积对不够的地方补零，这个是取循环值） 卷积定理依然成立 倒数关系： 对连续函数$f(t)$采样，总时间长度为$T=M\\Delta T$，离散频域中的间隔$\\Delta u=\\frac{1}{M\\Delta T}=\\frac{1}{T}$ 离散频域范围$\\Omega = M\\Delta U=\\frac{1}{\\Delta T}$ 二维DFT F(u,v)=\\sum\\limits_{x=0}^{M-1}\\sum\\limits_{y=0}^{N-1}f(x,y)e^{-2j\\pi (ux/M+vx/N)}, u=0,1,\\ldots,M-1; v= 0,1,\\ldots, N-1 $f(x,y)$是大小为$M\\times N$的二维图像 二维IDFT f(x,y)=\\frac{1}{MN}\\sum\\limits_{u=0}^{M-1}\\sum\\limits_{v=0}^{N-1}F(u,v)e^{j2\\pi (ux/M+vx/N)} 对连续$f(x,y)$采样，两个方向上的总时间$T=M\\Delta T, Z=N\\Delta Z$ 离散频域中的间隔$\\Delta u=\\frac{1}{M\\Delta T}, \\Delta v=\\frac{1}{N\\Delta Z}$ 离散频域范围$\\frac{1}{\\Delta T}, \\frac{1}{\\Delta Z}$ 性质 平移不影响幅值：$f(x-x_0, y-y_0)\\Leftrightarrow F(u-u_0, v-v_0)$ 旋转性：$F(u,v)$ 和$f(x,y)$旋转相同的角度 $f(x,y)(-1)^{x+y}\\Leftrightarrow F(u-M/2, v-N/2)$ 对称性：相对于序列中心而言 $w_e(x,y)=w_e(M-x, N-y)$ $w_o(x,y)=-w_o(M-x, N-y)$ 实函数的傅里叶变换共轭对称：$F^*(u,v)=F(-u,-v)$ 虚函数的傅里叶变换共轭反对称 傅里叶谱和相角 幅度（傅里叶谱）：$|F(u,v)|$ 相角$[-\\pi, pi]$：$\\pi(u,v)=\\arctan\\left[\\frac{I(u,v)}{R(u,v)} \\right]$ 傅里叶谱决定了正弦波的幅度，表示灰度 相角表示正弦波的位移，携带了定位信息 二维卷积定理和一维一样。 要让卷积定理和直接卷积一致，需要0填充，避免缠绕错误 Ch08 频率域滤波、平滑图像考点： 频域滤波基本流程 3种低通滤波器特点，不会考公式 频域滤波基本流程 给定大小为$M\\times N$的输入图像$f(x,y)$，选择0填充参数$P,Q$，一般$P=2M, Q=2N$ 对$f(x,y)$进行0填充，得到$f_p(x,y)$ $f_p(x,y)$乘上$(-1)^{x+y}$移到变换中心 计算上一步中函数的DFT，得到$F(u,v)$ 生成一个实的、对称的滤波函数$H(u,v)$，大小为$P\\times Q$，中心$(P/2, Q/2)$，用阵列相乘形成乘积$G(u,v)=H(u,v)F(u,v)$ 得到处理后的图像$g_p(x,y)$，注意是$G(u,v)$IDFT后实部乘以$(-1)^{x+y}$ 通过$g_p(x,y)$的左上象限提取$M\\times N$区域，得到最终处理结果$g(x,y)$ 低通滤波器 傅里叶变换的低频部分：灰度变化缓慢的地方（墙、地面、天空） 傅里叶变换的高频成分：灰度变化剧烈的地方（边缘、噪声） 低通滤波器：衰减高频，通过低频 理想低通滤波器 理想：低频完全保留，高频完全抑制 图：一个向上的圆柱（不要问我圆柱为什么会有方向+ 图形显示：一块黑的中间一个白圆+ 硬件无法实现 利用半径构造的低通滤波器会产生振铃现象（一圈一圈跟撸多了一样） 振铃原因：sinc函数两边振荡的小尾巴 半径越大越清晰 巴特沃斯低通滤波器 $D_0$为截止频率 透视图：MATLAB logo 利用半径构造的巴特沃斯滤波器($n=2$)：没有振铃现象 $n=2$是比较好的折中 高斯低通滤波器 透视图：MATLAB logo 没有振铃现象 Ch09 锐化图像、选择性滤波、实现考点： 3种高通 拉普拉斯算子，其他俩不用看 低通高通模糊锐化（基本常识 高通滤波器从低通构造高通： H_{HP}(u,v)=1-H_{LP}(u,v)图像都是低通倒过来 理想高通滤波器 低频完全抑制，高频完全保留 产生振铃，随着$D_0$增大振铃会有所缓解 巴特沃斯高通滤波器 轻微振铃现象 高斯高通滤波器 结果更清晰一些 对比 频率域拉普拉斯算子频域滤波器（中心化）： H(u,v)=-4\\pi^2D^2(u,v)$D(u,v)$为点$(u,v)$到中心点$(P/2,Q/2)$的距离 拉普拉斯图像 \\Delta^2f(x,y)=\\mathcal{F}^{-1}\\{H(u,v)F(u,v)\\}图像锐化$g(x,y)=f(x,y)-\\Delta^2 f(x,y)$，频率域写法 g(x,y)=\\mathcal{F}^{-1}\\{F(u,v)-H(u,v)F(u,v)\\}=\\mathcal{F}^{-1}\\{[1+4\\pi^2D^2(u,v)]F(u,v)\\} $f(x,y)$归一到$[0,1]$，$\\Delta^2f(x,y)$归一到$[-1,1]$，再计算DFT CH10 图像复原考点： 图像复原是干啥（建模），跟增强的区别 噪声的大概特点，不会考公式 均值滤波器、统计排序滤波器，自适应不考 图像复原复原 v.s. 增强 图像复原 以预先制定的目标改善图像，客观 对模糊的图像去模糊 利用退化现象的先验知识来恢复图像 建模退化过程-&gt;利用逆过程复原图像 图像增强 由人的主观感受来评判，主观 对比度拉伸、增强 退化/复原建模 输入$f(x,y)$ 退化函数$H$ 加性噪声$\\eta(x,y)$ 复原滤波器 输出$\\hat{f}(x,y)$ 目标：$f(x,y)\\approx f(x,y)$ 空间域表示 g(x,y)=h(x,y)\\star f(x,y)+\\eta(x,y)频率域表示 G(u,v)=H(u,v)F(u,v)+N(u,v)噪声模型 高斯噪声 瑞利噪声 爱尔兰（伽马）噪声 指数噪声 均匀噪声 脉冲（椒盐）噪声 周期噪声： 通常由电力或机电干扰产生 噪声与空间位置有关 可以通过频域滤波复原 噪声参数估计： 通过检查傅里叶谱、图像本身 一般噪声的PDF 查看传感器说明书 主动成像去估计参数，如拍摄纯色物体 从图像的局部稳定区域来估计噪声 根据形状识别PDF的类型 根据均值和方差来计算具体参数 脉冲噪声直接估计概率 均值滤波器 算术均值滤波器 取当前点为中心的一个区域的算术平均数作为当前点的像素值 平滑图像中的局部变化 几何均值滤波器 取当前点为中心的一个区域的几何平均数作为当前点的像素值 丢失的细节少 谐波均值滤波器 难以文字描述…反正不考公式 适用于盐粒噪声，不适用于胡椒噪声 逆谐波均值滤波器 有个阶数$Q$ $Q&gt;0$：消除胡椒噪声 $Q=0$：算术均值噪声 $Q&lt;0$：消除盐粒噪声 $Q=-1$：谐波均值滤波器 统计排序滤波器 中值滤波器 $(x,y)$处的像素也参与计算 良好的去噪能力，并且模糊少 尤其适用于单极或双极的脉冲信号 最大值滤波器 寻找图像中的亮点 降低胡椒噪声 黑色物体会变细 最小值滤波器 寻找图像中的暗点 降低盐粒噪声 黑色物体会变粗 中点滤波器（1/2(max+min)) 最大值和最小值的中点 结合了统计排序和求平均 适用于随机噪声（高斯噪声、均匀噪声 $\\alpha$截断的均值滤波 去掉$S_{xy}$中灰度最高、最低各$d/2$个像素 适用于存在多种噪声的情况（高斯噪声、椒盐噪声混合 滤波次数太多，图像会变模糊 Ch11-12 彩色图像处理考点： 3种颜色模型，含义，特点，不考颜色模型转换 RGB彩色模型 笛卡尔坐标系 红绿蓝在3个角(1,0,0),(0,1,0),(0,0,1) 黑色在原点(0,0,1) 白色在最远的角(1,1,1) 过原点的体对角线是灰色 3幅分量图像 每种主颜色对应一幅图像 叠加在一起合成一幅彩色图像 像素深度：表示每个像素的比特数 全彩色图像：24比特的RGB图像，颜色数目$2^{24}$ 高端设备支持24比特的RGB图像，低端设备通常只能显示256种彩色 稳定RGB色：真实展现、与硬件无关，通常包括$6^3=216$种 CMY 颜色模型 青色(C)，洋红(M)，黄色(Y) 彩色打印机 转换公式：CMY=1-RGB（自行脑补列矩阵） CMYK颜色模型：添加了黑色（表面说不纯其实是便宜 HSI颜色模型RGB/CMY颜色模型不够直观（人不会用颜色相关的信息：色调、饱和度，对人而言更直观 色调（Hue）：主波长，也就是感知到的颜色 与红色轴的夹角，柱坐标中的$\\theta$ 饱和度(Saturation)：反映白光的比例，白光越多越不饱和 与强度轴的距离，柱坐标中的$r$ 亮度(Brightness)：主观描绘，类似于无色光的强度（Intensity) 强度轴为体对角线，柱坐标中的$z$轴 会出现色调的不连续现象（因为色调以红色轴为基准） Ch13-14 图像分割考点 基本边缘检测 高级边缘检测（MH和Canny 拉普拉斯 算法的基本原理，算子的优点 基本边缘检测边缘检测三个基本步骤 为降噪对图像进行平滑处理：导数对噪声敏感 边缘点的检测：抽取所有潜在边缘点 边缘定位：选出真正的边缘点 梯度的大小和方向（略）边缘的方向和梯度正交 梯度计算模板： 举例： 梯度向量和边缘法线： 梯度算子 一维模板 二维模板：罗伯特交叉梯度算子，普鲁伊特算子（同上面截图中的），Sobel算子（刻在DNA里的） 阈值化：如果初始图像未平滑处理，则边缘可能会出现中断；如果平滑处理过，则边缘中断会缓解，但部分边缘会消失 Marr-Hildreth边缘检测器设计理念 灰度变化和图像尺度有关 需要用不同尺寸的算子 灰度变化会影响导数 一阶导数出现波峰或波谷 二阶导数出现零交叉 理想的检测器具备如下功能 能够近似１阶或2阶导数 能够被调整以在不同尺寸上起作用 大的算子检测模糊边缘、小的算子检测细节 滤波器：$\\Delta^2 G$：拉普拉斯算子和高斯函数（LoG）又名墨西哥草帽算子类似空间域的高通滤波器 用法 对$G(x,y)$进行采样，得到$n\\times n$的模板 与拉普拉斯模板卷积——系数之和自动为0 将LoG滤波器和图像卷积，寻找零交叉来确定边缘位置 等价于先用高斯滤波器平滑图像，然后用拉普拉斯算子 $n$是$\\ge 6\\sigma$的最小奇数 优点： 高斯部分会模糊图像，可以去掉尺寸小于$\\sigma$的细节，比如噪声 二阶导数：各向同性，对任何方向的变化有相同的响应；符合人的视觉系统 缺点: 可能会产生闭环，”意大利空心粉“效应——通过阈值化可以缓解 Canny边缘检测器理念 低错误率：所有边缘都被找到，并且没有伪响应 边缘点应被很好地定位：已定位的边缘必须尽可能接近真实边缘 单一的边缘点响应：对每个真实边缘点，检测器仅返回1个点 用法 高斯函数平滑输入图像 计算图像$f_s$的梯度 非最大抑制 目的：把梯度生成的粗边缘变细 指定梯度的4个离散方向（水平、垂直、$+45^{\\circ}$、$-45^{\\circ}$） 根据梯度的方向确定边缘的方向： 考虑$(x,y)$为中心的$3\\times 3$区域和上述4个方向，确定和梯度$\\alpha(x,y)$最接近的方向$d_k$ 如果$M(x,y)$的值比$(x,y)$在$d_k$方向的任一邻居数值小，则抑制($g_N(x,y)=0)$；否则保留($g_N(x,y)=M(x,y)$) 滞后阈值 目的：减少伪边缘点 低阈值$T_L$，高阈值$T_H$，一边比例为2:1或3:1 大于等于$T_H$的为强边缘点，全部保留；小于$T_L$的全部抑制；剩下的是弱边缘点 连通性分析（这里我怀疑讲义写反了） 遍历弱边缘点，保留和强边缘点连通（随便是什么连通）的点 Ch15 图像压缩考点： 压缩的基本概念，相对冗余，压缩比 灰度图像中3种冗余 解决冗余问题的编码方式（霍夫曼要掌握，其他不考） 基本概念数据压缩：减少表示给定信息所需的数据量冗余数据：包含不相关或重复信息的表示 $b$和$b’$（$b&gt;b’$）是两种不同表示方式的比特数相对数据冗余$R=1-\\frac{1}{C}=1-\\frac{b’}{b}$压缩比$C=\\frac{b}{b’}&gt;1$（大的除以小的）e.g.$C=10$意味着有90%的冗余 灰度图像的3种冗余编码冗余 编码：表示信息的符号系统 码字：符号序列 灰度图像的8位编码往往是冗余的 采用固定长度编码普遍存在冗余，因为灰度直方图不是均匀分布的 空间和时间冗余 图像中紧邻点是空间相关的 视频中连续帧是时间相关的 行程对：灰度值+该灰度值连续出现的次数 图像中的像素往往是空间和时间相关的：可以通过紧邻像素预测该像素的值 更加高效但是视觉不可见的表示：行程+相邻像素的灰度差（灰度差值具有规律性 映射：可逆/不可逆 不相关的信息 被视觉系统忽略的信息 与图像用途无关的信息 丢失信息，不可逆映射 霍夫曼编码 简化信源 对符号的概率进行排序，合并低概率符号 重复该过程直到剩余2个符号 对简化后的信息源编码 从最小信源开始，返回到原信源 为每一个分支分配符号 实现 构造霍夫曼编码 查表法编码、解码 瞬时性：每个编码独立解码 唯一可解码：序列的解码方式唯一 Ch16 形态学处理考点： 腐蚀膨胀 开闭操作 定义概念，理解，效果 腐蚀与膨胀腐蚀 集合$B$对集合$A$的腐蚀：$A\\ominus B={z|(B)_z\\subseteq A}$ $(B)_z$表示把$B$的原点平移到坐标$z$ 通常假设$B$为结构元 等价定义：$A\\ominus B={z|(B)_z\\cap A^c=\\emptyset}$ 膨胀 集合$B$对集合$A$的膨胀：$A\\oplus B={z|(\\hat{B})_z\\cap A\\neq\\emptyset}$ $\\hat{B}$表示集合$B$的反射，反射指$\\hat{B}={w|w=-b, b\\in B}$（关于原点的中心对称） 通常假设$B$为结构元 等价定义：$A\\oplus B=\\bigcup\\limits_{b\\in B}(A)_b$ 对偶性 (A\\ominus B)^c=A^c\\oplus \\hat{B} (A\\oplus B)^c=A^c\\ominus \\hat{B}开闭操作开操作 A\\circ B=(A\\ominus B)\\oplus B 先腐蚀后膨胀 平滑物体的轮廓 断开窄的连接 消除细的突出 闭操作 A\\bullet B=(A\\oplus B)\\ominus B 先膨胀后腐蚀 熔合窄的间断和长沟壑 消除小孔洞 填补轮廓中的空隙 性质 对偶性 $(A\\bullet B)^c=(A^c\\circ \\hat{B})$ $(A\\circ B)^c=(A^c\\bullet \\hat{B})$ 开操作 $A\\circ B\\subseteq A$ 如果$C$是$D$的子集，那么$C\\circ B$是$C\\circ D$的子集 禁止套娃：$(A\\circ B)\\circ B=A\\circ B$ 闭操作 $A\\subseteq A\\bullet B$ 如果$C$是$D$的子集，那么$C\\bullet B$是$C\\bullet D$的子集 禁止套娃：$(A\\bullet B)\\bullet B=A\\bullet B$ 举例：去噪（指纹） Ch17 目标识别考点： 最小距离分类器 最佳统计分类模型（贝叶斯高斯） 最小距离分类器 把原型定义为每个类的平均向量：$mj=\\frac{1}{N_j}\\sum\\limits{x_j\\in \\omega_j}x_j, j=1,\\ldots W$ $N_j$是类别$\\omega_j$包含的模式数量 就是把这个类里面所有的向量加起来取平均 利用欧式距离判断远近：$D_j(x)=||x-m_j||, j=1,\\ldots W$ $||a||=(a^Ta)^{1/2}$ 如果$D_i(x)$是最短距离，那么$x\\in\\omega_i$ 等价计算方式：$d_j(x)=x^Tm_j-\\frac{1}{2}m_j^Tm_j$，如果$d_i(x)$是最大值，那么$x\\in\\omega_i$ $\\omegai$和$\\omega_j$之间的决策边界：$d{ij}(x)=d_i(x)-d_j(x)=0$ $n=2$对应直线，$n=3$对应平面 最佳统计分类器基础知识没学过ML我哭了 把$\\omegai$的模式预测为属于$\\omega_j$，遭受损失$L{ij}$ 模式$x$属于类别$\\omega_i$的概率记为$p(\\omega_i/x)$ 条件平均风险（把$x$预测为$\\omegaj$会遭受的损失：$r_j=\\sum\\limits{k=1}^WL_{kj}p(\\omega_k/x)$ 根据贝叶斯公式可以写成：$rj(x)=\\frac{1}{p(x)}\\sum\\limits{k=1}^WL_{kj}p(x/\\omega_k)P(\\omega_k)$ 贝叶斯分类器：预测$x\\in\\omega_i$如果：$\\forall j\\neq i, r_j(x)&lt;r_i(x)$ 一般使用0-1损失函数：正确无损失，错误损失为1 用0-1损失函数并经过一通计算，决策函数$d_j(x)=p(x/\\omega_j)P(\\omega_j)$ 贝叶斯分类器：能够最小化平均损失 前提：每个类$\\omega_i$出现的概率$P(\\omega_i)$已知（从数据中估计或直接$1/W$）；每个类的概率密度$p(x/\\omega_i)$已知（困难，通常假设密度函数为某种解析形式e.g.高斯分布） 针对高斯模式类的贝叶斯分类器假设概率密度$p(\\bf{x}/\\omega_j)$为高斯函数 考虑一维空间内的二分类问题 决策函数就一高斯函数 d_j(\\bf{x})=\\frac{1}{\\sqrt{2\\pi}\\sigma_j}e^{-\\frac{(\\bf{x}-m_j)^2}{2\\sigma_j^2}}P(\\omega_j) 参数为均值和标准差 考虑$n$维空间内的$W$分类问题 公式太多了，自己看图吧 当协方差矩阵$C_j$都相等且为单位矩阵时，等价于最小距离分类器","categories":[],"tags":[]},{"title":"数据库学习笔记","slug":"database","date":"2019-10-09T11:41:22.000Z","updated":"2020-01-03T07:24:25.366Z","comments":true,"path":"2019/10/09/database/","link":"","permalink":"https://mengzelev.github.io/2019/10/09/database/","excerpt":"","text":"Ch1 数据库系统概述基本概念 数据库（DB）： 长期存储在计算机内、有组织、大量的、共享的数据集合 是数据集合，具有统一的结构形式并存放于统一的存储介质内，它由多种应用数据集成，并可被应用所共享。 数据库管理系统（DBMS）： 位于用户与OS之间的一层数据管理软件，为用户或应用程序提供访问数据库的方法和接口 能对持久性数据进行管理 能对大量数据进行有效存取 可为众多使用者使用同一数据（即数据共享） 数据库系统（DBS）： 实现有组织地、动态地存储大量关联数据、方便多用户访问的计算机硬件、软件和数据资源组成的系统；采用数据库技术的计算机系统 是一个以对海量的、具有复杂数据结构的、可以持久保存的、可供多用户共享的数据进行统一管理为目标的计算机系统。 组成：DB，DBMS，DBA，软件平台，硬件平台 数据库管理员（DBA）：对数据库进行规划、设计、维护、监视的专职人员 数据库设计、建立与调整+ 数据库维护 改善系统性能，提高系统效率 数据库系统的基本特点 数据集成性：集多种应用数据于一体。表现：采用统一的数据结构，建立一个全局统一的数据模式，根据每个应用的数据需要构作局部模式。 数据独立性：数据库中的数据与使用这些数据的应用程序之间的互不依赖性。 物理独立性：物理结构（存储结构、存取方式等） 逻辑独立性：总体逻辑结构的改变，如修改数据模式，增加新的数据类型，改变数据间联系等，不需要修改相应应用程序 数据共享：可供多个应用程序使用，并可用于不同的目的；可以在已有的数据库系统上开发新的应用程序；可向外界提供信息服务功能 数据冗余：同一个数据在不同的地方出现了重复存储 数据的完整性检查：对数据库中数据正确性作检查以保证数据的正确。 数据的安全性保护：对数据库访问者作检查以防止非法访问。 并发控制：对多个应用并发访问所产生的相互干扰作控制以保证其正确性。 故障恢复：对遭受破坏的数据具有恢复能力，使数据库具有抗破坏性。 数据库内部结构体系数据模式：数据库系统中数据结构的一种表示形式，它具有不同的层次与结构方式 三级模式 概念模式（简称模式） 是关于整个数据库中数据的全局逻辑结构的描述。 是面向数据库系统的，它一般以某种数据模型为基础，利用具体的DBMS所提供的数据定义语言（DDL）来描述： 数据的类型、长度、特征 数据间的联系 安全性、完整性等方面的要求 外模式（也称子模式、用户模式） 是关于某个（组）用户所需数据的逻辑结构的描述。 可由概念模式推导而出，是概念模式的一个子集。一个概念模式可对应着多个外模式。 有利之处： 简化用户接口，便于使用 降低数据冗余度 有利于数据的安全性保护和保密 内模式（也称物理模式） 是关于数据库中数据的物理存储结构和物理存取方法的描述。 只有物理数据库真实存在于外存中，其它由物理数据库通过DBMS构造而成。 三级模式是对数据在三种不同的抽象级别上进行的描述。上述三种模式可以构造出三个层次上的数据库概念：概念数据库、用户数据库、物理数据库 二级映射 概念模式到内模式的映射 该映射给出了概念模式中数据的全局逻辑结构到数据的物理存储结构间的对应关系 此种映射一般由DBMS实现。 可实现物理独立性 外模式到概念模式的映射 该映射给出了外模式与概念模式的对应关系 这种映射一般也由DBMS实现。 一个概念模式可以定义多个外模式，而每个外模式是概念模式的一个基本视图。 概念模式是一个全局模式，而外模式则是用户的局部模式。 可实现“逻辑独立性 三级模式与数据独立性的关系 数据库系统通过两级映射建立三级模式间的联系与转换，使得概念模式与外模式虽然在物理上并不存在，但也能通过映射而获得其存在的实体； 三级模式之间的两级映射也保证了数据库系统中的数据独立性的实现，即数据的内模式或概念模式的改变，并不影响用户实际使用到的外模式，只要调整它们之间的映射方式即可。 Ch2 数据模型数据模型的基本概念数据模型定义：描述数据的结构，定义在该数据结构上可以执行的操作以及数据之间必须满足的约束条件（结构+操作+约束） 数据结构（数据模式） 描述数据的类型、内容、性质以及数据间的联系 数据结构是一个数据模型的基础，数据操作与数据约束均是建立在相应的数据结构上的 为了便于区别，数据模型中的数据结构被称为“数据模式” 数据模式是划分不同类型的数据模型的依据 数据操作 在相应数据结构上可以执行的操作类型与操作方式 数据约束 主要描述数据结构内数据间的相互关系，包括： 数据间的语法/语义联系 数据间的制约与依存关系 数据（间）的动态变化规则 其目的是确保数据的正确、有效与相容 数据模型的核心：数据结构 三个抽象层次上的数据模型概念 概念数据模型 侧重于对客观世界中复杂事物的结构描述及它们之间内在联系的刻画，不涉及具体的描述细节和物理实现因素 是一种面向客观世界和用户的模型，与具体采用的DBMS及计算机实现无关 主要的几种概念模型：E-R模型，EE-R模型；面向对象模型；谓词模型 侧重于对客观对象的数据特征及其相互关系进行描述，包括 有哪些客观对象？（e.g.学生、教师、课程…… 每一类客观对象都有哪些数据特征？（e.g.学生：学号、姓名、专业、性别…… 他们之间有哪些相互关系？ 要了解每个数据项的语义含义，但并不需要定义其实现细节（如数据类型、取值约束等 逻辑数据模型 着重于数据模型在数据库系一级的实现，即利用具体的DBMS所提供的工具(DDL)来定义的数据模型 一种面向数据库系统的模型，概念数据模型只有在转换成逻辑数据模型后才能在数据库中得以表示 一个中介模型，具有承上启下的作用 曾经流行过的：层次、网状、关系、面向对象、对象关系…… 后来将数据模型划分为三类： 结构化：模型一旦定下来就基本不会发生改变，传统数据库系统基本属于这一类。 半结构化：有模型定义但又易于变化，有自己的模型定义语言与数据操作语言。XML数据库。 非结构化：数据结构不规则或不完整，没有预定义的数据模型，如文档、图片、网页、音视频等 现在一般分为结构化（关系模型）和非结构化（NoSQL） 客观事物的实现结构：表及其属性的定义；相互关系的实现结构：表及其外键 物理数据模型 用于描述数据是如何在计算机中进行存储，如何表达记录结构、记录顺序和访问路径等信息 面向计算机物理实现的模型 大都由DBMS来负责，但也向用户提供如：索引的定义、集簇的定义、存储区域的选择 数据模型的四个世界 现实世界：在客观世界中根据用户的需求目标而划定边界的一个应用环境。为整个转换过程提供了客观基础与初始启动环境。 概念世界：以现实世界为基础作进一步的抽象而形成的概念模型。DB设计人员进行用户需求分析，形成一些基本概念与基本关系，并用某一种概念数据模型中所提供的术语和方法来统一表示。概念世界与具体的DBMS和计算机无关。 信息世界：以概念世界为基础，选用特定的DBMS构造而成的逻辑数据模型。信息世界与具体的DBMS有关。 计算机世界：基于逻辑数据模型在计算机中的物理实现而形成的物理数据模型。侧重于数据库物理存储结构的描述，是DB的最终实现结构。 概念世界与概念模型E-R模型与E-R图 最核心的三个概念：实体（矩形）、属性（椭圆形）、联系（菱形） 实体：客观存在且又能相互区别的事物。是对现实世界中的客观事物的抽象，是概念世界中的基本单位。 属性：实体所具有的某种特性或特征，属性可以有值。可以取的值的集合，被称为该属性的域 (domain)。 组合属性：用于描述实体或联系的性质的简单属性的集合 多值属性：一个对于单个实体呈现多个值的属性 联系：一个实体集中的实体与另一个实体集中的实体之间存在着某种对应关系。在概念世界中，我们用两个实体集的联系来反映它们之间的这种关系。 两个实体集间的联系（二元联系） 多个实体集间的联系（多元联系） 单个实体集内部的联系 联系的函数对应关系 一一对应 一多对应：一个A对应多个B，一个B只能对应一个A(e.g.宿舍vs.学生) 多多对应 实体集（联系）与属性间的连接关系 属性的描述：属性名 实体的描述：实体名+实体型（实体中的所有属性名所构成的集合） 实体集的描述：实体名+实体型+关键字（区分同一个实体集中不同实体的 ‘最小属性集合’） 联系与实体集间的连接关系 联系名 联系的属性 函数对应关系 连接关系的表示：无向线段 属性依附实体or联系？ 实体中的属性：该实体的内在特征，不会因某些联系的出现而改变或消亡 联系上的属性：用于描述因联系的发生而需要记录、存储下来的信息，和联系同生同灭 EE-R模型与EE-R图 IS-A联系 如果实体集B是实体集A的一个子集，且具有比实体集A更多的属性，则我们称在实体集A与实体集B之间存在着一种特殊的‘IS-A联系’。其中实体集A被称为超(实体)集，实体集B被称为子(实体)集。子集B可以通过IS-A联系继承超集A中的所有属性。 表示方法：用从‘子实体集’指向‘超实体集’的单向箭头表示 继承性与传递性 覆盖约束：所有子集的并集=超集；一个实体至少隶属于某一个子集 不相交约束：任意两个子集都是互不相交的；一个实体至多隶属于某一个子集 弱实体 如果一个实体A的存在需要依赖于其他某个实体的存在，那么实体A被称为弱实体。弱实体(集)与所依赖的实体(集)之间的函数对应关系通常应该是“多对一”的关系。 表示方法：从弱实体到联系的有向箭头 不在考纲里的： 属性划分 属性基数：可以用一个二元组 (x, y) 来描述一个实体在该属性上的取值数量特征。 标识符：关键字或候选关键字 描述符：非关键字的属性 属性基数 用二元组(x,y)描述一个实体在该属性上的取值数量特征 (0, ?)：该属性可以取空值 (1, ?)：该属性必须有值 (?, 1)：每一个实体在该属性上最多只能有一个值，单值属性 (?, N)：多值属性 x表示能否取空值，y表示单值or多值 参与基数 画实体联系图（椭圆点-点椭圆） 最大参与基数max-card(E,R)：从左边一个点出发的最多的边数（1 or N) 最小参与基数min-card(E,R)：最少边数(0 or 1) 参与基数：card(E, R)=(min-card(E, R), max-card(E, R)) (?, 1) ：单值参与（只能有一个）；(?, N)：多值参与（可以有多个） (1, ?)：强制参与（必须要有）；(0, ?)：可选参与（可以没有） 多对一关系：多值参与的是“一”，单值参与的是“多”（搞啥？？？ 面向对象模型 对象：客观世界中能够相互区别开来的事物。OO模型中的最基本的概念。 对象标识符（OID）：每个对象均具有的一个能相互区别的名字 方法：是可以作用在对象上的一段程序。用于反映对象的行为特征，是对象的固有动态行为的表示，可用于审视并改变对象的内部状态（属性值）。 类：具有相同属性、方法的对象集合。可以被抽象成一个对象，我们称其为‘类对象’或实例。 继承 一个类的定义和实现建立在其它类的基础之上，并共享其它类的定义和实现 IS-A联系，被继承的是超类，继承的是子类 继承关系构成单向不循环的层次结构 作用：支持代码的共享与重用；有助于系统的扩充 类的聚合与分解 类的聚合：由若干个简单类聚合成一个复杂的类的过程 类的分解：由复杂类分解成若干层次上的简单类的过程 三种语义：组成语义、嵌套语义、联系语义 实质上反应了类中对象之间的组合与分解关系 信息世界和逻辑模型 关系模型 基本数据结构：二维表，简称‘表’ 数据操纵：建立在二维表上的操作，包括查询、删除、插入、修改 关系：由行和列组成的二维表格 同一表中的属性名各不相同 表中的属性与属性的排放次序无关 表中的元组均不相同 表中的元组与元组的排列次序无关 表中的每一分量必须是一个不可分割的基本数据项 属性：实体所具有的某种特性或特征 值域（域）：属性的取值范围 元组：关系中的每一行 关系模式：一个关系的关系名及其属性名的集合 关系数据库模式：该关系数据库中所有关系的关系模式的集合 关键字：关系中的一个属性集的值能唯一标识关系中的一个元组，且又不含多余的属性值，则称该属性集为该关系的关键字。一个关系也可以有多个关键字，所以关键字也被称为‘候选关键字’。 主关键字：可以从关系的候选关键字中选取一个作为该关系的主关键字 外关键字：设关系R中的属性集F，其取值来自于关系S中的主关键字K，则称属性集F是关系R的外关键字。关系R和关系S可以是同一个关系。 五种基本操作：属性指定、元组选择、关系合并、元组插入、元组删除 计算机世界与物理模型逻辑模型的数据存储 项：文件系统中最小基本单位，项内符号是不能继续分割的。 记录：由若干项组成，记录内的各项间有内在语义联系 文件：记录的集合 索引：将文件中的记录与其物理地址(即磁盘块)间建立一张对应关系表以便于快速查找。可以有多级索引。B+树是关系数据库的物理实现中最常用的一种多级索引技术。 集簇：在记录查找中往往需要按某项的项值查找，将具有相同或相邻项值的记录聚集在相同磁盘块内或圆柱体内以减少读盘次数，提高查找速度。 提高文件访问效率的常用方法 索引：见上 集簇：见上 HASH法：一种函数转换法。通过一个hash函数将要查找的记录转换成该记录所在的物理地址，然后可以直接进行记录的定位读取操作。 Ch3 关系数据库系统概述优点 数据结构简单（二维表） 使用方便 功能强 数据独立性高 理论基础深 可移植性好 标准化程度高 分布式功能 开放性 其他方面的功能扩展 完全关系型的12条衡量准则完全关系型的12条严格标准 信息准则(关系数据库的所有信息都应能在逻辑一级唯一地用‘表’中的值显式表示) 确保访问准则(应能保证用逻辑方式依靠表名、关键字值与列名的组合来访问数据库中每一个原子数据) 空值的关系处理准则(系统应该具有处理空值的能力) 基于资源管理的动态联机目录(数据库的描述信息(数据字典)与用户数据具有相同的表示形式与操作方式) 统一易用的数据子语言(至少有一种数据子语言能全面支持下列功能:数据定义、视图定义、数据操纵、完整性约束能力、授权机制、事务处理能力) 视图更新准则(通过视图不仅可以查询,还可以执行对数据的增、删、改等操作) 高级的插入、删除及修改操作(一条命令可以插入、删除及修改操作多条元组) 物理数据独立性 逻辑数据独立性 数据完整性准则(提供三类数据完整性约束的定义功能) 分布独立性(数据分布的改变不影响原有的应用程序) 无损害原则(对提供低级数据子语言的要求) 关系数据库产品分类 半关系型系统：满足12条中少量准则 基本关系型系统：满足12条中大部分 完全关系型：严格符合12条 基本数据结构都是关系 空值（NULL）的定义：无意义或当前未知的值。 关系代数关系模型（概念）名词术语对应关系 关系—表 属性—列 元组—行 模式(schema)—表头（有名字的列的集合） 关系数据结构 表框架 由$n$个命名的属性组成，$n$称为表的元数（$n$元表） 每个属性有一个取值范围，称为值域 元组 在表框架中按行存放数据，每一行数据被称为一个元组 $n$元表中，一个元组由$n$个分量组成，第$j$个分量是表框架中的第$i$个属性 一个表框架可存放$m$个元组，$m$称为表的基数（行数） 关系 对二维表的一种抽象，是关系模型的基本数据单位 关系名($R$)及其所有的属性名($A_1,A_2\\ldots, A_n$)构成了关系框架$R(A_1,A_2,\\ldots, A_n)$ 关系模型：以符合7个性质的二维表为基本数据结构所建立的模型 性质：不能有多值属性（First Normal Form Rule）、行列无序性(Access row by content only)、不能有完全相同的两行(The unique row rule) 关键字Key 在二维表中能唯一最小标识元组的属性集(要根据语义来判断 每张二维表都至少存在一个键 候选键：候选关键字（关键字不一定唯一） 主键：所有候选键中被选中的一个 超键：a set of columns that has the uniqueness property，键是最小超键 外键：如果表A中的属性集F是表B的键，则称该属性集F是表A的外键。（学生表里的学号vs选课表里的学号） 表A是引用表，表B是被引用表。 表A和表B可以是同一张二维表 关系数据库：关系子模式-视图（没找到） 关系操作建立在关系上的数据操纵功能 数据查询：两个关系的合并、单个关系内的元组选择（选择满足指定条件的元组）、单个关系内的属性指定（选择结果所需要的属性） 数据删除：确定被删除的元组（满足给定逻辑条件）、执行删除操作（一次删除操作只能删除一个关系内的元组） 数据插入：在指定关系中插入一个或多个新的元组（一条数据插入操作只能向一个关系中增加新的元组） 数据修改：在指定关系中插入一个或多个新的元组（一条数据插入操作只能向一个关系中增加新的元组）。不是基本操作，可以由删除+插入实现 空值处理 主键中不允许出现空值 算术表达式中出现空值则结果为空值 逻辑表达式中出现空值则结果为假 计算SUM，AVG，MAX，MIN，COUNT时空值不统计在内 对空值作SUM，AVG，MAX或MIN统计操作时，结果均为空值 对空集作COUNT统计操作时，结果为0 五种基本操作： 元组选择 属性指定 两个关系的合并 元组插入 元组删除 关系中的数据约束三类数据完整性约束 实体完整性约束：主键中的属性不能有空 参照完整性约束：外键要么取空值，要么是被引用表当前存在的某元组上的主键值 用户定义的完整性：用户自己定义的属性取值约束 关系代数$(A, \\pi, \\sigma, \\times, \\cup, -)$由关系的集合Ａ及关系间的五种基本运算所构成的代数系统被称为关系代数 关系的表示 $n$元关系$R$是一个$n$元有序组的集合 设$n$元关系$R$的属性域分别是$D_1,D_2,\\dots, D_n$，那么这$n$个域的笛卡儿乘积也是 关系操作的表示 关系上的五种基本操作 关系代数中的五种基本运算 元组选择 选择运算 属性指定 投影运算 关系合并 笛卡尔乘积 元组插入 并运算 元组删除 差运算 关系代数中的五种基本运算每种运算的执行条件和结果关系 并运算： 条件：参与运算的两个关系必须是同类关系（具有相同的属性个数，且对应列所表示的属性应具有相同的值域）。 结果：关系模式不变，由所有属于关系$R$或属于关系$S$的元组所组成的集合。 相容表：有相同表头的表是相容表（属性相同，值域相同，含义相同）。并交差运算都只能作用在相容表上。 差运算： 条件：参与运算的两个关系必须是同类关系。 结果：关系模式不变，由所有属于关系$R$但不属于关系$S$的元组所组成的集合。 差运算不满足交换律与结合律 交运算不是基本运算，可以由差运算得到：$R\\cap S=R-(R-S)=S-(S-R)$ 投影运算：$\\pi_{B_1,B_2,\\dots, B_m} (R)$，其中$B_i\\in{ A_1,A_2,\\dots, A_n } (i=1,2,\\dots,m)$。 结果：是一个由$B_1,B_2,\\dots, B_m$所组成的$m$元关系。关系$R$中的每个元组$t$在$B_1,B_2,\\dots, B_m$这$m$个属性上的取值$t_1,t_2,\\dots, t_m$构成结果关系中的一个元组。 不满足交换律 选择运算： $\\sigma_F(R)$，根据给定的条件$F$从关系$R$中选出符合条件的元组。 结果：结果关系的关系模式不变，由属于关系$R$且满足条件$F$的元组所组成。 先选择再投影 ，颠倒后的表达式不一定合法；$\\pi_A\\sigma_F(R)$默认运算顺序：从右向左 满足交换律 笛卡儿乘积： 设关系$R$和$S$分别有$n$和$m$个属性，即：$R(A_1,A_2,\\dots, A_n)$和$S(B_1,B_2,\\dots, B_m)$，则它们的笛卡儿乘积$T = R\\times S$有$(n+m)$个属性，即：$T(A_1,A_2,\\dots, A_n, B_1,B_2,\\dots, B_m)$。 若关系R和S分别有$p$和$q$个元组，那么它们的笛卡儿乘积中就含有$(p\\times q)$个元组。 【笛卡儿乘积满足交换律和结合律】 如果存在相同属性名，必须对其中至少一个进行换名 关系模型与关系代数：由关系的集合$A$及关系间的五种基本运算（$\\pi, \\sigma, \\times, \\cup, -$）所构成的代数系统被称为关系代数。 扩充运算 交运算 条件：同类关系 结果：关系模式不变，由所有既属于关系$R$也属于关系$S$的元组所组成的集合 除运算 $T=R\\div S$: $Head(T)=Head(R)-Head(S)$ 能取遍关系$S$中所有值的$R$中的元组组成的集合（见例子） 若$R=T\\times S$，则$T=R\\div S$且$S=R\\div T$。若$T=R\\div S$，则$T\\times S\\subseteq R$ $T\\times S\\subseteq R$ 【记住！！！】$R\\div S=\\pi{A_1,A_2\\ldots A_n}(R)-\\pi{A1,A_2\\ldots A_n}((\\pi{A_1,A_2\\ldots A_n}(R)\\times S)-R)$ 联接(join)运算 $R\\underset{F}{\\Join}S$: 将关系$R$和关系$S$根据联接条件$F$合并为一个关系，又称$\\theta$-联接运算 不必消除它们之间的同名属性，但在结果中同名属性需要换名 $R\\underset{F}{\\Join}S=\\sigma_F(R\\times S)$ 自然联接($R\\Join S$)：根据同名属性进行等值联接，同名属性只保留一份 条件：要求关系$R$和关系$S$有公共属性即$\\textrm{Head}(R)\\cap\\textrm{Head}(S)\\neq\\emptyset$ 外联接：允许外的另一边的有null 关系代数的一些栗子查询折扣最高的客户的编号 $\\pi{C.cid}(C)-\\pi{C.cid}(\\sigma_{C.discnt&lt;S.discnt}(C\\times S)), S:=C$ $\\pi{C.cid,S.cid}(\\sigma{C.discnt&gt;=S.discnt}(C\\times S))\\div \\pi_{cid}(C)$ 关系演算基本概念（不在考纲里） 命题 个体词。个体域（个体变元的取值范围） 谓词 指派 量词：$\\forall, \\exists$ 连接符：与或非蕴含 关系的表示（不在考纲里） 元组关系演算：$R={t\\mid P(t)}$, 可简写为$P(t)$ 公式中的每个变元的取值都是一个元组，称为元组变量 $n$元关系$R$可用一个谓词$R(t)$表示，$t$是元组变量，$t(i)$表示关系$R$中的第$i$个属性 用来描述由谓词$P(t)$的所有成真指派所构成的元组集合 域关系演算：$R={\\mid P(x_1,x_2,…,x_n) }$ 每个变元的取值是单个的属性值，称为域变量 $n$元关系$R$用$n$元谓词$R(x_1,x_2,\\cdots x_n)$表示 通常混用 原子公式 谓词$R(t)$是原子公式 $u(i)\\theta v(j)$是原子公式（其中：$u$，$v$是两个元组变量，$u(i)$代表元组$u$在第$i$个属性上的值，$v(j)$代表元组$v$在第$j$个属性上的值，$\\theta$是比较运算符） $u(i)\\theta a$是原子公式（其中$a$是常量） 公式的定义 原子公式是公式 如果$\\varphi_1,\\varphi_2$是公式，则$(\\varphi_1\\wedge\\varphi_2),(\\varphi_1\\vee\\varphi_2),(\\varphi_1\\rightarrow\\varphi_2)$及$(\\neg\\varphi_2)$均为公式 如果$\\varphi$是公式，$\\varphi$中有自由变元$r$，则$\\exists r(\\varphi),\\forall r(\\varphi)$均为公式 公式由且仅由上面三种方式通过有限次组合构成 基于关系演算的数据查询表示 基于关系演算的数据查询表示 所有目标属性均以自由变元形式出现，其它属性以约束变元形式出现。(先写完查询标出目标属性，后填上约束变元) 一般情况下我们使用存在量词对变元作约束，根据题目的需要也可以使用全称量词来约束变元。 检索条件(元组选择条件）以合取形式(逻辑与）与谓词相联结。 当变元与常量进行相等比较时，可以用常量值代替变元直接出现在谓词中。 关系操作的表示关系模型有5种基本操作，分别对应5中基本关系运算 $R\\cup S={t\\mid R(t)\\vee S(t) }$ $R-S={t\\mid R(t)\\wedge \\neg S(t) }$ $\\sigma_F(R)={t\\mid R(t)\\wedge F }$ $\\pi_{A_1,A_2}(R)={u^{(2)}\\mid \\exists t, (R(t)\\wedge u(1)=t(1)\\wedge u(2)=t(2))} $ $R\\times S={t^{m+n}\\mid\\exists u^{(m)}\\exists v^{(n)}(R(u)\\wedge S(v)\\wedge t(1)=u(1)\\wedge t(2)=u(2)\\wedge\\ldots t(m)=u(m)\\wedge t(m+1)=v(1)\\wedge \\ldots t(m+n)=v(n))}$ ${t\\mid\\Phi(t)}$可以简写为$\\Phi(t)$ 运算优先级： 比较运算符 &gt; 量词 &gt; 非 &gt; 与或蕴含 关系的联结 逻辑与实现笛卡尔乘积：$R(q)\\wedge S(q)$ 通过选择条件$F$实现$\\theta$-联结：$R(q)\\wedge S(q)\\wedge F$ 通过两个谓词中的公共变元（同名变元）实现两个关系的自然联结：$R(x,y,z)\\wedge S(y,u,v)$ 自联结：谓词名不变，对部分变元进行重命名 关系演算的例子 检索所有学生的学号、姓名：$\\exists sd,sa (S(\\underline{sno}, \\underline{sn}, sd ,sa))$ 检索修读课程号$C_1$的所有学生的姓名：$\\exists sno, sd, sa, g (S(sno,\\underline{sn},sd, sa)\\wedge SC(sno, ‘C’, g))$ 检索修读所有课程的学生的姓名：$\\exists sno,sd,sa(S(sno,\\underline{sn},sd,sa)\\wedge \\forall cno(\\exists cn,pno(C(cno, cn, pno))\\to \\exists g(SC(sno, cno,g))) )$ 关系演算的安全性问题（不在考纲里）无限关系、无穷验证安全公式：不会产生无限关系和无穷验证现象的关系演算表达式约束集$\\text{DOM}(\\varphi)$组成： 公式$\\varphi$中所出现的关系中的某些分量 公式$\\varphi$中显式出现的常量符号 安全公式的判定条件： 若$t$满足公式$\\varphi$，则$t$的每个分量必定是$\\text{DOM}(\\varphi)$的元素——不会产生无限关系 对$\\varphi$中每一个形为$\\exists t(W(t))$的子公式，若$t$满足$W$，则$t$的每个分量一定属于$\\text{DOM}(\\varphi)$——不会存在无穷验证 对$\\varphi$中每一个形为$\\forall t(W(t))$的子公式，如果$t$的任一分量不在$\\text{DOM}(\\varphi)$中，则$t$必定满足$W$.——不会存在无穷验证 关系代数与关系演算（不在考纲里）关系代数：安全的关系演算 关系演算→关系代数： $\\phi_1\\wedge \\phi_2$：$R_1\\Join R_2$（有公共变元）或$R_1\\times R_2$（无公共变元） $\\phi_1\\vee\\phi_2$：$R_1\\cup R_2$ $\\phi_1\\to \\phi_2$：$R_1\\div R_2$ $\\neg\\phi$： $(D_1\\times D_2\\ldots \\times D_n)-R$ $\\exists r, \\varphi$：$\\pi_{…}(R)$（下标为原公式中所有自由变元） $\\exists r, \\varphi$： $R\\div S$ 完备系统 能够提供关系代数的五种基本运算功能的关系模型系统 具有安全的关系演算功能的关系模型系统 SQL语言这一块提纲有点乱，不做重新整理了，基本都覆盖到了，反正也是考计算就凑合着看吧 结尾有分号 不区分大小写 字符(串)和日期时间类型的常量需要定界符’，数字不需要 SQL概貌 基本概念 关系——基表；关系子模式——视图（虚表）；属性——列；元组——行 基表和虚表统称为表 使用方式： 自含式：独立的交互式命令行语言 嵌入式：嵌入到某种高级程序设计语言（主语言）中使用。嵌入方式：嵌入式SQL（ESQL），函数调用 数据定义功能（DDL）基本数据类型 小整型SMALLINT：同C的short, $[-32768,32767]$ 大整型INT: 同C 巨整型BIGINT: 同C的long long 浮点数DEC(p,s), NUM(p,s): 精度p(最大31位)和小数位s(小数点右边数字的长度) 字符大对象字符串CLOB(n[K|M|G]) 图形字符串 二进制串 日期DATE：年月日 时间TIME：时分秒 时间戳TIMESTAMP：年月日时分秒和微秒 基表创建1234CREATE TABLE tablename( colname, datatype [NOT NULL] &#123;, colname datatype [NOT NULL]&#125;); [...]仅允许出现0或1次 &#123;...&#125;可以出现0或若干次 e.g.12345CREATE TABLE SC( sno CHAR(5) NOT NULL, cno CHAR(4) NOT NULL, g CHAR(1)); 基表修改 表中属性的增加/删除12ALTER TABLE tablename ADD colname datatype;ALTER TABLE tablename DROP colname; 删除整个表1DROP TABLE tablename 数据操纵功能 SQL和关系代数的关系单个关系上的选择和投影$\\pi_{A_1, A_2,\\cdots A_m}(\\sigma_F(R_1\\times R_2\\times\\cdots\\times R_n))$ 123SELECT A1, A2, ..., AmFROM R1, R2, ..., RnWHERE F 笛卡尔积$R\\times S$ 12SELECT R.A1, R.A2, ..., R.An, S.B1, S.B2, ..., S.BmFROM R,S $\\theta$-连接$R\\underset{F}{\\Join}S$ 123SELECT R.A1, R.A2, ..., R.An, S.B1, S.B2, ..., S.BmFROM R,SWHERE F 自然连接$R\\Join S$ 12345SELECT R.A1, R.A2, ..., R.An, R.B1, R.B2, ..., R.Bk, S.C1, S.C2, ..., S.CmFROM R,SWHERE R.B1=S.B1 and R.B2=S.B2 and ... and R.Bk=S.Bk 很麻烦，一般用笛卡尔积+选择+投影 123SELECT attr_1, attr_2, ..., attr_x FROM R, SWHERE F 可以将两个关系按任意指定的方式F进行合并 映像语句的结构 类型 形式 目标子句 `SELECT * \\ colname { , colname … }` 范围子句 FROM tablename &#123; , tablename ... &#125; 条件子句 [WHERE search_condition ] 分组子句 [ GROUP BY colname &#123; , colname ... &#125; 分组查询子句 [ HAVING group_condition ] ] 排序输出子句 `[ ORDER BY colname [ ASC DESC ] { , colname [ ASC DESC ] … } ];` 两个必须有的子句：SELECT,FROM HAVING子句前必须有GROUP BY 目标子句1SELECT * \\| colname &#123; , colname ... &#125; 定义结果关系所需要的属性 给出结果属性的属性名 表明.属性名 可以给结果属性重命名： &lt;column_expr&gt; AS &lt;colname&gt; *表示表中所有属性 distinct消除结果关系中的重复元组 范围子句1FROM tablename &#123; , tablename ... &#125; 指定操作对象 可以在FROM子句中对一个关系重命名：&lt;tablename&gt; &lt;aliasname&gt; 多个表通过笛卡尔乘积合并 SELECT子句和FROM子句是一条映像语句中必不可少的两个组成部分 条件子句1WHERE search_condition 包括单个关系中的元组选择条件 和关系与关系之间的联接条件 常用谓词 DISTINCT BETWEEN...AND... LIKE column [NOT] LIKE val1 [ESCAPE val2] 模板val1:任意字符_， 任意字符串%(包括空字符串)，其他字符匹配自身 转义指示字符val2：紧跟在val2字符后的_和%不再是通配符而是其自身 查询课程名中含有百分号的课程的课程号123SELECT cnoFROM CWHERE cn LIKE &#x27;%A%%&#x27; ESCAPE &#x27;A&#x27; IS NULL/IS NOT NULL 查询无课程分数的选课记录中的学号与课程号123SELECT sno, cnoFROM SCWHERE g is NULL; 布尔运算AND,OR,NOT 自连接连接两张相同的表时，可以在FROM语句中对其中一张换名 12tablename AS newnametablename newname (AS可以省略) e.g.查询至少修读学号为S5的学生所修读的一门课程的学生的学号123SELECT SC1.snoFROM SC SC1, SC SC2 //重命名WHERE SC1.cno=SC2.cno AND SC2.cno=&#x27;S5&#x27;; 结果排序123ORDER BY colname [ASC | DESC] &#123;, ...&#125;-- colname: 需要排序的列名-- ASC/DESC 升序/降序， 默认升序 嵌套查询 在一条映像语句的某个子句中嵌入另一条映像语句(子查询) 通常在WHERE中 子查询的结果是一个集合——集合谓词 IN：元素和集合之间的关系 限定比较谓词SOME|ANY|ALL：标量与集合元素之间的量化比较12345678// 查询有学生成绩大于C1课程号中所有学生成绩的学生学号SELECT snoFROM SCWHERE g &gt; ALL( SELECT g FROM SC WHERE cno=&#x27;C1&#x27;); EXISTS：是否为空集的判断谓词 除法的表示e.g.查询至少修读学号为S4的学生所修读的所有课程的学生的学号关系代数表示：$\\pi{sno,cno}(SC)\\div\\pi{cno}(\\sigma_{sno=’S4’}(SC))$123456789101112131415161718192021222324SELECT S.snoFROM SWHERE NOT EXISTS ( SELECT * FROM SC x WHERE x.sno = &#x27;S4&#x27; and NOT EXISTS ( SELECT * FROM SC y WHERE y.cno = x.cno and y.sno = S.sno ));//另一种表示SELECT S.snoFROM SWHERE NOT EXISTS ( SELECT * FROM SC x WHERE x.sno = &#x27;S4&#x27; and x.cno NOT IN ( SELECT y.cno //注意这里就要用别名 FROM SC y WHERE y.sno = S.sno )) 子查询的合并 并：UNION[ALL] 交: INTERSECT[ALL] 差：EXCEPT[ALL] SQL统计功能可以在同一条SQL语句中同时执行多个统计计算不能在WHERE子句中使用统计函数，需要嵌套子查询 count count(*)返回集合中元组的个数 count(colname): 返回在colname属性上取值非空的元组个数 count(distinct, colname): 返回colname取值非空且互不相同的元组个数 空值处理 统计函数将忽略空值元素 在空集上进行统计计算时，COUNT()返回0，SUM,AVG,MIN,MAX返回NULL 插入记录是如果没有给出某个属性的取值，系统会自动为该属性赋上空值 123456789-- 给出学号为S1的学生修读的课程门数SELECT COUNT(*)FROM SCWHERE sno = &#x27;S1&#x27;;-- 给出学号为S7的学生所修读课程的平均成绩SELECT AVG(G)FROM SCWHERE sno = &#x27;S7&#x27; 计算功能1234//给出计算机系下一年度学生的年龄SELECT sn, sa + 1FROM SWHERE sd = &#x27;CS&#x27;; 分类功能分组查询子句GROUP BY colname &#123;, colname ...&#125; 根据属性colname的取值不同，将满足WHERE条件的元组划分为不同的集合 可以在SELECT子句中针对不同的元组集合分别进行统计计算，实现分类统计查询 DBMS会自动对分组进行排序 分组统计查询中，目标属性必须包含所有的分组属性 1234//给出每个学生的平均成绩SELECT sno, AVG(G)FROM SCGROUP BY sno 分组选择子句HAVING group_condition 根据GROUP BY子句的分组结果，定义分组选择条件 只有满足group_condition的元组才会被保留 12345//给出选修人数超过5个的课程的课程号及其选修人数SELECT cno,COUNT(sno)FROM SCGROUP BY cnoHAVING COUNT(*) &gt; 5; SELECT语句使用的一般规则（不在考纲中）处理顺序 合并FROM子句中的表(笛卡尔乘积) 利用WHERE子句中的条件进行元组选择 根据GROUP BY子句对保留下来的元素进行分组 利用HAVING子句中的条件对分组后的元组集合进行选择 根据SELECT子句进行统计计算，生成结果关系 根据ORDER BY子句对查询结果进行排序 SQL更新功能元组删除12DELETE FROM tablename [WHERE search_condition] 删除符合条件的元组 一条语句只能删除一张表中的元组 没有WHERE子句就删除表中所有元组 WHERE中也可以嵌入子查询 元组插入12345INSERT INTO tablename[(colname&#123;, colname ...&#125;)] -- 属性名列表，默认是基表定义中的顺序VALUES (expr | NULL &#123;, expr | NULL ...&#125;) | subquery;-- 被插入的常量元组值，属性值的数量与排列顺序必须与INTO子句中的一致-- 也可以将子查询的结果插入表中，注意属性的数量和排列顺序 常量元组插入e.g.12INSERT INTO SCVALUES (&#x27;S10&#x27;, &#x27;C25&#x27;, &#x27;B&#x27;)带子查询的元组插入e.g.12345-- 插入计算机系学号学生选修数据库的选课记录INSERT INTO SC(sno, cno)SELECT sno, cnoFROM S, CWHERE sd = &#x27;CS&#x27; and cn = &#x27;Database&#x27;; 元组修改123UPDATE tablenameSET colname = expr | NULL | subquery, ...[WHERE search_condition]; 修改指定基表中满足WHERE条件的元组e.g12345678-- 将计算机系学生的成绩全置零UPDATE SCSET g = 0WHERE sno IN ( SELECT sno FROM S WHERE sd = &#x27;CS&#x27;); 视图 12CREATE VIEW viewname [(colname&#123;, colname, ...&#125; )]AS &lt;映像语句&gt; [WITH CHECK OPTION] 视图概念：由若干张表经映像语句构筑而成的表，又称“导出表” 视图与基表的区别： 视图的二维表本身（结构与数据）并不实际存在与数据库内，而仅仅保留了其构造信息（有关视图的定义信息），因此视图又被称为“虚表” 当用户执行视图上的访问操作时，DBMS将根据视图的定义命令把视图访问操作转换成相应的基表访问操作 WITH OPTION CHECK用于约束视图上的修改操作，使修改后的新元组仍能够通过视图上的查询操作查出来 e.g.123456-- 定义学生的学号、姓名及其平均成绩的视图CREATE VIEW S_G(sno, sn, Avg_G)AS SELECT sno, sn, AVG(G)FROM S, SCWHERE S.sno = SC.snoGROUP BY sno, sn 视图的嵌套定义可以用已有的视图定义新的视图12345-- S_C_G是一个已经存在的视图CREATE VIEW C_G(cn, Cavg)AS SELECT cn, AVG(G)FROM S_C_GGROUP BY cn 视图删除1DROP VIEW viewname 将连带删除定义在该视图上的其他视图 可更新视图的判断标准 视图的每一行必须对应基表的惟一一行 视图的每一列必须对应基表的惟一一列 视图的作用 提高了数据独立性 简化用户观点 提供自动的安全保护功能。 练习中的一些难题12345678910111213141516171819202122232425262728293031323334353637383940414243-- 3.2 检索为居住在Duluth和Kyoto的所有客户订购过同一种商品的经销商的编号-- 注意调用子查询时要加上外层查询的约束条件SELECT a.aidFROM Agents aWHERE EXISTS ( SELECT * FROM Orders o WHERE o.aid = a.aid and o.pid IN ( SELECT p.pid -- 所有这两个城市的居民都买过的商品 FROM Products p WHERE NOT EXISTS ( SELECT * FROM Customers c WHERE (c.city = &#x27;Duluth&#x27; or c.city = &#x27;Kyoto&#x27;) and NOT EXISTS ( SELECT * FROM Orders x WHERE x.pid = p.pid and x.cid = c.cid and x.aid = a.aid ) ) ) );-- 返回每个客户的编号及最后两份订单的订购日期-- 至少有2条订单的客户SELECT o1.cid, o1.orddate AS last_but_one_ord, o2.ordate AS last_ordFROM Orders o1, Orders o2WHERE o1.cid = o2.cid and o1.ordno &lt; o2.ordno NOT EXISTS ( SELECT * FROM Orders o WHERE o.cid = o1.cid and o.ordno &lt;&gt; o2.ordno and o.ordno &gt; o1.ordno);-- 只有一条订单的客户SELECT o1.cid, o1.orddate AS last_but_one_ord, NULLFROM orders o1WHERE NOT EXISTS ( SELECT * FROM orders o WHERE o.cid = o1.cid and o.ordno &lt;&gt; o1.ordno);-- 没有订单的客户（自己想吧）-- 结果是把以上三个查询UNION起来 全称量词可以用ALL、NOT EXISTS、NOT IN或MAX()/MIN()来实现 CH4 数据库的安全性与完整性保护4.1 数据库的安全性保护数据库安全的基本概念与内容 主体：数据库中数据的访问者 客体：数据库中的数据及其载体，如表、视图、快照、存储过程、数据文件等 身份标识与鉴别：每个主体必须有一个标识自己身份的标识符（以区别不同的主体）以及一个用以验证其身份的访问口令。当主体访问客体时，TCB 将对主体所提交的身份标识符和口令进行鉴别，以阻止非法访问。 自主访问控制（DAC）：是一种基于存取矩阵的安全控制模型。用户对信息的存取控制是基于“用户的鉴别”和“存取访问规则的确定” 每个用户都要给以对系统中每个存取对象的存取权限 当一个主体要求访问一个客体时，系统将检查该主体在相应客体上是否拥有所需要的存储权限 存取权限：一个客体的所有者自动拥有该客体上的所有操作权限；拥有权限的用户可以自主地将他所拥有的权限传授给其它任意在系统登录的用户。用户只能通过这两种方式来获得在一个客体上的存取权限。 访问控制：在用户登录时进行用户的身份鉴别；在用户访问数据库时执行访问检查控制 审计：跟踪记录用户对数据的访问操作：访问时间/访问内容/用户名/终端名/操作类型/操作结果，并可根据审计结果给出报警信息。 执行审计操作需要额外的时间和空间开销，因此在DBMS中，审计通常是一个可选择的安全保护手段，主要用于安全性要求较高的部门。 SQL对数据库安全的支持 在SQL’92中提供的C1级数据库安全的支持：主体、客体及主客体分离；身份标识与鉴别；数据完整性；自主访问控制与授权功能；审计。 SQL的自主访问控制与授权功能：SQL中的自主访问控制是通过（用户、操作对象、操作权限）这样的三元组来定义用户对数据的访问权限的，并可通过授权（Grant）和回收（Revoke）语句来改变用户的访问权限。 SQL的存取权限（操作权限）：SELECT权，INSERT权，DELETE权，UPDATE权，REFERENCY权，EXECUTE权，USAGE权 SQL中的授权命令GRANT123GRANT &lt;操作权限列表&gt; ON &lt;操作对象&gt; TO &lt;用户名列表&gt; [WITH GRANT OPTION]--e.g.GRANT SELECT, UPDATE on S to XULIN with grant option SQL中的权限的回收命令REVOKE123REVOKE &lt;操作权限列表&gt; ON &lt;操作对象&gt; FROM &lt;用户名列表&gt; [RESTRICT | CASCADE]--e.g.REVOKE UPDATE on S from XULIN CASCADE CASCADE：连锁回收 RESTRICT:在不存在连锁回收问题时才能回收权限，否则拒绝回收 4.2 数据库的完整性保护 数据库完整性保护 目的：及时发现错误；能够采取措施防止错误的进一步蔓延；最终将数据库回复到正确状态。 常用实现措施：完整性约束条件的定义及审查；触发器；并发控制技术 功能：三个基本功能：设置功能、检查功能、处理功能 完整性规则 实体完整性规则：在一个基表的主关键字（主键）中，其属性的取值不能为空值。 参照完整性：关系R中的每个元组在外关键字F上的值或者是空值（NULL），或必须引用在关系S中存在的元组，即不能引用不存在的实体。 引用：若关系R中有属性集F与另一个关系S的关键字$K_s$相对应（具有相同的语义和取值范围），则称关系R引用关系S中的元组。 用户定义完整性：由用户来定义的数据库完整性要求。 完整的CREATE TABLE命令 需要定义的内容：模式名与表名。属性的定义：属性名与数据类型、缺省值、数据约束。表级（元组级）的数据约束定义。 基表的创建12345678910[CONSTRAINT constraint_name]&#123; UNIQUE(colname &#123;, colname, ...&#125;) | PRIMARY KEY (colname, &#123;, colname, ...&#125;) | CHECK (search_condition) | FOREIGN KEY (colname, &#123;, colname, ...&#125;) REFERENCES table_name[(colname &#123;, colname, ...&#125;)] [ON DELETE CASCADE | RESTRICT | SET NULL] [ON UPDATE CASCADE | RESTRICT | SET NULL]&#125;-- 基于多个属性的取值约束 NOT NULL v.s. DEFAULT NULL Constraint name：对某个数据约束条件进行命名（可选项），以利于以后使用ALTER TABLE命令来修改表中数据约束定义 UNIQUE v.s. NOT NULL：UNIQUE属性可以取空值，候选键：UNIQUE+NOT NULL PRIMARY KEY v.s. NOT NULL：主键定义自动蕴含着“非空”的约束要求 REFERENCES：外键v.s.主键；外键上的取值约束及其一致性的保证措施 CHECK：其他任意的属性取值约束 FOREIGN KEY：定义主外键的引用关系。当对引用表中的外键进行赋值时，需要检查外键值的正确性。 ON DELETE/UPDATE：当在被引用表中删除元组或修改主键值时，需要维护引用表中外键值的正确性，具体方式如下： CASCADE：同步做连带更新/删除 RESTRICT：如果在引用表中存在与被删除或修改的主键相关的元组，则拒绝本次对被引用表的DELETE/UPDATE操作 SET NULL：如果在引用表中存在与被删除或修改的主键相关的元组，则自动地将相关元组上的外键值设置为空 完整性约束的定义：主关键字，外关键字，CHECK约束，UNIQUE，NOT NULL, DEFAULT 主键定义：PRIMARY KEY (&lt;column-list&gt;) 唯一键定义：UNIQUE(&lt;column-list&gt;) 外键定义1234FOREIGN KEY (&lt;fk-col-list&gt;)REFERENCES &lt;table-name&gt; (&lt;pk-col-list&gt;)[ON DELETE [CASCADE | RESTRICT | SET NULL]][ON UPDATE [CASCADE | RESTRICT | SET NULL]] e.g.123456789101112CREATE TABLE EMP ( ... CONSTRAINT pk PRIMARY KEY(Empno) --主键定义 CONSTRAINT uni_name UNIQUE(PersonId) --候选键的定义 --外键Deptno的定义 CONSTRAINT fk_depy FOREIGN KEY(Deptno) REFERENCES DEPT(Deptno) ON UPDATE CASCADE --DEPT表中Deptno更新时同步更新EMP的Deptno ON DELETE RESTRICT --删除某个部门的员工，禁止在部门表中删除该部门元组 CONSTRAINT chk_1 CHECK (...)); 触发器及其创建命令 定义：一个事件的发生会导致另外一些事件的发生 功能：某个事件的发生会导致另外一些事件的执行，以消除前一个事件对数据完整性所起的影响。 组成：触发事件、结果事件、触发过程 定义命令1234567891011121314151617CREATE TRIGGER trigger_name&#123;BEFORE | AFTER&#125; --触发事件 &#123; INSERT | DELETE | UPDATE [OF &lt;col-list&gt;] ON table_name &#125; --执行方式 [REFERENCING corr_name_def&#123;, ...&#125;] [FOR EACH ROW | FOR EACH STATEMENT] [WHEN (search_condition)] &#123;statement | BEGIN ATOMIC statement; &#123;statement; ...&#125;&#125;--结果事件END--e.gCREATE TRIGGER update_sal BEFORE INSERT or UPDATE(sal, pos) ON Teach FOR EACH ROW WHEN (:new.Pos = &#x27;Prof.&#x27;) BEGIN IF :new.sal &lt; 2000 THEN :new.sal := 2000; END IFEND; CH5 事务处理、并发控制与故障恢复技术 5.1 事务处理（概念） 事务的定义：由某个用户所执行的一个不能被打断的对数据库的操作序列 应用程序访问数据库的基本逻辑工作单位 通常由一组对于数据库的访问操作组成，在执行过程中按照预定的次序顺序执行 串行执行；中间状态可能会不一致，但结束时系统保证数据一致性 ACID性质 原子性（Atomicity）：所有操作要么都不执行要么都执行； DBMS自动维护：DBMS的事务管理子系统 + 事务日志 一致性（Consistency）：一个事务的成功67执行总是将数据库从一个一致的状态转换到另一个一致的状态。 状态：数据库中所有数据对象的当前取值情况 一致状态：数据必须满足1.在数据库中显式定义的各种完整性约束2.用户心目中的隐式数据约束 一致性原则基于假设：在一个事务开始执行之前数据库处于一个一致的状态，如果没有其它事务的干扰和系统故障，那么当该事务执行结束时数据库仍然处于一致的状态。 一致性由两方面完成：DBMS中的“数据完整性保护”子系统 + 编写事务的应用程序员 隔离性（Isolation）：一个事务的执行与并发执行的其它事务之间是相互独立的，互不干扰。 多个事务并发执行的最终结果，应该与它们的某种串行执行的最终结果相等，这被称为并发事务的可串行化。 实现：DBMS的并发控制子系统（包含在事务管理子系统中） 持久性（Durability）：一个事务一旦完成其全部操作后，它对数据库的所有更新应永久地反映在数据库中，即使以后系统发生故障也应该能够通过故障恢复来保留这个事务的执行结果 实现：DBMS的恢复管理子系统 事务活动及其状态转换图 两组类型的读写操作：事务与Cache之间，Cache与Disk Files之间 活动状态 事务在开始执行后立即进入“活动状态”，事务将执行对数据库的访问操作 在DBMS的事务管理子系统看来，用户事务对数据库的访问操作就是对数据库中数据的读写操作 “预提交”状态 当事务的最后一条访问语句执行结束之后，事务进入预提交状态。此时数据都在Cache里。 预提交阶段必须确保将当前事务的所有修改操作的执行结果被真正写入到数据库的磁盘中去。 在所有写磁盘操作执行结束后，事务就进入提交状态。 完成提交任务的过程中仍然会发生系统故障，导致当前事务执行失败。预提交失败后当前事务也将被放弃（abort），进入失败状态 “失败”状态 从活动状态转变为失败的原因：用户或应用程序主动放弃（abort）当前事务；因并发控制而被放弃的事务；发生系统故障 从预提交状态转变为失败的原因：发生系统故障 “异常终止”状态 失败状态下事务很可能修改了磁盘的一部分数据，为了保证原子性，需要撤销这些修改。撤销完成后，事务被打上aborted标志，转而进入异常终止”状态 回退（rollback）：对事务的撤销操作，也称为事务的“回退”或“回滚”；由DBMS的恢复子系统实现 进入异常终止后两种选择：作为一个新的事务重启；取消事务 “提交”状态 预提交后检查通过，系统执行commit操作，把数据修改写到磁盘上，并通知系统事务成功结束 为事务打上一个提交标志（commited），事务就进入提交状态 “异常终止”和“提交”都意味着一个事务的执行结束 事务开始运行：活跃状态(active transaction);执行结束：不活跃状态(inactive transaction) 并发控制只针对活跃状态的事务 事务控制即相关的参数设置语句 事务的开始（考纲无） 事务提交：提交当前事务，事务在执行过程中对于数据库的所有修改操作都将永久地反应到数据库中，并且不可被取消。 事务回滚：取消在该事务执行过程中的所有操作，回滚该事务至事务的起点或某个保存点，以便重新执行或放弃（abort）该事务。 保存点：事务中的存档点。用户事务可以使用Rollback命令将当前事务回退到前面某个保存点sp。不带保存点的回退操作将结束并放弃整个事务。 设置事务的自动提交命令：SET AUTOCOMMIT ON|OFF 设置事务的读写类型：SET TRANSACTION READONLY|READWRITE 只读型事务 读写型事务（缺省定义） 设置事务的隔离级别 SET TRANSACTION ISOLATION LEVEL READUNCOMMITED | READCOMMITED | READREPEATABLE | SERIALIZABLE 隔离级别不同，系统所采用的封锁策略不同 未提交读：当前事务不需要申请任何类型的封锁，因而可能会读到未提交的修改结果。（写不可以这样） 提交读：在读数据对象A之前需要先申请对数据对象A的共享性封锁，在读操作执行结束之后立即释放该封锁，以避免读到其他并发事务未提交的修改结果。 可重复读：在读数据对象A之前需要先申请对数据对象A的共享性封锁，并将该封锁维持到当前事务的结束。可以避免其它的并发事务对当前事务正在使用的数据对象的修改。 可序列化（可串行化）：并发事务以一种可串行化的调度策略实现其并发执行，以避免它们相互之间的干扰现象。 不论何种隔离级别，“写”操作之前先要申请数据对象的“排他性”封锁，并将该封锁维持到当前事务的结束。 可能的并发错误现象：更新丢失、脏读、不可重复读、幻象读（同一个事务多次执行同一个查询返回的结果不同） 隔离级别 脏读 不可重复读 幻象读 未提交读 有 有 有 提交读 无 有 有 可重复读 无 无 有 可串行化 无 无 无 事务的语句组成成分事务相关的操作包含两类：事务控制操作 &amp; 数据访问操作 事务控制操作 事务的开始：START T0（启动一个新事务时，DBMS自动分配一个唯一的事务标识符 提交事务：COMMIT T0 回退（放弃）事务：ABORT T0 数据访问操作 将数据对象A的值从磁盘中读入内存缓冲区：INPUT(A) 将内存缓冲区中数据对象A的值写入磁盘：OUTPUT(A) 将内存缓冲区中数据对象A的值读入内存变量t：READ(A, t)可能隐含INPUT(A) 将内存变量t的值写入内存缓冲区中数据对象A：WRITE(A, t) 5.2 并发控制技术（概念）事务 事务的并发性：数据库是一个多用户共享系统，每个用户（或用户程序）都是以“事务”为单位访问数据库 并发控制：用于实现多个用户的并发执行的技术。目标是实现并发事务的可串行化调度。 调度：一个或多个事务中的数据库访问操作，按照这些操作在DBMS中被执行的时间先后，排序所形成的一个操作序列 必须满足两个要求：必须包括所有事务的所有操作，包括每一个事务的结束命令 （commit或abort）；单个事务内部的操作顺序必须保持不变 串行调度：首先是一个事务的所有操作，然后是另一个事务的所有操作，依此类推，则我们称该调度是串行的 可串行化调度：如果一个调度对数据库状态的影响和某个串行调度相同，则我们称该调度是可串行化的 冲突：调度中的一对相邻操作，如果交换它们两者的执行顺序，那么涉及的事务中至少有一个的行为会改变 来自同一个事务的任意两个相邻操作都是冲突，不可以交换执行顺序 来自不同事务的两个相邻操作除非涉及同一个数据对象且至少有一个是写操作，都可以交换顺序 冲突可串行化：对于初始给定的一个调度，如果通过一组非冲突操作的交换，能够将该调度转换成一个串行调度，则我们认为最初的调度就是一个可串行化调度 冲突可串行是可串行化的充分不必要条件 冲突可串行化的判定方法 优先：两个事务$T_1$和$T_2$，各有一个动作$A_1$和$A_2$。如果在调度$H$中，$A_1$在$A_2$之前，且$A_1$和$A_2$涉及同一个数据对象，且$A_1$和$A_2$至少有一个写操作，则称$T_1$优先于$T_2$，记作$T_1&lt;_sT_2$ 优先图：$(i,j)\\in E\\quad iff.\\quad T_i&lt;_sT_j$ 调度$S$是冲突可串行化调度当且仅当事务优先图中无环 视图可串行化 相同的一组事务，两个不同的调度S与H。S和H被称为视图等价当且仅当满足下列三个条件：对每一个数据项D， 如果在调度S中事务$T_k$读到D的初始值，则在调度H中事务$T_k$也必须读到D的初始值；（都读到初始值） 如果在调度S中事务$T_k$执行了$r_k(D)$，并且读到的是由事务$T_j$写入的D的值，则在调度H中事务$T_k$的$r_k(D)$读到的也必须是由事务$T_j$写入的D的值；（读到的同一个数据对象的值都是同一个事务写入的） 如果在调度S中是由事务$T_k$来执行最后一条关于D的写操作$w_k(D)$，则在调度H中也一定是事务$T_k$执行最后一条关于D的写操作$w_k(D)$。（每个数据对象的最后一条写操作是同一个事务执行的） 不正确的事务并发所导致的数据不一致现象：丢失修改、脏读、不可重复读 丢失修改 现象：一个事务的修改结果破坏了另一个事务的修改结果 原因：对多个事务的并发修改同一个数据对象的情况未加控制 脏读 现象：读到了错误的数据（与数据库中的情况不相符） 原因：一个事务读取了另一个事务未提交的修改结果 不可重复读 现象：在一个事务的执行过程中，前后两次读同一个数据对象所获得的指出现了不一致 原因：在两次读操作之间插入了另一个事务的写操作 幻象读 在同一个事务T中，同一条查询命令Q可能被多次执行。在此期间，如果有其他并发事务执行了元组插入操作并提交，那么事务T中的查询Q，前后执行可能返回不一样的结果集，这种现象被称为幻像读. 封锁 常用封锁类型 共享锁（S锁）：只能读；其他事务也可以读（提高并发性）不能写；不必维持到事务执行结束。 排它锁（X锁）：可读可写；其他事务禁止访问；维持到事务执行结束；缺点：降低了整个系统的并行性。 锁相容矩阵：把上面的锁的获得关系列成表，自己脑补吧 锁申请/锁释放算法（OS再放送） 申请对数据对象A的S锁：read_lock(A)123456789101112B： if (LOCK(A) &#x3D;&#x3D; ‘Unlocked&#39;) &#123; LOCK(A) &#x3D; &#39;Read_locked&#39;; no_of_reads(A) &#x3D; 1; &#125; else &#123; if (LOCK(A) &#x3D;&#x3D; &#39;Read_locked&#39;) no_of_reads(A) &#x3D; no_of_reads(A) + 1; else &#123; wait ( until LOCK(A) !&#x3D; &#39;Write_locked&#39; and the lock manager wakes up the transaction); go to B; &#125; &#125; 申请对数据对象A的X锁：write_lock(A) 12345678 B：if LOCK(A) &#x3D; &#39;Unlocked&#39;&#123; LOCK(A) :&#x3D; &#39;Write_locked&#39;;&#125;else &#123; wait ( until LOCK(A) &#x3D; &#39;Unlocked&#39; and the lock manager wakes up the transaction); go to B;&#125; 释放对数据对象A的封锁：unlock(A)1234567891011 if LOCK(A) &#x3D; &#39;Write_locked&#39; &#123; LOCK(A) :&#x3D; &#39;Unlocked&#39;; wake up one of the waiting transaction, if any&#125;else if LOCK(A) &#x3D; &#39;Read_locked&#39; &#123; no_of_reads(A) :&#x3D; no_of_reads(A) - 1; if no_of_reads(A) &#x3D; 0 &#123; LOCK(A) :&#x3D; &#39;Unlocked&#39; wake up one of the waiting transaction, if any &#125;&#125; 在DBMS的“封锁管理器”中维护者一张锁表，记录当前封锁的持有情况和申请等待情况 基于封锁技术的并发控制实现方法 三级封锁协议以及与数据不一致现象之间的关系 一级封锁协议：事务T在写数据对象A之前，必须先申请并获得A上的X锁，并维持到事务T的执行结束(包括Commit与Rollback)才释放被加在A上的X锁。 二级封锁协议：在一级封锁协议的基础上，事务T在读数据对象A之前，必须先申请并获得A上的S锁，在读操作完成后即可释放A上的S锁（没有规定释放S锁的时间）。 三级封锁协议：在一级封锁协议的基础上，事务T在读数据对象A之前，必须先申请并获得A上的S锁，并维持到事务T的执行结束(包括Commit与Rollback)才释放被加在A上的S锁。 一级：防止丢失修改；二级：防止丢失修改和脏读；三级：防止丢失修改、脏读和不可重复读 两阶段封锁协议以及与冲突可串行化之间的关系 第一个阶段：申请并获得锁。事务可以申请整个执行过程中需要的所。但不能释放已经申请到的锁；也成为“锁的扩展阶段” 第二个阶段：释放持有的锁。“锁的收缩阶段”；一旦开始释放就不能再申请 两阶段封锁事务（2PL事务）：所有封锁请求都先于所有解锁请求 定理: 由2PL事务所构成的任意合法调度S都是冲突可串行化的 多粒度封锁封锁粒度/并发度/并发控制实现开销之间的关系 封锁粒度：一把锁可以封锁的数据对象的大小 封锁粒度 系统并发度 并发控制的开销 大 低 小 小 高 大 多粒度封锁：在一个系统中同时支持多种封锁粒度供事务选择使用的封锁方法。 多粒度树： 可以按照封锁粒度的大小构造出一棵多粒度树，以树中的每个结点作为封锁对象，可以构成一个多粒度封锁协议。 基于意向锁的多粒度封锁协议 可以对多粒度树中的每个节点独立加锁（显式封锁） 对一个节点加锁意味着该节点的所有后裔节点也被加以同样类型的锁（隐式封锁） 意向锁： 如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的上层结点加意向锁。 3种常见意向锁：意向共享锁（IS锁）, 意向排他锁（IX锁）, 共享意向排它锁（SIX锁） 意向共享锁（IS锁）：如果对结点N加IS锁，表示准备在结点N的某些后裔结点上加S锁 意向排它锁（IX锁）：如果对结点N加IX锁，表示准备在结点N的某些后裔结点上加X锁 共享意向排它锁（SIX锁）：如果对结点N加SIX锁，表示对结点N本身加S锁，并准备在N的某些后裔结点上加X锁 意向锁锁相容矩阵：S，X，IS, IX, SIX 意向锁锁申请/释放算法 如果要对一个结点加锁，必须先对它的上层结点加意向锁 申请封锁的顺序：自上而下 释放封锁的顺序：由底向上 死锁的检测与预防 死锁：每个事务都可能拥有一部分锁，并因申请其它事务所持有的锁而等待，因此产生的循环等待现象被称为死锁。 活锁：活锁：有部分事务因封锁申请得不到满足而处于长期等待状态，但其它的事务仍然可以继续运行下去，这种情况被称为活锁。（没死全的锁） 死锁的检测及其处理办法 等待图法：（ppt上无）使用一个协调者来集中检测系统状态，并消除出现的死锁。维护一个全局的等待图。有必要时检查者运行回路算法。 超时死锁检测法：锁申请等待超时 &amp; 事务执行超时 时间戳死锁检测法：每个事务都具有一个用于死锁检测的时间戳，该时间戳反映当前事务的新老程度（即已运行时间的长短）。如果事务T必须等待另一个事务U所持有的锁，那么有两种死锁检测策略（牺牲的往往是较年轻的事务） 等待-死亡方案：如果T比U老，那么允许T等待U持有的锁；如果U比T老，那么事务T死亡（被回滚）。（年轻的在等待就回滚） 伤害-等待方案：如果T比U老，它将伤害U，U必须被回滚；如果U比T老，那么T等待U持有的锁。（年轻的被等待就回滚） 5.3 数据库恢复技术 数据库恢复 含义：在数据库遭受破坏后即使进行恢复的功能 方法：利用数据冗余原理，将数据库中的数据在不同的存储介质上进行冗余存储，当数据库本身受到破坏时，可以利用这些冗余信息进行恢复。 常用措施：数据转储、日志、数据库镜像 数据库故障的分类（三类六种） 小型故障（事务内部故障）：故障的影响范围在一个事务之内，不影响整个系统的正常运行 中型故障（系统故障，外部影响）：可导致整个系统停止工作，但磁盘数据不受影响。在系统重启时，可通过当前的日志文件进行恢复 大型故障（磁盘故障、计算机病毒、黑客入侵）：可导致内存及磁盘数据的严重破坏，需要对数据库做彻底的恢复’ 数据库故障恢复三大技术 数据转储：定期地将数据库中的内容复制到其它存储设备中去的过程 后备副本：经转储而得到的备份数据 分类：静态转储/动态转储；海量转储/增量转储 （动态转储）需要结合日志进行故障恢复 日志：是由数据库系统创建和维护的，用于自动记载数据库中修改型操作的数据更新情况的文件。 内容：每个更新操作的事务标识、更新对象、更新前的值和/或更新后的值；每个事务的开始、结束等执行情况；其他信息。 组成：日志是日志记录的一个序列，每个日志记录记载有关某个事务已执行操作的情况（主要是事务的更新操作的执行情况）。由于事务通常是并发执行的，所以多个事务的日志记录通常是交错在一起的。 作用：确保事务执行的原子性；实现增量转储；实现故障恢复（commit——redo，abort—撤销）。 记载原则：按照操作执行的先后次序，遵循先写日志，后修改数据库的原则。 在日志中设置检查点的作用：降低数据库故障恢复开销。在故障恢复时，只要逆向扫描到第一条&lt;CKPT&gt;记录(最后一个被记入的检查点)就可以结束故障恢复工作。 事务的撤销（UNDO）：反向扫描日志文件，查找应该撤消的事务，查找这些事务的更新操作，对更新操作做逆操作（插入变删除、删除变重新插入、修改变修改前的值），如此反向扫描直到日志文件的头部。 事务的重做（REDO）：正向扫描日志文件，查找应该重做的事务，查找这些事务的更新操作，对更新操作作重做处理（重新插入、重新删除、重新修改），如此正向扫描直到日志文件的尾部。 UNDO日志 内容（记录格式）： 开始一个事务：&lt;Start T&gt; 提交事务T：&lt;Commit T&gt; 放弃事务T：&lt;Abort T&gt; 更新记录：&lt;T,X,V&gt;（事务T修改了数据库元素X的值，X的旧值是V） 记载规则：（更新前提交后） $U_1$：如果事务T修改了数据库元素X，则更新日志&lt;T,X,V&gt;必须在X的新值写到磁盘前写到磁盘 $U_2$：如果事务T提交，则日志记录&lt;Commit T&gt;必须在事务T改变的所有DB元素已写到磁盘后再写到磁盘（之后还要FLush一次确保事务T被提交 作用：用于被放弃事务（包括发生在故障时上位结束的事务）的撤销工作 基于UNDO日志的故障恢复流程 将所有事务划分为两种类型：已提交事务（有&lt;Start T&gt;和&lt;Commit T&gt;），未提交事务（有Start无Commit） 从undo日志的尾部开始（最晚的）向后（向头部）开始扫描整个日志，对每一条更新记录&lt;T,X,V&gt;作如下处理： 如果&lt;Commit T&gt;已被扫描到，则继续扫描下一条日志记录（基于规则U2） 否则，由恢复管理器将数据库中X的值改为V（基于规则U1） 在日志的尾部为每个未结束的事务T写入一条日志记录&lt;Abort T&gt;，并刷新日志（Flush Log) 不足：将事务改变的所有数据写到磁盘前不能提交该事务，会导致在事务的提交过程中需要执行许多写磁盘操作，从而增加了事务提交的时间开销 REDO日志 内容（记录格式）：同undo，唯一的区别是在&lt;T,X,V&gt;中记载的是更新后的值 记载规则：（更新前提交前） $R_1$：在由于某个事务T所做的改变而修改磁盘上的数据库元素X之前，要保证所有与X这一修改有关的日志记录（包括更新记录和提交记录）都必须出现在磁盘上。（事务提交(Commit)和写数据库磁盘(Output)的操作顺序是随机的） 作用：用于已提交事务的重做工作 基于REDO日志的故障恢复流程 先扫描一遍日志文件，确定所有已提交的事务 从日志文件的头部开始扫描日志，对遇到的每一条更新记录&lt;T,X,V&gt; 如果T是未提交事务，则继续扫描日志 如果T是已提交的事务，则为数据库元素X写入新值V 对每个未完成的事务T，在日志的尾部写入结束标志&lt;Abort T&gt;并刷新日志 不足：要求事务提交和日志记录刷新之前所有修改过的数据保留在内存缓冲区中，可能增加事务需要的平均缓冲区数量 UNDO和REDO的不足：如果被访问的数据对象X不是完整的数据块，那么在Undo日志和Redo日志之间可能产生相互矛盾的请求。 UNDO/REDO日志 内容（记录格式）：与undo或redo的公式基本一样，区别在于更新记录&lt;T,X,v,w&gt;，v为更新前的值，w为更新后的值。 记载规则：（更新前） $UR_1$：在事务T修改磁盘上的数据库元素X之前，更新记录&lt;T,X,v,w&gt;必须出现在磁盘上。（事务提交(Commit)和写数据库磁盘(Output)的操作顺序是随机的） 为了确保在日志中写入&lt;Commit T&gt;记录的事务T确实被提交，在每一条&lt;Commit T&gt;后面必须紧跟一条Flush Log操作。 作用：解决UNDO和REDO日志的矛盾 基于UNDO/REDO日志的故障恢复流程 根据&lt;Commit T&gt;是否已经出现在磁盘中来决定事务Ｔ是否已经被提交 按照从后往前的顺序，撤销所有未提交的事务 按照从前往后的顺序，重做所有已提交的事务 UNDO/REDO日志的优点与缺点：优点没写，缺点见上 恢复策略 小型故障：利用未结束事务的undo操作进行恢复 中型故障： 非正常中止事务：执行undo操作 已完成提交的事务：其更新操作的修改结果还留在内存缓冲区中，尚未来得及写入磁盘，由于故障使内存缓冲区中的数据被丢失，故执行redo操作 大型故障：先利用后备副本进行数据库恢复，再利用日志进行数据库的恢复。具体步骤如下—— 将后备副本中的数据拷贝到数据库中 检查日志文件：确定哪些事务已经执行结束，哪些尚未结束 按照日志的记载顺序：逆向：对尚未结束的事务作撤消处理(undo)；正向：对已经结束的事务作重做处理(redo) Ch6-7 数据交换与存储题目是自己xjb起的 游标管理 游标的作用：将SQL变量中的集合型变量逐个取出后送入应用程序（标量型）变量内供其使用 定义游标 为某一个映像语句（可能返回多个结果元组）的结果集合定义一个命名的游标12345678910EXEC SQL DECLARE cursor-name CURSOR FOR subquery [ORDER BY ...] [FOR &#123;READ ONLY | UPDATE[OF columnname ...]&#125;];-- e.g.EXEC SQL DECLARE agent_dollars CURSOR FOR SELECT aid, SUM(dollars) FROM orders WHERE cid = :cust_id --主语言变量 GROUP BY aid; 如果一条查询语句的执行返回多条结果元组，那么必须使用游标来获取结果集合中的每一个结果元组 仅当用户确信只可能返回单个结果元组的情况下才可以使用SELECT... INTO...形式的嵌入式SQL查询语句 打开游标 执行相应的映像语句并打开获得结果集，此时游标处于活动状态并指向结果集合的第一条记录的前面1EXEC SQL OPEN agent_dollars 使用游标 将游标推向结果集合中的下一条记录，读出游标所指向记录的值并赋给对应的主语言变量 fetch the result rows1234while(TRUE)&#123; -- loop to fetch rows exec sql fetch agent_dollars into :agent_id, :dollar_sum; printf(&quot;%s %11.2f\\n&quot;, agent_id, dollar_sum)l&#125; end fetch loop12345678exec sql whenever not found goto finish;-- 声明&#x27;not found’事件处理...while(TRUE) &#123; exec sql fetch ... into ...; ...&#125;finish: exec sql close agent_dollars; 关闭游标 关闭所使用的游标，释放相关的系统资源1EXEC SQL CLOSE agent_dollars; 游标一旦被定义(declare)，可以被重新使用(open-fetch-close)。每一次open一个游标，都将重新执行对应的query，并生成新的结果集。 一个游标结果集只能被比那里一次，其中的结果元组被fetch的顺序是随机的（如果游标定义中无order by子句） 应用程序可以通过“游标状态变量”来了解一个游标的当前状态（是否处于打开状态、结果元组的个数、是否fetch到结果元组…..) 可滚动游标的定义及其在数据更新命令中的使用 定义123456EXEC SQL DECLARE cursor_name [INSENSITIVE] [SCROLL] CURSOR [WITH HOLD] FOR subquery &#123;UNION subquery&#125; [ORDER BY] [FOR READ ONLY | FOR UPDATE OF columnname]; Fetch by scrollable Cursors123EXEC SQL FETCH [&#123;NEXT | PRIOR | FIRST | LAST | &#123;ABSOLUTE | RELATIVE&#125; value_spec&#125; FROM]cursor_name INTO ... B+索引 数据结构 叶节点构成的最下面的一级索引通常采用稠密索引，其他层次上的索引采用稀疏索引 特点：平衡性，过半性，顺序性，自适应性 结点：每个结点占用一个磁盘块，每棵B+树都有一个被称为秩的整型参数$n$。每个结点能容纳$n$个键和$n+1$个指针，将$n$取得尽可能大。 搜索算法 CH8 关系数据库规范化理论概述 模式设计质量的评价指标：数据冗余度、插入/删除等更新异常 好的设计方案：既具有合理的数据冗余度，又没有插入和删除等操作异常现象 关系的规范化：在每个关系中，属性与属性之间的语义联系（函数依赖、多值依赖）需要满足一定的要求 范式：范式(Normal Form)：对一个关系中允许存在的依赖的要求 规范化的途径：将一个关系分解形成多个子关系，在模式设计中，用分解后的这一组子关系代替原来的单个关系。 竖向规范化：关系模式的分解。采用投影和联接运算，将一个关系模式的属性集分解构成若干个子关系模式。有关理论构成了关系数据库的规范化理论。 水平规范化：采用选择和并运算，将一个关系的元组集合分解成若干个子集，从而构成若干个与原来关系具有相同关系模式的子关系，尚未形成一个成熟的规范化理论。 规范化的目的：降低数据冗余度，消除插入、删除及修改异常 规范化的手段：模式分解 规范化理论规范化途径（不在考纲里） 将一个关系分解成多个子关系，用分解后的这一组子关系代替原来的单个关系。 竖向规范化 关系模式的分解 投影和联接 将一个关系模式的属性集分解构成若干个子关系模式 水平规范化 元组集合的分解 选择和并 函数依赖（FD） 定义：一个关系中两组属性之间的某种取值约束，简称FD $X\\to Y$: X函数决定Ｙ, Y函数依赖于X，关系$R$满足函数依赖$X\\to Y$ 即关系$R$中，每一个X值都有唯一的一个Y值与之相对应 $X$: 决定因素， $Y$: 依赖因素 符号说明（不在考纲里） $ABC={A,B,C}$, ABC三个属性构成的集合 $XY=X\\cup Y$， X,Y是关系的属性子集 $R(U,F)$： 关系名R，关系中的属性集合U，函数依赖集F $r,s,t$: 关系实例 $r_1,s_1,t_1$: 关系中的元组 $r_1(A)$: 元组$r_1$在属性$A$上的取值 如何寻找函数依赖 语义联系 根据具体数据否定函数依赖 根据两组属性间的对应关系（一一对应和多一对应 分析数据完整性的约束条件 一些定义（非）平凡函数依赖：$X\\to Y$若满足$Y\\not\\subseteq X$，则称此函数依赖是非平凡函数依赖。否则是平凡函数依赖。提到函数依赖时默认非平凡。完全函数依赖: $X\\to Y$，且对$X$的任意真子集$X’$都有$X’\\not\\to Y$，则称$Y$完全依赖于$X$，记为$X\\overset{f}{\\to}Y$.部分函数依赖: $X\\to Y$且$Y$不完全依赖于$X$，记作$X\\overset{p}{\\to} Y$传递函数依赖: $X\\to Y, Y\\not\\subset X, Y\\not\\to X, Y\\to Z$, 则称$Z$传递函数依赖于$X$; 否则称为非传递函数依赖。 Armstrong公理系统 $R_1$自反规则：若$Y\\subseteq X$, 则$X\\to Y$ $R_2$增广规则：若$X\\to Y$, 则$XZ\\to YZ$ $R_3$传递规则：若$X\\to Y, Y\\to Z$, 则$X\\to Z$ $R_4$分解规则：若$X\\to YZ$, 则$X\\to Y$且$X\\to Z$ $R_5$合并规则：若$X\\to Y$且$X\\to Z$, 则$X\\to YZ$ $R_6$伪传递规则: 若$X\\to Y$且$WY\\to Z$, 则$WX\\to Z$ 数理逻辑复习： $F$逻辑蕴含$X\\to Y$($F\\models X\\to Y$)：能从$F$的已有函数依赖推导出$X\\to Y$ 闭包$F^+$: 被$F$逻辑蕴涵的所有函数依赖构成的集合 基于函数依赖的关键字定义关键字: 在关系模式$R(U,F)$中，如有$K\\subseteq U$且满足$K\\overset{f}{\\to}U$，则称$K$为关系$R$的关键字。关键字可能不唯一。 主属性集: 由关系模式$R$的所有关键字中的属性所构成的集合。（所有关键字集合的并）主属性: 主属性集中的属性非主属性集: 主属性的补集 寻找关键字（不在考纲里） 方法一：用Armstrong公理系统推导 方法二：运用属性集闭包的概念，寻找满足条件($K_F^+=U$)的最小属性集合$K$ 优点：有算法支持 缺点：计算工作量大 方法三：运用最小函数依赖集来优化方法二中的关键字计算算法 属性集闭包：$X_F^+={A\\mid F\\models X\\to A }$，可以简写为$X^+$。所有函数依赖于$X$的属性所构成的集合。 算法8-1：计算属性集$X$在函数依赖集$F$上的闭包：输入：函数依赖集$F$，属性集$X$输出：闭包$X_F^+$ $X^+=X$repeat:&nbsp;&nbsp;&nbsp;&nbsp; old$X^+ := X^+$&nbsp;&nbsp;&nbsp;&nbsp; for each functional dependency $Y\\to Z$ in $F$ do&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if $Y\\subseteq X^+$ then $X^+=X^+\\cup Z$until(old$X^+=X^+$) 一言以蔽之：不断拉新的属性进来知道没有可拉的 若$K$是关系模式$R(U)$的一个关键字，则 $K_F^+=U$ 对于$K$的任意一个真子集都有$Z_F^+\\neq U$(可以用来验证公理推导的结果) 可以用来验证某个集合是不是关键字 算法8-2：寻找关系模式$R(U,F)$的关键字$K$set $K:=U$for each attribute $A$ in $K$:&nbsp;&nbsp;&nbsp;&nbsp; if $(K-A)_F^+ = U$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then set $K:= K-A$return $K$ 一言以蔽之：遍历每个属性，如果删不删都一样就删掉注意：根据遍历属性的顺序不同，得到的关键字不唯一 关键字计算优化算法$F$是最小函数依赖集，可以将属性集$U$划分为三个子集 $U_L$: 只在函数依赖的左边出现 $U_R$: 只在函数依赖的右边出现 $U_A$: 在两边都出现过 其中， $U_L$中的属性是每一个关键字的组成部分 $U_R$中的属性不可能出现在任何一个关键字中 关键字计算只需要遍历$U_A$中的属性 与函数依赖有关的范式 第一范式(1NF)：如果关系模式$R(U)$中的每个属性值都是一个不可分割的数据量，则称该关系模式满足第一范式，记为$R\\in 1\\text{NF}$ 关系模式的基础，每个关系都必须满足$1\\text{NF}$ 可能有数据冗余，会产生更新异常 第二范式（2NF）: 设有关系模式 $R(U)\\in 1\\text{NF}$，且其每个非主属性都完全函数依赖于关键字，则称关系模式$R(U)$满足第二范式，并记作：$R\\in 2\\text{NF}$ 找到关系$R$的所有非主属性和所有的候选关键字（注意不唯一） 检查每一个非主属性和每一个候选关键字之间的函数依赖，判断是否存在“非主属性对关键字的部分函数依冗余 满足2NF仍可能有数据冗余，因为可能存在非主属性对关键字的传递函数依赖。 第三范式（3NF）：设有关系模式 $R(U)\\in 2\\text{NF}$，且其每个非主属性都不传递函数依赖于关键字，则称关系模式$R(U)$满足第三范式，并记作：$R\\in 3\\text{NF}$ 存在函数依赖$X\\to Y$，其中$X$是关键字的真子集（不是2NF）或$X$不是关键字。 BCNF: 设关系模式$R(U)$满足1NF，且若 $X\\to Y$时$X$必含有该关系模式的关键字，则称关系模式$R(U)$满足BCNF范式，并记作$R\\in \\text{BCNF}$ 如果关系模式$R(U)\\in\\text{BCNF}$, 则$R(U)\\in 3\\text{NF}$，反之不成立。 各级范式与数据冗余度、插入删除异常的关系（见上） 1NF，2NF：有异常有冗余 3NF：无异常，小冗余 模式分解 （不在考纲里但我觉得会考）目标：每个小的关系模式都能够满足2NF（更高要求的范式）的要求，消除因非主属性关键字对关键字的部分函数依赖而产生的数据冗余 模式分解方法（对所有NF都适用） 找出所有不满足范式$M$要求的函数依赖关系 选择一个不符合要求的函数依赖关系作如下分解：假设$X\\overset{f}{\\to}Y\\in F^+$且不满足范式$M$的要求，则我们将关系模式$R$分解为如下两个子关系： $R_1(X\\cup Y, {X\\to Y})$ $R_2(Head(R)-Y, F_2)$, 其中：$F_2={A\\to B\\mid A\\to B\\in F^+ \\text{ and }(A\\cup B)\\subseteq Head(R_2) }$ 一言以蔽之：$Y$跟着$X$跑了，$Head(R)$就把$Y$给T了（$X$没T） 对于分解得到的子关系模式$R_2$重复上述步骤1和2，直到所有的子关系模式都能满足范式$M$的要求 合并那些具有相同关键字的子关系模式 多值依赖与第四范式 多值依赖(multivalued dependency, 简称MVD) 对$X,Y\\subseteq U$，对$X$的一个确定值，存在$Y$的一组值与之对应；且$Y$的这组值又与关系中的其他属性$(U-X-Y)$的取值不相关，此时称$Y$多值依赖于$X$，并记为$X\\to\\to Y$。（“不相关”可以理解为两个属之间构成完全二部图的交叉关系） e.g. 一门课有多个任课老师，又有多本参考书，任课老师和参考书不相关 产生原因：存在两个相互独立的 属性间的一对多数量对应关系，合并起来就会产生多值依赖 会造成大量数据冗余 平凡多值依赖：$U-X-Y$是空集 非平凡多值依赖：$U-X-Y$不是空集 多值依赖与函数依赖的关系（性质） 若$X\\to\\to Y$，则必有$X\\to\\to (U-X-Y)$（非平凡函数依赖总是成对出现的） 若$X\\to Y$, 则必有$X\\to\\to Y$（函数依赖也是一种多值依赖，反之未必) 第四范式 在关系模式$R(U)$中，若$X\\to\\to Y$是非平凡多值依赖，则$X$必含有关键字，此时称关系模式$R$满足第四范式，并记作$R\\in 4\\text{NF}$ 函数依赖要满足$\\text{BCNF}$ 不是FD的多值依赖一定是平凡的 推导规则（不在考纲里） $IR_1$自反规则：同$R_1$ $IR_2$增广规则：同$R_2$ $IR_3$传递规则：同$R_3$ $IR_4$求补规则：若$X\\to\\to Y$, 则$X\\to\\to (U-X-Y)$ $IR_5$多值依赖的增广规则：若$X\\to\\to Y$且$W\\subseteq Z$，则$WX\\to\\to YZ$ $IR_6$多值依赖的传递规则：若$X\\to\\to Y, Y\\to\\to Z$，则$X\\to\\to (Z-Y)$ $IR_7$转换规则：若$X\\to Y$，则$X\\to\\to Y$ $IR_8$结合规则：若$X\\to\\to Y$，且存在另一个属性结合$W$满足：$W\\cap Y=\\emptyset, W\\to Z, Z\\subseteq Y$，则$X\\to Z$ 规范化所引起的一些问题 函数依赖的蕴含 设$F$是关系模式$R(U)$的一个函数依赖集，$X$, $Y$是关系模式$R$的属性子集，如果从$F$中的已有函数依赖关系利用Armstrong公理系统能够推出$X\\rightarrow Y$，则称$F$逻辑蕴涵$X\\rightarrow Y$，并记为：$F\\models X\\rightarrow Y$。 函数依赖集的等价 若两个函数依赖集的闭包是相等的，则这两个函数依赖集是等价的 如果其中任何一个函数依赖集中的每一个函数依赖都被另一个所蕴涵，则两个函数依赖集是等价的 函数依赖的闭包：由被$F$逻辑蕴涵的所有函数依赖关系构成的集合被称为函数依赖集$F$的闭包，并记为$F^+$，有$F^+={X\\rightarrow Y │ F\\models X\\rightarrow Y }$。 最小函数依赖集及其判定条件 最小函数依赖集 $F$的最小函数依赖集： 与$F$的相等价的所有函数依赖集中的最小者 判定条件：对于$F$中的每一个FD关系$X\\to A$均作如下判断： 依赖因素$A$为单个属性（非必需） 令$F_1=F-{X\\to A}$, 则$F_1^+\\neq F^+$(不存在冗余的函数依赖) 对于决定因素$X$的每一个真子集$Y$($Y\\subset X$)均作判断：令$F_2=F-{X\\to A}\\cup{Y\\to A}$, 则$F_2^+\\neq F^+$(不存在部分函数依赖) 算法8-3：寻找与函数依赖集$F$等价的最小函数依赖集$G$任务： 消除$F$中的部分函数依赖 消除冗余的函数依赖 懒得打字了 输入：函数依赖集$F$输出：与$F$等价的最小函数依赖集 一言以蔽之：先删部分FD，再删冗余FD； P.S.要证明两个只差一个函数依赖的集合的闭包相等，只需要证明互相蕴含自己不包含的那个函数依赖 最小依赖集可能不唯一，只需要计算一个(而函数依赖要写全) 模式分解的研究 无损联接性 分解后，原关系中的信息不会丢失 设$R$是一个关系模式，$F$是关系模式上$R$的函数依赖集，$\\rho = { R1, R_2, …, R_k }$ 是对$R$的一个分解。如果对$R$中满足$F$的每一个关系实例$r$都有：$$r=\\pi{R1}(r)\\Join \\pi{R2}(r)\\Join \\cdots\\Join\\pi{R_k}(r)$$,则称该分解$\\rho$相对于$F$是“无损联接分解”，或称分解$\\rho$具有无损联接性 判定定理: 如果$R$的分解为$\\rho={R_1, R_2}$，$F$为$R$所满足的函数依赖集合，分解$\\rho$具有无损联接性的充要条件是$R_1\\cap R_2\\to(R_1-R_2)$或$R_1\\cap R_2\\to (R_2-R_1)$（公共部分可以推出剩余部分） 依赖保持性 原有的函数依赖关系在分解后的关系模式上依然存在 判定方法：设$F$是属性集$U$上的函数依赖集，$Z$是$U$的一个子集，$F$在$Z$上的投影用$\\piZ(F)$表示：$$\\pi{Z}(F)={X\\to Y\\mid X\\to Y\\wedge (X\\cap Y)\\subseteq Z }.设存在关系模式$R$的一个分解$\\rho = \\{ R_1, R_2, …, R_k \\}$,$F$是$R$上的函数依赖集，如果F^+=(\\pi{R_1}(F)\\cup\\pi{R2}(F)\\cup\\cdots\\cup\\pi{R_k}(F))^+$$,则称分解$\\rho$具有依赖保持性 一言以蔽之：（分解后的所有函数依赖并起来和原来的函数依赖等价） 在必须同时满足无损联接性和依赖保持性的要求下，一个关系模式最高可以被分解到满足第三范式 算法8-4：把关系模式分解到满足第三范式并满足无损联接性和依赖保持性 计算$F$的最小函数依赖集，并用来代替$F$进行下面的模式分解; $S=\\emptyset$ 对 F 中的每一个函数依赖$X\\to Y$做如下处理： 如果在集合$S$中找不到满足下述条件的子关系模式$Z$：X\\cup Y\\subseteq Z 则由$X$和$Y$构成一个新的子关系加入到集合$S$中，即$S=S\\cup \\text{Heading}(X\\cup Y)$ 如果关系$R$的每一个候选关键字$K$都没有出现在分解后的子关系模式中，即：找不到一个关键字$K$和一个子关系模式$Z$，他们之间满足$K\\subseteq Z$, 那么，就从关系R中任选一个候选关键字$K$, 由$K$中的属性单独构成一个子关系模式并加入到集合$S$中去，即：$S=S\\cup\\text{Heading}(K)$ 一言以蔽之：先把所有函数依赖的Headings都组起来，然后把关键字补上去 Ch9 数据库设计9.1 数据库设计概述 数据库设计的基本任务 根据用户对象的信息需求（用户的数据、结构及其要求）、处理需求（用户对数据的处理过程和方式）和数据库的支持环境（包括硬件、操作系统与DBMS）设计出数据模式。 数据库的生命周期：需求分析$\\rightarrow$概念设计$\\rightarrow$逻辑设计$\\rightarrow$物理设计$\\rightarrow$编码$\\rightarrow$测试$\\rightarrow$运行$\\rightarrow$进一步修改（前四个为数据库设计的四个阶段） 9.2 数据库设计的需求分析 需求说明书：从调查用户单位着手，深入了解用户单位的数据流程、数据使用情况，数据的数量、流量、流向、性质，并作出分析，确定需要在数据库保存其信息的客观事物（things）及其相互关系（relationship），最终按一定规范要求以文档形式写出数据的需求说明书。 三个角度 Things Attributses of Things Relationships among Things 9.3 数据库的概念设计 数据库概念设计的过程 用户分解：首先将所有用户划分为功能相对独立的若干个用户组，然后针对每个用户组进行视图设计。 视图设计：针对每个用户组设计其数据视图，以反映该组用户对于数据的需求。 视图集成：将设计好的若干个局部数据视图集成为一个完整的全局数据视图。 等同：两个或多个数据对象具有相同的语义 聚合：数据对象之间的一种组成关系（属性聚合成实体，属性和实体聚合成新的实体） 抽取：将不同实体中的相同属性提取成一个新的实体，并构造成具有集成关系的结构 命名冲突（同义异名，同名异义）$\\rightarrow$重命名 概念冲突（同一概念在一处为实体，而在另一处则为属性或联系）$\\rightarrow$统一为同一个概念（一般为实体） 域冲突（类型冲突、度量单位冲突）$\\rightarrow$统一 “数据类型” 和 “度量单位” 约束冲突$\\rightarrow$统一数据约束，或者如果不同数据约束的语义之间有包含关系，可以尝试构建具有‘父子’关系的继承层次结构，子类可以有比父类更严格的数据约束。或构建不同的实体集。 E-R模型与扩充E-R模型的设计：见第二章 9.4 数据库的逻辑设计 从E-R模型和EE-R模型向关系模型的转换 （此处建议看原ppt/gtmd直接做） 基本方法：每个实体集$\\to$一个关系模式；每个联系$\\to$一个关系模式 实体集的转换方法（规则R1）：每个实体集被转换成一个关系（模式），关系及其属性的命名采用原实体集及其属性的名称。 联系的转换方法（规则R2）：在一般情况下，每个联系也被转换成一个关系模式，联系名被用作转换得到的关系模式的关系名。来自于相关实体集的标识属性也是相关实体集转换得到的关系模式的主关键字，因此它们也是联系转换得到的关系模式中的外关键字。 命名与属性域的处理 关系及属性的命名：尽量采用在EE-R模型中原有的名称；可以重新命名，但要避免命名的冲突现象。 属性域的定义：根据DBMS的选型进行必要的数据类型转换 非原子属性的处理 集合属性的处理（规则R1.1）：关系模式不变，但原有关系的一个元组将被纵向展开成多个元组。转换得到的关系模式的主关键字由原实体集的标识属性和该集合属性联合构成。例如张三一个人选修了3门课就拆成3个元组。 元组属性的处理（规则R1.2）：将一个元组属性横向展开成多个属性。如实体集‘圆’有三个属性：圆标识符，圆心和半径，而圆心又由其X坐标轴和Y坐标轴的值组成。转换得到的关系模式即为（圆标识符，X轴，Y轴，半径） 联系的转换 全参与：如果$E_1$中的每个实体都与$E_2$中的某些实体有关联；否则是非全参与 1:1二元关系 若$E_1$和$E_2$都是非全参与 可以转化为三个关系模式： $E_1(k_1,a)$（关键字为$k_1$） $E_2(k_2,b)$（关键字为$k_2$） $R(k_1,k_2,r)$（关键字为$k_1$或$k_2$） + **若$E_1$全参与，$E_2$非全参与** 可以转化为两个关系模式： $E_1(k_1,a,k_2,r)$（关键字为$k_1$，外键为$k_2$） $E_2(k_2,b)$（关键字为$k_2$） + **若$E_1$和$E_2$都是全参与** 可以转化为一个关系模式： $E(k_1,a,k_2,b,r)$（$k_1, k_2$是两个候选关键字） 1:n二元关系 若多端$E_2$是全参与 可以转化为两个关系模式： $E_1(k_1,a)$（关键字为$k_1$） $E_2(k_2,b,k_1,r)$（关键字为$k_2$，外键为$k_1$） 若多端$E_2$是非全参与 可以转化为三个关系模式： $E_1(k_1,a)$（关键字为$k_1$） $E_2(k_2,b)$（关键字为$k_2$） $R(k_2,k_1,r)$（关键字为$k_2$，外键为$k_1$） m:n二元关系 可以转化为三个关系模式： $E_1(k_1,a)$（关键字为$k_1$） $E_2(k_2,b)$（关键字为$k_2$） $R(k_1,k_2,r)$（关键字为$(k_1,k_2)$，两者都为外键） 单个实体集内部的联系 将该联系转换成两个实体集之间的二元联系，再按照二元联系的处理方式转换成关系模式将两个实体集转换得到的关系模式合并为一个关系。 1:1联系可合并为$E(k,a,k’,r)$ 1:n联系可合并为$E(k,a,k’,r)$ m:n联系可合并为$E(k,a)$, $R(k_1,k_2,r)$ 继承的转换 若$E1,E_2$继承于$S$，$S$的属性有$(k,A_1,A_2,\\dots,A_n)$，其中$k$为标识属性；实体集$E_1$的属性有$(B{11},B{12},\\dots,B{1i})$，实体集$E2$的属性有$(B{21},B{22},\\dots,B{2j})$。有三种转换方式： 每一个实体集都将被转换为一个关系： $S(k,A1,A_2,\\dots,A_n)$ $E_1(k,B{11},B{12},\\dots,B{1i})$ $E2(k,B{21},B{22},\\dots,B{2j})$ 只有最底层的叶子结点才会被转换为关系，并从其所有超实体集中继承属性： $E1(k,A_1,A_2,\\dots,A_n,B{11},B{12},\\dots,B{1i})$ $E2(k,A_1,A_2,\\dots,A_n,B{21},B{22},\\dots,B{2j})$ 被转换为单个关系，其中含有所有实体集中的属性： $E1(k,A_1,A_2,\\dots,A_n,B{11},B{12},\\dots,B{1i},B{21},B{22},\\dots,B_{2j})$ 对转换得到的关系模式进行规范化设计（见Ch8）——到3NF 根据给定的数据完整性约束发现函数依赖（最小函数依赖集） 关键字的计算 范式的判断及分解9.5 数据库的物理设计 设计目标：对数据库内部物理结构作调整并选择合理的存取路径，以提高数据库访问速度及有效利用存储空间。 索引设计的作用及设计策略 在主关键字及外关键字上建立索引：提高关系联接查询的速度，有利于实体完整性及引用完整性的检查。 以读为主的关系应尽可能多地建立索引 如果根据某属性的等值查询所得到的结果元组数量较少，则可以考虑对该属性建立索引 对经常用于统计查询的属性建立索引：可以根据索引数据直接获取统计结果，不必再去访问对应关系的数据块。","categories":[],"tags":[]},{"title":"论文阅读笔记","slug":"paper-reading","date":"2019-07-20T08:55:11.000Z","updated":"2019-11-15T12:23:07.081Z","comments":true,"path":"2019/07/20/paper-reading/","link":"","permalink":"https://mengzelev.github.io/2019/07/20/paper-reading/","excerpt":"","text":"阅读一些论文的收获整理，全是私货(雾) A Large-Scale Empirical Study of Compile Errors in Continuous Integration这篇论文通过整理并筛选了github上的使用了一个名叫Travis CI的java项目，统计CI历史中出现的CE与各项因素的关系主要遵循了采集数据-分析数据-发现联系-提出解释-给出建议的思路整个项目的build分为多个过程，build的状态有success, error, fail, canceled和started等，maven和gradle的error和fail分别出现在不同的步骤最后对developer,tool,researcher各自提出了自己的建议 频率分析分析了CE频率与项目性质、分支、代码类型(production code or test code)、build state、trgerring events之间的关系 分布分析作者使用了正则表达式匹配统计各种错误类型，并与google的结果进行了比较因素作用关系基本同上 fix effort分析通过分析CE出现到消失的时间来衡量fix某个CE所耗费的effort 排除掉了多错误CE，因为研究难度过大 排除掉了超过12个小时的fix，因为这可能跟程序员的个人生活安排有关设计到代码架构实现CE比个别地方写错的CE需要更多的时间fixgoogle的平均fix时长短一些，可能是因为google对fix时间有要求，而且还有数据集的区别 fix pattern分析人工分析 Programmers’ Build Errors: A Case Study(at Google)这篇论文研究了3个问题： 编译错误的频率 编译错误的原因 修复错误编译的时间 方法：一个parser，可以将报错分类 标准数据来源是build的log file计算了以下维度的数据： 编译次数 编译失败率：失败次数/总编译次数 编译错误类型 count-all:一次编译中出现的多个同类错误算多个 count-distinct:….算一个 但是错误出现的次数权重是不对等的(比如漏写一个声明会报一堆符号错误)，所以采用count-distinct比较合理 解决时间：第一次build fail结束到第一次build success开始之间的时间，同时记录了这期间build fail的次数 只考虑单错误的fail building 只考虑在12个小时内解决的错误 RQ1：错误频率把开发者按照经验分类进行了数据分析但是对经验程度的定义可能不够准确 RQ2：错误原因把各种编译错误分成了5个大类：Dependency, Type mismatch, Syntax, Semantic, Other对于C++和Java来说，Dependency-related error都是最常见的错误类型 RQ3：修复时间把研究对象限定为单一类型的错误信息，排除多错误修复时间带来的误差 进一步分析，还进行了case study首先随机选择了25个Java的cant.resolve类型的编译错误，这些错误都是在下一次build的时候就修复了的，对比了修复前后的文件来观察错误是如何被修复的，并将结果记入表格 How do fixes become bugs?Intro. 举例证明incorrect fix普遍存在性 提出了导致incorrect fix的三个可能原因 吹一下自己研究的重要性 Methodologysoftware projects under study四个OS(一个闭源商业OS，FreeBSD, OpenSolaris, Linux)选择stable&amp;widely deployed的series为了机密性把四个OSmap成了ABCD而不知道哪个是哪个 find incorrect fixesdef: introduce new problems or not completely fixedidentify bug fix: whether associatied with a bug report not always systematically maintained leverage the verbal info in bug reports oir cahnge logs to reconstruct the linkssemi-automatically check whether fixed correctly: automatically select potential incorrect fix candidates source code overlap between changes -&gt; the latter may be to correct the first(more comprehensive) search for words in bug report indicating incorrect fixes manually check each candidate(unique challenge) even discuss with developersmay prune a few incorrect fixes out, but rare target bugs to studySample set1: post-release bugsSample set2: fixes to memory leaks, buffer overflow, data race, deadlock bugs Measuring code knowledge略 Significance proportion of incorrect bug fixes(14.8%~24.4%) result what kinds of problems(crash, hang, data loss, …) Incorrect fix patterns concurrency bugs: hardest to fix data race -&gt; add locks -&gt; deadlock deadlock -&gt; new deadlock/hided bugs buffer overflow: use safe string function is safest, enlarged buffer may not solve, dynamic allocation introduces memory leaks memory leak -&gt; dangling pointer/null pointer dereference -&gt; good to nullify pointer after fix semantic bugs: conditions are difficult to fix","categories":[],"tags":[]},{"title":"Windows-Ubuntu双系统重装笔记","slug":"system-rebuild-notes","date":"2019-07-08T05:49:57.000Z","updated":"2019-07-08T07:04:40.002Z","comments":true,"path":"2019/07/08/system-rebuild-notes/","link":"","permalink":"https://mengzelev.github.io/2019/07/08/system-rebuild-notes/","excerpt":"","text":"之前Linux只给了20个G过于局促，Windows企图装WSL又出现了各种各样的问题，于是就脑子一发热把两个系统备份以后都重装了。期间查了很多教程，就统一汇总在这里了。 Windows重装 原来装的是win10家庭版，很多功能被阉割掉了，就决定重装学校买的win10教育版，几种版本的nb程度大概是教育版≈企业版&gt;专业版&gt;家庭版 如果是同一个版本内的重装，只需要到设置里找”重装windows”就可以了，甚至可以保留个人文件 下载windows的iso文件到U盘里(U盘不需要格式化)，解压，启动盘就做好了。因为现在的笔记本电脑基本都装有UEFI，可以自己选择启动方式，所以不需要再格式化做引导盘。 把原先C盘里的重要文件备份一下l电脑品牌的官网上去查找进入方式)，选择装了windows安装程序的U盘进入 接下来按照指示一步步做就可以了，需要注意的是如果是要重装系统，要选择“自定义安装”，然后选一个位置作为C盘安装windows 等20分钟左右系统就装好辣 进入windows后如果发现连不上wifi了/没有声音了，应该是相关驱动在格式化的时候被删掉了，只需要到电脑厂商的官网上下载对应型号的驱动程序就可以了 ps既然重装了windows，国产流氓软件例如3*0，驱动*灵就不要装了，我之前年少无知装了3*0卸载了几次都把自己给装回来了 Ubuntu重装与配置因为打算以后常驻Ubuntu了，而且可以个性化的内容也比较多，所以这边要配置的东西会相对多一些 重装首先要在磁盘上准备好一定的空间，Ubuntu比较小，往死里压的话20G都能装得下，但是后期使用会经常出现磁盘空间不足的问题（不要问我怎么知道的），所以这次我给了70G（磁盘总大小256G）到windows的“磁盘格式化与压缩”（我忘了是不是叫这个了，欢迎纠正）中选择一个可以压缩的磁盘，右击“压缩卷”，选择需要压缩的大小。如果需要压缩的空间比可压缩空间小还是失败的话应该是当前磁盘的碎片太多，建议备份以后格式化一下。注意： 双系统重装选手一定要先装Windows再装Ubuntu，不然windows的引导会覆盖掉Ubuntu的引导，产生不必要的麻烦 然后就只需要重启进入UEFI像重装windows一样操作即可从windows重启可能会出现进不了UEFI的情况，可能是windows快速启动优化导致的，解决方法是重启时按住shift键，会出现蓝色的屏幕，选择高级选项-&gt;进入UEFI Ubuntu的安装程序也比较亲民，基本按照指示做点Continue就可以，唯一的稍微有困难的地方是磁盘分区那里，我只提供一下我的分区方案做参考，不保证一定是最好的： biosgrub：200M,用于放置引导 swap：交换分区，我也不清楚这个是做什么的，看到网上不少地方说和内存差不多大就可以了，我的内存是8G，所以我给了10G 剩下的空间全都给根目录”/“，挂载方式选择ext4文件系统，挂载点选择”/“ 20分钟不到你就可以看到船新的Ubuntu了 安装软件拿到新系统第一件事是把基本的软件都装了Linux系统装软件都很方便，直接sudo apt install [软件名]就可以了一般必备的软件有：git, gcc, g++等，其他可以等用到了的时候再装，反正很方便 更换软件源在Ubuntu菜单里面找到”Software &amp; Updates”“Download from”下拉条里面选择”Other…”, 国家找到China，然后选择你要换的网址，我用的是阿里云的镜像确定并关闭之后应该会有更新提示，等就可以了 中文输入法由于我装的是英文系统，上百度搜教程非常不方便，所以第一件事是把中文输入法给装好Ubuntu自带的中文输入法iBus非常反人类，所以建议自己装中文输入法，我装的是搜狗拼音输入法for Linux 解决Ubuntu 18.04中文输入法的问题，安装搜狗拼音 chromeUbuntu自带的是Firefox浏览器，相比于IE来说也很好用了，但是舍不得chrome的同步功能所以还是决定用chrome 百度搜索chrome官网，下载.deb文件，完成后直接打开，Ubuntu的软件商店会跳出来，再点Install就可以了 小飞机要想登录google账号肯定需要科学上网 ubuntu配置小飞机 值得补充的是，如果从github上下载的SwitchyOmega的crx文件拖进chrome显示INVALID_CRX_HEADER，就把crx文件后缀直接改成zip，然后解压该zip文件，在chrome插件管理界面中打开开发者模式-&gt;导入(Load Unpacked)，选择一个名叫”SwitchyOmega_xxx”(xxx为版本号)的文件夹即可 QQ or TIMwszqkzqk/deepin-wine-ubuntu 美化用惯了windows的人表示想要一个好康的GUI环境，Ubuntu原生的有点太死板了 美化桌面环境需要先下载gnome-tweak-tools，不要问，问就是apt 更换主题到gnome-look.org上找喜欢的主题和icon主题就可以了我装的是排名最高的Flat Remix GNOME/Ubuntu/GDM theme安装方法里面都有写装完以后在菜单里面找Tweaks，在里面改Applications，icons等设置就可以了 gnome插件这次装机突然了解到一个很骚的直接在浏览器里管理gnome的插件的工具如何手动或通过浏览器轻松安装 GNOME Shell 扩展？ 我装的插件有 dash to dock(可以把任务栏一样的条拿到下面，还可以设置自动隐藏) Hide top bar(设置上面那条东西自动隐藏) User themes(让shell可以使用主题同样的风格) 字体Ubuntu本来的字体就还可以，不过我还是最喜欢苹果的monaco ubuntu16.04安装monaco字体 zshUbuntu默认的终端是bash，但是zsh比bash好看，而且插件也很丰富，所以我把默认终端换成zsh了 Ubuntu 16.04下安装zsh和oh-my-zsh 主题我用的是powerlevel9k值得提醒的是，改.zshrc之前一定要记得备份，我就把自己的zsh玩坏过还回不去orz vim和tmux我直接用了github上别人的配置文件，安装方法里面都有 gpakosz/.tmuxamix/vimrc 说实话我已经用惯了vscode基本不碰vim了(x)","categories":[],"tags":[]},{"title":"操作系统期末复习笔记","slug":"os-review","date":"2019-06-21T12:58:41.000Z","updated":"2019-06-23T03:37:40.845Z","comments":true,"path":"2019/06/21/os-review/","link":"","permalink":"https://mengzelev.github.io/2019/06/21/os-review/","excerpt":"","text":"这其实是jyy课程讲义摘抄 存储介质维度：价格、容量、速度、可靠性 持久化存储介质统称Non-Volatile Memory IO设备与驱动设备：三种操作（发送命令、读取状态、传输数据）的集合 管理IO设备查看系统IO设备：lspci,lsblk(实现： open(&quot;/sys/bus/pci&quot;)) Loop Back Device(回路设备)：把一个文件模拟成一个块设备a pseudo-device that makes a file accessible as a block device in Unix-like operating systems IO设备类型众多、访问模式差距很大解决：抽象层——设备驱动设备驱动：操作系统对设备进行的额外抽象，使得更上层的部分（通常是文件系统）能够以统一的接口访问这些设备，i.e.把文件API翻译成设备命令 设备驱动层帮助我们屏蔽了底层设备的具体实现细节 使得创建“虚拟”设备非常容易(/dev/random,/dev/null) I/O设备最主要的功能：input/output(read/write)还有一些设备相关设置(ioctl) DMA解决中断没能解决的问题一个完成CPU和设备之间数据传输的I/O设备这样CPU可以在传送数据时做别的事 文件系统概念存储设备虚拟化虚拟磁盘：一个可以读写的动态字节序列传统理解：文件系统是保存在持久存储上的数据结构(存储格式规范+允许的操作) 文件系统【以下是我能找到的所有描述】 存储设备的虚拟化机制 保存在持久存储上的数据结构 文件名到虚拟磁盘的映射 管理操作系统内部对象的中间层 连接应用程序与设备驱动的桥梁 管理操作系统中能够抽象成“虚拟磁盘”接口访问的任何数据 文件系统实现 = 数据结构的查询/修改操作文件：可读写的数据对象，相当于一个虚拟磁盘文件操作 打开（返回文件描述符），关闭 文件描述符操作：read,write,lseek,ioctl,mmap… 目录：文件和目录的集合目录操作 改变进程工作目录(没有/bin/cd) 目录解析 读取目录 目录操作：link,unlink,rename 文件系统设计文件（扩展）：操作系统中的一个可读/写/控制的对象文件描述符：指向操作系统对象的handle管理操作系统对象的本质：传递数据的需求 为什么/proc不是进程树？-方便根据pid查找进程 虚拟文件系统：把read/write翻译成对操作系统对象(进程线程、文件目录、设备等)的读写 文件系统API文件系统管理挂载：mount -t type device dir把一个设备和一个文件系统实现联系起来，在设备上创建一个文件系统实例，并且把创建的文件系统“放置”到文件系统中的一个路径里 chroot切换根目录只影响路径解析如果持有外部文件描述符很容易越狱 目录管理本质也是文件，只是操作系统在路径解析、目录遍历时对它的数据有特殊的解读 硬♂链接 目标只能是文件(不能是目录) 不能跨越文件系统 符号链接 目标可以是任何相对/绝对路径 只是一个路径解析提示 文件管理：打开文件打开目录：得到一个指向文件系统某个位置的指针 文件操作：文件描述符 避免每次操作都要重新打开文件 帮助我们自动管理文件访问的偏移量 文件系统的同步操作系统做了很多激进地缓存，所以多用sync 文件系统实现实现文件系统需要考虑以下因素 虚拟磁盘的数据结构（链表，树…） 目录文件的数据结构 inode的表示和存储 balloc/bfree的实现 块设备固定大小的block的数组在/sys/block里可以找到块设备API：进程/线程向存储设备提交I/O request, request首先进入设备队列，经过调度器调度后执行设备上的I/O操作系统不管Block I/O调度，只管进程尽可能公平地获得I/O操作和请求优化 虚拟磁盘数据结构：链表/树，提供balloc/bfree链表在文件小时表现较好，索引的lseek性能更好block bitmap(联系L3) 文件应该有 一个唯一的编号 元数据信息（类型，大小，权限，访问时间、链接数量、索引） 目录文件目录=文件名$\\to$文件id的映射 Inode的存储 存储方式 好处 坏处 在磁盘用单独区域统一存储和管理 查找快速（可以快速计算出inode在磁盘中的位置） 容易被破坏（备份）；浪费空间 存储在目录文件中（如FAT） 节约空间 不支持硬链接 存储在文件头部 容错性 评价文件系统 性能 存在超大文件、超大目录时各个操作的性能表现 在各种类型workload的读写（顺序/随机，读/写分布）、目录操作比例下的性能表现 多进程并发时的文件系统表现 可靠性 在系统可能意外崩溃时文件系统实现的正确性 在磁盘可能损坏的前提下文件系统的可靠性 FAT和ext2File Allocationg Table链表实现文件，为每个block维护一个next block文件分配表：集中存储next PBR(Partition Boot Record)：存储在分区头部 缺陷 读写序列不够连续 FAT容易被枪毙（一般都有两个备份） 文件系统可能碎片化（巨大的文件可能散落在磁盘的各个角落） 不支持链接只是因为手册里没写 FAT32最大文件只有4GB（因为是从小磁盘时代过来的） 磁盘碎片整理：使文件尽可能在磁盘中占有连续的块 ext2索引实现文件：混合多种存储方式inodes单独管理：支持硬链接inodes连续存储：提高文件访问的局部性相比于FAT空间浪费比较多 分组 分配分成了两级(组级、块级) 不用管理全局的bitmap 一定程度的性能优化 尽量把相近的文件分配在同一个组里 尽量把同一个文件的数据块分配在同一个组里 使磁盘大小容易动态调整 持久数据的可靠性RAID如何把虚拟磁盘映射到物理磁盘块 RAID-0没有冗余 方案1 Block 磁盘1 磁盘2 #0 0 3 #1 1 4 #2 2 5 方案2 Block 磁盘1 磁盘2 #0 0 1 #1 2 3 #2 4 5 方案一 方案二 顺序读写速度 1X 2X 随机读写速度 2X 2X 实际使用中对目录访问较多（顺序读写），方案2中磁盘2等于没有 毫无容错 RAID-1 镜像维护两块数据完全一样的磁盘实现容错 Block 磁盘1 磁盘2 #0 0 0 #1 1 1 #2 2 2 #3 3 3 RAID-4 Block 磁盘1 磁盘2 磁盘3 磁盘4 磁盘P #0 0 1 2 3 $0\\oplus1\\oplus2\\oplus3$ #1 4 5 6 7 $4\\oplus5\\oplus6\\oplus7$ #2 8 9 10 11 $8\\oplus9\\oplus10\\oplus11$ #3 12 13 14 15 $12\\oplus13\\oplus14\\oplus15$ 顺序读：4X 顺序写：4X 随机读：4X 随机写：X/2(校验盘是性能瓶颈) RAID-5RAID-4升级版 Block 磁盘1 磁盘2 磁盘3 磁盘4 磁盘P #0 0 1 2 3 P #1 4 5 6 P 7 #2 8 9 P 10 11 #3 12 P 13 14 15 随机写可以并发 带宽分析见OSTEP RAID硬件 缓冲&amp;日志 奇偶校验电池 保证数据写回 崩溃恢复与日志磁盘上的数据结构读磁盘的请求： 读一个已经写过的块，可以不从磁盘读取 读一个未被访问过的块，必须从磁盘读取（等待） 写磁盘的请求： 原则上可以无限排队，让磁盘的读请求先行 但同时最终应当被写入磁盘 原子性的丧失崩溃=缓存数据丢失 简单的workload: 追加写 $FAT[b’]\\leftarrow EOF$ $data[b’]\\leftarrow$ 数据 $FAT[f_{end}]\\leftarrow b’$ 一下考虑所有可能的崩溃情况 $FAT[b’]\\to$❌ (dead block/leak) $data[b’]\\to$❌ (random writes, 写到了没办法再读到的地方) $FAT[f{end}]\\to$❌ (corrupted FAT, inconsistency) $data[b’]\\to FAT[f_{end}]\\to$❌ (random writes + corrupted FAT) $FAT[b’]\\to data[b’]\\to$❌ (dead block * 2) $FAT[b’]\\to FAT[f_{end}]\\to$❌ (corrupted file, incorrect data) $FAT[f_end’]\\to FAT[b’]\\to data[b’]$ ✅ dead block不是个很大的问题所以$FAT[b’]\\to FAT[f_{end}]\\to data[b’]$是个相对可以接受的方案，但这只是追加写，一般情形就很困难了 文件系统一致性当磁盘上的数据结构不合法或不满足文件操作的语义，文件系统就处于不一致的状态，e.g. 链接成环 FAT指向未被分配数据块 两个文件的索引共享数据块 FSCKFile System Checking在崩溃后扫描磁盘进行补救 缺陷： 为了一点小事扫描整个磁盘，太花时间了 没人能证明这么做一定能回到一个一致的状态 fsck的时候也会崩溃 实现崩溃一致性Key idea: 使磁盘上的状态能推导出某个过去时刻的文件系统状态借助sync()保证数据写入磁盘后才返回 日志(Journaling)把操作以append only的方式记下来：写入TXbegin和数据→sync→写入TXEND→sync用一个额外的指针维护journal完成的时刻 崩溃恢复：从指针开始向后重做journal中记录的操作优化：合并log，只对metadata做journaling(但可能导致应用程序丢失数据) 期末复习I/O设备模型传输数据、发送命令、读取状态这三种操作的集合 设备驱动：操作系统对设备进行的额外抽象，使得更上层的程序能够以统一的接口访问这些设备 main函数之前的故事hello的第一条指令：ld.so的_start hello的main函数执行之前 加载器(ld.so)把hello进程的地址空间加载进来 加载器的_start加载libc到hello进程的地址空间 进入hello自己的_start, 调用__libc_start_main 线程安全的printf复习条件变量和信号量 文件系统的实现FAT 维护了（可能不止）一份文件分配表，记录每个文件中每一个block的下一个block的编号，位于文件系统头部、super block之后 block被称为sector的cluster 文件的元数据(inode)保存在目录项里，不支持链接，目录项按顺序存储在文件中 缺陷：lseek困难，FAT块容易被枪毙，文件系统碎片化 ext2 多级索引 inode单独管理，提高了文件访问的局部性 目录项顺序存储inode编号、该目录项长度、类型、文件名 分组：不用管理全局的bitmap，性能优化，简化磁盘大小动态调整 保护数据不受损害RAID RAID lv. 容量 容错 顺序读 顺序写 随机读 随机写 0 $n$ 0 $n$ $n$ $n$ $n$ 1 $n/2$ $1…n/2$ $&gt;n/2$ $n/2$ $n$ $n/2$ 4 $n-1$ 1 $n-1$ $n-1$ $n-1$ $1/2$ 5 $n-1$ 1 $n-1$ $n-1$ $n$ $n/4$ fsck崩溃之后的补救措施 扫描inodes里所有数据块，检查bitmap的一致性 检查inode数据是否看起来合法，否则删除 检查链接情况，没有链接的inode被移到lost+found目录 缺陷：没事儿就扫描整个磁盘开销太大；也不一定能把文件系统恢复成一致的状态；fsck的时候崩溃了就完蛋了 日志 记录所有操作 维护一个指针，指向已经完成的checkpoint 崩溃后从指针处开始重做所有操作，向后恢复 优化：批处理；metadata journaling","categories":[],"tags":[]},{"title":"OSTEP阅读笔记-持久化部分","slug":"OSTEP-persistence","date":"2019-06-21T02:23:27.000Z","updated":"2019-06-23T02:47:49.522Z","comments":true,"path":"2019/06/21/OSTEP-persistence/","link":"","permalink":"https://mengzelev.github.io/2019/06/21/OSTEP-persistence/","excerpt":"","text":"Ch36 IO设备典型设备协议设备的两个重要组成部分：硬件接口+内部结构 OS通过读写状态、命令和数据寄存器来控制设备行为 协议模型 1234567while(STATUS &#x3D;&#x3D; BUSY);&#x2F;&#x2F;wait until device is not busy(polling)write data to DATA reg;write cmd to cmd reg; (Doing so starts the device and executes the cmd)while(STATUS &#x3D;&#x3D; BUSY);&#x2F;&#x2F;wait until device is done with your request 缺陷：轮询浪费时间——用中断减少CPU浪费(概括一下：等待设备的时候去做别的事情) 使用中断还是轮询取决于设备的速度 DMA要传送数据的时候，OS告诉DMA数据在哪里、送多少、要送给谁，然后OS就可以去干别的事了，数据拷贝全部由DMA来完成 OS与设备的交互明确的I/O指令古代方法e.g. x86的in,out指令PA你都写过了都是特权指令，只有OS可以使用 内存映射现代方法但古代方法没有被抛弃 设备驱动by传统艺能：抽象设备驱动：OS中的某一块(piece)知道设备的工作细节的软件，封装了所有与设备的交互行为(原话：a piece of software in the OS must know in detail how a device works)但这样会使设备损失特殊功能(e.g SCSI有比ATA和IDE更丰富的error handling机制)OS里70%的代码都是设备驱动程序，而且因为设备驱动主要都是野鸡程序猿(相对于内核代码)写的，所以是贡献内核bug的中坚力量 Ch37 硬盘驱动虽然现代os会一次性往硬盘写很多数据，但是硬盘只保证一个sector(512字节)的写是原子的(要么写了要么没写) 物理构造盘片(platter)的两个面称为盘面(surface)，盘片装在转轴(spindle)上。数据按磁道(track)排列在盘片上，由磁头(disk head)读写。每个盘面都有一个磁头(disk head)。磁头长在磁臂(disk arm)上RPM(rotation per minute) 缓存(track buffer) 写判定 写回(write back): 把数据放入磁盘缓冲就算写完 直写(write through): 把数据写入磁盘后才算写完 下面都是磁盘读写调度我不看了啦 Ch38 RAIDsRedundant Arrays of Inexpensive Disks廉价磁盘冗余阵列RAID其实是一个firmware(编程硬件)，有自己的处理器、存储和磁盘 评价标准performance, capacity, reliability.其中performance有两个判定尺度：single-request latency(单操作延迟), steady-state throughput(稳态吞吐量, the total bandwidth of many concurrent requests) 故障模型(Fault Model)fail-stop磁盘只有两个状态：wording &amp; failed(永远没有了)，不考虑坏了半块这样的情况 RAID Level 0: Striping(串列)毫无冗余，虚假的RAID capacity: perfectreliability: any disk failure will lead to data lossperformance: excellent 【此处省略懒得截图的截图】stripe: 排在同一行的blockschunk size(组块大小): 连续分布在同一块磁盘上的数据大小chunk size对RAID的performance影响最大小的chunk size能提高连续读的并发性，但是延长了把block分配到不同磁盘的时间大的chunk size只有在读大文件时才能有较好的并发性，但缩短了分配时间chunk size的选择依赖于workload workload有两种：sequential和random RAID Level 1: Mirroring 图上那个又叫RAID-10 读：随机选一个写：两份都要写（并发） capacity: N块磁盘，容量N/2 reliability: 可以忍受单块磁盘爆炸(只要不是同一块磁盘的两个备份同时爆炸) performance: 读延迟：速度同读单块磁盘 写延迟：同时写两份（并发），与同时写单块相同。但写时间由两块中时间长的决定，因此比写单块会慢一丢丢 连续读：同随机写 连续写：最大带宽$(\\frac{N}{2}\\cdot S)$，峰值带宽的一半 随机读：满带宽$N\\cdot R$ MB/s 随机写：一半 多块磁盘的一致性维护刚决定写一块磁盘，另一块磁盘写不写还没确定，就断电了，这时另一块磁盘完全没被写，导致两块磁盘数据不一致。也就是说希望镜像的两块盘的写操作是原子的。解决：write-ahead log大多数磁盘都带有电池供电的小型非易失性RAM RAID Level 4: Saving Space With Parity用时间(performance)换空间(capacity) 给每个stripe加了一个parity check block(XOR)当一块盘坏掉时，我们需要读同一个stripe中其他所有盘的数据才能恢复出这块盘的数据 capacity： $N-1$ reliability: 能容忍每个stripe中有一块磁盘爆炸 performance 连续读：只有校验盘没有被占用，$(N-1)\\cdot S$ MB/s 连续写：full-stripe write很高效，因为写完一个stripe正好能写校验盘，$(N-1)\\cdot S$ MB/s 随机读：除了校验盘，$(N-1)\\cdot S$ MB/s 随机写：当修改了一块盘中的数据时，需要同时修改校验盘，这里有两种方法。一是additive parity，把同一个stripe中的块的数据全部读出来再算一遍校验位，然后并发地写入校验盘和数据盘，这种做法在RAID块比较多的时候会很慢；另一种是subtractive parity，从检验位中把原来的数据减去再加上新的数据，这种方法的瓶颈在于校验盘不能并发读写，带宽只有$R/2$ MB/s，即使加磁盘也不会加快。 读延迟：同读单块磁盘 写延迟：写单块时需要进行两次读和写(subtractive parity)，但读写都可以并发，因此写延迟为写单块磁盘的两倍（速度是一半） RAID Level 5： Rotating Parity 为了消除RAID-4校验盘的性能瓶颈 三围基本和RAID-4相同随机读的performance会好一些，因为所有的磁盘都被占用了随机写性能大大提升，因为写操作之间可以并发了。当有较大的随机写操作序列时，可以保证每块磁盘都能并发工作，但依然有2读2写，带宽是$\\frac{N}{4}\\cdot R$ MB/s.在市场上已经基本取代了RAID-4 Summary一张表格概括本章精髓 方案选择取决于实际使用，对reliability、顺序或随机读写的不同需求","categories":[],"tags":[]},{"title":"难问题求解学习笔记-随机算法","slug":"ps-4-13-Randomized-Algorithms","date":"2019-05-25T03:20:40.000Z","updated":"2019-06-19T12:33:02.918Z","comments":true,"path":"2019/05/25/ps-4-13-Randomized-Algorithms/","link":"","permalink":"https://mengzelev.github.io/2019/05/25/ps-4-13-Randomized-Algorithms/","excerpt":"","text":"前言输出为随机变量的算法称为蒙特卡洛算法(Monte Carlo)输出总是正确的但时间复杂度为随机变量的算法称为拉斯维加斯算法(Las Vegas) 概率论理论引入了随机算法$A$与确定输入$x$构成的随机试验。试验可以被描述为概率空间$(S{A,x},Prob)$，其中$S{A,x}={C\\mid C \\text{is a computation (radom run) of } A \\text{ on } x}$，$Prob$是$S_{A,x}$上的概率分布。 基础一种新的复杂度度量$Random_A(x)$: 对于所有$A$在$x$上的随机计算中使用的random bits的最大数量$Random_A(n)=\\max{Random_A(x)\\mid x \\text{is a input of size }n}$ 这么衡量的两点原因 产生真随机数非常困难，且真随机序列越长越困难 如果一个算法的$Random_A(x)$是对数级的，那就可能可以在多项式时间内追踪它的所有运行的可能情况，做到去随机化(derandomization) $Prob_{A,x}(C)$: 某一次$A$对输入$x$的计算$C$, 由相应的随机序列的概率决定$Prob(A(x)=y)$: $A$ outputs $y$ for an input $x$的概率$Time(C)$: the time complexity of the run $C$ of $A$ on $x$ 期望时间复杂度of $A$ on $x$(expected time complexity) Exp-Time_A(x)=E[Time]=\\sum\\limits_{C}Prob_{A,x}(C)\\cdot Time(C)$A$的期望时间复杂度(worst case approach) Exp-TIme_A(n)=\\max\\{Exp-Time_A(x)\\mid x \\text{is an input of size } n\\}Time_A(x)=\\max\\{Time(C)\\mid C \\text{ is a run of} A \\text{on} x \\}Time_A(n)=\\max\\{Time_A(x)\\mid x \\text{ is an input of size }n\\}随机算法不一定会终止，可能会进行无限次计算，在实际情况下可以在某一时间后叫停，算法输出”?”，即无法在给定时间内解决该问题，然后重新开始 随机算法的分类拉斯维加斯算法拉斯维加斯算法与其时间复杂度有两种定义方式，适用于不同的场景 第一种定义若对问题$F$的任意输入实例$x$，$Prob(A(x)=F(x))=1$,其中$F(x)$是问题$F$对于输入$x$的解，则称$A$是计算问题$F$的拉斯维加斯算法。这种定义下时间复杂度是$Exp-Time_A(n)$ 第二种定义允许”?”输出若对问题$F$的任意输入实例$x$，$Prob(A(x)=F(x))\\ge\\frac{1}{2}$且$Prob(A(x)=”?”)=1-Prob(A(x)=F(x))\\le\\frac{1}{2}$.这种定义下时间复杂度采用$Time_A(n)$ 第一种定义一般用于计算函数，第二种一般用于计算decision problem 单边误差蒙特卡洛算法ONE-SIDED-ERROR MONTE CARLO ALGORITHMS $L$的单边蒙特卡洛算法满足 对任意$x\\in L, Prob(A(x)=1)\\ge 1/2$ 对任意$x\\notin L, Prob(A(x)=0)=1$ 重复次数越多，得到正确答案的可能性就越大 质数定理：集合${1,2,\\cdots,m}$中质数的个数大约是$m/\\ln m$，且当$m\\ge 100$时至少是$m/\\ln m$ 双边误差蒙特卡洛算法TWO-SIDED-ERROR MONTE CARLO ALGORITHMS 若存在实数$\\varepsilon, 0\\le\\varepsilon &lt;1/2$，满足对于$F$的任意输入$x, Prob(A(x)=F(x))\\ge\\frac{1}{2}+\\varepsilon$,则称该算法为$F$的双边蒙特卡洛算法 无限制误差蒙特卡洛算法UNBOUNDED-ERROR MONTE CARLO ALGORITHMS 若对于$F$的任意输入$x, Prob(A(x)=F(x))&gt;\\frac{1}{2}$，则称这样的算法$A$是无限制蒙特卡洛算法 随机最优化问题判定问题的随机算法是选择出现最多的答案，而最优化问题是选择最接近(根据cost function)的答案 随机近似算法随机算法可以看成是以高概率得到与最优解差别不大的解的近似算法 定义5.2.2.10：设$U=$(略)是一个最优化问题。对任意正实数$\\delta&gt;1$，随机算法$A$是$U$的随机$\\delta-$近似算法，若$A$满足以下要求 $Prob(A(x)=\\mathcal{M}(x))=1$且 $Prob(R_A(x)\\le\\delta)\\ge 1/2$ 对任意$x\\in L_I$ 类似可定义随机$f(n)-$近似算法 随机多项式近似方案(RPTAS) 还有随机 完全多项式近似方案(RFPTAS) $\\delta-$期望近似算法 以上两种定义互不包含 随机算法设计挫败对手随机选择一系列算法中的一个，这样就无法特意构造一组最坏输入 充分取证常用于判定问题 如Example5.2.2.6的取模运算 指纹用于判定等价问题 随机采样松弛与随机舍入比如把线性规划的值舍入成整数规划","categories":[],"tags":[]},{"title":"难问题求解学习笔记-近似算法","slug":"ps-4-12-Approximation-Algorithms","date":"2019-05-18T03:03:30.000Z","updated":"2019-06-19T08:16:41.230Z","comments":true,"path":"2019/05/18/ps-4-12-Approximation-Algorithms/","link":"","permalink":"https://mengzelev.github.io/2019/05/18/ps-4-12-Approximation-Algorithms/","excerpt":"","text":"概念近似算法是能提供最优化问题的可行解的算法，所提供的解的质量不会与最优解相差太多 形式化定义：$U={\\Sigma_I, \\Sigma_O, L, L_I, \\mathcal{M}, cost, goal}$是一个最优化问题，$A$是$U$的consistent algorithm. 对任意$x\\in L_I$, $A$在$x$上的相对误差(relative error)$\\varepsilon_A(x)$定义为 \\varepsilon_A(x)=\\frac{|cost(A(x))-Opt_U(x)|}{Opt_U(x)}对任意$x\\in\\mathbb{N}$,定义$A$的相对误差\\varepsilon_A(n)=\\max\\{\\varepsilon_A(x)|x\\in L_I\\cap (\\Sigma_I)^n\\}对每个$x\\in L_I$,$A$在$x$上的的近似率(approximation ration)$R_A(x)$定义为R_A(x)=\\max\\{\\frac{cost(A(x))}{Opt_U(x)}, \\frac{Opt_U(x)}{cost(A(x))}\\}对任意$n\\in\\mathbb{N}$,定义$A$的近似率为R_A(n)=\\max\\{R_A(x)|x\\in L_I\\cap (\\Sigma_I)^n\\}$R_A$又名最坏情况性能(worst case performance)，近似因子(approximation factor), 性能约束(performance bound)，性能率(performance ratio)，误差率(error ratio) 若$A$是最小化问题且$R_A(x)=\\frac{Opt_U(x)}{cost(A(x))}$,则$R_A(x)=1+\\varepsilon_A(x)$ 对于任意正实数$\\delta&gt;1$，若$R_A(x)\\le\\delta$对任意$x\\in L_I$恒成立，则称$A$是$U$的$\\delta-$近似算法对任意函数$f:\\mathbb{N}\\to\\mathbb{R}^+$,若$R_A(x)\\le f(n)$对任意$n\\in\\mathbb{N}$恒成立，则称$A$是$U$的$f(n)-$近似算法 近似方案(approximation scheme)用户可以指定一个小的相对误差值$\\varepsilon$，程序可以提供出一个误差至多为$\\varepsilon$的可行解 定义4.2.1.6：$U={\\Sigma_I, \\Sigma_O, L, L_I, \\mathcal{M}, cost, goal}$是一个最优化问题。若对任意输入对$(x,\\varepsilon)\\in L_I\\times\\mathbb{R}^+$, $A$计算出一个相对误差至多为$\\epsilon$的可行解$A(x)$, 且$Time_A(x,\\varepsilon^{-1})$以某个$|x|$的多项式函数为界，则称$A$是$U$的多项式时间近似方案(polynomial-time approximation scheme, PTAS). 若$Time_A(x,\\varepsilon^{-1})$以某个同时是$|x|$和$\\varepsilon^{-1}$的多项式的函数为界，则称$A$是$U$的完全多项式近似方案(fully polynomial-time approximation scheme, FPTAS) 一般来说$Time_A(x,\\varepsilon^{-1})$关于$|x|$和$\\varepsilon^{-1}$都单调递增 好处：用户有权决定要快还是要精度 最优化问题的分类在近似的意义下NPO可以被分为以下五类： NPO(I): NPO中所有存在FPTAS的最优化问题(e.g.背包问题) NPO(II): NPO中所有存在PTAS的最优化问题(e.g. MS) NPO(III): 包含所有$U\\in NPO$满足： 对某些$\\delta&gt;1$存在多项式时间的$\\delta-$近似算法 对某些$d&lt;\\delta$不存在多项式时间的的$d-$近似算法 i.e.$U$没有PTAS NPO(IV): 包含所有$U\\in NPO$满足： 对某些$f:\\mathbb{N}\\to\\mathbb{R}^+$,存在多项式时间的$f(n)-$近似算法,其中$f$以某个多项式函数为界 对任意$\\delta\\in\\mathbb{R}^+$不存在任何多项式时间的$\\delta-$近似算法 e.g.集合覆盖问题 NPO(V): 包含所有$U\\in NPO$，满足若存在多项式时间的$f(n)-$近似算法，则$f(n)$不以任何多项式函数为界(e.g. TSP, 最大团问题) 以上分类都基于合理的假设P$\\neq$NP所有集合都是非空的 近似算法的稳定性即使是NPO(V)中的问题，也可能有很大一部分的输入是比较简单的 稳定性用来衡量问题实例的限定(参数，特性等)对近似率的影响如果对模型的限制影响近似率的程度很低，则可以说我们的算法是稳定的 定义4.2.3.1：$U={\\Sigma_I, \\Sigma_O, L, L_I, \\mathcal{M}, cost, goal}$, $\\overline{U}={\\Sigma_I, \\Sigma_O, L, L, \\mathcal{M}, cost, goal}$是两个最优化问题，$L_I\\subseteq L$. $\\overline{U}$依据$L_I$的距离函数(distance function for $\\overline{U}$ according to $L_I$)是任何满足下列性质的函数$h_L:L\\to\\mathbb{R}^+\\cup{0}$: 对任意$x\\in L_I, h_L(x)=0$ $h$可以在多项式时间内计算 定义：对任意$r\\in\\mathbb{R}^+$,Ball_{r,h}(L_I)=\\{w\\in L\\mid h(w)\\le r\\} $p$是正实数，若对任意实数$0\\le r\\le p$, 存在$\\delta{r,\\varepsilon}\\in\\mathbb{R}^{&gt;1}$, $A$是$U_r={\\Sigma_I, \\Sigma_O, L, Ball{r,h}, \\mathcal{M}, cost, goal}$的$\\delta_{r,\\varepsilon}-$近似算法，则称$A$是p-stable according to $h$ 若对任意$p\\in\\mathbb{R}^+$，$A$都是p-stable的，则称$A$是stable according to $h$反之，若对任意$p\\in\\mathbb{R}^+$，$A$都不是p-stable的，则称$A$是unstable according to $h$ 对任意正整数$r$和任意函数$f:\\mathbb{N}\\to\\mathbb{R}^{&gt;1}$,若$A$是$Ur={\\Sigma_I, \\Sigma_O, L, Ball{r,h}, \\mathcal{M}, cost, goal}$的$f_r(n)-$近似算法，则称$A$是$(r,f_r(n))$-quasistable accroding to $h$ 把PTAS$A$看作一系列多项式时间$(1+\\varepsilon)-$近似算法的集合$A\\varepsilon$.若在某个距离度量$h$下对任意$\\varepsilon&gt;0$,$A\\varepsilon$都是稳定的，则我们可以得到以下二者之一 $U_r$的一个PTAS(for every $r\\in\\mathbb{R}^+$) $Ur$的一个$\\delta{r,\\varepsilon}$近似算法，但没有PTAS 定义4.2.3.6： $U,\\overline{U}$定义同上。$h$是$\\overline{U}$根据$LI$的距离函数，$U_r$同上。设$A={A\\varepsilon}{\\varepsilon&gt;0}$是$U$的一个PTAS若对任意$r&gt;0$和$\\varepsilon&gt;0$,$A\\varepsilon$是$\\delta{r,\\varepsilon}$-近似算法，则$A$是关于$h$stable的若$\\delta{r,\\varepsilon}\\le f(\\varepsilon)\\cdot g(r)$，其中$f$和$g$是某些$\\mathbb{R}^{\\ge 0}\\to\\mathbb{R}^+$的函数且$\\lim\\limits_{\\varepsilon\\to 0}f(\\varepsilon)=0$, 则称$A$关于$h$超稳定(superstable). 如果$A$对$U$超稳定，则$A$对$U_r$也超稳定 对偶近似算法修改限制条件$\\mathcal(M)$来简化计算 定义4.2.4.1：$U={\\Sigma_I, \\Sigma_O, L, L_I, \\mathcal{M}, cost, goal}$是一个最优化问题。$U$的限制距离函数(constraint distance function)是任何满足下列条件的函数$h:L_I\\times\\Sigma^*_O\\to\\mathbb{R}^{\\ge 0}$: 对任意$S\\in\\mathcal{M}(x), h(x,S)=0$ 对任意$S\\notin\\mathcal{M}(x), h(x,S)&gt;0$ $h$是多项式时间内可计算的 对任意$\\varepsilon\\in\\mathbb{R}^+$,任意$x\\in LI$,$\\mathcal{M}\\varepsilon^h(x)={S\\in\\Sigma_O^*\\mid h(x,S)\\le\\varepsilon}$是$\\varepsilon-$ball of $\\mathcal{M}(x)$ according to $h$. 定义4.2.4.2: $U$是最优化问题，$h$是$U$的限制距离函数. 若对任意$x\\in L1$,有$A(x)\\in\\mathcal{M}\\varepsilon^h(x)$且$cost(A(x))\\ge Opt_U(x)$ if $goal=maximum$且$cost(A(x))\\le Opt_U(x)$ if $goal=minimum$, 则称$A$是$U$的$h-$对偶$\\varepsilon-$近似算法 定义4.2.4.3: 条件同上。若 对任意输入$(x,\\varepsilon)\\in LI\\times\\mathbb{R}^+, A(x,\\varepsilon)\\in\\mathcal{M}\\varepsilon^h(x)$ $cost(A(x))\\ge Opt_U(x)$ if $goal=maximum$且$cost(A(x))\\le Opt_U(x)$ if $goal=minimum$ $Time_A(x,\\varepsilon^{-1})$以某个$|x|$的多项式函数为界 则称$A$是$U$的$h-dual$PTAS类似的可以定义$U$的$h-dual$FPTAS 总结降低问题难度的方法： 对输出精度要求降低 对输入做限制","categories":[],"tags":[]},{"title":"自己看得惯的板子整理","slug":"oj-templates","date":"2019-04-19T08:20:44.000Z","updated":"2019-04-20T10:55:16.017Z","comments":true,"path":"2019/04/19/oj-templates/","link":"","permalink":"https://mengzelev.github.io/2019/04/19/oj-templates/","excerpt":"","text":"动态规划状态压缩dpdfs版1234567891011121314151617int dfs(int i, int rnd, int status) &#123; int j; if (status == two[num] - 1) return 0; if (f[i][status] &gt; 0) return f[i][status]; int q = 1e9; for (j = num; j &gt; 0; --j) &#123; int temp = 1 &lt;&lt; (j - 1); if (j != i &amp;&amp; (!(status &amp; temp))) &#123; if (q &gt; dfs(j, rnd + 1, status | temp) + a[need[i]][need[j]]) &#123; q = dfs(j, rnd + 1, status | temp) + a[need[i]][need[j]]; c[i][status] = j; &#125; &#125; &#125; f[i][status] = q; return q;&#125; bfs版123456789101112131415161718192021222324252627282930313233343536373839404142434445void bfs(int start) &#123; memset(s, 0, sizeof(s)); memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(start); vis[start] = true; s[start] = 0; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int i = 1; i &lt;= m; ++i) &#123; int v1 = u + ok[i]; int v2 = u - ok[i]; if (v1 &lt;= n &amp;&amp; !vis[v1]) &#123; Q.push(v1); s[v1] = s[u] + 1; vis[v1] = true; &#125; if (v2 &gt;= 0 &amp;&amp; !vis[v2]) &#123; Q.push(v2); s[v2] = s[u] + 1; vis[v2] = true; &#125; &#125; &#125;&#125;int dp() &#123; for(int i = 0; i &lt; 20; ++i) e[i] = (1 &lt;&lt; i); int sn = 1 &lt;&lt; cnt1; //状态数 for(int i = 1; i &lt; sn; ++i) f[i] = INF; f[0] = 0; for(int i = 0; i &lt; sn; ++i) &#123; int j = 0; while(i &amp; e[j]) ++j; for(int p = j + 1; p &lt; cnt1; ++p) &#123; if(!(i &amp; e[p]) &amp;&amp; dist[p+1][j+1]) &#123; f[i | e[j] | e[p]] = min(f[i | e[j] | e[p]], f[i] + dist[p+1][j+1]); &#125; &#125;&#125; return f[sn-1];&#125; 并查集普通并查集1234567891011121314151617//别忘了初始化f[i]=iint find(int x)&#123; int root = f[x]; while(root != f[root]) root = f[root]; int y = f[x]; while(f[x] != root)&#123; f[x] = f[y]; y = f[y]; &#125; return f[x];&#125;void unite(a, b)&#123; int fa = find(a); int fb = find(b); if(fa != fb) f[fa] = fb;&#125; 带权并查集12345678910111213141516171819202122int find(int x)&#123; if(f[x] == x) return x; int temp = f[x]; f[x] = find(temp); rel[x] = (rel[x] + rel[temp]) % 3; //rel[x]初始化为全0 return f[x];&#125;void unite(int d, int x, int y)&#123; int fx = find(x); int fy = find(y); if(fx != fy)&#123; f[fy] = fx; rel[fy] = (3 + d + rel[x] - rel[y]) % 3; &#125;&#125;bool judge(int d, int x, int y)&#123; if(d == 0) return (rel[x] == rel[y]); if(d == 1) return ((3 - rel[x] + rel[y]) % 3 == d); &#125; 最小生成树kruskal12345678910111213141516int kruskal() &#123; int ans = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) f[i] = i; sort(e + 1, e + m + 1, cmp); for (int i = 1; i &lt;= m; ++i) &#123; int fu = find(e[i].u); int fv = find(e[i].v); if (fu != fv) &#123; f[fv] = fu; ans += e[i].weight; cnt++; if (cnt == n - 1) break; &#125; &#125; return ans;&#125; 最短路dijkstra12345678910111213141516171819202122232425262728struct node&#123; int id; //序号，找边权用 int d; bool operator &lt; (const node &amp;y) const &#123; return d &lt; y.d; &#125;&#125;vertex[MAXN] = &#123;&#125;;double dijkstra()&#123; priority_queue &lt;node&gt; q; vertex[0].d = 0; q.push(vertex[0]); while(!q.empty())&#123; node u = q.top(); q.pop(); for(int i = 0; i &lt; son[u.id].size(); ++i)&#123; int vid = son[u.id][i]; double weight = w[u.id][i]; if(vertex[vid].d &lt; u.d) continue; if(vertex[vid].d &gt; u.d + weight)&#123; vertex[vid].d = u.d + weight; q.push(vertex[vid]); &#125; &#125; &#125;&#125; floyd12345678void floyd()&#123; for(int k = 0; k &lt; n; ++k) for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j)&#123; if(map[i][j] &gt; map[i][k] + map[k][j]) map[i][j] = map[i][k] + map[k][j]; &#125;&#125; 各种tarjan有向图强连通分量数123456789101112131415161718192021222324252627282930313233//dfn[u] u的时间戳//low[u] u或u的子树能够追溯到的最早栈中节点void tarjan(int u)&#123; dfn[u] = low[u] = ++cnt; vis[u] = true; stack1[++index] = u; for(int i = 0; i &lt; son[u].size(); ++i)&#123; int v = son[u][i]; if(!dfn[v])&#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(vis[v]) low[u] = min(low[u], dfn[v]); //u-v is a back edge &#125; if(low[u] == dfn[u])&#123; scnum ++; //强连通分量数 do&#123; belong[stack1[index]] = scnum; num[scnum] ++; vis[stack1[index]] = false; index --; &#125;while(u != stack1[index + 1]); &#125; return;&#125;// for(int i = 1; i &lt;= n; ++i)&#123;// if(!dfn[i]) &#123;// cnt = 1;// tarjan(i);// &#125;// &#125; 无向图割点与割边1234567891011121314151617181920212223void tarjan(int u, int pre)&#123; int child = 0; dfs_clock ++; dfn[u] = low[u] = dfs_clock; for(int i = 0; i &lt; son[u].size(); ++i)&#123; int v = son[u][i]; if(!dfn[v])&#123; tarjan(v,u); child ++; low[u] = min(low[u], low[v]); if((u == 1 &amp;&amp; child &gt; 1) || (u != 1 &amp;&amp; dfn[u] &lt;= low[v])) &#123; cut.push_back(u); //割点判定 //iscut[u] = true; &#125; if(low[v] &gt; dfn[u]) bridge.push_back(&#123;min(u,v), max(u,v)&#125;); //割边判定 &#125; else if(dfn[v] &lt; dfn[u] &amp;&amp; v != pre) low[u] = min(low[u], dfn[v]); &#125; return;&#125;//tarjan(1,-1); 无向图双连通分量点（边）双连通分量：若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥），则称作点（边）双连通图。 1234567891011121314void tarjan(int u, int pre)&#123; dfs_clock ++; dfn[u] = low[u] = dfs_clock; for(int i = 0; i &lt; son[u].size(); ++i)&#123; int v = son[u][i]; if(!dfn[v])&#123; tarjan(v,u); low[u] = min(low[u], low[v]); &#125; else if(dfn[v] &lt; dfn[u] &amp;&amp; v != pre) low[u] = min(low[u], dfn[v]); &#125; return;&#125;//统计无向图的边双连通分量，在一个双连通分量中当且仅当low[u] == low[v] 欧拉图有向图123456789101112131415161718192021bool directed_euler()&#123; int moreout = 0; int morein = 0; for(int i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; ++i)&#123; if(ver[i].indeg &gt; ver[i].outdeg) &#123; if(ver[i].indeg == ver[i].outdeg + 1) morein ++; else return false; &#125; else if(ver[i].deg &lt; ver[i].outdeg) &#123; if(ver[i].outdeg == ver[i].indeg + 1) moreout++; else return false; &#125; &#125; //printf(&quot;morein = %d, moreout = %d&quot;, morein, moreout); if(morein &lt;= 1 &amp;&amp; moreout &lt;= 1) return true; else return false;&#125;//判断连通有向图是否含欧拉迹//至多一顶点出度=入度+1//至多一顶点入度=出度+1//其余顶点：入度=出度 无向图1234567bool undirected_euler()&#123; int odd = 0; for(int i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; ++i) if(ver[i].deg % 2 == 1) odd++; if(odd == 0 || odd == 2) return true; else return false;&#125;; 哈密尔顿回路12345678910111213141516void hamilton()&#123; path.push_back(1); for(int i = 2; i &lt;= n; ++i)&#123; bool flag = false; for(int j = 0; j &lt; path.size() - 1; ++j)&#123; if(map[path[j]][i] &amp;&amp; map[i][path[j + 1]])&#123; path.insert(path.begin() + j + 1, i); flag = true; break; &#125; &#125; if(flag) continue; if(map[path.back()][i]) path.push_back(i); else path.insert(path.begin(), i); &#125;&#125; 完美匹配匈牙利算法1234567891011121314151617bool find(int x)&#123; for(int i = 1; i &lt;= m; ++i)&#123; if(map[x][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if(match[i] == 0 || find(match[i]))&#123; match[i] = x; return true; &#125; &#125; &#125; return false;&#125;for(int i = 1; i &lt;= n; ++i) &#123; memset(vis, 0 , sizeof(vis)); if(find(i)) ans ++;&#125; KM：最小权匹配12345678910111213141516171819202122232425262728293031323334353637383940414243444546bool find(int i) &#123; S[i] = true; for (int j = 1; j &lt;= num; ++j) &#123; if (!T[j] &amp;&amp; ls[i] + lt[j] == map[i][j]) &#123; T[j] = true; if (!match[j] || find(match[j])) &#123; match[j] = i; return true; &#125; &#125; &#125; return false;&#125;void relax() &#123; int relax_val = 1e9; for(int i = 1; i &lt;= min(n,m); ++i) if(S[i]) &#123; for(int j = 1; j &lt;= num; ++j) if(!T[j] &amp;&amp; ls[i] + lt[j] &gt; map[i][j]) relax_val = min(relax_val, ls[i] + lt[j] - map[i][j]); &#125; assert(relax_val &gt; 0); for (int i = 1; i &lt;= num; ++i) &#123; if (S[i]) ls[i] -= relax_val; if (T[i]) lt[i] += relax_val; &#125;&#125;int KM() &#123; memset(match, 0, sizeof(match)); for (int i = 1; i &lt;= min(m,n); ++i) &#123; ls[i] = 0; for (int j = 1; j &lt;= num; ++j) ls[i] = max(map[i][j], ls[i]); &#125; for(int i = 1; i &lt;= num; ++i) lt[i] = 0; for (int i = 1; i &lt;= min(n,m); ++i) &#123; while (1) &#123; memset(S, 0, sizeof(S)); memset(T, 0, sizeof(T)); if (find(i)) break; else relax(); &#125; &#125;&#125; 网络流Dinic+当前弧优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bool bfs() &#123; memset(depth, 0 , sizeof(depth)); queue &lt;int&gt; q; q.push(s); depth[s] = 1; while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = 0; i &lt; son[u].size(); ++i) &#123; int v = son[u][i]; if(map[u][v] &gt; 0 &amp;&amp; !depth[v]) &#123; depth[v] = depth[u] + 1; q.push(v); &#125; &#125; &#125; if(depth[t] == 0) return false; else return true;&#125;int dfs(int u, int dist) &#123; /* * 寻找当前增广路径上的最小容量 */ if(u == t) return dist; for(int &amp;i = cur[u]; i &lt; son[u].size(); ++i) &#123; int v = son[u][i]; if(depth[v] == depth[u] + 1 &amp;&amp; map[u][v] &gt; 0) &#123; int minc = dfs(v, min(dist, map[u][v])); if(minc &gt; 0) &#123; map[u][v] -= minc; map[v][u] += minc; return minc; &#125; &#125; &#125; return 0;&#125;void dinic() &#123; while(bfs()) &#123; memset(cur, 0 , sizeof(cur)); while(int minc = dfs(s, INF)) &#123; ans += minc; //printf(&quot;minc=%d\\n&quot;,minc); &#125; &#125;&#125; 矩阵高斯消元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void swap2row(int x, int y) &#123; for(int i = 1; i &lt;= n + 1; ++i) swap(a[x][i], a[y][i]); //printf(&quot;**swap row %d with row %d**\\n&quot;,x,y);&#125;void pivot_one(int x, int y) &#123; double temp = a[x][y]; if(temp == 1) return; for(int i = y; i &lt;= n + 1; ++i) a[x][i] /= temp; //printf(&quot;**pivot one at row %d**\\n&quot;, x);&#125;void mul_and_add(int src, int dst, double cof) &#123; for(int i = 1; i &lt;= n + 1; ++i) &#123; a[dst][i] -= a[src][i] * cof; &#125; //printf(&quot;**mul row %d with %lf add to row %d**\\n&quot;, src, cof, dst);&#125;void print_matrix() &#123; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) printf(&quot;%lf &quot;, a[i][j]); printf(&quot;| %lf\\n&quot;, a[i][n + 1]); &#125; printf(&quot;------------------------\\n&quot;);&#125;bool iszero(int row) &#123; for(int i = 1; i &lt;= n + 1; ++i) if(a[row][i] != 0) return false; return true;&#125;void Guass() &#123; int row = 1, col = 1; bool ok = false; while(row &lt;= n &amp;&amp; col &lt;= n) &#123; //printf(&quot;Now row=%d, col=%d\\n&quot;,row, col); if(a[row][col] == 0.0) &#123; ok = false; for(int i = row + 1; i &lt;= n; ++i) if(a[i][col] != 0) &#123; swap2row(row, i); ok = true; break; &#125; if(ok == false) &#123;col++; continue;&#125; //else print_matrix(); &#125; pivot_one(row,col); if(col == n &amp;&amp; row == n &amp;&amp; a[row][col] == 1) return; //print_matrix(); for(int i = 1; i &lt;= n; ++i) if(i != row &amp;&amp; a[i][col] != 0) &#123; assert(a[row][col] != 0); double cof = a[i][col] / a[row][col]; if(cof != 0) mul_and_add(row, i, cof); assert(a[i][col] == 0); &#125; //print_matrix(); row ++; col ++; &#125;&#125; 线性规划 — simplex单纯形算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071int sgn(double x) &#123; if (x &lt; -EPS) return -1; return x &gt; EPS ? 1 : 0;&#125;void pivot(int r, int c) &#123; swap(id[n + r], id[c]); double x = -a[r][c]; a[r][c] = -1; for (int i = 0; i &lt;= n; ++i) a[r][i] /= x; for (int i = 0; i &lt;= m; ++i) &#123; if (sgn(a[i][c]) &amp;&amp; i != r) &#123; x = a[i][c]; a[i][c] = 0; for (int j = 0; j &lt;= n; ++j) a[i][j] += x * a[r][j]; &#125; &#125;&#125;int simplex() &#123; /* important: revert symbols of conditions */ for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; a[i][j] *= -1; &#125; &#125; for (int i = 1; i &lt;= n; ++i) id[i] = i; /* initial-simplex */ while (true) &#123; int x = 0, y = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (sgn(a[i][0]) &lt; 0) &#123; x = i; break; &#125; &#125; if (!x) break; for (int i = 1; i &lt;= n; ++i) &#123; if (sgn(a[x][i]) &gt; 0) &#123; y = i; break; &#125; &#125; if (!y) return -1; // infeasible pivot(x, y); &#125; /* solve-simplex */ while (true) &#123; int x = 0, y = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (sgn(a[0][i]) &gt; 0) &#123; x = i; break; &#125; &#125;// printf(&quot;choose x%d, cof=%d\\n&quot;, x, a[0][x]); if (!x) break; // finished double w = 0, t = 0; //t是最苛刻的非基本变量能取到的最大值 bool f = true; for (int i = 1; i &lt;= m; ++i) &#123; if (sgn(a[i][x]) &lt; 0) &#123; t = ((double)-a[i][0]) / ((double)a[i][x]);// if(x==3) printf(&quot;t: -%d / %d = %.lf\\n&quot;, a[i][0], a[i][x], t); if (f || t &lt; w) &#123; w = t, y = i, f = false; &#125; &#125; &#125; if (!y) &#123; return 1; &#125; // unbounded pivot(y, x); &#125; for (int i = 1; i &lt;= n; ++i) v[i] = 0; for (int i = n + 1; i &lt;= n + m; ++i) v[id[i]] = a[i - n][0]; return 0;&#125; 字符串匹配KMP12345678910111213141516171819202122void build_kmp() &#123; int j = -1; kmp[0] = -1; for(int i = 1; i &lt; len2; ++i) &#123; while(j &gt;= 0 &amp;&amp; s2[i] != s2[j + 1]) j = kmp[j]; if(s2[j + 1] == s2[i]) j ++; kmp[i] = j; &#125;&#125;void do_kmp() &#123; int j = -1; for(int i = 0; i &lt; len1; ++i) &#123; while(j &gt;= 0 &amp;&amp; s1[i] != s2[j + 1]) j = kmp[j]; if(s1[i] == s2[j + 1]) ++j; if(j == len2 - 1) &#123; printf(&quot;%d\\n&quot;, i - len2 + 2); j = kmp[j]; ok = true; &#125; &#125;&#125; 字典树12345678910111213141516171819202122232425262728293031323334struct Trie&#123; /*字典树*/ int tot, root; int nxt[MAXN][26] = &#123;&#125;; Trie() &#123; tot = 1; root = newNode(); &#125; int newNode() &#123; memset(nxt[tot], 0 ,sizeof(nxt[tot])); return tot++; &#125; void append(string s) &#123; int cur = root; for(int i = 0; i &lt; s.size(); ++i) &#123; int id = s[i] - &#x27;a&#x27;; if(nxt[cur][id] == 0) nxt[cur][id] = newNode(); cur = nxt[cur][id]; &#125; &#125; void print() &#123; for(int i = 1; i &lt; tot; ++i)&#123; for(int j = 0 ; j &lt; 26; ++j) &#123; if(nxt[i][j] != 0) printf(&quot;S.nxt[%d][%c]=%d\\n&quot;,i, j+&#x27;a&#x27;, nxt[i][j]); &#125; &#125; &#125; &#125;S; 快速幂1234567891011ll qpow(ll a, ll n, ll mod) &#123; /*快速幂*/ ll ans = 1; a %= mod; while(n &gt; 0) &#123; if(n &amp; 1) ans = (ans * a) % mod; a = (a * a) % mod; n &gt;&gt;= 1; &#125; return ans;&#125;","categories":[],"tags":[]},{"title":"os期中复习","slug":"os-midterm","date":"2019-04-15T14:17:55.000Z","updated":"2019-06-22T15:58:43.968Z","comments":true,"path":"2019/04/15/os-midterm/","link":"","permalink":"https://mengzelev.github.io/2019/04/15/os-midterm/","excerpt":"","text":"应用眼中的OS 操作系统一方面需要提供程序的执行的环境和相应的资源，还要提供和操作系统世界中其他对象交互的方法和约定 并发共享内存多线程 并发定义：一个程序、算法或问题的不同部分乱序或偏序执行而不影响最终结果的能力 程序经历了什么？ 编译器优化$\\to$顺序丧失 操作系统中断，多处理器、缓存(硬件)$\\to$原子性(all or nothing)丧失 缓存，乱序（硬件）$\\to$可见性丧失 顺序丧失：允许源代码中内存访问指令不再按顺序甚至不再出现 原子性的丧失：指令序列可以在任意时刻被中断，然后操作系统切换到其他线程执行 可见性丧失：缓存&amp;乱序 互斥评估一把锁的基本准则 能够完成基本任务：提供互斥性质 锁的分配是公平的：不会有现成想要上锁却永远得不到它 锁的高效的：无等待时性能？多线程同时等待时性能？多CPU每个核的线程都要上锁时性能？ 自旋锁的正确性证明： 建模程序的状态 证明safety(只有一个线程进入临界区)和liveness(至少有一个线程能进入临界区) 几种上锁方法 TestAndSet；相当于atomic_xchg CompareAndWait LL&amp;SC FetchAndAdd：彩票锁，保证公平性 同步(CV) wait(&amp;cond)：当前进程进入睡眠状态，等待cond被满足后唤醒 signal(&amp;cond)：唤醒在等待cond条件的某个进程 broadcast(&amp;cond): 唤醒在等待cond条件的所有进程 需要配合互斥锁使用：读取状态到wait()之间不能被打断，改变状态到signal之间也不能被打断 使用条件变量记 得 上 锁 123456789101112131415void worker(int id) &#123; mutex_lock(&amp;mutex); done[id] = 1; signal(&amp;joins); mutex_unlock(&amp;mutex);&#125;int main() &#123; for(int i = 0; i &lt; nworkers; ++i) create(worker,i); for(int i = 0; i &lt; nworkers; ++i) &#123; mutex_lock(&amp;mutex); if(!done[i]) wait(&amp;joins, &amp;mutex); mutex_unlock(&amp;mutex); &#125;&#125; 信号量互斥锁(二元信号量)和同步都可以使用信号量来实现信号量就相当于有一个管理员manage了一堆资源，进程需要资源时先向管理员请求(semi_wait)，暂时没有资源就等，使用完毕后归还(semi_post)给管理员 需要配合锁使用注意死锁：lock之后P，其他线程是无法获得lock的 期中考题 12345678910111213&#x27;(&#x27;: lock(&quot;(&quot;); // assume lock can nest putchar(); V(fill1);&#x27;)&#x27;: P(fill1); putchar(); unlock(&quot;(&quot;);&#x27;[&#x27;: lock(&quot;(&quot;); putchar(); V(fill2); unlock(&quot;(&quot;);&#x27;]&#x27;: P(fill2); lock(&quot;(&quot;); putchar(); unlock(&quot;(&quot;); 不能上一把大锁（会死锁），所以拆了小锁来保证原子性 P不能在锁中间进行 自旋锁是为了保证圆括号和方括号不冲突（互斥），信号量是为了保证左右括号配对（同步） 之所以用锁而非信号量来处理圆括号和方括号的关系，是因为为了保证原子性本来就要上锁，这样一举两得。用信号量不是不可以，但一样也要上锁，造成了资源浪费。 APIs sem_wait：信号量-1，表示在等待的线程增加了一个，消耗一个执行名额；如果信号量&lt;0, 表示等待的线程数多于可执行线程数，当前线程进入睡眠 sem_post：信号量+1，表示执行的线程少了一个，可以让出一个执行名额 哲学家吃饭问题One general solution: 让一个人集中管理所有叉子(信号量) 并发Bugs 原子性违反(AV) —&gt; 上锁 顺序违反(OV) —&gt; 同步 死锁出现的四个条件 互斥 请求与保持(同一个进程要同时上多把锁) 没有抢占(不能强制解锁) 循环等待 对付死锁 避免：规定上锁顺序 检测：打log 虚拟化每个进程都以为自己独占CPU和整个内存空间进程：OS提供的对运行程序的抽象 进程抽象CPU执行指令时假设自己直接占有整个CPU进程分时共享物理CPU 进程状态 Running: 进程正在处理器上执行命令 Ready：进程准备执行，但由于某些原因OS决定现在不让它运行 Blocked：进程此前执行了某些操作(e.g. I/O)，让它在其他事件发生前停止执行 实现进程 进程=线程+地址空间 进程就是个结构体 名字 pid 上下文 地址空间 堆栈 状态 其他信息（如父进程、文件描述符等） 进程管理 fork execve exit exit()是库函数，_exit()是系统调用 文件描述符一个指向os内对象的指针fork-exec不改变文件描述符int dup2(int oldfd, int newfd); - 关闭newfd，并复制oldfd到newfd(dup+close的并发版) 重定向123456789pid_t pid = fork();assert(pid != 0);if(pid == 0) &#123; //子进程 int fd = open(...); dup2(fd, STDOUT_FILENO); close(fd); execve(...);&#125;else&#123;...&#125; 管道123456789101112if(pipe(fds) != 0) &#123;panic(&quot;pipe error&quot;);&#125;pid = fork();if(pid == 0) &#123;//child dup2(fds[1], STUOUT_FILENO); //连接写口，往管道内写数据 close(fds[1]); close(fds[0]);&#125;else&#123; //parent dup2(fds[0], STDIN_FILENO); //连接读口，从管道内读数据 close(fds[0]); close(fds[1]);&#125; 信号进程组实现 进程调度衡量标准 轮转时间(turnaround time): $\\sum t{complete}-t{arrival}$ 响应时间(response time): $\\sum t{firstrun}-t{arrival}$ FIFO 优点：简单易实现 缺点： 会产生护航效应（有一个不要脸的任务占坑很久） SJF(Shortest Job First) 当假设所有任务同时到达时的最优算法 非抢占式(preemptive)算法 STCF(Shortest Time-to-Completion First) 抢占式策略，又名Preemptive Shortest Job First(PSJF) 轮转时间短但响应时间长 RR(Round Robin) 每个进程运行一段时间片(time slice, sometimes called scheduling quantum) 时间片越短，响应时间越短，但是切换上下文的时间会变长(trade-off) 当考虑轮转时间时非常糟糕 保证了公平性但是损失了效率 MLFQ(Multi-level Feedback Queue)MLFQ有很多种实现但都大同小异，书上只介绍一种 有很多队列，每个队列具有不同的优先级，优先级高的先运行 通过观察进程过去的行为调整优先级 如果一个进程频繁让出CPU，保持高优先级；反之一个进程如果长时间占用CPU则会被降低优先级 并不知道一个任务是长是短，因此先假设是短的，然后根据进程的后续表现修改认知 优先级的修改workload: 交互式短时间任务(会频繁让出CPU)+不交互的长时间任务(响应时间不那么重要) Basic Rules If Priority(A)&gt;Priority(B), A runs (B doesn’t) If Priority(B)==Priority(B), A &amp; B runs in RR 一个任务最初进入系统时位于最高优先级4(a). 如果一个任务耗尽了时间片，则优先级下降4(b). 如果一个任务在时间片耗尽之前放弃了CPU,优先级不变4(改进). 当一个任务在一定程度上用尽了被分配到的时间，优先级就下降5(新增). 在一段时间$S$后，将所有任务移到最高优先级上(Priority-boost) 缺陷： 饥饿：如果交互式进程很多就会完全占用CPU使得长任务得不到调度(5解决) 有些心脏的应用可以玩弄这个规则，一直主动让出一小会儿CPU来使自己停留在高优先级上(4解决) 任务的行为可能会随着时间改变(5解决) PS(Proportional-share) 老子才不管什么的轮转时间和响应时间，老子只要每个任务都能按比例分到一定时间 lottery scheduling 随机的好处 防止了边界情况 轻量级，需要记录的信息少 快(太快了可能会变成伪随机数) 怎么分配彩票也是个很棘手的问题 stride scheduling 根据每个任务的彩票数决定每次调度执行的时间长短 每次调度都选取运行时间最短的任务 多处理器调度不想看了【瘫 链接和加载 静态链接下的加载：_start(程序自己的)-&gt;__libc_start_main-&gt;generic_start_main-&gt;...-&gt;main 动态链接： PLT：程序链接表，放入进行链接的代码，方便lazy linking(名字叫表格其实就是一小段代码，用来判断是否已经完成链接) GOT：全局偏移表，存放函数代码开始的地址 第一条指令 静态链接：a.out的entry 动态链接：ld.so的entry 动态链接libc：链接器使用一系列mmap把libc链接进进程地址空间 虚存抽象多级页表(PML): 复习ICS反置页表(IPT): 硬件维护一个全局的hash table，计算$f(as,x)$IPT实现Copy-on-Write有困难，且PML能高效地标记一段连续内存为某个权限 mmap把操作系统里的对象映射到进程的地址空间 e.g.加载可执行文件的时候把文件搬到某个地址处 不映射任何文件的时候就相当于malloc 只记录相关信息，余下的等发生缺页时再处理，所以非常快 可以用红黑树维护分配的内存 fork采用写时复制 进程的地址空间pmap-查看进程的地址空间 静态链接的程序的地址空间：代码、数据、bss、堆、栈、用户态系统调用动态链接：多了动态链接库和链接器 期中复习系统调用：操作系统为用户进程提供的一组API，通常在内核空间中实现，实现用户进程对操作系统对象/物理硬件访问的请求。进程=操作系统中的数据系统调用=这些数据上的操作","categories":[],"tags":[]},{"title":"问题求解学习笔记-密码算法","slug":"ps-4-7-cryptographic-algorithm","date":"2019-04-13T04:04:44.000Z","updated":"2019-06-19T02:47:13.526Z","comments":true,"path":"2019/04/13/ps-4-7-cryptographic-algorithm/","link":"","permalink":"https://mengzelev.github.io/2019/04/13/ps-4-7-cryptographic-algorithm/","excerpt":"","text":"RSA公钥加密系统每个参与者都有一把公钥($P$)和密钥($S$) $\\mathcal{D}$表示允许信息的集合，要求公钥与密钥指定一种从$\\mathcal{D}$到自身的一一对应的函数。Alice的公钥函数$P_A$和密钥函数$S_A$都是$\\mathcal{D}$的排列 系统中任何参与者的公钥与密钥都是匹配对，指定函数互为反函数，对任何消息$M\\in \\mathcal{D}$，有 M=S_A(P_A(M))M=P_A(S_A(M))加密过程 Bob取得Alice的公钥$P_A$ Bob计算出相应与$M$的密文$C=P_A(M)$，并把$C$发送给Alice 当Alice收到密文$C$后，运用自己的密钥$S_A$恢复原始信息$M$ 数字签名 Alice运用密钥$S_A$和等式$\\sigma=S_A)M’$计算出信息$M’$的数字签名$\\sigma$ Alice把消息/签名对$(M’,\\sigma)$发给Bob Bob收到$(M’,\\sigma)$时，通过验证等式$M’=P_A(\\sigma)$来证实消息的确是来自Alice 任何人都可以把数字签名翻译出来，但只有密钥持有者可以生成数字签名 RSA加密系统 加密 P(M)=M^e\\bmod n解密 S(C)=C^d\\bmod n上述加密解密操作可以使用快速幂实现。 运行时间假定： 公钥$(e,n)$和密钥$(d,n)$满足$\\lg~e=O(1), \\lg~d\\le\\beta, \\lg~n\\le\\beta$ 应用公钥需要执行$O(1)$次模乘法运算和$O(\\beta^2)$次位操作 应用密钥需要执行$O(\\beta)$次模乘法运算和$O(\\beta^2)$次位操作。 正确性证明定理31.36(RSA的正确性)：RSA加密和解密等式定义了满足再上面两个等式的$\\mathbb{Z}_n$的逆变换 RSA加密系统的安全性主要来源于对大整数进行因子分解的困难性 效率提高 无公钥加密系统 抗冲突散列函数$h$ 证书 整数的因子分解Pollard的rho启发式方法 通过随机数寻找$n$的非平凡约数 可能会出现”$\\rho$”字型回路，在出现回路之前预计要执行的步数为$\\Theta(\\sqrt{n})$ 一种找出大整数的小素数因子的可供选择的办法 私钥密码学仿射密码系统(affine cryptosystem)：$f(p)=ap+b\\bmod 26$, $f^{-1}(p)=a^{-1}p-a^{-1}b\\bmod 26$ 多字码密码系统(polyalphabetic cryptosystem): $f(\\textbf{p})=A\\textbf{p}+b$,其中$A$是矩阵，$b$是列向量，$f^{-1}(\\textbf{p})=A^{-1}\\textbf{p}-A^{-1}\\textbf{p}$ 公钥密码学RSA加密系统（CLRS上已讲","categories":[],"tags":[]},{"title":"算法导论学习笔记-数论算法","slug":"clrs-31Number-Theoretic-Algorithms","date":"2019-04-06T03:18:48.000Z","updated":"2019-06-18T09:43:32.189Z","comments":true,"path":"2019/04/06/clrs-31Number-Theoretic-Algorithms/","link":"","permalink":"https://mengzelev.github.io/2019/04/06/clrs-31Number-Theoretic-Algorithms/","excerpt":"","text":"输入规模和算数计算的代价给定$k$个整数输入$a_1,a_2,\\cdots ,a_k$，如果算法可以在关于$\\lg~a_1,\\lg~a_2,\\cdots ,\\lg~a_k$的多项式时间内完成，即算法在关于二进制编码后的输入长度的多项式时间内完成，则称该算法为多项式时间算法 当输入很大时，基本运算也会变得耗时。两个$\\beta$位整数相乘需要耗时$\\Theta(\\beta^2)$.一个$\\beta$为整数除以另一个较短整数的商或余数需要耗时$\\Theta(\\beta^2)$ 基础数论概念整除性与约数你懂的 素数与合数你也懂的 除法定理、余数和等模定理31.1(除法定理): 对于任何整数$a$和任何正整数$n$，存在唯一整数$q$和$r$，满足$0\\le r&lt;n$且$a=qn+r$ 根据整数模$n$的余数，可以将所有整数划分成$n$个等价类。包含整数$a$的模$n$等价类为$\\left[a\\right]_n={a+kn:k\\in\\mathbb{Z}}$所有这类等价类的集合是$\\mathbb{Z}_n={[a]_n:0\\le a\\le n-1}$ 公约数与最大公约数公约数的重要性质： $d\\mid a$且$d\\mid b$蕴含$d\\mid (a+b)$且$d\\mid (a-b)$ 对任意整数$x$和$y$，都有$d\\mid a$且$d\\mid b$蕴含$d\\mid(ax+by)$ $a\\mid b$且$b\\mid a$蕴含$a=\\pm b$ 定理31.2: 如果任意整数$a$和$b$不都为0，则gcd$(a,b)$是$a$与$b$线性组合集${ax+by:x,y\\in\\mathbb{Z}}$中的最小正元素。(最小正线性组合) 推论31.3: 对任意整数$a$与$b$，如果$d\\mid a$且$d\\min b$，则$d\\mid gcd(a,b)$ 推论31.4: 对所有整数$a$和$b$以及任意非负整数$n$，有$gcd(an,bn)=n~gcd(a,b)$ 推论31.5: 对于任意正整数$n,a$和$b$，如果$n\\mid ab$且$gcd(a,n)=1$,则$n\\mid b$. 互质数定理31.6: 对任意整数$a,b$与$p$,如果$gcd(a,p)=1$且$gcd(b,p)=1$，则$gcd(ab,p)=1$. 唯一因子分解定理定理31.7: 对所有素数$p$和所有整数$a,b$，如果$p\\mid ab$,则$p\\mid a$或$p\\mid b$(或两者都成立)。 定理31.8(唯一因子分解定理): 合数$a$仅能以一种方式写成如下乘积形式 a=p_1^{e_1}p_2^{e_2}\\cdots p_r^{e_r}其中$p_i$为素数，$p_1&lt;p_2&lt;\\cdots p_r$且$e_i$为正整数 最大公约数定理31.9(GCD递归定理): 对任意非负整数$a$和任意正整数$b$，$gcd(a,b)=gcd(b,a\\bmod b)$ 欧几里得算法运行时间引理31.10: 如果$a&gt;b\\ge 1$并且EUCLID($a,b$)执行了$k\\ge 1$次递归调用，则$a\\ge F{k+2}， b\\ge F{k+1}$.($F_n$为斐波那契数列的第$n$项) 定理31.11(Lame定理): 对任意整数$k\\ge 1$,如果$a&gt;b\\ge 1$,且$b&lt;F{k+1}$,则EUCLID($a,b$)的递归调用次数少于$k$次该上界是最优的，因为$k\\ge 2$时，EUCLID$(F{k+1},F_k)$正好调用了$k$次 $F_k$约为$\\phi^k/\\sqrt{5}$, $\\phi=(1+\\sqrt{5})/2$EUCLID执行中递归调用的次数为$O(\\lg b)$如果EUCLID作用于两个$\\beta$位数，则将执行$O(\\beta)$次算术运算和$O(\\beta^3)$次位操作 扩展形式用于计算满足下列条件的整系数$x$和$y$(可能为0或负数): d=gcd(a,b)=ax+by 运行时间与EUCLID相同 模运算群论复习 模$n$加法群你懂的 模$n$乘法群(\\mathbb{Z}_n^*, \\cdot_n)\\mathbb{Z}_n^*=\\{[a]_n\\in\\mathbb{Z}_n: gcd(a,n)=1\\}定理31.13: 模$n$乘法群是有限交换群 $\\mathbb{Z}_n^*$中的除法由等式$a/b\\equiv ab^{-1}\\pmod n$定义 $\\mathbb{Z}_n^*$的规模表示为欧拉phi函数($\\phi(n)$) \\phi(n)=n\\prod\\limits_{p:\\text{p is prime and }p\\mid n}(1-\\frac{1}{p})直观理解(类似筛法求质数思想)：开始有一张$n$个余数组成的表，然后对于每个能整除$n$的素数$p$,在表中划掉所有$p$的倍数。 若$p$是素数，则$\\phi(p)=p-1$ 若$n$是合数，\\frac{n}{e^\\gamma\\ln\\ln n+\\frac{3}{\\ln\\ln n}}","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"}]},{"title":"问题求解学习笔记-数论基础","slug":"ps-4-6-basic-number-theory","date":"2019-03-30T06:49:23.000Z","updated":"2019-06-18T09:18:23.495Z","comments":true,"path":"2019/03/30/ps-4-6-basic-number-theory/","link":"","permalink":"https://mengzelev.github.io/2019/03/30/ps-4-6-basic-number-theory/","excerpt":"","text":"数学归纳法你都懂的 辗转相除法(Division Algorithm)定理2.9(辗转相除法): $a,b$为整数，满足$b&gt;0$，则存在唯一的整数$q$和$r$使得$a=bq+r$，此处$0\\le r&lt;b$ $a\\mid b$: $a$能整除$b$,$b$能被$a$整除 定理2.10: $a,b$为非零整数，则存在整数$r,s$使得gcd($a,b)=ar+bs$. $gcd(a,b)$是唯一的。但$r,s$不唯一 推论2.11: $a,b$为互质的整数，则存在整数$r,s$使得$ar+bs=1$【事实上是当且仅当的关系】 欧几里得算法(The Euclidean Algorithm)使用多次除法得到一个递减的序列来求出gcd$(a,b)$$b=aq1+r$$a=r_1q_2+r_2$$r_1=r_2q_3+r_3$$\\vdots$$r{n-2}=r{n-1}a_n+r_n$$r{n-1}=rnq{n+1}$将这一系列等式反过来书写可以得到$d$的表示(略) 质数引理2.13(Euclid): $a,b$为整数，$p$为质数。如果$p\\mid ab$,则$p\\mid a$或$p\\mid b$ 定理2.14(Euclid): 质数的个数是无限的 定理2.15(算术基本定理Fundamental Theorem of Arithmetic): $n$为大于1的整数，则$n=p_1p_2\\cdots p_k$，其中$p_1,…,p_k$为质数。这个分解是唯一的，即若$n=q_1q_2\\cdots q_l$，则$k=l$且$q_i$只是$p_i$的排列 以下内容出自CZ $\\mathbb{Z}_n$上的乘法逆元乘法逆元(multiplicative inverse): $a’\\cdot_{n}a=1$,则称$a’$是$a$在$\\mathbb{Z}_n$中的乘法逆元 引理2.5: 设$a$在$\\mathbb{Z}n$中存在乘法逆元$a’$. 则对于任意$b\\in\\mathbb{Z}_n$,等式$a\\cdot{n}x=b$有唯一解$x=a’\\cdot_{n}b$. 推论2.6: 若存在$b\\in\\mathbb{Z}n$使得$a\\cdot{n}x=b$的$a$无解，则$a$在$\\mathbb{Z}_n$上不存在乘法逆元 定理2.7: 若$\\mathbb{Z}_n$中的元素有一个乘法逆元，则它的乘法逆元是唯一的。因此可以用$a^{-1}$来表示乘法逆元。 引理2.8: $a\\cdot_{n}x=1$有解当且仅当存在整数$x,y$使得$ax+ny=1$ 定理2.9: $a$在$\\mathbb{Z}_n$中有乘法逆元当且仅当存在整数$x,y$使得$ax+ny=1$ 推论2.10: 若$a\\in\\mathbb{Z}_n$且$x,y$是满足$ax+ny=1$的整数，则$a$在$\\mathbb{Z}_n$中的乘法逆元是$x\\bmod n$ 引理2.11: 若存在整数$x,y$使得$ax+ny=1$，则$a,n$互质 定理2.12(欧几里得除法定理): 同最TJ的定理2.9 引理2.13: 若$j,k,q,r$是满足$k=jq+r$的正整数，则gcd($j,k$)=gcd($r,j$) 欧几里得扩展算法其实就是计算$x$和$y$的算法 定理2.15: 两个正整数$j$和$k$互质当且仅当存在整数$x,y$使得$jx+ky=1$ 推论2.16: 对于任意正整数$n$A，$\\mathbb{Z}_n$的元素$a$有乘法逆元当且仅当$gcd(a,n)=1$ 推论2.17: 对任意质数$p$,$\\mathbb{Z}_p$的任意非零元素存在乘法逆元。 计算乘法逆元跑欧几里得算法求出满足$ax+ny=1$的$x$,就是$a$在$\\mathbb{Z}_n$中的乘法逆元","categories":[],"tags":[]},{"title":"算法导论学习笔记-字符串匹配","slug":"clrs-32String-Mathcing","date":"2019-03-23T06:42:50.000Z","updated":"2019-03-23T15:40:43.447Z","comments":true,"path":"2019/03/23/clrs-32String-Mathcing/","link":"","permalink":"https://mengzelev.github.io/2019/03/23/clrs-32String-Mathcing/","excerpt":"","text":"基本知识问题的形式化定义 文本是一个长度为$n$的数组$T[1,…n]$ 模式是一个长度为$m$的数组$P1,…m$ $P$和$T$的元素都是来自一个有限字母集$\\Sigma$的字符 若$0\\le s\\le n-m$,且$T[s+1,…s+m]=P[1,…m]$,则称模式$P$在文本$T$中出现，且偏移为$s$(模式$P$在文本$T$中出现的位置是$s+1$开始的) 如果$P$在$T$中以偏移$s$出现，那么称$s$是有效偏移，否则是无效偏移 字符串匹配问题：找到所有的有效偏移 算法总运行时间=预处理时间+匹配时间 符号和术语 $\\Sigma^*$: 包含所有有限长度的字符串的集合 $\\varepsilon$: 长度为0的空字符串，$\\varepsilon\\in\\Sigma^*$ $|x|$: 字符串$x$的长度 $xy$: 两个字符串$x$和$y$的连结(concatenation) 若对某个字符串$y\\in \\Sigma^$有$x=wy$，则称字符串$w$是字符串$x$的*前缀，记作$w\\sqsubset x$ 若对某个字符串$y$有$x=yw$，则称字符串$w$是字符串$x$的后缀，记作$w\\sqsupset x$ 空字符串$\\varepsilon$同时是任何一个字符串的前缀和后缀 $x\\sqsupset y$当且仅当$xa\\sqsupset ya$ $\\sqsubset$和$sqsupset$都是传递关系 引理32.1(后缀重叠引理): 假设$x,y$满足$x\\sqsupset z$和$y\\sqsupset z$的字符串。如果$|x|\\le |y|$, 那么$x\\sqsupset y$; 如果$|x|\\ge |y|$, 那么$y\\sqsupset x$; 如果$|x|=|y|$, 那么$x=y$ 把模式$P[1..m]$的由$k$个字符组成的前缀$P[1..k]$记作$P_k$，因此$P_0=\\varepsilon$,$P_m=P=P[1..m]$ 把文本$T$中由$k$个字符组成的前缀记为$T_k$ 采用这种记号，字符串匹配问题能被表述为：找到所有偏移$s(0\\le s\\le n-m)$, 使得$P\\sqsupset T_{s+m}$ 假设：检测$x==y$需要时间$\\Theta(t+1)$，其中$t$是满足$z\\sqsubset x$和$z\\sqsubset y$的最长字符串$z$的长度 朴素字符串匹配算法通过循环找到所有有效偏移对$n-m+1$个可能的$s$进行检测 运行时间最坏情况下：$O((n-m+1)m)$无预处理时间 Rabin-Karp算法为了便于说明，假设$\\Sigma={0,1,2,…,9}$在通常情况下可以假定每个字符都是以$d$为基数表示的数字$p$: 模式$P$表示的十进制值$t_s$: 文本$T[s+1..s+m]$对应的十进制值把字符串匹配转化为数值匹配 计算$t1,…t_s$时，可以根据$t_s$计算$t{s+1}$ t_{s+1}=10(t_s-10^{m-1}T[s+1])+T[s+m+1](去掉高位数字，左移，加上低位数字) 如果$p$和$t_s$的值太大，可以选取一个合适的模$q$来计算$p$和$t_s$的模在一般情况下，选取一个$q$，使得$dq$在一个计算机字长内，调整递归式 t_{s+1}=(d(t_s-T[s+1]h)+T[s+m+1])\\mod~q其中$h\\equiv d^{m-1}(mod q)$是一个具有$m$数位的文本窗口的高位数位上的数字”1”的值 运行过程 计算所有长度为$m$的文本窗口对$q$取模的值 找出$t_s\\equiv q(\\mod~q)$的$s$值(伪命中点) 进行字符串匹配检验 伪代码 去除$t$的下标不会影响程序运行 循环不变量：$t_s=T[s+1…s+m]\\mod~q$ 运行时间预处理：$\\Theta(m)$最坏情况运行时间: $\\Theta((n-m+1)m)$(e.g.$P=a^m$且$T=a^n$时需要对所有可能进行字符串匹配验证，相当于退化为朴素算法) 若有效便宜只有常数$c$个，算法的期望匹配时间为$O((n-m+1)+cm)=O(n+m)$ 若假设$q$是从适当大的整数中随机得出的，则伪命中的次数为$O(n/q)$(因为任意$t_s$模A$q$与$p$同余的概率为$1/q$)。 第10行中的测试会在$O(n)$个位置上失败，每次命中的时间代价是$O(m)$。因此Rabin-Karp算法的期望运行时间是O(n)+O(m(v+n/q))其中$v$为有效偏移量 若选取的素数$q$大于模式的长度，则可以估计Rabin-Karp算法的匹配时间为$O(n+m)=O(n)$ 利用有限自动机进行字符串匹配有限自动机一个有限自动机$M$是一个五元组$(Q,q_0,A,\\Sigma,\\delta)$,其中： $Q$是状态的有限集合 $q_0\\in Q$是初始状态 $A\\subseteq Q$是一个特殊的接受状态集合 $\\Sigma$是有限输入字母表 $\\delta$是一个从$Q\\times\\Sigma$到$Q$的函数，称为$M$的转移函数 状态转移 开始状态为$q_0$，每次读入输入字符串的一个字符 如果在状态$q$时读入字符$a$，就从状态$q$变为状态$\\delta(q,a)$(进行了一次转移) 当前状态$q\\in A$时，就说$M$接受了迄今为止所读入的字符串，没有被接受的输入称为被拒绝的输入 终态函数终态函数$\\phi:\\Sigma^*\\to Q$$\\phi(w)$: $M$在扫描字符串$w$后终止时的状态当且仅当$\\phi(w)\\in A$时，$M$接受字符串$w$ 用转移函数递归定义$\\phi$: \\phi(\\varepsilon)=q_0,\\phi(wa)=\\delta(\\phi(w),a), ~~w\\in\\Sigma^*,a\\in\\Sigma字符匹配自动机后缀函数$\\sigma:\\Sigma^*\\to{0,1,…,m}$，满足$\\sigma(x)$是同时是$x$的后缀和$P$的前缀的字符串的长度 \\sigma(x)=\\max\\{k:P_k\\sqsupset x\\}对于任意的状态$q$和字符串$a$，转移函数$\\delta$定义如下： \\delta(q,a)=\\sigma(P_qa)记录已得到的与模式$P$匹配的文本字符串$T$的最长前缀 匹配时间为$\\Theta(n)$ 正确性证明引理32.2(后缀函数不等式): 对任意字符串$x$和字符$a$，$\\sigma(xa)\\le\\sigma(x)+1$ 引理32.3(后缀函数递归引理): 对任意$x$和字符$a$，若$q=\\sigma(x)$,则$\\sigma(xa)=\\sigma(P_qa)$ 定理32.4: 如果$\\phi$是字符串匹配自动机关于给定模式$P$的终态函数，$T[1..n]$是自动机的输入文本，则对$i=0,1,..,n,\\phi(T_i)=\\sigma(T_i)$(终态函数的值=后缀函数的值) 计算转移函数 计算转移函数的运行时间为$O(m^3|\\Sigma|)$，可以改进为$O(m\\Sigma)$","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"}]},{"title":"问求学习笔记-群同构基本定理与正规子群","slug":"ps-4-4-isomorphism","date":"2019-03-14T08:20:40.000Z","updated":"2019-06-18T03:21:47.200Z","comments":true,"path":"2019/03/14/ps-4-4-isomorphism/","link":"","permalink":"https://mengzelev.github.io/2019/03/14/ps-4-4-isomorphism/","excerpt":"","text":"同构(Isomorphisms)定义对两个群$(G,\\cdot)$和$(H,\\circ)$，若存在一个保群运算的双射$\\phi:G\\to H$，即对于任意$a,b\\in G$ \\phi(a\\cdot b)=\\phi(a)\\circ\\phi(b)则称$G$和$H$同构(isomorphic)，记作$G\\cong H$. $\\phi$称为同构函数(isomorphism)。 基本定理定理9.6: Let $\\phi: G\\to H$ be an isomorphism of two groups. Then the following statements are true. $\\phi^{-1}:H\\to G$ is an isomorphism (废话) $|G|=|H|$ (废话) If $G$ is abelian, then $H$ is abelian. If $G$ is cyclic, then $H$ is cyclic. If $G$ has a subgroup of order $n$, then $H$ has a subgroup of order $n$. 定理9.7: All cyclic groups of infinite order are isomorphic to $\\mathbb{Z}$. 无穷阶循环群与$\\mathbb{Z}$同构。 定理9.8: If $G$ is a cyclic group of order $n$, then $G$ is isomorphic to $\\mathbb{Z}_n$. 推论9.9: If $G$ is a group of order $p$, where $p$ is a prime number, then $G$ is isomorphic to $\\mathbb{Z}_p$. (不需要是循环群) 定理9.10: The isomorphism of groups determines an equivalence relation on the class of all groups. 群的同构关系将群划分成等价类。 Cayley’s Theorem定理9.12(Cayley定理): Every group is isomorphic to a group of permutations. 任意群都与一个置换群同构。 The isomorphism $g\\mapsto \\lambda_g$ is known as the left regular representationof G. 直积(Direct Products)qlz管它叫直和 外直积定义运算G\\times H: (g_1,h_1)(g_2,h_2)=(g1\\cdot g_2, h_1\\circ h_2) 命题9.13: Let $G$ and $H$ be groups. The set $G\\times H$ is a group under the operation $(g_1,h_1)(g_2,h_2)=(g1\\cdot g_2, h_1\\circ h_2)$ where $g_1, g_2\\in G$ and $h_1, h_2\\in H$. 群$G\\times H$称为$G$和$H$的外直积(external direct product) 定理9.17: 设$(g,h)\\in G\\times H$. 若$g$和$h$分别为有限阶$r$和$s$,则$(g,h)$在$G\\times H$中的阶数是$r$和$s$的最小公倍数(least common multiple) 推论9.18: 设$(g_1,…g_n)\\in \\prod G_i$. 若$g_i$在$G_i$中为有限阶$r_i$，则$(G-1,..g_n)$在$\\prod G_i$中的阶数为$lcm(r_1,…r_n)$. 定理9.21: 群$\\mathbb{Z}m\\times\\mathbb{Z}_n$与$Z{mn}$同构当且仅当$m,n$互质($gcd(m,n)=1$). (From定理9.17) 推论9.22: $n1,…n_k$为正整数，则$\\prod\\limits{i=1}^{k}\\mathbb{Z}_{n_1…n_k}$当且仅当$gcd(i,j)=1$对任意$i\\neq j$恒成立。 内直积(Internal Direct Product)外直积把小群组建成大群，内直积把大群打碎成小群 群$G$拥有子群$H,K$满足以下条件: $G=HK={hk:h\\in H, k\\in K}$ $H\\cap K={e}$ $hk=kh$ for all $k\\in K$ and $h\\in H$ 称$G$是$H$和$K$的内直积 不是所有的群都可以写成其真子群的内积的形式 定理9.27: 设$G$是其子群$H$和$K$的内直积，则$G$与$H\\times K$同构。(外直积群与内直积群同构) 推广到多维： $G=H_1H_2…H_n={h_1h_2…h_n:h_i\\in H_i}$ $Hi\\cap\\left\\langle \\cup{j\\neq i}H_j\\right\\rangle={e}$ $H_ih_j=h_jh_i$ for all $h_i\\in H_i$ and $h_j\\in H_j$ 定理9.29: 若$G$是其子集$H_i(i=1,2,…n)$的内直积，则$G$与$\\prod_i H_i$同构 正规子群(Normal Subgroups)若对任意$g\\in G$有$gH=Hg$, 则称$H$是$G$的正规子群。(左陪集与右陪集相同)交换群的所有子群都是正规的。 定理10.3: 设$N$为$G$的子群，则如下命题等价： $N$是$G$的正规子群 $\\forall g\\in G, gNg^{-1}\\subseteq N$. $\\forall g\\in G, gNg^{-1}=N$. 商群(Factor Group)定理10.4: $N$为$G$的正规子群，$N$在$G$中的陪集构成了一个群$G/N$, 阶为$[G:N]$(复习: $[G:N]=|G|/|N|$). 该群的运算为$(aN)(bN)=abN$.这个群被称为商群(fatcor or quotient group).$eN=N$是单位元，$g^{-1}N$是$gN$的逆元。商群是集合组成的群。简记为$N\\triangleleft G$ 对于正多边形旋转群$D_n$, 旋转群$R_n$是$D_n$的一个正规子群。 交替群的简单性单群(simple group): 没有非平凡正规真子群的群 e.g.$\\mathbb{Z}_p$($p$为质数) 引理10.8: 替换群$A_n(n\\ge 3)$是由3-cycles生成的。 引理10.9: $N$是$A_n(n\\ge 3)$的正规子群.若$N$包含了一个3-cycle，则$N=A_n$. 引理10.10: 对$n\\ge 5$, $A_n$的每一个非平凡正规子群$N$都包含一个3-cycle. 引理10.11: $n\\ge 5$的替换群$A_n$是单群。 同态(homomorphism)两个群$(G,\\cdot)$和$(H,\\circ)$间的同态函数是一个映射$\\phi:G\\to H$，满足$\\phi(g_1\\cdot g_2)=\\phi(g_1)\\circ\\phi(g_2)$,其中$g_1,g_2\\in G$.$\\phi$在$H$中的值域被称为同态像(homomorphism image).若$\\phi$是双射，则$G$和$H$同构。 命题11.4: 设$\\phi:G_1\\to G_2$是群间的同态函数，则 若$e$是$G_1$的单位元，则$e$是$G_2$的单位元 对于任意$g\\in G_1$, $\\phi(g^{-1})=[\\phi(g)]^{-1}$ 若$H_1$是$G_1$的子群，则$\\phi(H_2)$是$G_2$的子群 若$H_2$是$G_2$的子群，则$\\phi^{-1}(H_2)={g\\in G_1: \\phi(g)\\in H_2}$是$G_1$的子群。此外，若$H_2$是$G_2$的正规子群，则$\\phi^{-1}(H_2)$是$G_1$的正规子群 由命题11.4知，$\\phi^{-1}({e})$是$G$的子群，这个子群被称为$\\phi$的核(kernel),记为$ker\\phi$. 该子群是正规的。 定理11.5： 设$\\phi:G\\to H$是群的同态函数，则$\\phi$的核是$G$的一个正规子群潜台词：对于每一个同态函数都能找到一个正规子群$ker\\phi$ 核函数可以用来推测两个群间是否存在单射同态函数。(e.g. Example11.9 $\\mathbb{Z}7$与$\\mathbb{Z}{12}$不存在单射同态函数) 同态定理设$H$是$G$的正规子群。定义自然同态函数或规范同态函数(natural or canonical homomorphism) \\phi:G\\to G/H为\\phi(g)=gH该同态函数的核为$H$ 定理11.10(第一同态定理): 若$\\varphi:G\\to H$是核为$K$的同态函数， 则$K$是$G$的正规子群。设$\\phi:G\\to G/K$是规范同态函数。则存在唯一的同构函数$\\eta:G/K\\to\\varphi(G)$使得$\\varphi=\\eta\\phi$ 规范同态函数产生的商群与原同态函数的像同构 定理11.12(第二同态定理): 设$H$是$G$的子群(不需要正规)，$N$是$G$的正规子群，则$HN$是$G$的子群，$H\\cap N$是$H$的正规子群，且 H/H\\cap N\\cong HN/N定理11.13(一致性定理): 设$N$是$G$的正规子群，则$H\\mapsto H/N$是包含$N$的子群$H$的集合与$G/N$的子群的集合间的一对一关系。此外，包含$N$的$G$的正规子群与$G/N$的正规子群相对应。 定理11.14(第三同构定理): 设$N$和$H$是$G$的正规子群满足$N\\subseteq H$,则G/H\\cong\\frac{G/N}{H/N}. (可以当成分数来直观理解)","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Group Theory","slug":"Group-Theory","permalink":"https://mengzelev.github.io/tags/Group-Theory/"}]},{"title":"问求学习笔记-置换群与拉格朗日定理","slug":"ps-4-3-permutation-lagrange","date":"2019-03-09T09:15:13.000Z","updated":"2019-06-17T14:18:27.347Z","comments":true,"path":"2019/03/09/ps-4-3-permutation-lagrange/","link":"","permalink":"https://mengzelev.github.io/2019/03/09/ps-4-3-permutation-lagrange/","excerpt":"","text":"置换群(Permutation Group)定理5.1:The symmetric group on $n$ letters, $S_n$, is a group with $n!$ elements, wherethe binary operation is the composition of maps. 置换群(permutation group):所有排列的集合$S_n$的一个子集 Cycle NotationA permutation $\\sigma\\in S_X$ is a cycle of length $k$ if there exist elements $a_1,a_2,…a_k\\in X$ such that \\sigma(a_1) = a_2\\sigma(a_2) = a_3...\\sigma(a_k) = a_1and $\\sigma(x)=x$ for all other elements $x\\in X$. We write $(a_1,a_2,…a_k)$ to denote the cycle $\\sigma$. Cycles are the building blocks of all permutations.循环是所有排列的基石。 Two cycles in $S_X$, $\\sigma=(a_1,a_2,…a_k)$, $\\tau=(b_1,b_2,…b_l)$, are disjoint if $a_i\\neq b_j$ for all $i$ and $j$ 命题5.8: Let $\\sigma$ and $\\tau$ be 2 disjoint cycles in $S_X$. Then $\\sigma\\tau=\\tau\\sigma$. 定理5.9: $S_n$中的所有排列都可以被写成不相交循环的乘积的形式。 Transpositions: a cycle of length 2 (任意两个数交换位置) 命题5.12: 任意至少含有两个元素的有限集的排列都可以写成transposition乘积的形式e.g. (253)=(23)(25) 引理5.14: identity(恒等变换)只能写成偶数个transposition的乘积的形式 定理5.15: 如果一个排列能被写成偶数个置换乘积的形式，那么另一个与之等价的排列也一定拥有偶数项置换乘积。奇数同理。据此定理可以将排列分为奇偶两类 交替组(The Alternating Groups)交替组$A_n$是所有偶排列的集合 定理5.16: 集合$A_n$是$S_n$的子群 命题5.17: $S_n$中奇排列和欧排列的数目相等，都为$n!/2$ 反组(Dihedral Groups)the nth dihedral group($D_n$): the group of rigid motions of a regular n-gon(正多边形的刚性运动=转动+反射) 定理5.20: $D_n$ is a subgroup of $S_n$ of order $2n$ 定理5.23: The group $D_n$, $n\\ge 3$, consists of all products of the two elements $r$ and $s$, satisfying the relations r^n=1s^2=1srs=r^{-1}($r,s$分别为转动和反射) D_n=\\{1,r,r^2,..,r^{n-1},s,sr,sr^2,...,sr^{n-1}\\}立方体的运动命题5.27: The group of rigid motions of a cube contains 24 elements. 命题5.28: The group of rigid motions of a cube is $S_4$.(看体对角线) 陪集(Coset)$G$为群，$H$为$G$的子群，定义左陪集(left coset): $gH={gh:~h\\in H}$右陪集(left coset): $Hg={hg:~h\\in H}$ (这真的不是汞吗)其中$g\\in G$称为代表元(representative) 在交换群中，左陪集与右陪集是相同的。 引理6.3: $g_1,g_2\\in G$，以下条件等价:$1. g_1H=g_2H$;$2. Hg_1^{-1}=Hg_2^{-1}$;$3. g_1H\\subset g_2H$;$4. g_2\\in g_1H$;$5. g_1^{-1}g_2\\in H$; 定理6.4: $H$为$G$的子群。$H$的左陪集分割(partition)了$G$,即$G$是$H$的左陪集的disjoint union. (右陪集同理) index of $H$: the number of left cosets of $H$ in $G$. 表示为$[G:H]$ 定理6.8: $H$在$G$中的左陪集与右陪集的个数相等。 拉格朗日定理命题6.9: 定义映射$H\\to gH$ by $\\phi(h)=gh$. 该映射是双射，$H$中元素的个数等于$gH$中元素的个数。 定理6.10(拉格朗日定理): Let $G$ be a finite group and let $H$ be a subgroup of $G$. Then $|G|/|H|=[G:H]$ is the number of distinct left cosets of $H$ in $G$. In particular, the number of elements in $H$ must divide the number of elements in $G$. |G|=[G:H]|H|推论6.11: Suppose that $G$ is a finite group and $g\\in G$. Then the order of $g$ must divide the number of elements in $G$. 推论6.12: Let $|G|=p$ with $p$ a prime number. Then $G$ is cyclic and any $g\\in G$ such that $g\\neq e$ is a generator. 含有质数个元素的群为循环群且任何非单位元的元素都是生成元。 推论6.13: Let $H$ and $K$ be subgroups of a finite group $G$ such that $G\\supset H\\supset K$. Then $[G:K]=[G:H][H:K]$. 拉格朗日定理的逆命题是不成立的 命题6.15: The group $A_4$ has no subgroup of order 6. 定理6.16: Two cycles $\\tau$ and $\\mu$ in $S_n$ have the same length if and only if there exists a $\\sigma\\in S_n$ such that $\\mu=\\sigma\\tau\\sigma^{-1}$. 费马与欧拉定理欧拉函数$\\phi(n)$表示$n$以内与$n$互质的数的个数对任意质数$p$, $\\phi(p)=p-1$ 定理6.17: Let $U(n)$ be the group of units in $\\mathbb{Z}_n$. Then $|U(n)|=\\phi(n)$ 怎么又是欧拉定理6.18(欧拉定理): Let $a$ and $n$ be integers such that $n&gt;0$ and $gcd(a,n)=1$. Then $a^{\\phi(n)}\\equiv 1\\pmod n$ 定理6.19(费马小定理): Let $p$ be any prime number and suppose that $p\\nmid a$($p$ does not divide $a$). Then $a^{p-1}\\equiv 1\\pmod p$.Furthermore, for any integer $b$, $b^p\\equiv b\\pmod p$.","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Group Theory","slug":"Group-Theory","permalink":"https://mengzelev.github.io/tags/Group-Theory/"}]},{"title":"问求学习笔记-群论初步","slug":"ps-4-2-group","date":"2019-03-02T06:03:29.000Z","updated":"2019-06-17T09:30:57.511Z","comments":true,"path":"2019/03/02/ps-4-2-group/","link":"","permalink":"https://mengzelev.github.io/2019/03/02/ps-4-2-group/","excerpt":"","text":"由于接下来的书没有中文版了，因此笔记中英文都看心情 群整数等价类命题3.4：模运算下的整数等价类具有以下性质： 加法和乘法交换律 加法和乘法结合律 加法(0)与乘法(1)恒等式 乘法分配律 任意元素都存在加法逆元 $a$为非零整数，$gcd(a,n)=1$当且仅当$a$存在乘法逆元，即存在非零整数$b$，使得$ab\\equiv 1(mod n)$ (虽然我觉得这玩意儿记了应该没什么卵用)【复习时的我回来打脸了 定义 二元运算(binary operation)或合成律(law of composition):a function $G\\times G\\to G$ that assigns to each pair $(a,b)\\in G\\times G$ a unique element $a\\circ b$, or $ab$ in $G$, called the composition of $a$ and $b$ 群(group): a set $G$ together with a law of composition $(a,b)\\mapsto a\\circ b$ that satisfies the following axioms: 合成律满足结合律(asscociative) 存在单位元(identity element)$e\\in G$，满足$e\\circ a = a\\circ e = a$ 对于每个$a\\in G$，都存在逆元$a^{-1}$，使得$a\\circ a^{-1}=a^{-1}\\circ a=e$ 群 = 运算封闭+结合律+单位元+逆元 阿贝尔群(Abelian)或交换群(commutative):满足$a\\circ b=b\\circ a$的群，反之为nonabelian或noncommutative 凯莱表(Cayley table):用加法或乘法描述群的表格 可逆元素群(group of units): 拥有逆元的元素组成的群 一般线性群(general linear group) 四元群(quaternion group) 群是有限的(finite)，或者说有有限序数(has finite order)，当它具有有限个元素，否则是无限的(infinite)或有无限序数(infinite order) 群的基本性质命题3.17: 群中的单位元是唯一的命题3.18: 逆元是唯一的命题3.19: $G$是群，$a,b\\in G$，则$(ab)^{-1}=b^{-1}a^{-1}$命题3.20: $(a^{-1})^{-1}=a$命题3.21: $ax=b$和$xa=b$在$G$中有唯一解命题3.22(左右消去律right and left cancellation law): $ba=ca$ implies $b=c$ and $ab=ac$ implies $b=c$ 对群中的元素，可以定义乘方 定理3.23: 在群中，一般指数的运算律成立 子群 子群(subgroup):仿照子空间的定义 平凡子群(trivial subgroup):$H={e}$ 真子群(proper subgroup) 子群必须继承群的二元运算 子群相关的定理命题3.30: $G$的子集$H$是子群当且仅当 $G$的单位元$e\\in H$ $H$对$G$的运算封闭：If $h_1,h_2\\in H$, then $h_1h_2\\in H$ If $h\\in H$, then $h^{-1}\\in H$ 命题3.31: $H$是$G$的子群当且仅当$H\\neq\\emptyset$ and whenever $g,h\\in H$ then $gh^{-1}$ is in $H$ 循环子群(Cyclic Subgroups)定理4.3: Let $G$ be a group and $a$ be any element in $G$. Then the set $\\left⟨a\\right⟩={a^k:k\\in\\mathbb{Z}}$is a subgroup of $G$. Furthermore, $⟨a⟩$ is the smallest subgroup of $G$ that contains $a$. 循环子群(Cyclic Subgroup):$⟨a⟩$循环群(Cyclic group): 包含了某个元素$a$，使得$G=⟨a⟩$.此时$⟨a⟩$是$G$的生成器(generator).The order of $a$: 最小的整数$n$满足$a^n=e$，表示为$|a|=n$。如果不存在满足要求的$n$，则称$a$是无穷的(infinite)，表示为$|a|=\\infty$e.g. $\\mathbb{Z}$和$\\mathbb{Z}_n$都是循环群，1和-1是$\\mathbb{Z}$的生成器，1是$\\mathbb{Z}_n$的生成器但不一定是唯一的。 定理4.9: 所有循环群都是可交换的。(Every cyclic group is abelian). 定理4.10: 循环群的子群都是循环子群。(Every subgroup of a cyclic group is cyclic.) 引理4.11: The subgroups of $\\mathbb{Z}$ are exactly $n\\mathbb{Z}$ for $n=0,1,2…$ 命题4.12: Let $G$ be a cyclic group of order $n$ and suppose that $a$ is a generatorfor $G$. Then $a^k = e$ if and only if $n$ divides $k$.($n$能整除$k$,$k$能被$n$整除) 定理4.13: Let $G$ be a cyclic group of order $n$ and suppose that $a\\in G$ is a generatorof the group. If $b = a^k$, then the order of $b$ is $n/d$, where $d = gcd(k, n)$. 引理4.14: The generators of $\\mathbb{Z}_n$ are the integers $r$ such that $1\\le r&lt; n$ and$gcd(r,n) = 1$. $\\mathbb{Z}_n$的生成器与$n$互质。 复数乘法群(Multiplicative Group of Complex Numbers)一堆复数的基础知识……. $r(\\cos\\theta+i\\sin\\theta)$ 会被简写为 $r~cis\\theta$ 命题4.20: $z=r~cis\\theta$ and $w=s~cis\\phi$. Then $zw=rs~cis(\\theta+\\phi)$ 圆群(The circle group)定义: \\mathbb{T}=\\{z\\in\\mathbb{C}: |z|=1\\} 命题4.24: 圆群是$\\mathbb{C}^*$的子群 定理4.25: If $z^n=1$, then the nth roots of unity are z=cis(\\frac{2k\\pi}{n})where $k-0,1,…n-1$. Furthermore, the nth roors of unity form a cyclic subgroup of $\\mathbb{T}$ of order $n$. A generator for the group of the nth roots of unity is called a primitive nth root ofunity. 重复平方法(The Method of Repeated Squares)其实就是快速幂 理论基础: If $b\\equiv a^x (\\mod n)$ and $c\\equiv a^y (\\mod n)$, then $bc\\equiv a^{x+y}(\\mod n)$$(a^{2n})^2\\equiv a^{2\\cdot 2n}\\equiv a^{2^{n+1}}(\\mod n)$","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Group Theory","slug":"Group-Theory","permalink":"https://mengzelev.github.io/tags/Group-Theory/"}]},{"title":"2019年寒假计划(flags)","slug":"2019-winter-flags","date":"2019-02-17T16:00:00.000Z","updated":"2019-01-31T10:11:55.613Z","comments":true,"path":"2019/02/18/2019-winter-flags/","link":"","permalink":"https://mengzelev.github.io/2019/02/18/2019-winter-flags/","excerpt":"","text":"美赛准备 MATLAB入门《MATLAB数学工具软件实例简明教程》 《MATLAB在数学建模中的应用》 研读优秀论文，总结模板 项目 学习Python 分析minilab的git log中的CE数据 HK学术竞赛 等打完美赛再来研究 番剧追番 多罗罗 灵能百分百第二季 关于我转生成为史莱姆的这档事 强风吹拂 不吉波普不笑 约定的梦幻岛 补番 战栗杀机 小林家的龙女仆 吉他 看B站教学视频","categories":[{"name":"Flags","slug":"Flags","permalink":"https://mengzelev.github.io/categories/Flags/"}],"tags":[{"name":"Flags","slug":"Flags","permalink":"https://mengzelev.github.io/tags/Flags/"}]},{"title":"算法导论学习笔记-线性规划","slug":"clrs-29Linear-Programming","date":"2019-02-13T12:28:03.000Z","updated":"2019-06-16T06:39:36.166Z","comments":true,"path":"2019/02/13/clrs-29Linear-Programming/","link":"","permalink":"https://mengzelev.github.io/2019/02/13/clrs-29Linear-Programming/","excerpt":"","text":"知识背景 一个线性规划问题是一个线性函数最小化或最大化的问题，该线性函数服从一组有限个线性约束，分为最小化线性规划和最大化线性规划 可行解：所有满足约束条件的自变量的取值 可行区域：所有可行解在二维空间中构成的凸区域 目标函数：希望最大化的函数 目标值：目标函数在一个特定点上的值 最优解：所有目标值中最大的一个，其目标值为最优目标值 不可行的：一个线性规划没有可行解 无界的：一个线性规划有可行解但没有有限的最优目标值 标准型和松弛型标准型 所有的约束都是不等式 标准型=目标函数+约束+非负约束 重写为向量与矩阵的形式，可以用一个元组$(A,b,c)$来表示一个标准型的线性规划 最大化c^Tx满足约束Ax\\le b x\\ge 0 线性规划的等价：对两个最大化线性规划$L$和$L’$，如果对$L$的每个目标值为$z$的可行解$\\overline{x}$，都存在一个对应的$L’$的目标值为$z$的可行解的$\\overline{x}’$；(反过来同理)，则称$L$和$L’$是等价的。 最小化线性规划和目标函数取负后得到的最大化线性规划是等价的 非标准型的标准化 目标函数是最小化：取负 某些变量不具有非负约束：假设$xj$无非负约束，则将所有出现的$x_j$替换为$x{j}’-x{j}’’$，并令$x{j}’\\ge 0, x_{j}’’\\ge 0$ 存在等式约束：$\\ge + \\le$ 存在大于等于约束：取负 松弛型 松弛变量$s=bi-\\sum\\limits{j=1}^{n}a_{ij}x_i,s\\ge 0$ 只有非负约束是不等式，其余都是等式 当从标准型转换到松弛型时，我们将使用$x{n+i}$表示与第$i$个不等式相关的松弛变量$$x{n+i}=bi-\\sum\\limits{j=1}^{n}a{ij}x_i,x{n+i}\\ge 0$$ 基本变量：等式左边的变量 非基本变量：等式右边的变量 有时描述时会省略词语“最大化”和“满足约束”以及明显的非负约束要求 简洁记号 $N$:非基本变量下标的集合 $B$:基本变量下标的集合 $N\\cup B={1,2,…,n+m}$ 用一个元组$(N,B,A,b,c,v)$来表示松弛型 这里的$a_{ij}$是“出现”在松弛型中的 负数 $A,b,c$的小标不必是连续整数的集合，依赖于索引集合$B$和$N$ 将问题表达为线性规划单对最短路径如下的线性规划可以计算从$s$到$t$的最短路径权值 之所以是最大化目标函数，是因为最短路径问题的一个最优解把每一个$\\overline{d}_v$设置成所有$\\overline{d}_u+w(u,v)$的最小值，使得$\\overline{d}_v$是小于等于集合${\\overline{d}_u+w(u,v)}$所有值的最大值；而最小化目标函数会使所有$\\overline{d}_v=0$，这个解显然没有意义 最大流最大流问题表示为一个线性规划 这个线性规划可以重写为有$O(V+E)$个约束的表示，这样计算起来会更高效 最小费用流问题描述 最大流的推广 每条边除了容量还有费用值$a(u,v)$。如果通过边$(u,v)$传送了$f{uv}$个单位的流，那么产生了一个费用$a(u,v)f{uv}$。 求从$s$到$t$发送$d$个单位的流(流目标)，使得流上发生的总费用$\\sum\\limits{(u,v)\\in E}a(u,v)f{uv}$最小 最小费用流有专门设计的多项式时间算法，但算导上没有涉及到 线性规划建模 这不是很直观吗 多商品流问题描述 在最小费用流问题的基础上，有$k$种不同的商品$K_1,K_2,…,K_k$，其中用三元组$K_i=(s_i,t_i,d_i)$来详细说明商品的源点、汇点和需求 定义商品$i$的流$fi$，汇聚流为各种商品流的总和$f{uv}=\\sum\\limits{i=1}^{k}f{iuv}$ 不用最小化任何目标函数，只需要确定是否存在这样的一个流 线性规划建模 单纯形算法 求解线性规划的经典方法 在最坏情况下执行时间非多项式 在实际中次算法通常相当快速 可以看成不等式上的高斯消元法 主要思想 每轮迭代都关联一个“基本解” 从松弛型中得到“基本解” 将每个非基本变量设为0，并从等式约束中计算基本变量的值 每轮迭代把一个松弛型转换成一个等价的松弛型 如果一个非基本变量从0开始增加时目标值也增加(目标函数中系数为正)，则增加该非基本变量直到某基本变量为0 重写松弛型，交换此基本变量和选定的非基本变量，这个操作称为转动 一个转动选取一个非基本变量$x_e$(替入变量)和一个基本变量$x_l$(替出变量) 单纯型算法执行了两个操作 重写等式使得变量在等式的左边与右边之间移动 替换一个等式为另一个等式 这两个操作都建立了等价的问题 步骤 在目标函数中选一个最大正系数非基本变量$x_1$，尝试增大$x_1$，使得$z$增大(增大时必须满足约束条件) 找到最紧的约束，解出$x_1$ 将$x_1$代入系统中其他约束和目标函数【转动】 找到新系统的基本解 转动 输入：元组$(N,B,A,b,c,v)$，替出变量$x_l$的下标$l$(从左边调到右边),以及替入变量$x_e$的下标$e$(从右边调到左边)出入是相对非基本变量集合$N$而言的 输出：新松弛的元组$(\\hat{N},\\hat{B},\\hat{A},\\hat{b},\\hat{c},\\hat{v})$ 正式的单纯形算法SIMPLEX 输入：一个标准型的线性规划 输出：一个$n$维向量，表示该线性规划的一个最优解 假设INITIALIZE-SIMPLEX过程返回一个初始基本解可行的松弛型或不可解信息 3~12行：算法主体 如果都是目标函数所有系数为负，则while循环终止，否则第4行选择替入变量$x_e$ 5~9行检查每个约束，然后挑出一个最严格限制$x_e$增加幅度的约束相关联的基本变量$x_l$，如果没有约束能够限制替入变量增加的幅度，则在第11行返回无界 调用PIVOT交换替入变量和替出变量 13~16行吧所有非基本变量设为0，把基本变量$\\overline{x_i}$设为$b_i$ 17行返回这些值 循环不变式while循环每次迭代开始： 此松弛型等价于调用INITIALIZE-SIMPLEX返回的松弛型 对每个$i\\in B$，有$b_i\\ge 0$(保证新系统的基本解可行) 此松弛型相关的基本解是可行的 需要保证while循环终止，可以通过第4行和第9行总是选择具有最小下标的变量来打破目标值不变的局面 假设INITIALIZE-SIMPLEX返回一个基本解可行的松弛型，那么SIMPLEX要么报告一个线性规划是无界的，要么以一个可行解结束，且至多$(^{m+n}_{m})$次循环内终止 对偶性对偶性：给定一个最大化问题，我们定义一个相关的最小化问题，使得这两个问题具有同样的最优目标值(e.g.最大流最小割) 给定一个标准型的原式线性规划，我们定义其对偶线性规划为(将最大化改为最小化，交换右边系数与目标函数的系数) 弱对偶性：原式线性规划的任意可行解的值不大于此对偶线性规划的任意可行解的对应值 引理 29.8：线性规划对偶性 证明涉及大量数学推导 对偶问题都可以像最大流最小割一样，用来转移火力，找到一个等价的问题来求解原来的问题","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://mengzelev.github.io/tags/Graph-Algorithms/"}]},{"title":"SVM的临时抱佛脚for HK","slug":"SVM-getstart","date":"2019-02-12T06:28:39.000Z","updated":"2019-03-02T02:32:09.405Z","comments":true,"path":"2019/02/12/SVM-getstart/","link":"","permalink":"https://mengzelev.github.io/2019/02/12/SVM-getstart/","excerpt":"","text":"参考资料B站 机器学习（Machine Learning）- 吴恩达（Andrew Ng） 关于调参使用SVM需要指定的参数 参数$C$ $C$较大：小偏差，大方差 $C$较小：大偏差，小方差 核函数(kernel)的选择 线性核函数(Linear Kernel/No Kernel) 高斯核函数(Gaussian Kernel) 以上是两个最常用的核函数 多项式核函数 字符串核函数 卡方核函数 …. $n=$number of features, $m=$number of training examples If $n$ is large(relative to $m$),e.g.$n\\ge m$, use logistic regression or SVM without a kernel If $n$ is small, $m$ is intermediate, use SVM with Gaussian kernel If $n$ is is small, $m$ is large, create/add more features, then use logistic regression or SVM without a kernel 线性核函数特征数较多，样本数较少时选择 高斯核函数f_i=exp(-\\frac{\\Vert{x-l^{(i)}}^2}{2\\sigma^2}),\\text{where} l^{(i)}=x^{(i)}选择高斯核的情况：特征数较少，样本较多 $\\sigma$的选取： 大$\\sigma$: high bias, low variance 小$\\sigma$: low bias, high variance Note:在使用高斯核之前记得特征归一化(feature scaling) 多项式核函数(x^Tl + C)^d 当$x$和$l$都是严格的非负数时才会使用 用得不多","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://mengzelev.github.io/tags/Machine-Learning/"}]},{"title":"HKUST项目讨论内容","slug":"HKUST-discussion","date":"2019-02-11T07:12:48.000Z","updated":"2019-02-19T07:05:47.387Z","comments":true,"path":"2019/02/11/HKUST-discussion/","link":"","permalink":"https://mengzelev.github.io/2019/02/11/HKUST-discussion/","excerpt":"","text":"问题理解原文【来自有道机翻】预测Sklearn程序的运行时间在共享基础设施上高效运行分布式应用程序具有挑战性。过去的研究表明，选择合适的硬件配置可以显著提高性能和降低成本。为了选择最佳配置，需要准确地预测不同应用程序的性能。 我们考虑这个挑战的一个简化版本:预测单个服务器上机器学习程序的性能。Scikit-learn (sklearn)是一个用于python的机器学习库。提供的数据集描述了在sklearn中运行SGDClassifier的几个示例。数据集的特征描述了SGDClassifier以及用于生成综合训练数据的特征。待分析数据为SGDClassifier的训练时间。 在这个文件夹中，您可以找到一个样例训练数据集(“sample_train.csv”)。“Time”是模型的训练时间。具体来说，“n_samples”、“n_features”描述了如何使用sklearn.dataset.make_classification生成训练合成数据集。在生成数据集之后，即使用SGDClassifier进行分类。‘l1_ratio’，‘alpha’，‘max_iter’描述了sklearn.linear.model.SGDClassifier的设置。所有特性名称都遵循sklearn文档中的定义。 本项目的目标是最小化预测运行时间的误差，即您应该预测接近真实运行时间的测试集的运行时间。使用的评价指标是均方误差。您可以找到“sample_test.csv”和“sample_submission”，用于测试集和解决方案提交格式。 项目分为两个阶段: 阶段1：在访问HKUST前，你可浏览样本数据集及草拟解决方案。建议您提前处理数据集并准备模型。 阶段2:在您访问期间，我们将为您提供一个更大的数据集，包含更多的示例和特性。然后，您可以使用扩展的数据集处理您的解决方案。请注意，我们在阶段1中提供的数据只是一个示例，在示例数据集上建立一个准确的模型并不一定意味着在这个阶段在真实数据集上具有良好的性能。 项目的其他信息和要求: 所有的训练和测试数据集都在同一个服务器上生成。 不受编程语言或机器学习技术的限制。但是，您不允许运行sklearn程序来扩展训练集或预测测试集。 你需要在你自己的笔记本电脑上编程和训练你的模型。 任何查询欢迎发送邮件至jxiaab @ust.hk与Jiacheng Xia联络 相关名词说明 make_classification sklearn.linear_model.SGDclassifier 任务概括 得到一个时间关于l1_ratio, alpha, max_iter, n_samples, n_features这5个参数的回归方程 将以上5个参数重新命名一下，即求$T(x_1,x_2,x_3,x_4,x_5)$ 任务理解看到这个问题，有以下两种思路 把SGDclassifier当成黑盒处理，不管SGD分类器算法的内部运作，用现有的算法作回归分析，拟合回归方程 根据SGD分类器具体运行的原理，自己确定一个时间函数 后者需要的数学知识过多，几乎是不可能做到的，而且到时候还会有一个更大、feature更多的数据集，所以采用前者 数据分析参数解释SGD分类器模型相关 penalty:惩罚函数的选择 l1_ratio:混合惩罚函数中l1和l2方法的比例 alpha:乘以正则项的常数 max_iter:最大迭代次数 random_state:随机数种子 n_jobs:运算使用的CPU个数，’-1’表示使用了所有的CPU 数据生成相关 n_samples:样本个数 n_features:feature个数 n_classes:类别的个数 n_clusters: 每一个分类中的团簇个数 n_informative:看不懂orz flip_y:随机交换所属类别，越大噪声越多 scale:对每个值乘以一个数 演讲思路 问题分析(如果已经有人讲过可以简单带过 简述问题【提取关键字 简要介绍一下SGDclassifier 拉出我们参考的一篇论文，仿照论文决定训练模型计算 我们尝试了诸多算法，决策树表现得比较好【数据可视化列举各种算法的表现情况 介绍决策树 对决策树进行改进【决策树，随机森林 总结结果","categories":[],"tags":[]},{"title":"2019美赛经历","slug":"ICM-feelings","date":"2019-01-30T09:45:38.000Z","updated":"2019-01-31T10:09:50.651Z","comments":true,"path":"2019/01/30/ICM-feelings/","link":"","permalink":"https://mengzelev.github.io/2019/01/30/ICM-feelings/","excerpt":"","text":"在经过了一夜的通宵之后终于把论文交上去惹，然后睡了一天，摸了一天，终于想起来要写这篇blog了。 赛前准备 学习MATLAB基本语法，笔记见MATLAB临时抱佛脚 学习数模基本算法，资料见NJUBroccoli的github仓库 抄写常用算法模板，如：规划问题、AHP、灰色系统、灰色预测、主成分分析、方差分析等 阅读往年赛题和O奖论文，摸清套路 和朋友出去看电影 和队友做迫真模拟 补番 团队配置 po主：cs大二狗，会C/C++，LaTeX，以及Java和Verilog的皮毛，MATLAB是比赛前速成的。建模、计算、写论文、校对多面打杂，兼职美工和排版工人。 队友A：数学系大二小姐姐。建模扛把子。 队友B：大气科学大二小哥哥。负责给建模提供灵感，负责抱大气老师教授大腿，负责询问环科同学、商科同学…这么写会不会被打死 分工 模型是一起讨论建的 数据是一起找的(虽然后来没怎么用上) 编程队友B不会所以我和队友A小姐姐一起负责 论文是每个人挑几个部分一起写的 翻译是交给有道姬完成的，由我和队友A校对因为队友B校对的质量堪忧 排版由原po一人完成 比赛过程选题之前和队友商量好了选E或F题，因为MCM比较有难度，D题需要排队论和马氏链不想看。比赛当天题目公布的时候，看到F题需要不少硬核经济学知识果断放弃了，然后果断就上了E题这条贼船。MCM碰都没碰所以错过了养龙的机会，我想养康娜酱啊呜呜呜 今年赛题内容大致为 A题：养龙 B题：救救难民 C题：美国总统五大洲四日游 D题：逃离卢浮宫 E题：生态服务成本估价 F题：电子货币 (只有E题是认真看过的，如有偏差欢迎指出) 题目概述E题按照惯例是环境问题，今年是要求对生态系统服务(ecological services)进行估价。生态系统服务是指生态系统提供的诸如净化空气、水体自净、保持水土等功能。要求大概有以下几点 建立生态系统估价模型(ecological services valuation model) 对不同规模的土地开发利用项目进行成本效益分析(CBA)，评估这些项目的真实经济成本 决策者和管理者提出建议(implication) 随着时间推移模型如何修改 本来是抱着AHP+GRA+PCA的觉悟来选的E题，结果一看这tm难道不是$\\sum$单价$\\times$数量的小学生模型吗，只要我找到每吨废水处理的价格，每吨垃圾回收的价格etc.然后标准结局出现了：找不到！！！比如污水处理费，中国大陆，HK和法国是按吨收的，美国英国是每年交固定的类似于下水道保护费一样的费用。而且题干里都说了“现在的土地利用项目一般不考虑环境成本”，所以根本就找不到工程前后环境相关的数据。几篇类似的论文都是有自己的监测站的啊！！！！我们上哪找去啊！！！环境经济学的书查了一堆啊！！！直接说环境估价是一个尚未解决的难题啊！！！！【废话要是解决了还会出成赛题吗如此绝望了一天半之后，我们决定，死马当活马医：gtnd，上AHP！然后就开始了玄学AHP玄学建模玄学论文解释由于只是个心路历程记录，所以就不详细解释了 计算我们的玄学模型只有CBA那一块有一丢丢计算量，直接上MATLAB甚至把图调得更好看花的时间还多一些【丢人 论文是大家一起写的中文稿，然后扔给有道姬翻成英文，再手动修改 流水账DAY1： 1234567选题while(true)&#123; 讨论模; 找论文; 找数据; 推翻模型;&#125; DAY2： 找数据 推翻模型 玄学建模开始 玄学AHP 玄学CBA 玄学编程 队友B开始玄学扯淡写论文 DAY3： 12345while(true)&#123; 论文扯淡; 发现模型有问题; 打补丁;&#125; DAY4(通宵)： 写论文 继续给模型打补丁 翻译并校对 排版 提交 感想 美赛是真的很累！！！【不过也有些队伍早早就做完提交了根本没有通宵 前面不知道做些什么，所以每天都睡足了8小时，事情都积到最后一天做了，所以不得不通宵，所幸还是赶上了的 没有养龙好遗憾啊，反正哪题都不会做，不如养龙爽一把，非要吊死在E题上 美赛过于昂贵。3人平分100美元的报名费不说，因为作死没有留在学校里打，导致只能去市图书馆讨论，花费大量金钱在吃饭上，最后一天为了通宵还开了个房 这次的E题感觉还是挺坑的，涉及到不少环境经济学的知识，外行人慎选。其实哪道题都是坑 我们的模型后来算出来西气东输是个失败的工程，感觉小命不保了 33.33美元，体验通宵的感觉，参赛一次，受益一生【棒读】 MCM/ICM真是一个骗钱又坑爹的比赛啊","categories":[{"name":"Diary","slug":"Diary","permalink":"https://mengzelev.github.io/categories/Diary/"}],"tags":[{"name":"Math Modeling","slug":"Math-Modeling","permalink":"https://mengzelev.github.io/tags/Math-Modeling/"}]},{"title":"python学习笔记","slug":"python-getstart","date":"2019-01-23T07:37:50.000Z","updated":"2019-03-13T03:42:01.600Z","comments":true,"path":"2019/01/23/python-getstart/","link":"","permalink":"https://mengzelev.github.io/2019/01/23/python-getstart/","excerpt":"","text":"持续更新中参考： 廖雪峰的Python3教程 《Python编程：从入门到实践》 数据类型Python是动态语言，即变量本身类型不固定，不需要提前声明变量类型的Python有三大数据类型：整数、浮点数、字符串 整数整数可以是任意大小的 浮点数浮点数可以是任意精度的【但是运算也会出现误差】 字符串 字符串用单引号或双引号括起来 会涉及到转义符的问题 在字符串前加r表示让所有的转义符都不转 字符串拼接：+号 几个骚方法 title()首字母大写 upper()全部大写 lower()全部小写 rstrip()暂时删除字符串右端的空白 123456&gt;&gt;&gt; s = &#x27;python &#x27;&gt;&gt;&gt; s.rstrip()&#x27;python&#x27;&gt;&gt;&gt; s&#x27;python &#x27;&gt;&gt;&gt; s = rstrip() #永久删除右端空格 lstrip()暂时删除字符串左端的空白 strip()同时暂时删除字符串两端空白 注释 Python中使用#注释掉一整行 PyCharm中可以使用Ctrl+/ 类型转换函数 int(x)把x转化为整数 float(x)把x转化为浮点数 str(x)把x转化为字符串 编码问题 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 Python 3的字符串是以Unicode编码的 ord()获取字符的整数表示，chr()把编码转换为对应的字符 字符串类型是str，加前缀b&#39;可以转换为bytes类型 Unicode表示的str通过encode()方法可以编码为bytes类型，反过来bytes类型可以通过decode()方法解码为str类型 12345678&gt;&gt;&gt; &#x27;ABC&#x27;.encode(&#x27;ascii&#x27;)b&#x27;ABC&#x27;&gt;&gt;&gt; &#x27;中文&#x27;.encode(&#x27;utf-8&#x27;)b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;&gt;&gt;&gt; b&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)&#x27;ABC&#x27;&gt;&gt;&gt; b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;.decode(&#x27;utf-8&#x27;)&#x27;中文&#x27; len()函数返回字符串长度或bytes字节数 始终坚持使用UTF-8对str和bytes进行转换 开头通常需要加上 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 格式化字符串%，用法同C的printf 布尔值 值为True或False 运算and、or、not 空值 None，是一个特殊变量 常量 习惯用全部大写的变量名表示常量 然而并不能保证该变量不会改变，不像C有const list 列表 []表示list []为下标索引，从0开始，同C [-1]表示最后一个元素,负号索引-n就表示倒数第n个这也太nb了吧 list里的数据类型可以不同 list可以嵌套 list方法123456789101112131415len(mylist) #获得list元素的个数 mylist.append(&#x27;a&#x27;) # 往list中追加元素到末尾mylist.insert(1, &#x27;a&#x27;) # 把元素插入到指定位置mylist.pop() # 删除list末尾的元素mylist.pop(1) # 删除指定位置的元素#pop返回值为被删除的元素del mylist[1] #使用del可以删除任何位置的列表元素，条件是知道索引mylist.remove() #按值删除元素，只删除第一个指定的值# `pop和`del`的选择：删除后是否还要使用该元素mylist.sort() #永久排序mylist.sort(reverse = True) #倒序排序sorted(mylist) #暂时排序，也可以加入倒序参数mylist.reverse() #永久倒置mylist[1:3] #list切片，同MATLAB，首尾可缺省copy_list = mylist[:] #通过切片赋值list 切片1234567L[head : tail :step]L[:3] #取出从第0个到第3个元素L[1:3] #取出从第1个到第3个元素L[:10:2] #前10个数，每2个取一个L[::5] #所有数，每5个取一个L[:] #原样复制一个list&#x27;ABCDEFG&#x27;[1:3] #字符串也可以看成List 列表生成式1234squares = [value ** 2 for value in range(1,11)]squares = [value ** 2 for value in range(1,11) if value % 2 == 0][m + n for m in &#x27;ABC&#x27; for n in &#x27;XYZ&#x27;] #两两组合双重循环[s.lower() for s in L] #将一个list中所有字符串变成小写 上述代码等价于对squares这个list执行了一个for循环，每个元素都平方(**是乘方的意思)自然语言编程指日可待 生成器generator lits保存的是数据，generator保存的是算法 使用next()函数可以获得generator的下一返回值 generator也是可迭代对象 定义generator 把list的[]变成() 使用yield关键字把函数变成generator 变成generator的函数，每次调用next()时执行，遇到yield语句返回，再次执行时 12345&gt;&gt;&gt; g = (x * x for x in range(10)) #把list的[]变成()就可以得到生成器&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;&gt;&gt;&gt; for n in g: print(n) 1234567891011#斐波那契数列def fib(max): n, a, b = 0, 0, 1 while(n &lt; max): yield b a, b = b, a + b #相当于(a,b) = (b, a+b) n = n + 1 return &#x27;done&#x27;&gt;&gt;&gt; for n in fib: print(n) 12345678910111213141516#杨辉三角生成器def triangles(): L = [1,] while True: yield L L = [1,] + [L[i-1] + L[i] for i in range(1, len(L))] + [1,]n = 0results = []for t in triangles(): print(t) results.append(t) n = n + 1 if n == 10: break tuple 元组 与list类似，但是一旦初始化就不能修改，类似于C的enum 不可变的tuple使代码更安全 注：定义一个元素的tuple时需要加一个逗号, tuple的不变是指向不变，即给元组变量赋值是合法的 1234t = () #定义空tuplet = (1,) #定义单元素tupledim = (200, 5)dim = (400, 10) #合法，相当于重新定义了整个元组 分支语句if 除了不要括号、冒号换行、缩进代替大括号外，其他都和C语言一样 else if可以缩写为elif if mylist 可以检验列表是否非空 if a in mylist你以为我是自然语言编程其实我只是检查某个元素在不在列表里哒 123456789# -*- coding: utf-8 -*-s = input(&#x27;birth:&#x27;)birth = int(s) //将字符串输入转化为数字类型if birth &gt;= 2000: print(&#x27;00后&#x27;)elif birth &lt; 1960: print(&#x27;60前&#x27;)else: print(&#x27;00前&#x27;) 循环语句forpython有2种循环 for x in ...循环，依次把list或者tuple中的每个元素迭代出来 range(m,n,step)函数生成从m开始到n的整数序列，步长为step，m缺省为0，step缺省为1 123for value in range(1,6): #行尾要有冒号 print(value) #别忘了缩进对齐numbers = list(range(1,11,2)) #list()函数将参数转换为列表 类似C语言的循环123456for i, value in enumerate([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]): print(i, value)# enumerate可以将list变成索引-元素对，相当于数组for x,y in [(1,1),(2,4),(3,9)]: print(x,y)#同时对两个变量进行迭代 迭代对象for可以作用于所有可迭代对象 123456789101112# 可以通过isinstance()函数判断一个对象是否为Iterable(可迭代对象)&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)True&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False 迭代器 可以被next()调用并不断返回下一个值的对象成为迭代器Iterator Iterator对象表示的是一个数据流 生成器都是Iterator对象 Iterable可迭代对象不一定是Iterator 123456789&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)False&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterator)False while123456ans = 0;n = 99;while n &gt; 0: ans += n n -= 2 # 没有n--这种语法糖了print(ans) break和continue都可以像以前一样用 字典dict dict就相当于C++里的map，功能类似于Hash Table 是关键字-值对(key-value),key和value只是名字，并不规定类型 dict相比于list，是在用空间换时间 dict的key必须是不可变对象 创建dict注意dict的初始化使用的&#123;&#125;花括号 12d = &#123;&#x27;Michael&#x27;:95, &#x27;Bob&#x27;:75, &#x27;Tracy&#x27;:85&#125; #将名字和成绩对应起来，项比较多的时候可以加上换行d[&#x27;Adam&#x27;] = 67 #直接通过关键字索引放入数据 多次对一个关键字放入数据，后面的值会把前面的冲掉 访问了不存在的关键字时会报错 12&#x27;Thomas&#x27; in d #返回布尔值，判断某关键字是否在该字典中del d[&#x27;Bob&#x27;] #删除指定关键字 dict方法12d.get(&#x27;Thomas&#x27;,-1) #寻找某个关键字的值，-1是规定的不存在时的返回值，缺省时返回None，Python交互环境不显示结果d.pop(&#x27;Bob&#x27;) #删除一个关键字 遍历dict12345678for key,value in d.items(): # 使用items()方法可以访问所有条目 print(key + &quot;:&quot; + value)# 需要声明两个变量，命名任意for key in d.keys(): # 使用keys()方法可以访问所有的关键字 print(key.title())#遍历字典时默认遍历所有key#同理有values()方法 集合set 无序、无重复元素的集合 不能放入可变对象 创建set1s = set([1,1,2,2,3]) #需要提供一个list作为输入，重复元素自动过滤 set方法12s.add(4) #添加元素s.remove(4) #删除元素 set操作12s1 &amp; s2 #交集s1 | s2 #并集 可变对象与不可变对象不可变对象：调用对象自身的方法不会改变该对象自身的内容，而是会创建新的对象并返回，如str可变对象：恰恰相反，如list 函数 函数名可以像变量一样赋值【太骚了 定义函数12345def my_abs(x): #行尾加个冒号 if x = 0: return x else: return -x 空操作123def nop(): pass# pass可以用作占位符，没想好写什么但函数可以先运行起来 参数类型检查1234567def my_abs(x): if not isinstance(x,(int, float)): #数据类型检查 raise TypeError(&#x27;bad operand type&#x27;) #异常处理(后续会提到) if x &gt;= 0: return x else: return -x 返回多值这也太骚了 123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 事实上返回的是一个tuple 参数 位置参数：普通意义上的参数 默认参数：有缺省值的参数，如def power(x,n=2) 必选参数在前，默认参数在后 多个默认参数时，可以按顺序调用，也可以将需要修改的参数值的名称写好，不写的使用默认值，如enroll(&#39;Adam&#39;, &#39;M&#39;,city=&#39;Tianjin&#39;) 默认参数必须指向不变对象，例如默认参数为list时用None代替[] 可变参数：参数个数不确定时，可以使用list或tuple传参，带*表示可变参数 参数在函数调用时自动组装为tuple12345678def cal(*numbers): #加*表示可变参数 ans = 0 for n in numbers: ans += n * n return ans #传参&gt;&gt;&gt; cal(1,2) #传递变量&gt;&gt;&gt; cal(*number) #传递list和tuple 关键字参数：允许传入0个或任意个含参数名的参数 参数在内部自动组装为dict123456789101112131415161718192021 def person(name, age, **kw): #表示接受关键字参数`kw` print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw) #调用 &gt;&gt;&gt; person(&#x27;Michael&#x27;, 30) #可以只传入必选参数 &gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, gender=&#x27;M&#x27;, job=&#x27;Engineer&#x27;) &gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, **extra) #将现成的dict作为参数+ 命名关键字参数：在函数内部检查传入了哪些参数 + 为了限制调用者可以传入的参数名，同时可以提供默认值。 + 必须传入参数名，否则调用将报错 + 命名关键字参数可以有缺省值 + 使用时，如果没有可变参数，必须加一个`*`作为分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数 ```py def person(name, age, **kw): if &#x27;city&#x27; in kw: #有city参数 pass if &#x27;job&#x27; in kw: #有job参数 pass def person(name, age, *, city, job): #限制关键字参数的名字，分隔符*后的参数被视为命名关键字参数 def person(name, age, *args, city, job): #有可变参数时后面的命名关键字参数不再需要分隔符* 参数定义顺序：必选参数、默认参数、可变参数、命名关键字参数和关键字参数 对于任何函数，都可以通过类似func(*args, **kw)的形式调用 P.S. 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3)) 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;) *args和**kw是习惯写法 递归12345def fact(n): if n == 1: return n else: return n * fact(n-1) 函数式编程 函数名也是变量 有点C里面函数指针的感觉 123&gt;&gt;&gt; f = abs&gt;&gt;&gt; f(-10)10 高阶函数 接收函数作为参数的函数叫做高阶函数 map map(f,L)，f为函数，L为一个list，表示将f作用于L的每一个元素上 123&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81] reduce reduce(f,L)，把结果继续和序列的下一个元素做累计计算 reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 使用时需要加上from functools import reduce 1234567&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25#求和运算可以直接用sum()函数 map()与reduce()结合使用可以用很少的代码写出str2int函数 12345678910num = &#123;&#x27;0&#x27;:0, &#x27;1&#x27;:1, &#x27;2&#x27;:2, &#x27;3&#x27;:3, &#x27;4&#x27;:4, &#x27;5&#x27;:5, &#x27;6&#x27;:6, &#x27;7&#x27;:7, &#x27;8&#x27;:8, &#x27;9&#x27;:9&#125;from functools import reducedef str2num(s): def fn(x,y): return x * 10 + y def char2num(s): return num[s] return reduce(fn, map(char2num, s)) filter 用于过滤list 把传入的函数依次作用于某个元素，根据返回值是True还是False决定保留还是丢弃该元素 返回的是一个惰性序列，需要用list()函数将所有结果组织为list 1234567#筛选回文数def is_palindrome(n): s = str(n) rev = s[::-1] #使用切片倒转字符串 return s == revoutput = filter(is_palindrome, range(1, 1000)) sorted 可以直接对全是数据的list排序，sort(L)返回升序排序的L 可以接受一个key函数来实现自定义的排序，sort(L,key) key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序 然后sorted()函数按照keys进行排序，并按对应关系返回原list的相应元素 要进行反向排序可以传入第三个参数reverse=True 1234567891011def by_name(t): return t[0] #按姓名字母顺序排序def by_score(t): return -t[1] #按分数降序排序L = [(&#x27;Bob&#x27;, 75), (&#x27;Adam&#x27;, 92), (&#x27;Bart&#x27;, 66), (&#x27;Lisa&#x27;, 88)]L1 = sorted(L, key=by_name)L2 = sorted(L, key=by_score)print(L1)print(L2) 返回函数 函数作为返回值的函数 “闭包”程序结构：相关参数和变量都包含在返回的函数中 返回的函数不会被立刻执行，而是直到调用了才执行 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量 有啥卵用：保存当前的运行环境。被引用的自由变量与函数同在，即使离开了创造它的环境也不例外 将外部函数的变量与内部函数绑定 匿名函数 关键字lambda表示匿名函数，冒号前的x表示函数参数 1234lambda x : x * x#相当于def f(x): return x * x 只能有一个表达式，不用写return，返回值就是该表达式的结果 好处：没有名字，不用担心和其他函数名冲突 匿名函数也是函数对象，可以把匿名函数赋值给一个变量，再利用变量来调用该函数【有毒吗，不能直接def吗 匿名函数也可以作为返回值返回 1L = list(filter((lambda x : x%2==1), range(1,20))) 装饰器 函数对象有个__name__属性，可以获得函数的名字 在代码运行期间动态增加函数的功能的方式成为装饰器(decorator) 123456789101112131415import functoolsdef log(func): @functools.wraps(func) # 把原始函数的属性复制到wrapper()函数中 def wrapper(*args, **kw): print(&#x27;call %s():&#x27; % func.__name__) # 先打印日志 return func(*args, **kw) # 再调用原函数 return wrapper@log # @语法，相当于执行now=log(now)def now(): print(&quot;2019-2-6&quot;)&gt;&gt;&gt; now()call now():2019-2-6 偏函数 把一个函数的某些参数固定住(设置一个参数的默认值)，返回一个新的函数，可以直接调用这个新的函数 functools.partial(f,*args,**kw) 12int2 = functools.partial(int, base=2) #固定转化为二进制的函数 模块 一个.py文件就是一个模块 可以避免函数名和变量名冲突 包下的是模块，包中必包含init.py模块 注意模块命名不要与python原有模块冲突 模块名为包名.模块名 类似于C的库 标准模块文件123456#!/usr/bin/env python3# -*- coding: utf-8 -*-&#x27; a test module &#x27;__author__ = &#x27;Michael Liao&#x27; 第一行：标准注释，表示该文件可以直接在Unix/Linux/Mac上运行 第二行：标准注释，表示该文件本身使用标准UTF-8编码 第四行：模块文档注释，任何模块代码的第一个字符串都被视为模块的文档注释 第六行：作者标注，使用__author__变量把作者写进去 使用模块 导入模块：import 模块名 函数和变量的作用域 正常的函数和变量名是公开的(public)，可以直接被引用 类似__xxx__的变量是特殊变量，可以被直接引用，但一般不建议这么做 例如，如果调用len()试图获取一个对象的长度，会自动调用该类的__len__方法 类似_xxx和__xxx的函数或变量是非公开的(private)，不应该被引用，但是Python不能完全限制它们的引用 外部不需要引用的函数和变量全部定义为private，只有外部需要引用的函数才定义为public 安装第三方模块1pip install [模块名] OOP类的定义12class Student(object):# Student是类名 类名一般首字母大写 括号中标明了从哪个类继承下来，所有类最终都继承自object(同Java) 实例 创建实例：类名+()，如bart = Student() 可以自由地给一个实例变量绑定属性 实例的初始化可以使用__init__函数 将一些必须绑定的属性写上去 __init__方法的第一个参数永远是self，需要声明但无需传递(类似于C的this) 不就是构造函数吗123456class Student(object): def __init__(self, name, score): self.name = name self.score = score# 创建实例bart = Student(&#x27;Bart Simpson&#x27;,59) 定义方法除了第一个参数是self外，与定义函数无异 访问限制 私有变量：名称前加两个下划线__xxx，外部无法访问(其实只是Python解释器把它解释为了另一个名字) 单下划线实例变量名:“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问” 继承和多态 基本类似Java的继承 子类继承父类的方法 子类和父类可以有相同的方法，但子类的方法会覆盖父类的方法 “鸭子类型”：一个对象只要“看起来像鸭子，走起路来像鸭子”，就可以被看成鸭子 不要求严格的继承体系，调用方法时只要保证对象有这样的方法 获取对象信息 type()函数：判断对象、函数类型，返回对应的Class类型，可以用if语句比较两个变量的类型是否相同 判断基本数据类型可以直接写int，str等 判断一个对象是否是函数可以使用types模块中定义的常量1234567891011121314&gt;&gt;&gt; type(123) == intTrue&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():... pass...&gt;&gt;&gt; type(fn) == types.FunctionTypeTrue&gt;&gt;&gt; type(abs) == types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x : x) == types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10))) == types.GeneratorTypeTrue isinstance()可以用来判断继承关系 能用type()判断的基本类型也可以用isinstance()判断 优先使用isinstance() dir()可以获得一个对象的所有属性和方法，返回一个包含字符串的list 12&gt;&gt;&gt; dir(&#x27;ABC&#x27;)[&#x27;__add__&#x27;, &#x27;__class__&#x27;,..., &#x27;__subclasshook__&#x27;, &#x27;capitalize&#x27;, &#x27;casefold&#x27;,..., &#x27;zfill&#x27;] 配合getattr()，setattr()和hasattr()可以直接操作一个对象的状态12345678910111213141516171819202122&gt;&gt;&gt; hasattr(obj, &#x27;x&#x27;) # 有属性&#x27;x&#x27;吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, &#x27;y&#x27;) # 有属性&#x27;y&#x27;吗？False&gt;&gt;&gt; setattr(obj, &#x27;y&#x27;, 19) # 设置一个属性&#x27;y&#x27;&gt;&gt;&gt; hasattr(obj, &#x27;y&#x27;) # 有属性&#x27;y&#x27;吗？True&gt;&gt;&gt; getattr(obj, &#x27;y&#x27;) # 获取属性&#x27;y&#x27;19&gt;&gt;&gt; obj.y # 获取属性&#x27;y&#x27;19&gt;&gt;&gt; hasattr(obj, &#x27;power&#x27;) # 有属性&#x27;power&#x27;吗？True&gt;&gt;&gt; getattr(obj, &#x27;power&#x27;) # 获取属性&#x27;power&#x27;&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, &#x27;power&#x27;) # 获取属性&#x27;power&#x27;并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81 只有在不知道对象具体信息时，才会去获取对象的信息1234567 #正确用法 def readImage(fp):if hasattr(fp, &#x27;read&#x27;): return readData(fp)return None# 假设我们希望从文件流fp中读取图像# 我们首先要判断该fp对象是否存在read方法 实例属性和类属性 给实例绑定属性：通过实例变量或self变量 类本身需要绑定属性：直接在class中定义 类的所有实例都可以访问类属性1234567891011class Student(object): count = 0 def __init__(self, name): self.name = name Student.count += 1 # 类的属性增加一，而非实例的属性self.countAbart = Student(&#x27;Bart&#x27;)print(Student.count)lisa = Student(&#x27;Lisa&#x27;)print(Student.count) slots 实例可以绑定属性和方法 绑定方法需要使用到types模块中的MethodType`方法12345&gt;&gt;&gt; from types import MethodType&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法&gt;&gt;&gt; s.set_age(25) # 调用实例方法&gt;&gt;&gt; s.age # 测试结果25 以上方法绑定的方法对其他的实例是不起作用的 给类绑定方法可以给所有实例绑定方法，是一种动态绑定，绑定后所有实例均可调用 1234&gt;&gt;&gt; def set_score(self, score):... self.score = score...&gt;&gt;&gt; Student.set_score = set_score 使用__slots__可以限制实例的属性 仅对当前类的实例起作用，对继承的子类是不起作用的 如果在子类中也定义__slots__，则子类实例允许定义的属性 = 自身的__slots__ + 父类的__slots__ @property @property是装饰器，负责把一个setter方法变成属性赋值 123456789101112class Student(object) @property def score(self): return self._score # getter属性 @score.setter def score(self, value): # setter属性 if not isinstance(value, int): raise ValueError(&#x27;score must be an integer&#x27;) if value &lt; 0 or value &gt; 100: raise ValueError(&#x27;score must between 0 and 100&#x27;) self._score = value @property使得对实例属性操作时，通过getter和setter方法来实现 是定义getter方法就相当于定义了一个只读属性 多重继承 一个子类可以同时获得多个父类的所有功能 12class Dog(Mammal, Runnable): pass MixIn:除主线之外的继承关系 为了更好地看出继承关系，可以把主线外的继承类命名为xxxMixIn，如RunnableMixIn 这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类 Java是只允许单一继承的，不允许MixIn的继承 定制类上文提到的 __len__方法能让class作用于len()函数，就是一种定制类的方法 str __str__方法可以改变类的实例的打印方式，类似于Java的toString 12345678class Student(object): def __init__(self): self.name = name def __str__(self): return &#x27;Student object (name: %s)&#x27; % self.name&gt;&gt;&gt; print(Student(&#x27;Michael&#x27;))Student object (name: Michael) repr __repr__方法 直接显示变量调用(在交互模式下敲出变量名) __str__()方法返回用户看到的字符串，__repr__()返回程序开发者看到的字符串，为调试服务 通常__str__()和__repr__()代码都是一样的，有个偷懒的写法 123def __str__(self): pass__repr__ = __str__ iter __iter__方法返回一个迭代对象，让类可以被用用于for ... in循环 配合__next__方法，for循环会不断调用该迭代对象的__next__()方法得到循环的下一个值，直到遇到StopIteration错误退出循环 1234567891011121314151617181920212223class Fib(object): def __init__(self): self.a,self.b = 0,1 def __iter__(self): return self def __next__(self): self.a,self.b = self.b, self.a+self.b if self.a &gt; 100000: raise StopInteration() return self.a &gt;&gt;&gt; for n in Fib(): print(n) 1 1 2 3 5 ... 46368 75025 getitem __getitem__方法使类可以像list那样根据下标取出元素 123456789101112131415161718192021222324252627class Fib(object): def __getitem__(self, n): if(isinstance(n, int)): # n是索引 a,b = 1,1 for x in range(1, n): a,b = b,a+b return a if(isinstance(n, slice)): # n是切片 start = n.start stop = n.start if start is None: start = 0 a,b = 1,1 L = [] for x in range(stop): if x &gt;= start: L.append(a) a,b = b,a+b return L&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f[0]1&gt;&gt;&gt; f[100]573147844013817084101&gt;&gt;&gt; f[0:5][1, 1, 2, 3, 5] 以上__getitem__()方法没有对步长和负数做处理，因此要正确实现一个__getitem__()还是有很多工作要做的 如果把对象看成dict，__getitem__()的参数也可能是一个可以作key的object，例如str，与之对应的还有__setitem__和__delitem__ getattr __getattr__方法能够动态返回一个属性，当调用不存在的属性时，会试图调用__getattr__(self,属性)来尝试获得属性 只有在没有找到属性的情况下才会调用__getattr__，已有的属性是直接获取的 123456class Student(object):def __getattr__(self, attr): if attr==&#x27;age&#x27;: return lambda: 25 raise AttributeError(&#x27;\\&#x27;Student\\&#x27; object has no attribute \\&#x27;%s\\&#x27;&#x27; % attr) call __call__使实例自身能被当作函数调用 12345678910class Student(object): def __init__(self, name): self.name = name def __call__(self): print(&#x27;My name is %s.&#x27; % self.name)&gt;&gt;&gt; s = Student(&#x27;Michael&#x27;)&gt;&gt;&gt; s()My name is Michael 通过callable函数可以判断一个对象是否能被调用 12345678910&gt;&gt;&gt; callable(Student())True&gt;&gt;&gt; callable(max)True&gt;&gt;&gt; callable([1, 2, 3])False&gt;&gt;&gt; callable(None)False&gt;&gt;&gt; callable(&#x27;str&#x27;)False 枚举类Enum12from enum import EnumMonth = Enum(&#x27;Month&#x27;, (&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;)) 这样就得到了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量 也可以枚举该类的所有成员 12from name,member in Month.__members.items() print(name, &#x27;=&gt;&#x27;, member, &#x27;,&#x27;, member.value) value属性是自动赋给int常量，默认从1开始计数(居然不是从0开始) 从Enum派生自定义类可以精确控制枚举类型 12345678910111213141516from enum import Enum@unique #装饰器，帮忙检查有无重复值class Weekday(Enum): # Enum的子类 Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6# 访问Weekday.MonWeekday[&#x27;Tue&#x27;]Weekday(1) type()函数 动态语言的函数和类不是编译时定义的，而是运行时动态创建的 type()函数可以查看一个类型或变量的类型 type()函数可以创建出新的类型，而无需通过class定义 123456def fn(self, name=&#x27;world&#x27;): print(&#x27;Hello, %s.&#x27; % name)Hello = type(&#x27;Hello&#x27;, (object,), dict(hello=fn)) #创建Hello类&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world. type()函数需依次传入3个参数 class的名称 继承的父类的集合，注意单元素tuple的写法 class的方法名称与函数绑定 metaclass()函数 先定义metaclass(元类)，就可以创建类，然后创建实例 可以把类看成metaclass创建出来的实例 metaclass正常情况下不会用到所以看不懂也没关系 123456789# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs[&#x27;add&#x27;] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs)# 使用metaclass定制类class MyList(list, metaclass=ListMetaclass): pass 创建Mylist时，通过ListMetaclass.__new__()来创建 可以用来修改类的定义，例如加上新的方法(样例中在MyList类中增加了add方法) __new__()方法接收的参数依次是 当前准备创建的类的对象 类的名字 类继承的父类的集合 类的方法的集合 应用上与SQL相结合的较多，等用到的时候再看了 错误、调试和测试try 当我们认为某些代码可能会出错时，可以用try来运行这段代码 如果出错，后续代码不会继续执行，而是直接跳转至错误处理代码 12345678910try: print(&#x27;try...&#x27;) r = 10 / 0 print(&#x27;result:&#x27;, r)# 错误处理代码except ZeroDivisionError as e: # 可以有多个except print(&#x27;except:&#x27;, e)finally: # finally无论如何都会被执行，表示执行结束 print(&#x27;finally...&#x27;)print(&#x27;END&#x27;) except后可加else语句块，当没有错误发生时会执行else语句块 try...except可以跨越多层调用，被调用者出错，调用者也能捕捉到 Python的错误也是类，所有错误类型都继承自BaseException 常见的错误类型和继承类型 记录错误 python有内置的logging模块，可以记录错误信息 程序打印完错误信息后会继续执行并正常退出 1234try: bar(&#x27;0&#x27;) except Exception as e: logging.exception(e) 抛出错误 根据需要，可以定义一个错误的类，选择好继承关系，用raise语句抛出一个错误的实例 只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型，尽量使用Python内置的错误类型 当前函数不知道如何处理该错误时，还可以在打印错误后再往上抛，让顶层调用者去处理 raise语句如果不带参数，就会将当前错误原样抛出 在except中raise一个Error，可以将错误转化成另一种类型 调试 print调试法 assert调试法 12assert n != 0, &#x27;n is zero!&#x27;# 表达式应该为True，否则输出AssertionError+后接的字符串 启动python解释器时可以用-O参数来关闭assert log调试法(Python管这叫logging) 1234import logginglogging.basicConfig(level=logging.INFO) # 配置logging.info(&#x27;n = %d&#x27; % n) # logging.info: 输出信息 可以指定DEBUG&gt;INFO&gt;WARNING&gt;ERROR几个不同级别(level)的信息，级别越高越先被屏蔽，e.g.level=INFO时DEBUG的logging就不起作用了 pdb调试法(命令同gdb) l: 查看代码 n: 单步执行 p 变量名: 打印变量 c: 继续执行 pdb.set_trace()在程序中设置断点，运行时程序会自动暂停并进入pdb 123456import pdbs = &#x27;0&#x27;n = int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 / n) PyCharm调试法 I/O文件读写读文件1234f = open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;)# 失败时会返回IOErrorf.read() #一次性读取全部内容到内存，用一个str对象表示f.close() #关闭文件，回收资源 为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现： 123456try: f = open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;) print(f.read())finally: if f: f.close() 嫌长可以简化为with语句123with open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;) as f: print(f.read())#隐式调用了f.close()不想一次读取所有文件 123f.read(size) # 读取一定size个字节的内容f.readline() # 一次读取一行f.readlines() # 一次读取所有行并返回list 还可以有效防止内存爆炸 内存的字节流，网络流，自定义流等等都是file-like Object，只需要写个read()方法就能用 二进制文件需要用&#39;rb&#39;模式打开 读取默认使用UTF-8编码，需要编码转换的时候要给open()传入encoding参数,errors参数表示出现错误后怎么处理，一般选择忽略 1f = open(&#x27;/Users/michael/gbk.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;,errors=&#x27;ignore&#x27;) 写文件和读一样，把r改成w(跟C也差不多) StringIO在内存中读写str 12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO() # 创建StringIO对象&gt;&gt;&gt; f.write(&#x27;hello&#x27;)5&gt;&gt;&gt; f.write(&#x27; &#x27;)1&gt;&gt;&gt; f.write(&#x27;world!&#x27;)6&gt;&gt;&gt; print(f.getvalue()) #getvalue()用于获得写入后的strhello world! 可以用一个str初始化StringIO，然后，像读文件一样读取 BytesIO操作内存中的二进制数据 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))6&gt;&gt;&gt; print(f.getvalue())b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87 操作系统命令Python内置的os模块可以直接调用操作系统提供的接口函数 文件名操作只对字符串进行，并不要求文件真实存在 shutil中可以找到很多对os的补充 1234567891011121314151617181920212223&gt;&gt;&gt; import os&gt;&gt;&gt; os.name #查看操作系统名称&gt;&gt;&gt; os.environ # 查看操作系统中所有的环境变量&gt;&gt;&gt; os.environ.get(&#x27;key&#x27;) # 获取某个环境变量的值&gt;&gt;&gt; os.path.abspath(&#x27;.&#x27;) # 查看当前目录的绝对路径:&#x27;/Users/michael&#x27;&gt;&gt;&gt; os.path.join(&#x27;/Users/michael&#x27;, &#x27;testdir&#x27;)# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&#x27;/Users/michael/testdir&#x27;# 然后创建一个目录:&gt;&gt;&gt; os.mkdir(&#x27;/Users/michael/testdir&#x27;)# 删掉一个目录:&gt;&gt;&gt; os.rmdir(&#x27;/Users/michael/testdir&#x27;)# 拆分路径，把当前文件名与目录分开&gt;&gt;&gt; os.path.split(&#x27;/Users/michael/testdir/file.txt&#x27;)(&#x27;/Users/michael/testdir&#x27;, &#x27;file.txt&#x27;)# 拆分文件扩展名&gt;&gt;&gt; os.path.splitext(&#x27;/path/to/file.txt&#x27;)(&#x27;/path/to/file&#x27;, &#x27;.txt&#x27;)# 对文件重命名:&gt;&gt;&gt; os.rename(&#x27;test.txt&#x27;, &#x27;test.py&#x27;)# 删掉文件:&gt;&gt;&gt; os.remove(&#x27;test.py&#x27;) 过滤文件不都是一行命令行就能搞定的吗 1234&gt;&gt;&gt; [x for x in os.listdir(&#x27;.&#x27;) if os.path.isdir(x)][&#x27;.lein&#x27;, &#x27;.local&#x27;, &#x27;.m2&#x27;, &#x27;.npm&#x27;, &#x27;.ssh&#x27;, &#x27;.Trash&#x27;, &#x27;.vim&#x27;, &#x27;Applications&#x27;, &#x27;Desktop&#x27;, ...]&gt;&gt;&gt; [x for x in os.listdir(&#x27;.&#x27;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#x27;.py&#x27;]`[&#x27;apis.py&#x27;, &#x27;config.py&#x27;, &#x27;models.py&#x27;, &#x27;pymonitor.py&#x27;, &#x27;test_db.py&#x27;, &#x27;urls.py&#x27;, &#x27;wsgiapp.py&#x27;] 还有psutil模块提供了对cpu信息、内存和磁盘使用信息的访问 序列化 把变量从内存中变成可存储或传输的过程叫作序列化(picking).序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 用到了再看吧","categories":[{"name":"Self-learning","slug":"Self-learning","permalink":"https://mengzelev.github.io/categories/Self-learning/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://mengzelev.github.io/tags/Python/"}]},{"title":"数学建模几种常用算法","slug":"matlab-usage","date":"2019-01-19T08:41:45.000Z","updated":"2019-01-24T13:22:25.808Z","comments":true,"path":"2019/01/19/matlab-usage/","link":"","permalink":"https://mengzelev.github.io/2019/01/19/matlab-usage/","excerpt":"","text":"数据拟合多项式拟合123456x = [...];y = [...];P = polyfit(x,y,n); % n是多项式的次数xi = 0: .2 :10;yi = polyval(P, xi);plot(xi, yi, x, y, &#x27;r*&#x27;); 规划线性规划标准型\\min~c^Tx s.t. Ax\\le b 1[x,y] = linprog(c, -a, -b, [], [], zeros(3,1)) 非线性规划123456[x,y] = fmincon(fun, x0, A, B, Aeq, Beq, LB, UB, [c,ceq], OPTIONS)% fun:目标函数% x0:x的初始条件% A,B,Aeq,Beq:线性约束条件% LB,UB:上下界% [c,ceq]:.m文件定义的非线性约束条件,分别为不等式与等式约束 二次规划1[x, fval] = quadprog(H, f, A, b, Aeq, Beq, LB, UB, X0, OPTIONS) 整数规划 隐枚举法 随机算法(蒙特卡洛) 分枝定界法 其他求解约束最优化问题的函数 fminbnd:单变量非线性函数在区间上的极小值 fseminf fminimax:函数族的极大极小值 灰色预测GM(1,1)模型适用于具有较强指数规律的序列，只能描述单调的变化过程，而Verhulst模型则适用于非单调的摆动发展序列或具有饱和状态的S形序列。原始数列$x^{(0)}$，AGO累加生成数列$x^{(1)}$，加权均值数列$z^{(0)}$ 关联分析和优势分析 根据bigger is better和smaller is better标准将数据分类进行初始化 根据公式算关联系数 根据关联系数计算关联度 灰色预测步骤 数据的检验与处理：计算级比，视情况进行必要的变换处理，使其落入可容覆盖内 建立模型 $x^{(1)}=…$可以得到预测值 残差检验 级比偏差检验 预测预报 另：灾变预测可以构造灾变数列 遗传算法 求解多约束复杂非线性规划问题 直接调库吧，不可能看懂的 层次分析法(Analytic Hierarchy Process) 用于解决较为复杂、模糊、难于定量分析的问题 当影响决策的因素较多且较主观时 分层、构造矩阵、检验一致性 因为基本上做E或F题都会用到，所以详细展开一下 基本步骤 建立递阶层次结构模型； 构造出各层次中的所有判断矩阵； 层次单排序及一致性检验； 层次总排序及一致性检验。 层次结构的建立 构造判断矩阵 层次单排序一致性检验 判断矩阵$A$对应于最大特征值$\\lambda_{max}$的特征向量$W$ ，经归一化后即为同一层次相应因素对于上一层次某因素相对重要性的排序权值，这一过程称为层次单排序 如果比较结果是前后完全一致的，则矩阵$A$的元素还应当满足$a{ij}a{jk}=a_{ik}$，此时矩阵$A$成为一致矩阵 $n$阶正互反矩阵$A$为一致矩阵当且仅当其最大特征根$\\lambda{max}=n$，且当正互反矩阵$A$非一致时，必有$\\lambda{max}&gt;n$ 一致性检验步骤 计算一致性指标$CI=\\frac{\\lambda_{max}-n}{n-1}$ 查找相应的平均随机一致性指标$RI$ 计算一致性比例$CR=\\frac{CR}{CI}$ $CR&lt;0.10$时，认为判断矩阵的一致性是可以接受的，否则应对判断矩阵作适当修正 层次总排序一致性检验设A层(上一层次)包含$A1,…A_m$共$m$个因素，层次总排序权重分别为$a_1,…a_m$，又设其后的下一层次B层包含$n$个因素$B_1,…B_n$，它们关于$A_j$的层次单排序权重分别为$b{1j},…b{nj}$(当$B_i$与$A_j$无关时，$b{ij}=0$)。现求$B$层中各因素关于总目标的权重，即求$B$层个因素的层次总排序权重$b1,…,b_n$。$B$层各因素的层次总排序权重$b_i=\\sum\\limits{j=1}^{m}b{ij}a{j}$B层总排序随机一致性比例CR=\\frac{\\sum\\limits_{j=1}^{m}CI(j)a_j}{\\sum\\limits_{j=1}^{m}RI(j)a_j}$CR&lt;0.10$时认为层次总排序具有较满意的一致性并接受该分析结果 方差分析(ANOVA) 又称F检验 用数理统计分析试验结果、鉴别各因素对结果影响程度的方法 单因素方差分析 任务：从试验结果推断某因素对指标有无显著影响 单因素方差分析表 方差分析命令anoval，p = anoval(x,group)将算得的概率p与\\alpha进行比较 双因素方差分析 p = anova2(x,reps) 多因素方差分析 anovan 12345y = [31 54 38 53 49 42 57 62 64]; %试验结果g1 = [1 2 3 1 2 3 1 2 3]; %正交表第一列g2 = [1 1 1 2 2 2 3 3 3];g3 = [2 1 3 1 3 2 3 2 1];[p,t,st] = anovan(y,&#123;g1,g2,g3&#125;) 回归分析 用来检验拟合函数的准确度 残差：实际观察值，估计值(拟合值)之间的差 $R^2$判定系数：可解释的变异占总变异的百分比 多元线性回归123456[b,bint,r,rint,stats] = regress(y,x,alpha);% b为回归系数估计值% bint为置信区间 % r为残差，rint为残差的置信区间% stats是用于检验回归模型的统计量[R^2,F,p,s^2]% alpha显著性水平，缺省时为0.05 一元多项式回归1234[p,s] = polyfit(x0, y0, 2);% s为用于计算函数值的数据结构，如[y,delta] = polyconf(p,x0,s);y%可以得到y的拟合值、置信区间半径delta 多元二项式回归1234rstool(x,y,model,alpha)% x:n×m维矩阵% y:n维向量%model:线性、纯二次、交叉、完全二次四选一 主成成分分析 用较少的变量去解释原来资料中的大部分变异 选出比原始变量个数少、能解释大部分资料中的变异的几个新变量 步骤 对原始数据进行标准化处理 计算相关系数矩阵$R$ 计算特征值和特征向量 选择$p$个主成分，计算综合评价值 计算综合得分 排队论 有很多公式，用的时候再查吧 优化：最优服务率，最优服务台数 灵敏度分析 当模型的数据中有一个或几个发生变化时，最优解会有什么变化 这些数据在什么范围内变化时，已求解的最优解不变","categories":[],"tags":[]},{"title":"MATLAB临时抱佛脚","slug":"matlab-getstart","date":"2019-01-16T09:04:59.000Z","updated":"2019-01-20T03:49:08.093Z","comments":true,"path":"2019/01/16/matlab-getstart/","link":"","permalink":"https://mengzelev.github.io/2019/01/16/matlab-getstart/","excerpt":"","text":"来源：王正盛 《MATLAB数学工具软件实例简明教程》 入门技能命令行命令matlab基本可以看成一个有自己语法的命令行终端使用下面列举一些我觉得自己将来可能会用到的 clc:擦除当前工作窗中所有显示内容 dir:相当于ls cd:你懂的 who:检查内存变量 whos:检查驻留变量的详细情况 help:召唤FM lookfor:对man进行grep MATLAB也是有当前工作路径的，同Linux的bash 变量变量基本以矩阵形式存在还有一些预定义的变量 eps:计算机表示的最小正数 pi:圆周率 inf或Inf NaN i,j flops:浮点运算次数，用于统计计算量 显示格式 short long short/long e 科学计数法显示 bank 银行格式 hex 十六进制格式 +用于大矩阵的紧凑格式 数值计算矩阵创建 直接输入法 reshape把长行向量拆成$n\\times m$的矩阵 diag可以实现向量和对角阵之间的互相转化 .m和.mat文件 矩阵运算与数组运算 矩阵运算：按矩阵法则进行的运算 数组运算：对元素逐个进行 可以将数组直接作为参数传入函数中，而不用写循环，不同于C MATLAB推荐：尽量使用除运算，少用逆运算 多项式表示 系数行向量表示：$p=[a_0,a_1,…a_n]$ 指令p=poly(AR)产生多项式 若AR是方阵，则产生特征多项式 若AR是向量，则AR中每个数是该多项式=0的解 多项式运算 R = roots(p)：求根 PA = polyval(p,S):按数组运算规则计算多项式的值 PA = polyvalm(p,S):按矩阵运算规则计算多项式的值 P = polyfit(x,y,n):用$n$阶多项式拟合$x,y$给定的数据 数值积分 S = quad(&#39;fname&#39;, a, b, tol, trace) 自适用Simpson数值积分法 S = quad8(&#39;fname&#39;, a, b, tol, trace)自适用Newton-Cotes数值积分法 quad8比quad性能和精度更好 非线性方程 r = roots(p) 多项式非线性函数求根 z = fzero(&#39;fname&#39;, x0, tol, trace) 单变量函数求零点，只给出离x0最近的根 微分方程的数值解 [t,x] = ode23/45(&#39;xprime&#39;, [t0,tf], x0, tol, trace) 文件管理 cd, type, delete, dir，和bash用起来差不多 !可用于执行外部程序 文件输入输出 fopen打开二进制文件 1fid = fopen(&#x27;a.dat&#x27;, &#x27;r&#x27;) fread将数据装入变量 123a = fread(fid);a = fread(fid, 100);a = fread(fid, [10,10]); fwrite按照指定的书精度将矩阵中的元素写入文件 123cnt = fwrite(fid, magic(5), &#x27;integer * 4&#x27;);%返回写入数据的个数status = fclose(fid); save命令及-ascii选项 12a = rand(4,3)save a.dat a -ascii 符号计算 符号定义 sym定义符号或表达式 1234sym(&#x27;x&#x27;)sym(`1 + x / 2`)syms a b c d %syms可以定义多个符号 findsym确认符号表达式中的符号 微积分运算求导 diff(f,t,n)函数f对变量t求n阶导，t缺省时对x求导，n缺省为1 参数为矩阵时，作用于每个元素 积分 int(f,t) 函数f对变量t求不定积分 int(f,t,a,b) 函数f对符号变量求从a到b的定积分 极限 limita(f,t,a)当符号变量t-&gt;a时，函数f的极限，t缺省x，a缺省为0 级数和 symsum(s,t,a,b)``s中的符号变量t从a到b的级数和 Taylor展开 taylor(f,n,a)函数f对符号变量x或最接近字母x的符号变量在a点的n-1阶泰勒多项式,n缺省时值为6,a缺省值为0 解方程 solve(f,t)对f中的符号标量t解方程f=0 solve(&#39;fname&#39;,t) 求解形如f(x)=g(x)的方程 dsolve(&#39;S&#39;,&#39;s1&#39;,...&#39;x&#39;) 线性代数 用，都可以用 化简和代换 collect合并同类项 expand将乘积展开为和式 factor将和式展开为乘积 horner嵌套多项式 simplify利用各种 画图二维 plot(x,y)其中x和y为坐标向量 在plot指令中增加一些参数，可以绘制出不同颜色与不同线性的图形，e.g. 1plot(x, y1, &#x27;k:&#x27;, x, y2, &#x27;b-&#x27;) 每条曲线的线型和颜色由字符串&#39;cs&#39;指定，其中&#39;c&#39;表示颜色，&#39;s&#39;表示线型 图形标记指令title,xlabel,ylabel,text,legend axis([xmin, xmax, ymin, ymax])设定坐标轴 hold on保持已有图形绘制新的图形 fplot(fname, lims, tol)为函数提供自适应采样 loglog(x,y)双对数坐标 semilogx,semilogy 单对数坐标 polar(theat, rho) 极坐标 三维 plot3用法同plot mesh(x,y,z,c)绘制三维网格图 surf(x,y,z,c)三维曲面图 view指定视点 contour3等高线图 MATLAB程序设计输入输出 input函数 12A = input(&#x27;Enter matrix A=&gt;&#x27;)%这样可以在执行该语句时首先给出提示，再接收键盘输入 pause(延迟秒数) Disp()输出函数， 输出项可以为矩阵或字符串 分支语句if语句 结尾需要加end else和if可以连起来写成elseif swith语句与C相比： default改为otherwise 结尾加end 循环语句for语句 for 初始条件:步长(缺省为1):终值 123for i = 1 : 2 : 2*n-1 %循环体end for 循环变量=矩阵表达式，使循环变量取遍矩阵里每个数的值(以行为周期) while语句 结尾加end，用法同C 函数文件 一般格式为 1234function 输出形参表 = 函数名(输入形参表) %注释说明部分 %函数体end 当输出形参多于1个时，用方括号括起来 函数调用[输出参数表]=函数名(输入参数表)，支持嵌套调用和递归 参数个数可变：通过变量nargin和nargout实现 函数内部申明的变量都是局部变量 全局变量前缀global，所有函数都可以对其进行存取和修改 关于括号() 圆括号引用数组中的元素 [] 方括号表示向量或矩阵 {} 花括号用于元胞(cell)数组的分配和引用元胞与矩阵的区别是能放任何类似的元素，而矩阵只能放数值型数据 12345678910D=&#123;[1 2 3 4],&#x27;abc&#x27;,&#123;7 8 9&#125;，[4 5 6;11 22 33]&#125;D&#123;1&#125; %表示D中第一个元素 显示为 1 2 3 4D&#123;1&#125;(2) %表示D中第一个元素中第二个元素 显示为 2D&#123;3&#125;&#123;1&#125; %表示第三个元素中第一个元素 显示为 7D&#123;3&#125;(1) %表示第三个元素中第一个元素 显示为&#123;[7]&#125;D&#123;[1 2 3]&#125; %表示前三个元素 显示为1 2 3 4 ; ‘abc’ ;&#123;[7]&#125; &#123;[8]&#125; &#123;[9]&#125;","categories":[{"name":"Self-learning","slug":"Self-learning","permalink":"https://mengzelev.github.io/categories/Self-learning/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://mengzelev.github.io/tags/MATLAB/"}]},{"title":"问题求解3-总复习","slug":"Problem-Solving-3","date":"2019-01-07T11:21:20.000Z","updated":"2019-01-08T15:40:21.122Z","comments":true,"path":"2019/01/07/Problem-Solving-3/","link":"","permalink":"https://mengzelev.github.io/2019/01/07/Problem-Solving-3/","excerpt":"","text":"动态规划最优子结构 问题的最优解由相关子问题的最优解组合而成，这些子问题可以独立求解 使用“剪切-粘贴”技术证明：假设原问题取得最优解时，子问题没有取最优解，那么可以将子结构从整体删除替换为最优解，这与原问题取得最优解的前提矛盾 子问题间互相独立 运行时间：子问题总数*每个问题要考察的选择数 求解时先找出最优子结构，列出递推式 实现 自顶向下的备忘算法（带备忘的递归） 自底向上的动态规划算法（难写，但是快） 并没有板子 能解决的问题 矩阵乘法问题 最长公共子序列 最长上升子序列 &gt;主要就是一个列递推式的问题但是就是列不出来 贪心贪心选择性质 进行选择时，直接做出当前问题中看来最优的选择，而不必考虑子问题的解 贪心不太方便时可以进行预处理 证明：替换法 贪心算法得到一个解S，假设存在一个抽象的最优解S’，证明S’可以通过若干步满足要求的替换变成S 也可以证明S优于S(e.g.S的代价$\\le$S’的代价)，加上S’优于S的天然条件，可知S与S’都是最优解 解决问题 教室安排问题 Huffman编码树【可以等价为叶结点的带权路径长度之和最小问题 区间选点问题 数轴上有n个闭区间$[a_i,b_i]$。取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以是同一个） 将区间按右端点升序排序，优先处理小区间 实现 这个完全就是因题而异的了啊【哭了 并查集三个基本操作 MAKE-SET($x$) UNION($x,y$) FIND-SET($x$)：返回$x$所在集合的代表元 链表 时间复杂度make和find是$O(1)$，UNION$O(n\\lg n)$ 简单加权合并式启发策略（小的并到大的上 不相交集合森林 按秩合并，路径压缩 make和find$O(1)$，UNION$O(m_{\\alpha}(n))$ 板子123456789101112131415161718192021222324252627282930313233void init() &#123; for(int i = 1; i &lt;= n; ++i) &#123; f[i] = i; rank[i] = 0; &#125;&#125;/*递归版*/int find(int i) &#123; return f[i] == i ? i : f[i] = find(f[i]);&#125;/*非递归版*/int find(int x) &#123; int root = f[x]; while(root != f[root]) root = f[root]; int y = f[x]; while(x != root) &#123; y = f[x]; f[x] = root; x = y; &#125; return root;&#125;void unite(int a, int b) &#123; int fa = find(a); int fb = find(b); if(fa != fb) &#123; if(rank[a] &lt; rank[b]) f[a] = fb; else f[b] = fa; &#125;&#125; 变种 带权并查集 分类并查集 &gt;考到自求多福 解决问题 无向图连通分量个数 图的基本概念参考了ytr的整理 概念 诱导子图 链walk，迹trail，路path 回路circuit，圈cycle 连通性，连通分支 距离，测地线(长度为$u-v$距离的$u-v$路)，直径 环(loop)，你 连 你 自 己 平行边：重边 度数deg，最小度数$\\delta(G)$，最大度数$\\Delta(G)$ 度序列，可图的 几种图 完全图$K_n$ 补图 二部图，完全二部图($K{s,t}$)，星图star($K{1,s}$) 多部图，完全多部图(K_{s,s,s}) $G+H$：$G$和$H$放一起，顶点两两连起来 $G\\times H$：$G$的每个点都替换成一个$H$ n方体cube($Qn=Q{n-1}\\times K_2$) $r-$正则图：每个点度数都为$r$ 定理 设$G$是一个阶至少为3的图，则$G$是连通的当且仅当$G$包含两个不同的顶点$u$和$v$,使得$G-u$和$G-v$都是连通的 非平凡图$G$是二部的当且仅当$G$不含奇圈 图论第一定理：度数和=边数*2 每一个图都有偶数个奇点 设$G$为$n$阶图,若对于$G$中任意两个不邻接的顶点$u$和$v$, 都满足deg~u+deg~v\\geq n-1，则$G$是连通的且$diam(G)\\leq$2 设$r$和$n$为满足$0\\leq r\\leq n-1$的整数． 则存在n阶的r正则图当且仅当$r$和$n$中至少有一个为偶数 度序列可图的充要条件(删掉一个点依然可图) 树定义 割边 树，森林 定理 某条边是割边当且仅当该边不在任何一个cycle上 每一棵非平凡树都至少有两个端点(最长路径的两个端点) 【可以成为数学归纳法的依据】 使用数学归纳法证明图论问题的关键在于找到一个端点 有$k$个连通分量的森林有$n-k$条边，树就有$n-1$条边 每一个有$n$个顶点的连通图至少有$n-1$条边【证明：最小数原理】 任意两条可得树：连通、无环、$m=n-1$ 每个连通图都包含一棵生成树 Matrix Tree Theorem：连通图$G$的生成树个数可以用行列式求得 $T$是唯一最小生成树当且仅当$\\forall e\\in G\\setminus T: w(e)&gt;w(\\text{every other edge on the cycle in $T+e$})$ 推论：distinct weights $\\Leftarrow$ unique MST 推论：Maximum-weight edge in any cycle is unique $\\Leftarrow$ unique MST 若每个点度数大于等于2，则该图有cycle $e$是割边当且仅当$e$存在于$G$的某一棵生成树上 最小生成树性质 Cut Property VER I:$X$是某棵最小生成树的一部分，$(S,V\\setminus S)$是一个$X$没有横跨的切割，$e$为横跨$(S,V\\setminus)$的一条最轻的边，则$X\\cup {e}$是某棵最小生成树$T_2$的一部分。 VER II:$e$为横跨$(S,V\\setminus)$的一条最轻的边，则$e$属于某棵最小生成树 贪心选择性质，可由替换法证明 Cycle Property 若$e$为任意一个cycle上权重最大的一条边，则存在一棵最小生成树$T$，使$e\\notin T$ Kruskal $O(E\\lg~V)$ 123456789101112131415161718int kruskal() &#123; sort(edge, edge + m, cmp);//将边按权重从小到大排序 int cnt = 0; int ans = 0; for(int i = 1; i &lt;= n; ++i) f[i] = i;//初始化并查集 for(int i = 0; i &lt; m; ++i) &#123; int a = edge[i].u; int b = edge[i].v; int fa = find(a), fb = find(b); if(fa != fb) &#123; f[fa] = fb; ans += edge[i].w; cnt ++; if(cnt == n - 1) break; &#125; &#125; return ans;&#125; Prim $O(E\\lg V)$ 1234567891011121314151617181920int my_prim() &#123; int ans = 0; for(int i = 0; i &lt; n; ++i) &#123; mincost[i] = INF; vis[i] = false; &#125; while(true)&#123; int v = -1; for(int i = 0; i &lt; n; ++i) &#123; if(!vis[i] &amp;&amp; (v == -1 || mincost[i] &lt; mincost[v])) v = i; &#125; if(v == -1) break; vis[v] = true; ans += mincost[v]; for(int i = 0; i &lt; n; ++i) &#123; mincost[i] = min(mincost[i], map[v][i]); &#125; &#125; return ans;&#125; 图的计算机表示及其遍历图的表示 邻接链表 邻接矩阵 BFS 维护一个队列 时间复杂度$O(V+E)$ 搜完了会得到广度优先树 DFS 前驱子图：深度优先森林 边的类型 树边 前向边F：祖宗指向儿子 后向边B：儿子指向祖宗 横向边C：没有亲缘关系 复杂度$O(V+E)$ 每个结点有两个时间戳 $v.d$：记录该结点第一次被发现的时间 $v.f$：记录搜索完成对$v$的邻接链表的扫描的时间 $v.d&lt;v.f$ 拓扑排序 根据DFS后的$v.f$时间戳降序排序，即拓扑序最前的最晚结束访问 若$(u,v)\\in G$，则$v.f&lt;u.f$ 只有DAG才有拓扑排序 SCC算法描述 DFS($G$) DFS($G^{T})$，在主循环根据$v.f$的大小降序访问其邻接点，得到的每棵树都是一个强连通分量 单源最短路径 松弛操作是唯一导致最短路径估计和前驱结点发生变化的操作 性质 三角不等式性质：$s,u,v$ 上界性质：$v.d$撑死就是$\\delta(s,v)$ 非路径性质：$s-v$之间没路则$\\delta(s,v)=+\\infty$ 收敛性质：松弛前是最短路径，松弛后也是最短路径 路径松弛性质：一条最短路径上的点按先后顺序松弛，则终点的估计值等于最短路径长度 前驱子图性质：$v.d=\\delta(s,v)$，则前驱子图是一棵根结点为$s$的最短路径树 Bellman-Ford 对每条边进行$|V|-1$次relax 可以识别负权重环 $O(VE)$ 本质上是DP 12345678910111213void bellman_ford() &#123; dist[s] = 0; for(int i = 1; i &lt;= n - 1; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; if(dist[e[j].u &lt; INF &amp;&amp; dist[e[j].v] &gt; dist[e[j].u] + e[j].w) &#123; dist[e[j].v] = dist[e[j].u] + e[j].w; pre[e[j].v] = e[j].u; &#125; &#125; &#125; for(int j = 1; j &lt;= m; ++j) if(dist[e[j].v] &gt; dist[e[j].u] + e[j].w) flag = false;&#125; DAG 按拓扑序松弛结点（路径松弛性质保证） $\\Theta(V+E)$ Dijkstra 所有权重都非负 二叉堆实现$O(E\\lg V)$ 123456789101112131415161718void dijkstra() &#123; prority_queue &lt;node&gt; q; ver[0].d = 0; q.push(ver[0]); while(!q.empty()) &#123; node u = q.top(); q.pop(); for(int i = 0 ; i &lt; son[u].size(); ++i) &#123; int vid = son[u.id][i]; if(ver[vid].d &lt; u.d) continue; if(ver[vid].d &gt; u.d + map[u.id][vid]) &#123; ver[vid].d = u.d + map[u.id][vid]; q.push(ver[vid]); &#125; &#125; &#125;&#125; 差分约束 差分图：若$x_j-x_i\\le b_k$，则$w(v_i,v_j)=b_k$ Bellman-Ford可以求解 所有结点对最短路矩阵乘法 我不想管了！！ 是$n$维的Bellman-Ford Floyd-Warshall 本质DP，枚举最短路径上的中间结点 不允许负权重环，但是能报错（看对角元是否有负数） $\\Theta(n^3)$ 1234567void floyd() &#123; init(); //记得将所有map[i][i]置零 for(int k = 1; k &lt;= n; ++k) for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) map[i][j] = min(map[i][j], map[i][k] + map[k][j]);&#125; Johnson算法 用于稀疏图 重新赋值 新增源点$s$，该点与各点有权重为0的边 先跑一次Bellman-Ford，没有负权重环就重新赋值为$\\hat{w}(u,v)=w(u,v)+\\delta(s,u)-\\delta(s,v)$ 对每个点Dijkstra 恢复权重并返回 $O(VE\\lg E)$ 连通度割点 $v$与割边相连，则$v$是割点当且仅当$deg~v\\ge 2$ 对于至少有3个顶点的连通图，只要有割边，就一定有割点 $v$是连通图$G$的割点，当且仅当存在两个不同的顶点$u$和$w$，使得$v$位于$u-w$的任意一条路径上 非平凡连通图中，距离某个点最远的点不是割点 任意非平凡连通图至少包含两个非割点的顶点 不可分图：没有割点的非平凡连通图 块 图的一个最大不可分子图【类比连通分量 任意两个不同块的性质 不相交 至多一个公共点 如果有公共点，则该公共点为割点 连通度 $\\kappa(G)$点连通度=最小顶点割基数 $\\lambda(G)$边连通度=最小边割基数 点连通度$\\le$边连通度$\\le$最小度数 $\\kappa(G)\\le \\lfloor\\frac{2m}{n}\\rfloor$ Menger定理 设$u$和$v$是$G$中两个不邻接的顶点，则$u-v$的最小分离集的顶点个数等于内部不相交$u-v$路的最大个数 类似的有边定理：分离$u-v$的边的最小个数等于边不相交$u-v$路的最大个数 $k$连通当且仅当任意两个顶点至少有$k$条内部不相交路 $k$连通图中任意$k$个顶点均位于某一个圈上 Tarjan算法12345678910111213141516171819/*无向图tarjan*/void tarjan(int u, int pre) &#123; int child = 0; dfs_clock ++; dfn[u] = low[u] = dfs_clock; for(int i = 0; i &lt; son[u].size(); ++i) &#123; int v = son[u][i]; if(!dfn[v]) &#123;//(u,v)是树边 tarjan(v,u); child ++; low[u] = min(low[u], low[v]); if((u == 1 &amp;&amp; child &gt; 1) || (u != 1 &amp;&amp; dfn[u] &lt;= low[v])) &#123; cut_node.push_back(u); &#125;//割点判定：根结点有多个子树，或非根结点的访问序数小于等于能回溯的最大祖先 if(low[v] &gt; dfn[u]) bridge.push_back(&#123;min(u,v), max(u,v)&#125;); &#125; else if(dfn[v] &lt; dfn[u] &amp;&amp; v != pre) low[u] = min(low[u], dfn[v]); &#125;&#125; 旅行问题欧拉图 欧拉回路【闭合】/欧拉迹 有欧拉回路才算欧拉图 一个非平凡连通图是Euler的 当且仅当它的每个顶点的度都为偶数 有欧拉迹当且仅当只有两个奇度点 哈密尔顿图 哈密尔顿圈/哈密尔顿路 性质 $G$的任一非空子集$S$，都有$k(G-S)\\ge |S|$（$G$是哈密尔顿图，$k(G)$指图$G$的连通分支数） 充分条件 (Ore定理)对于不少于3个顶点的图，任意两个不邻接的顶点度数之和大于等于$n$，则$G$是哈密尔顿的。 推论：每个点的度数大于等于$n/2$ $u$和$v$是不邻接的两个顶点，且度数之和大于等于$n$，则$G+uv$是哈密尔顿的当且仅当$G$是哈密尔顿的 一个图是哈密尔顿的当且仅当它的闭包是哈密尔顿的 对于每个整数$j(1\\le j\\le n/2)$，$G$中度数至多为$j$的顶点数小于$j$，则$G$是哈密尔顿的 匹配与覆盖匹配 Hall条件：$\\forall X\\subseteq U, |N(X)\\ge |X|$ 婚姻定理：$r$个女人，$s$个男人，可能出现$r$对婚姻当且仅当对任意$k$，任意$k$个女人共认识至少$k$个男人。 最大匹配 完美匹配：阶为$2k$的图存在一个基数为$k$的匹配 任意$r$正则二部图均有一个完美匹配 独立性参数 最大边独立数$\\alpha’(G)$ 最下边覆盖数$\\beta’(G)$ 最大点独立数$\\alpha’(G)$ 最小点覆盖数$\\beta(G)$ Gallai恒等式 点独立数+点覆盖数=$n$ 边独立数+边覆盖数=$n$ 一般独立集比覆盖集好求 因子分解 $r-$因子：图$G$的$r-$正则生成图 完美匹配产生1-因子 图$G$包含1-因子当且仅当对于$V(G)$的任意真子集$S$,$k_O(G-S)\\le |S|$。($k_O(G)$表示$G$的奇连通分支个数) Petersen定理：所有无割边的3-正则图包含1-因子 任一至多有两条割边的3-正则图包含1-因子 可因子分解：能划分成多个因子 Petersen图不可1-因子分解 匈牙利算法123456789101112131415161718192021bool find(int x) &#123; for(int i = 1; i &lt;= n; ++i) &#123; if(map[x][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if(match[i] == 0 || find(match[i])) &#123; match[i] = x; return true; &#125; &#125; &#125; return false;&#125;int hungary() &#123; int ans = 0; for(int i = 1; i &lt;= n; ++i) &#123; memset(vis, 0 ,sizeof(vis)); if(find(i)) ans ++; &#125; return ans;&#125; 最大流流 $f:V\\times V\\to\\mathbb{R}$ 容量限制：$0\\le f(u,v)\\le c(u,v)$ 流量守恒：$\\forall u\\in V-s,t, \\sum\\limits{v\\in V}f(u,v)=\\sum\\limits_{v\\in V}f(v,u)$【流入=流出】 流的值$|f|=\\sum\\limits{v\\in V}f(s,v)-\\sum\\limits{v\\in V}f(v,s)$(从源结点流出的总流量-流入源结点的总流量) 几种特殊处理 反平行边：拆其中一条边为两条边 多源多汇 残存网络残存容量 c_f=(u,v)=\\begin{cases} c(u,v)-f(u,v) & (u,v)\\in E \\\\ f(v,u) & (v,u)\\in E\\\\ 0 & o.w.切割 把$V$划分为$S$和$T$两个集合，其中$s\\in S, t\\in T$ 横跨该切割的净流量：$f(S,T)=\\sum\\limits{u\\in S}\\sum\\limits{v\\in T}f(u,v)-\\sum\\limits{u\\in S}\\sum\\limits{v\\in T}f(v,u)$【所有结点对的流量之和 切割的容量：$c(S,T)=\\sum\\limits{v\\in S}\\sum\\limits{v\\in T}c(u,v)$【只考虑$S$出发进入$T$的容量 最小切割：容量最小的切割 最大流最小割定理 网络流解决最大匹配 一个集合连$s$，一个集合连$t$，两个集合间两两连，每条边都是单位容量 $O(VE)$ 图论证明方法解题时可能会用到一个或多个 反证法 构造法 临界法(最小/最大的满足条件的一个图) 归纳法 算两次","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"}]},{"title":"Lab4 实验报告","slug":"lab4-report","date":"2018-12-29T09:22:55.000Z","updated":"2019-01-07T11:15:17.436Z","comments":true,"path":"2018/12/29/lab4-report/","link":"","permalink":"https://mengzelev.github.io/2018/12/29/lab4-report/","excerpt":"","text":"实验进度描述我已完成所有内容。 以下是可以忽略的碎碎念： 实验开始一小时：写代码；实验开始两小时推翻前一个小时写的代码；实验开始四小时：推翻前两小时写的代码…… 会发生上面的情况其实是因为写cache_read的时候觉得调入调出可以封装为函数，写到cache_write的时候觉得cache_read里的寻找比对、缺失处理都可以封装成函数。在写PA的时候深受Copy-paste其害，所以想把能共享的代码都尽量封装成函数，减轻debug的痛苦 测试的时候曾经出现过写过的地址从cache调出之后回写到内存不成功。加了回写检查函数check_write_back()依然没有定位错误。出去吹了冷风突然意识到可能是回写的内存地址算错了。回去一看发现是cache装入的时候tag没有更新。结论：吹冷风调试法真有用 一开始在虚拟机里用vim写的时候，为了区分变量，都取了超长的名字，打起来很累，后来无奈先在windows里用CLion打开写了基本框架再放到Linux里进行调试(因为虚拟机里开CLion会卡爆)。CLion写代码真的是体验极佳，下学期OSLab双系统走起了 我个**！！！第一遍做完数据没用给定的trace！第二遍做的数据被我一个手抖永久删除了！！！excel还没办法脚本导入！！！一个数据做了3遍！！！ 代码解释为了提高代码的复用率、降低debug负担，我封装了很多API。 为了模拟cache结构定义了如下结构体 123456struct CacheLine &#123; bool valid; //有效位 bool dirty; //脏位 uint32_t tag; //标记位 uint32_t data[16]; //一行64B数据&#125;line[1024]; 定义了如下全局变量来记录cache的相关信息 123456/* cache info */int ass_width; //关联宽度int total_width; //总宽度int group_width; //组宽度(指cache组号在主存地址中的位数)#define NR_ASS exp2(ass_width) //宏定义，组内行数#define OFFSET 0x3f //与操作后可以取出块内偏移量 将以下功能封装为了API。因为宏定义会涉及到加括号等问题，怕出现奇奇怪怪的bug，所以并没有使用宏定义，而是直接用函数代替 123456789uint32_t get_tag(uintptr_t addr) &#123; //获得一个内存地址的tag字段 return (addr &gt;&gt; (group_width + BLOCK_WIDTH));&#125;uint32_t get_group(uintptr_t addr) &#123; //获得一个内存地址的cache组号字段 return ((addr &gt;&gt; BLOCK_WIDTH) &amp; mask_with_len(group_width));&#125; 1234567891011121314151617181920212223void move_in(uintptr_t addr, int line_num) &#123; //将主存中某一块调入cache中 assert(line[line_num].valid == false); uint32_t block_num = addr &gt;&gt; BLOCK_WIDTH; mem_read(block_num, (uint8_t*)(line[line_num].data)); line[line_num].valid = true; line[line_num].dirty = false; line[line_num].tag = get_tag(addr);&#125;void move_out(int group_num, int line_num) &#123; //将cache的某一行调回到主存中，同时判断dirty bit并写回 assert(line[line_num].valid == true); assert(line_num &lt; 1024); line[line_num].valid = false; if(line[line_num].dirty) &#123; uintptr_t block_num = (line[line_num].tag &lt;&lt; group_width) + group_num; mem_write(block_num, (uint8_t*)line[line_num].data); line[line_num].dirty = false; //write back &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435int find_in_group(uintptr_t addr, int group_num) &#123; //在某一组寻找找某主存地址对应的行，返回其所在行号，缺失则返回-1 int group_start = group_num * NR_ASS; int group_end = group_start + NR_ASS; uint32_t tag = get_tag(addr); for(int i = group_start; i &lt; group_end; ++i) &#123; if(line[i].valid &amp;&amp; line[i].tag == tag) &#123; cycle_increase(1); hit_visit ++; return i; &#125; &#125; return -1;&#125;int replace_in_group(uintptr_t addr, int group_num) &#123; //将主存地址对应的主存块调入cache中 miss_visit ++; int group_start = group_num * NR_ASS; int group_end = group_start + NR_ASS; for(int i = group_start; i &lt; group_end; ++i) &#123; if(!line[i].valid) &#123; move_in(addr, i); return i; &#125; &#125; //如果组内有空行，则直接放入空行中 int line_out = group_start + choose(NR_ASS); assert(line_out &lt; group_end); move_out(group_num, line_out); move_in(addr, line_out); //否则随机替换一行 return line_out;&#125; 123456void write_in_line(int line_num, int index, uint32_t data, uint32_t wmask) &#123; //将数据写入cache某一行的某个index中 line[line_num].dirty = true; line[line_num].data[index] &amp;= (~wmask); line[line_num].data[index] |= (data &amp; wmask);&#125; 这样一来需要实现的3个函数只需要调用以上API即可 123456789101112131415161718192021222324252627282930313233343536373839404142void init_cache(int total_size_width, int associativity_width) &#123; /*设置cache的一系列参数*/ total_width = total_size_width; assert(total_width &lt;= 14); ass_width = associativity_width; group_width = total_width - ass_width - BLOCK_WIDTH; /*初始化用于统计的变量*/ cycle_cnt = 0; total_visit = hit_visit = miss_visit = 0; /* set all the valid bits and dirty bits to invalid */ for(int i = 0; i &lt; NR_LINE; ++i) line[i].valid = line[i].dirty = false;&#125;uint32_t cache_read(uintptr_t addr) &#123; total_visit ++; uint32_t group_num = get_group(addr); uint32_t index = (addr &amp; OFFSET) / sizeof(int); //index in group int line_num = find_in_group(addr, group_num); if(line_num &gt;= 0) return line[line_num].data[index]; //hit则直接读出 int line_out = replace_in_group(addr, group_num); return line[line_out].data[index]; //否则从主存调入cache&#125;void cache_write(uintptr_t addr, uint32_t data, uint32_t wmask) &#123; total_visit++; uint32_t group_num = get_group(addr); uint32_t index = (addr &amp; OFFSET) / sizeof(int); //index in group int line_num = find_in_group(addr, group_num); if(line_num &gt;= 0) write_in_line(line_num, index, data, wmask); //hit则直接写入 else &#123; int line_out = replace_in_group(addr, group_num); write_in_line(line_out, index, data, wmask); &#125;//否则写分配&#125; cache性能测试运行时间测算 框架代码已经给内存的读写赋好了相应的时钟周期数，所以我很自然地想到通过统计时钟周期数来统计运行的时间 关于怎么对cache读写操作的时钟周期测算，讲义说可以建立关于关联度的带参数的模型，但是我回想起来课本上讲过，组相联组内是用了很多比较器进行并行比较的。所以我认为读写的时钟周期数应该和关联度以及cache容量关系不大，所以将读写的时钟周期都设置为1。&gt;可能也有想省事的惰性成分在里面 除时钟周期数外，还衡量一个缺失率。由于主存读写比cache读写慢得多，读写命中率也能表征cache的性能 声明了一些用于统计的变量 1234/* statistics */uint64_t total_visit = 0;uint64_t hit_visit = 0;uint64_t miss_visit = 0; 测算方法：控制变量法，控制组相联度或cache总宽度其中一个量不变，改变另外一个量。每种配置测量3次后取平均。根据结果使用excel作图，得到如下结果。【数据已经放在打包上传的.xlsx文件中】 从以上数据和图表中可以看出： cache容量越大，缺失率越低，花费的总时钟周期数也越少。这是因为cache容量大了以后，能装入更多的主存块，缺失率就会相应地降低，需要进行替换的次数也会变少。但是cache大就意味着高昂的造价，而且SDRAM的材质(?)决定了cache不可能做到很大。而且由图中可以看出，当cache容量增大到一定大小时，其性能增长就很不明显了，因此一般会选择比较中等的大小。 缺失率与组相联度似乎并不是呈单调关系。原理上分析，组相联度越大，同一组内发生冲突的概率就越低，需要调出的次数也会越低。但有可能microbench-test中的访存顺序会导致某些经常访问的块，在相联度较小时被放到了不同的组中，而相联度较大时被放到了同一组中，导致发生冲突的次数增加。而且越高的组相联度，意味着越多的比较器，意味着更大的体积和更高的造价。 综上，对于microbench-test下的workload，我认为最佳的组相联宽度是2(4路组相联)。如果有钱任性，cache容量越大越好；如果要省钱经济，12或13的容量宽度(4KB或8KB的容量)是比较理想的。 思考题数据对齐和存储层次结构 如果没有对齐，同一个数据可能会被分配再两个主存块的交界处，读取这个数据的时候发生cache miss的概率更大，cache miss后可能需要调入两个主存块，代价更大，运行速度会大大降低。 不知道cache的复杂性对频率的影响? 我不是很看得懂这里的建模的意思。我认为$ak^2+b$中%a,b$只是两个参数，考察它们对cache性能的影响是没有意义的，而是应该固定$a,b$，考察组相联度和cache容量对cache性能的影响。但是我已经在上文提到了我并没有把这两者与cache的读写速度关联起来。所以我没有建立带参数的模型。 Acknowledgements 感谢不水的正经学习群的朋友们当我的小黄鸭，帮我调试 感谢*的自己，因为一系列\\*行为，成功锻炼了心理承受能力","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Lab","slug":"Lab","permalink":"https://mengzelev.github.io/tags/Lab/"},{"name":"Ics","slug":"Ics","permalink":"https://mengzelev.github.io/tags/Ics/"}]},{"title":"PA4实验报告","slug":"PA4-report","date":"2018-12-28T08:00:32.000Z","updated":"2019-01-07T11:13:04.106Z","comments":true,"path":"2018/12/28/PA4-report/","link":"","permalink":"https://mengzelev.github.io/2018/12/28/PA4-report/","excerpt":"","text":"实验进度我已完成全部实验内容。 2018/12/15:完成PA4.1。不少自认为关键的地方竟然怎么改都是对的，有点慌 2018/12/16:PA4.2第一个任务完成，再不开始做数电大实验就要死了，只能封印PA 2018/12/23：被数电大实验折磨完，PA4.2完成。仙剑跑得慢到感人。 2018/12/24：平安夜，发现4.2最后一个task忘了跑了，定位了半天bug发现是context_kload忘了改成context_uload，心情简单。开始做4.3，但是由于前几天睡眠不足连着写了好几个沙雕bug，于是决定先放弃。 2018/12/25：圣诞节，继续写PA4.3，花了一个小时解决了平安夜昏睡状态下写出的沙雕bug，花了4个小时解决了当天写出的沙雕bug，也就是PA最后一个bug。PA通关! 蓝框思考题迫于作业和复习考试压力，这次也一道都没做…… 我遇到的bug 没看到讲义上要求把loader把文件映射到物理页的要求，映射到虚拟页上，结果一直出发pte.present==0的assert。仔细一想loader的确有义务把程序搬到合适的实际位置 即使是一个简单的dummy程序，其内容也有两页多。而且不能直接用文件大小/PGSIZE，否则余数部分会被丢弃 make run的时候可能会碰到一大堆链接报错，原因不明，目前解决方案是在所有目录下都来一遍clean(-update)-run全家桶。这时候调试公理1是不是被打破了呢？ _switch是用来切换到下一个进程的，因此传入参数肯定为next而非tf【这不是我遇到的bug，是我不少同学都遇到的bug，所以也记下来了 增加时钟中断时需要填写idt表，太久没碰系统调用这个都忘了 4.3最后测试进程切换的时候千万不要因为嫌仙剑跑得太慢换成bmptest，这玩意儿是根本block了events_read()的，导致我debug了4个小时才发现 实验中的发现 与cr3和cr0有关的指令的译码函数其实可以使用框架代码提供的现成的译码函数,只不过需要研究一下怎么使用 在写_map函数时，我思考了很久，为什么当页目录的present位无效时，要用回调函数申请一个新的物理页。觉得应该是把这一页作为了存放页表的物理页 一些头文件里有不少讲义没提到的、可以方便coding的宏定义，例如x86.h和mmu.h,论RTFSC的重要性 实验心得 一定要好好读讲义 和同学交流了一下，发现不一定要全部理解了再开始写代码。可以把框架代码中提供的东西输出一下，根据输出的值来猜测这个变量的含义，或者这个函数的功能。做实验和理解理论是相辅相成的 每次开机，看着一行行初始化Log，就会想到这只是一个比我刚刚造完的(其实大部分都是yzh写的)的东西复杂一点(这个一点有点多)的家伙，就觉得五味杂陈 迫于时间压力不少挑战极限的选做题都没做 这学期做PA还是依赖了不少人的帮助，寒假想要二周目并完成PA5，希望也能把不少选做题都做一下 Acknowledgements 感谢某人提供的探路和盯着写bug服务 感谢不水的正经学习群的群友们互帮互助的debug氛围 本实验报告同样会将去掉必答题的版本同步上传至个人blog","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"},{"name":"ICS","slug":"ICS","permalink":"https://mengzelev.github.io/tags/ICS/"}]},{"title":"算法导论学习笔记-矩阵运算","slug":"clrs28Matrix-Operation","date":"2018-12-18T01:50:18.000Z","updated":"2019-01-07T11:16:02.932Z","comments":true,"path":"2018/12/18/clrs28Matrix-Operation/","link":"","permalink":"https://mengzelev.github.io/2018/12/18/clrs28Matrix-Operation/","excerpt":"","text":"求解线性方程组Ax=b欠定的(underdetermined)：方程的数目少于未知变量数目$n$，则该线性方程组为欠定的超定的(overdetermined):方程数目超过未知变量数目$n$非奇异矩阵：$A$的秩等于未知变量的个数$n$ LUP分解思想：找出3个$n\\times n$矩阵$L,U,P$，满足$PA=LU$,其中$L$是一个单位下三角矩阵$U$是一个上三角矩阵$P$是一个置换矩阵每一个非奇异矩阵$A$都会有这样一种分解 Ax=bPAx=PbLUx=Pbx求解两个三角线性系统下三角系统$Ly=Pb$上三角系统$Ux=y$ 正向替换与方向替换可在$\\Theta(n^2)$时间内求解下三角系统 置换阵$P$可以用数组$\\pi[1..n]$表示 P_{i,j}= \\begin{cases} 1 & (j == \\pi[i])\\\\ 0 & (j\\neq\\pi[i]) \\end{cases}从第一个式子开始正向替换，可以得到 y_i=b_{\\pi[i]}-\\sum\\limits_{j=1}^{i-1}l_{ij}y_i反向替换同理，最终可以得到 x_i=(y_i-\\sum\\limits_{j=i+1}^{n}u_{ij}x_j)/u_{ii} LU分解计算Gauss消元法： 行消元得到的行梯阵即$U$ $L$由消去变量所用的行的乘数组成 可以看成a_{ij}=a_{ij}-\\frac{a_{ik}a_{kj}}{a_{kk}} 运行时间$\\Theta(n^3)$ LUP分解计算在LU分解的基础上，为了保证除数不为0和减少数值不稳定，每次选择该列中具有最大绝对值的元素，交换到对角元的位置 运行时间$\\Theta(n^3)$ 矩阵求逆LUP分解可以用于计算逆矩阵(废话，高斯消元可以，LUP当然可以)AX_{i}=e_i 矩阵乘法和矩阵求逆具有相同的时间复杂度 证明时间复杂度相同：两个问题都能在O(另一个问题算法的时间复杂度)时间内解决 证明的时候可能会用到分块阵的思想来转化问题 对称正定阵引理28.3：任何对称正定矩阵都是非奇异矩阵任何对称正定矩阵都有逆矩阵。 引理28.4：如果$A$是一个对称正定矩阵，那么$A$的每一个主子矩阵都是对称正定的。 舒尔补：矩阵$A$关于主子矩阵$A_k$的舒尔补为$S=C-B{A_k}^{-1}B^T$。其中，$A$为对称正定阵且 A=\\left[ \\begin{matrix} A_k & B^T \\\\ B & C \\end{matrix} \\right]舒尔补定理：如果$A$是一个对称正定矩阵，$A_k$是$A$的$k\\times k$主子矩阵，那么$A$关于$A_k$的舒尔补是对称正定的。 推论28.6：一个对称正定矩阵的LU分解永远不会出现除数为0的情形 最小二乘逼近就是看上去很厉害实际上真的很厉害的曲线拟合","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://mengzelev.github.io/tags/Graph-Algorithms/"}]},{"title":"图论学习笔记-平面图与着色","slug":"planar-graph-and-coloring","date":"2018-12-13T06:30:30.000Z","updated":"2018-12-15T03:40:57.630Z","comments":true,"path":"2018/12/13/planar-graph-and-coloring/","link":"","permalink":"https://mengzelev.github.io/2018/12/13/planar-graph-and-coloring/","excerpt":"","text":"平面图平面图(planar graph)：如果$G$能够被画在一个平面上而使得任何两条边都不会交叉 平图(plane graph)：如果$G$是平面图且$G$的任何两条边都不交叉 平面图的例子：cycle, path, star, tree 区域(regions)：一个平图把平面分成一些连通片外区域(exterior region)：每个平图中总有的一个无界的区域边界(boundary)：在一个平图中，顶点和边斗鱼某个给定区域$R$关联的子图称为是$R$的边界 割边总是恰好在一个区域的边界上非割边一定位于两个区域的边界上 如果$G$是一个至少含有三条边的连通平图，则$G$的而每个区域的边界至少含有三条边 定理9.1(Euler恒等式)：如果$G$是一个阶为$n$，边数为$m$且含有$r$个区域的连通平图，则$n-m+r=2$ 定理9.2：如果$G$是一个阶为$n\\ge 3$且边数为$m$的平面图，则$m\\le 3n-6$。(平面图的必要条件，非平面图的充分条件)逆否命题：设$G$阶为$n$，若$m&gt;3n-6$，则$G$是非平面图。注：满足$m\\le 3n-6$的不一定是平面图 推论9.3：每个平面图含有一个度小于或等于5的顶点。 推论9.4：完全图$K_5$是非平面的。 极大平面的(maximal planar)：若$G$是平面的，且在$G$的任意两个不邻接的顶点之间添加一条边即可产生一个非平面图。另一种表述：$G$是平面的，但$G$不是任何一个平面图的生成子图极大平面图满足$m=3n-6$ 定理9.5：图$K_{3,3}$是非平面的 细分(subdivision)： 如果有一个或多个度为2的顶点被插入到$G$的一条或多条边中，则称图$G’$是图$G$的一个细分 定理9.7(Kuratowski定理)：一个图$G$是平面图当且仅当$G$不含$K5$，$K{3,3}$，或者$K5$或$K{3,3}$的一个细分作为子图。 如果一个图$G$含有(1)至多4个度大于或等于4的顶点(2)至多5个度大于或等于3的顶点，则$G$必定是平面的。 顶点染色对偶(dual)：每张地图都有一个与之关联的图$G$，称为该地图的对偶，其中$G$的顶点即为地图的区域，$G$的两个顶点是邻接的当且仅当它们所对应的区域是相邻的每张地图的对偶图都是平面图，每个连通的平面图都是某个地图的对偶。 真染色(proper coloring)：给$G$的顶点分配一些颜色(来自于某个颜色集合)，是的每个顶点都能分配到一种颜色，且邻接的顶点被染成不同的颜色，简称为染色(coloring) 色数(chromatic number)$\\chi(G)$：在$G$的所有染色中，所用的最少颜色数 $k$可染色的(k-colorable)：如果能用一个含有$k$种颜色的集合给$G$的顶点染色，则称$G$是$k$可染色的(k-colorable)，应用$k$种颜色的染色称为是$k$染色(k-coloring)。 若$\\chi(G)=k$，则$G$也称为是$k$色的(k-chromatic)，并且$G$的每个$k$染色都是$G$的最小染色(minimum coloring) 定理10.1(四色定理)：每个平面图的色数至多是4 色类(color classes)：若$G$是一个$k$色图，则可以把$V(G)$划分成$k$个独立集$V_1,V_2,…,V_k$，此时这些顶点集称为色类。 定理10.2：图$G$的色数是2当且仅当$G$是一个非空的二部图。 (复习：定理1.12：图$G$是二部的当且仅当其不含奇圈)若$G$含有奇圈，则$\\chi(G)\\ge 3$ $n$阶图$G$的色数为$n$当且仅当$G=K_n$ 证明$\\chi(G)=k$，必须证明： 至少需要$k$种颜色来为$G$染色(不能用$k-1$种颜色为$G$染色) 存在$G$的一个$k$染色 若$H$为$G$的一个子图，则$\\chi(H)\\le\\chi(G)$ 团(clique)：$G$的一个完全子图团数(clique number)\\omega(G)：图$G$中最大团的阶数$\\alpha(G)=k$当且仅当$\\omega(G)=k$ 定理10.5：对每个$n$阶图$G$：\\chi(G)\\ge\\omega(G), \\chi(G)\\ge\\frac{n}{\\alpha(G)}(给出了图$G$的色数的下限) 图$G$的染色可以看成是$V(G)\\to\\mathbb{N}$的一个函数$c:V(G)\\to\\mathbb{N}$，使得当$uv\\in E(G)$时，$c(u)\\neq c(v)$ 定理10.7：对于每个图$G$，$\\chi(G)\\le 1+\\Delta(G)$。($\\Delta(G)$为$G$的最大度) 定理10.8(Brooks定理)：对每个非奇圈也非完全的连通图$G$，$\\chi(G)\\le\\Delta(G)$ 定理10.9：对于每个图$G$,$\\chi(G)\\le 1+\\max{\\delta(H)}$，其中$\\max$取遍$G$的所有诱导子图$H$。 影子图(shadow graph)$S(G)$:通过在$G$中，对其每个顶点$v$，增加一个新的顶点$v’$，称之为$v$的影子顶点(shadow vertex) 定理10.10：对于每个整数$k\\ge 3$，都存在一个色数为$k$的无三角的图。","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"Graph Theory","slug":"Graph-Theory","permalink":"https://mengzelev.github.io/tags/Graph-Theory/"}]},{"title":"卫宫家今天的饭","slug":"Dinner","date":"2018-12-10T08:22:19.000Z","updated":"2018-12-10T09:43:06.918Z","comments":true,"path":"2018/12/10/Dinner/","link":"","permalink":"https://mengzelev.github.io/2018/12/10/Dinner/","excerpt":"","text":"题源POJ 3281 Diningopenjudge传送门饱受OJ折磨的我决定以德报怨给大家出道水题 题目描述基本只是把原题搬到了月球上 N位客人，F种食物，D种饮料 每位客人有多种喜欢的事物和饮料 每位客人只吃一种食物、只喝一种饮料 每种食物，每种饮料只能被一位客人吃/喝 可以看成两个二分图最大匹配问题 构建流网络 先尝试：食物-客人-饮料 会出现一位客人对应多份食物或饮料的情况 客人结点需要加上结点容量 将每个客人结点拆分为两个 源点s-食物-客人1-客人2-饮料-汇点 最大流算法 数据规模[1,100] EK完全OK 没有刻意生成卡任何算法的数据，也许可以尝试暴力 板子写起来有丶难度 代码虽然我贴了，但是务必自己写一遍！ EK板子 容量c[N][N]，流量f[N][N] 只需要一个记录当前残存容量的数组map[N][N] 随便搜一下就能找到 板子代码int edmonds_karp() &#123; int ans = 0; int minc; while((minc = bfs()) != -1) &#123; //bfs找到一条增广路径 ans += minc; //加上这条增广路径的流量 int tt = t,pt; while(tt != s) &#123; pt = pre[tt]; map[pt][tt] -= minc; map[tt][pt] += minc; tt = pt; &#125; //修改这条增广路径上的边的残存容量 &#125; return ans; &#125; bfs寻找增广路径int bfs()&#123; memset(pre, -1, sizeof(pre)); int minc = 1e9; queue &lt;int&gt; q; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); if(u == t) break; for(int i = 1; i &lt;= t; ++i) &#123; if(pre[i] == -1 &amp;&amp; map[u][i]) &#123; minc = min(minc, map[u][i]); //更新当前路径的最小残存容量 q.push(i); pre[i] = u; //pre数组用于记录bfs找到的增广路径 &#125; &#125; &#125; if(pre[t] == -1) return -1; else return minc; &#125; 建图代码不贴惹，自己写吧:) Tips:为了将各种不同类型的所有点都囊括在一个数组里的同时，增强代码的可读性，可以使用宏定义 #define FOOD(x) **我** #define GUEST1(x) **是** #define GUEST2(x) **马** #define DRINK(x) **赛** #define s **克** #define t **!**","categories":[],"tags":[]},{"title":"PA3实验报告","slug":"PA3-report","date":"2018-12-08T08:00:32.000Z","updated":"2019-09-14T07:43:09.174Z","comments":true,"path":"2018/12/08/PA3-report/","link":"","permalink":"https://mengzelev.github.io/2018/12/08/PA3-report/","excerpt":"","text":"实验进度我已完成所有内容。好，下面是惯例碎碎念。 2018/11/18心态爆炸的一天！先是因为脑子短路完全没有想到idt的地址就在lidt译码过后的id_dest里。然后还因为惯性思维从id_dest-&gt;val里读地址，疯狂出错才发现应该在id_dest-&gt;addr里（因为是地址）。组织Context的时候思考了半天，最后问了大腿才知道怎么判断上下文的组织结构。感觉还是课本知识学得不够扎实的恶果。今日不宜PA，关机睡觉。 2018/11/19PA3.1完成。感觉测试手段都不太给力，不知道有没有埋下隐藏bug 2018/11/24PA3.2完成。感觉莫名顺利，可能是3.3要自闭的征兆 2018/12/1开始自闭PA3.3，实现了文件读写操作，死活看不到PASS!!!，文件读写时对长度超过文件大小的情况的处理有一些麻烦，调了半天，最后发现是PA3.2时就好了的SYS_write没有加上刚刚写的fs_write，喷了。开始编写设备文件操作，看不懂vga那块到底是要干啥，机房关门了，回去睡觉。 2018/12/2继续自闭PA3.3。为了看懂VGA那块的架构直接翻出了bmptest的源码，然后一路摸到NDL库的源码，花了大概一个下去终于显示出了ProjectN的Logo。实现events_read()时还把事件的格式搞错了debug了半天，终于可以开始跑仙剑了。小心翼翼地开始游戏，没有注释掉Log因此看到了瀑布般的Log信息，然后50min才播放完片头对话，所幸无事。然后注释掉了所有Log，又胆战心惊地开始尝试所有存档点，尝试了穿墙和穿人，全部失败，确认了没有肉眼可见的bug。长舒一口气，然后加急写完了批处理系统，机房关门，走人。难以置信我居然跑出了仙剑，亢奋。 必答题其实我写PA的时候都在系统调用过程梳理里做好笔记了 好孩子要自己做！ 蓝框思考题最近太忙了一题都没写…想写的时候讲义又挂了…二周目的时候再思考吧orz 实验中的发现关于nanos-lite和nemu是怎么通讯的在写PA3.1中的lidt指令的时候，我有个很大的疑惑，idt是在nanos-lite里被定义的，nemu要怎么获取它的地址呢？_cte_init中有一步调用了set_idt函数，将idt的地址和大小用内联汇编语句写入了指令集。因此当nanos编译成nemu可执行的指令后，idt的地址就可以通过相应的译码函数写入id_dest中。问了一位nb的学长后，学长给出了如下理解 不在system.c里的指令，一般靠编译c文件成机器码就可以给nemu做事，所以pa2很顺利；而system.c的东西依赖于系统（比如中断），只靠编译c文件做不到int、lidt这些东西，所以要内联汇编 关于如何判断_Context结构的组织顺序_Context是在函数irq_handle里作为参数的类型被传入的，然而irq_handle是通过汇编代码直接调用的，因此没有显式的参数传递语句，实际的参数是存放在栈中%ebp-8的位置开始的位置，观察call irq_handle之前所有的push相关语句就可以得知寄存器的顺序。而eip,eflags和eip是硬件保存的，因此需要观察int指令中的入栈顺序才能知道这三者的顺序。 系统调用过程梳理 用户层navy-apps在相应的系统调用函数（如_exit()）中调用系统调用接口函数_syscall_() _syscall_用内联汇编语句将int 0x80和相应的系统调用参数传给nemu nemu执行int指令，叫出nanos-lite irq_handler通过int指令传入的参数识别出这是一次系统调用的event，打包传给do_event irq.c中的do_event()函数调用do_syscall()执行系统调用事件 syscall.c中的do_syscall()函数根据传入的参数（在上下文的相应寄存器中）执行相应的系统调用操作，设置返回值并返回 我遇到的bug 堆区管理的时候声明的用于记录program break的变量pbrk没有初始化【所以说初始化真的是个好文明 写了fs_write却忘了修改相应的系统调用SYS_write找了一个下午 所有关于文件读写的系统操作都需要控制open_offset，不能超过当前文件的size，但是serial_write和dispinfo_read等不同文件的读写又不能一概而论，写bug和debug的时候要特别注意 fs_lseek最后要控制当前的open_offset，不然可能会导致fs_read和fs_write的功能无法正常使用 fs_read和fs_write需要对open_offset做出修改 函数指针的调用就跟函数一样用就行了 fb_write里的offset怎么用，怎么给draw_rect传参，可能要一直摸到libnbl才能搞清楚 字符串不能x**初始化，会由于某些我搞不懂的原因编译出STOS指令，导致看到亲切的i386 Logo if((keytemp &amp; 0x8000) == 1)和if(keytemp &amp; 0x8000)是不一样的！！！！！！[你是沙雕吗.jpg] 对讲义的一些建议（你们选择性反馈给yzh） 建议把能看到PASS!!!信息的放在serial_write()之后，不少同学都在实现完SYS_write之后没看到PASS！！！感到困惑（当然仔细想一下还是能想通） 堆区管理那一块太考验阅读理解水平了，而且大部分人会忘掉PA2还接触过AM里一个叫heap的结构体，就稍微提醒一下下呗（ 让dummy实现_syscall_时，最好能提醒一下如果按照之前加系统调用一下加入do_event中会触发死循环，或者干脆把下面的必做部分并到一起写，减少困惑 实验心得 RTFSC是很难的，不要一下子看不出来就自闭，不然会出事情的 要成为一名优秀的程序猿，首先你要学好语文 出bug不可怕，如果能通过debug的过程对框架代码和计算机系统的原理有更深刻的理解，其实是一件很赚的事情。听了助教讲课之后我深刻感受到，一出bug就问大腿“怎么写才是对的”，实在太亏了，应该搞清楚哪里写错了，为什么写的fault这个出现这样的failure。 Appreciation 感谢某人提供的探路和debug服务，我觉得有点保护过度了再这样下去我要不会自己写代码了【捂脸 感谢名字一直在换的学习群的群友们互帮互助的debug氛围 本实验报告同样会将去掉必答题的版本同步上传至个人blog","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"}]},{"title":"算法导论学习笔记-最大流","slug":"clrs-26Maximum-Flow","date":"2018-12-05T07:03:20.000Z","updated":"2019-01-17T12:08:51.319Z","comments":true,"path":"2018/12/05/clrs-26Maximum-Flow/","link":"","permalink":"https://mengzelev.github.io/2018/12/05/clrs-26Maximum-Flow/","excerpt":"","text":"流网络流网络 有向图$G=(V,E)$ 图中中每条边$(u,v)\\in E$有一个非负的容量值$c(u,v)\\ge 0$ 如果$(u,v)\\notin E$，定义$c(u,v)=0$ 如果边集合$E$包含一条边$(u,v)$，则图中不存在反方向的边$(v,u)$ 有源结点$s$和汇点$t$ 流网络图是连通的 除源结点外的每个结点都至少有一条进入的边，$|E|\\ge |V|-1$ 流设$G=(V,E)$为一个流网络，其容量函数为$c$。设$s$为网络的源结点，$t$为汇点。$G$中的流是一个实值函数$f: V\\times V \\to \\mathbb{R}$，满足下面两条性质： 容量限制：对于所有的结点$u,v\\in V$，要求$0\\le f(u,v)\\le c(u,v)$ 流量守恒：对于所有的结点$u\\in V-{s,t}$，要求\\sum\\limits f(v,u)=\\sum\\limits f(u,v)当$(u,v)\\notin E$时，从结点$u$到结点$v$之间没有流，因此$f(u,v)=0$ 称非负数值$f(u,v)$为从结点$u$到结点$v$的流。（流入=流出） 一个流$f$的值$|f|=\\sum\\limits{v\\in V}f(s,v)-\\sum\\limits{v\\in V}f(v,s)$ （从源结点流出的总流量减去流入源结点的总流量） 最大流问题：给定一个流网络$G$、一个源结点$s$、一个汇点$t$，找到值最大的一个流 反平行边 如果要使用反平行边来模拟一个流问题，就选择两条反平行边中的一条，加入一个新结点来将其分解为两段，并以新的结点到原来边的结点的两条路替换所选边，同时将两条新设立的边的容量设置为与原来的边的容量相同。 具有多个源结点和多个汇点的网络加入一个超级源结点$s$和一个超级汇点$t$ Ford-Fulkerson方法 残存网络给定流网络$G$和流量$f$，残存网络$G_f$由那些仍有空间对流量进行调整的边构成。 残存容量为$c_f(u,c)=c(u,v)-f(u,v)$ 对正流量的缩减：将边$(v,u)$加入到图$G_f$中，并将其残存容量设置为$c_f(v,u)=f(u,v)$ 残存容量的形式化定义如下： 给定一个流网络$G=(V,E)$和一个流$f$，则有$f$所诱导的图$G$的残存网络为$G_f=(V,E_f)$，其中$E_f={(u,v)\\in V\\times V: c_f(u,v)&gt;0}$，有$|E_f|\\le 2|E|$ 递增：如果$f$是$G$的一个流，$f’$是对应的残存网络$G_f$的中的一个流，定义f'\\uparrow f':V\\times V\\to\\mathbb{R}为流$f’$对流$f$的递增 抵消操作：在残存网络中将流量推送回去 引理26.1：|f\\uparrow f'|=|f|+|f'| 增广路径增广路径$p$：残存网络$G_f$中一条从源结点$s$到汇点$t$的简单路径 残存容量：在一条增广路径$p$上能够为每条边增加的流量的最大值c_f(p)=\\min\\{c_f(u,v): (u,v)\\in p\\} 流网络的切割流网络的切割：将结点集合$V$划分为$S$和$T=V-S$两个集合，使得$s\\in S, t\\in T$ 横跨切割的$(S,T)$的净流量$f(S,T)$：f(S,T)=\\sum\\limits_{u\\in S}\\sum\\limits_{v\\in T}f(u,v)-\\sum\\limits_{u\\in S}\\sum\\limits_{v\\in T}f(v,u) 切割$(S,T)$的容量：c(S,T)=\\sum\\limits_{v\\in S}\\sum\\limits_{v\\in T}c(u,v)最小切割：整个网络中容量最小的切割 对于容量，只计算从集合$S$发出进入集合$T$的边的容量，而忽略反方向边上的容量 对于流，考虑从$S$到$T$的流量减去从$T$到$S$的反方向的流量 引理26.4：整个流网络的流量与横跨某一个切割的流量相等f(S,T)=|f| 推论26.5：$|f|\\ge c(S,T)$ 定理26.6(最大流最小割定理) 基本的Ford-Fulkerson算法 粗糙的时间复杂度上界：$O(E|f|)$（$f$为将有理数流网络转换成整数流网络后，网络中的一个最大流） Edmonds-Karp算法在Ford-Fulkerson算法的第三行使用广度优先搜索来寻找增广路径。每次在残存网络中选择的增广路径是一条从源结点$s$到汇点$t$的最短路径，其中每条边的权重为单位距离。 时间复杂度：$O(VE^2)$ 引理26.7：使用Edmonds-Karp算法，对于除源结点和汇点外的所有结点$v$，残存网络$G_f$中的最短路径距离$\\delta_f(s,v)$随着每次流量的递增而单调递增。 定理26.8：Edmonds-Karp算法所执行的流量递增操作的总次数为$O(VE)$ 关键边：在残存网络中，一条路径$p$的残存容量是该条路径上边$(u,v)$的残存容量，即$c_f(p)=c_f(u,v)$对于$E$的每条边来说，其成为关键边的次数最多为$|V|/2$次。 最大二分匹配在一个二分图中，结点集合可以划分为$V=L\\cup R$，其中$L$和$R$是不相交的，并且边集合$E$中所有的边都横跨$L$和$R$。 构造一个流网络$G=(V’,E’)$，其中V'=V\\cup\\{s,t\\}$$$$E=\\{(s,u):u\\in L, u\\in L\\}\\cup \\{(u,v):(u,v)\\in E\\}\\cup \\{(v,t):v\\in\\mathbb{R}\\}给$E’$中的每条边赋单位容量 流$f$是整数值的：对于所有的边$(u,v)\\in V\\times V$，$f(u,v)$都是整数值。 定理26.10（完整性定理Integrality theorem）：如果容量函数$c$只能取整数值，则$Ford-Fulkerson$方法所生成的最大流$f$满足$|f|$是整数值的性质。而且，对于所有的结点$u$和$v$，$f(u,v)$都是整数。 推论26.11：二分图$G$中的一个最大匹配$M$的基数等于其对应的流网络$G’$中某一最大流$f$的值。 时间复杂度：$O(VE)$","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://mengzelev.github.io/tags/Graph-Algorithms/"}]},{"title":"图论学习笔记-图中的匹配与覆盖","slug":"matchings","date":"2018-11-28T06:59:39.000Z","updated":"2018-12-01T02:14:22.945Z","comments":true,"path":"2018/11/28/matchings/","link":"","permalink":"https://mengzelev.github.io/2018/11/28/matchings/","excerpt":"","text":"匹配匹配的定义独立：若图的边集中任意两条边不邻接，则称该集合是独立的 匹配：图$G$中的边的一个独立集$G$的匹配是一个边的集合$M={e_1,e_2,…,e_k}$，其中$e_i=u_iw_i(1\\le i\\le k)$，使得$u_1,u_2,…,u_k$是$U$中$k$个不同的顶点，$w_1,w_2,…,w_k$是$W$中$k$个不同的顶点。 匹配存在的条件邻域(neighbourhood)$N(X)$：设$G$为二部图，其部集为$U$和$W$，且$|U|\\le |W|$，对于$U$的非空子集$X$，$X$中所有顶点的邻域的并。 Hall’s condition/友好的(neighborly)：对于$U$的任意非空子集$X$，均有$|N(X)|\\ge |X|$。 定理8.3：设$G$为二部图，其部集为$U$和$W$，且$r=|U|\\le |W|$。则$G$包含一个基数为$r$的匹配当且仅当$U$是友好的。 定理8.4：非空有限集族${S_1,S_2,…,S_n}$有一个互异代表元系(system of distinct representative) 当且仅当 对于任一整数$k(1\\le k\\le n)$，集族中任意$k$个集合的并至少包含$k$个元素。 定理8.5(婚姻定理):在一个由$r$个女人和$s$个男人构成的人群中，$1\\le r\\le s$，在熟识的男女之间可能出现$r$对婚姻当且仅当对每个整数$k(1\\le k\\le r)$，任意$k$个女人共认识至少$k$个男人。 最大匹配(maximum matching)：具有最大基数的匹配 完美匹配(perfect matching)：阶为$2k$的图$G$存在一个基数为$k$的匹配$M$，则称该匹配$M$为完美匹配 定理8.6：任意$r$正则二部图$(r\\ge 1)$均有一个完美匹配。 边的独立性参数边独立数(edge independence number)$\\alpha ‘(G)$：最大边独立集的基数 覆盖：一个顶点和与其相连的一条边 边覆盖数(edge covering number)$\\beta ‘(G)$：$G$中所有边覆盖的最小基数 最小边覆盖集(minimum edge cover)：具有最小基数的边覆盖集 定理8.7：对于任意不包含孤立点的$n$阶图$G$，\\alpha'(G)+\\beta'(G)=n 顶点的独立性参数如果图中的一个顶点集合中任意两顶点都不邻接，则称该顶点的集合是独立的 点独立数(vertex independence number)$\\alpha(G)$:$G$中点独立集的最大基数，又称独立数 最大独立集(maximum independence set)：图$G$中基数为$\\alpha(G)$的独立集 点覆盖(vertex cover)：图$G$的某个顶点子集可以覆盖$G$的所有边 点覆盖数(vertex covering number)$\\beta(G)$：$G$的所有点覆盖的最小基数 最小点覆盖(minimum vertex cover)：基数为$\\beta(G)$的点覆盖 定理8.8:对于任意不包含孤立点的$n$阶图，\\alpha(G)+\\beta(G)=n 定理8.7与定理8.8合称为Gallai恒等式 一般独立集比覆盖集好求 因子分解1因子1因子(1-factor)：图$G$的1正则生成子图。$n$阶图$G$的完美匹配$M$的诱导的子图$F[M]$是$G$的1因子。图$G$有1因子当且仅当$G$有完美匹配。 连通分支的奇偶性就是该连通分支的阶的奇偶性。$k_O(G)$表示图$G$的奇连通分支的个数。 定理8.10：图$G$包含1因子当且仅当对于$V(G)$的任意真子集$S$，$k_O(G-S)\\le |S|$。 定理8.11(Petersen定理)：所有无割边的3正则图包含1因子。 定理8.12：任一至多含有两条割边的3正则图包含1因子。 分解可因子分解的(1-factorable)：若$G$有1因子$F_1,F_2,…,F_r$，使得${E(F_1),E(F_2),…,E(F_r)}$是$E(G)$的一个划分，此时我们称$G$被因子分解(factored)成1因子$F_1,F_2,…,F_r$；这些1因子构成了$G$的1因子分解(1-factorization) 任一可1因子分解的图是正则的，反之不真，反例：Peterson图 定理8.13：Petersen图是不可1因子分解的。 定理8.14：对于任意正整数$k$，完全图$K_{2k}$是可1因子分解的。 循环因子分解(cyclic factorization)：如图所示，所有因子分解可以由某一个因子分解旋转一定角度得到 定理8.15：任意$r$正则的二部图$(r\\ge 1)$是可1因子分解的。 2因子2因子(2-factor)：图$G$的二正则生成子图 2因子的任一连通分支是一个圈。 可2因子分解的(2-factorable)：定义类似1因子 定理8.16：图$G$是可2因子分解的当且仅当存在某个正偶数$r$，是的$G$是$r$正则的。 *Hamilton因子分解(Hamilton factorization)：$G$的一个2因子分解，满足该分解中所有2因子均是Hamilton圈 定理8.17：对于任一整数$k\\ge 1$，完全图$K_{2k+1}$是可Hamilton分解的。证明：构造法（如图） 因子因子(factor)：图$G$不含有孤立点的生成子图 可因子分解(factorable)：因子$F_1,F_2,…,F_r$，满足${E(F_1),E(F_2),…,E(F_r)}$是$E(G)$的一个划分。 可F-因子分解的(F-factorable)：若存在某个图$F$，是的每个因子$F_i\\cong F$ Kirkman三元系n阶的Kirkman三元系(Kirkman triple system)：有一个基数为$n$的集合$S$，和$S$的三元子集（称为三元组(triple)）族$T$，以及$T$的一个划分$\\mathcal{P}$构成，且满足如下性质： $S$中任意两个不同的元素属于$T$中唯一的三元组 $S$中任一元素属于划分$\\mathcal{P}$的每一元素的唯一的三元组 存在一个$6k+3$阶Kirkman三元系当且仅当存在一个$K_{6k+3}$的$(2k+1)K_3$因子分解 定理8.19：$n(n\\ge 3)$阶的Kirkman三元系存在当且仅当$n\\equiv 3(mod 6)$，即$n=6k+3$ 定理8.20：对于每个整数$k\\ge 1$，完全图$K_{2k}$可因子分解为$k-1$个Hamilton圈和一个1因子。","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"Graph Theory","slug":"Graph-Theory","permalink":"https://mengzelev.github.io/tags/Graph-Theory/"},{"name":"Matchings","slug":"Matchings","permalink":"https://mengzelev.github.io/tags/Matchings/"},{"name":"Factorization","slug":"Factorization","permalink":"https://mengzelev.github.io/tags/Factorization/"}]},{"title":"Lab3：链接与加载（2）实验报告","slug":"lab3-report","date":"2018-11-24T09:17:47.000Z","updated":"2018-11-30T14:18:07.067Z","comments":true,"path":"2018/11/24/lab3-report/","link":"","permalink":"https://mengzelev.github.io/2018/11/24/lab3-report/","excerpt":"","text":"实现描述寻找正确的入口地址在框架代码抽取出的symtab中主项寻找，如果该项的Type属性为STT_FUNC，就根据其st_name属性去字符串表strtab里寻找该函数的Name属性，并与main进行对比，就能找到main函数对应的表项，此时该表项的st_value属性即 我们需要的入口地址。 加载程序loader()函数的实现需要程序头表，模仿load_elf_table()函数的写法可将程序头表抽取到结构体Elf32_phdr中，找到p_type为PT_LOAD的表项，读取其p_offset，p_vaddr，p_filesz，p_memsz属性，按照讲义的描述，使用fread函数将可执行文件中相对文件偏移p_offset的内容读取p_filedz到内存地址为[p_addr, p_addr + p_filesz的地方，并用memset函数将[p_vaddr + p_filesz, p_vaddr + p_memsiz)对应的物理区间清零。 打印栈帧链第一次打印eip的值作为当前地址，之后每次都取内存中ebp-4的地址存放的返回地址作为函数调用的地址。函数的名字通过去symtab中寻找对应表项并从strtab中提取而得。仿照gdb的bt命令输出打印出来。对ebp的值解引用能得到上一个函数的ebp的值。如此循环直到ebp的信息为0为止。 实验过程留着以后当笑话看的碎碎念 寻找正确的入口地址我本来以为这个只要做好RTFSC就不会花太多时间的，man 5 elf之后理所当然地写了如下代码： if(symtab[i].st_info == STT_FUNC) 发现怎么都找不到main，各种调试了一个多小时之后，问了同学才意识到，st_info不是直接的type值，type只占了低四位，高四位为绑定属性bind，把FM继续往下翻可以看到 ELF32_ST_BIND(info), ELF64_ST_BIND(info) Extract a binding from an st_info value. 泪，可以流下来吗论耐心RTFM的重要性 加载程序这部分基本是照抄框架代码抽取El32_Shdr的方法抽取了Elf32_Phdr，让我自己写大概还是写不出来的吧[自卑.jpg] 打印栈帧连先用gdb调试了给的segmentfault.c，摸索了一下bt命令的打印格式，确认了打印的栈帧链中的地址为函数调用时压入栈中的返回地址。 思考题堆和栈在哪里？经过PA3.2的调教，可以知道堆是程序运行时调用malloc动态向高地址申请空间维护的。堆区的开始位置就是数据段的结束位置。当调用malloc函数时，会触发系统调用sbrk查询并调整堆区的结束位置，即program break，以调整堆区的大小。栈区是从内核虚存区开始向低地址方向生长的，栈顶的地址保存在寄存器esp中。通过push和pop等指令来调整栈区大小。堆和栈的内容不放入可执行文件，我猜想一方面因为这些部分是动态生成的，程序执行过程中它们的大小时刻变化着，因此不能放入静态的可执行文件中。另一方面，栈区会有一个随机化操作来防止恶意攻击，不便于放入可读的可执行文件中。 如何识别不同格式的可执行文件？ELF可执行目标文件有ELF头，根据ELF可执行文件的各种规范书写。Windows生成的可执行文件应该也有自己的文件头的格式，在GNU/Linux下执行时，系统按照ELF头的格式解析该文件的文件头出现了错误，例如没有读到“魔数”，就会报告“格式错误”。 消失的符号因为这些符号只在本模块内被使用，其被动态分配在栈中，链接器并不需要这些符号的信息，因此不会出现在符号表中。符号是指参与链接的变量名和函数名。 寻找”Hello World!”用上述方法找到hello程序的字符串表，会发现“Hello World!”字符串…它…根本不在字符串表中，而是在.rodata节中。 因为printf中的格式化字符串是一个只读的字符串，所以编译时会被放入只读数据节.rodata节中。 冗余的符号表编译单独的hello程序没有问题，但是尝试对hello.o进行链接时就会链接报错（忘了截图了）。因为符号表用于链接中的符号解析，单独运行程序时没有符号表，单有指令就也没有问题。 冗余的属性？起初我猜测是.bss节的数据没有在Filesz中被计算，而是计算在了Memsz中。但是我把.bss节的大小加上Filesz后还是比Memsz小一些，STFW发现stackoverflow上有人问了类似的问题，欣喜地点进去发现并没有人回答….我再思考一下说不定就有stackoverflow首答了… 为什么要清零？数电和问求还没写完，溜了…….","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Lab","slug":"Lab","permalink":"https://mengzelev.github.io/tags/Lab/"},{"name":"Ics","slug":"Ics","permalink":"https://mengzelev.github.io/tags/Ics/"}]},{"title":"图论学习笔记-旅行问题","slug":"traversability","date":"2018-11-21T13:05:50.000Z","updated":"2018-11-30T14:19:40.503Z","comments":true,"path":"2018/11/21/traversability/","link":"","permalink":"https://mengzelev.github.io/2018/11/21/traversability/","excerpt":"","text":"Euler图Euler回路(Euler cycle)：图$G$的一条包含$G$的每一条边的回路$C$ Euler图(Euler graph):含有Euler回路的连通图 Euler迹(Euler trial)含有连通图$G$的每条边的开迹 当讨论图的Euler性质时， 定理6.1：一个非平凡连通图$G$是Euler的 当且仅当 $G$的每个顶点的度都为偶数 推论6.2：一个连通图$G$含有一条Euler迹当且仅当$G$恰有两个度为奇数的顶点，而且$G$的每一条Euler迹始于一个度为奇数的顶点而终止于另一个度为奇数的顶点。 例6.3结论：设$G$和$H$是两个非平凡的连通图，则$G\\times H$是Euler的当且仅当$G$和$H$都是Euler的或者$G$和$H$的每个顶点度均为奇数。 Hamilton图Hamilton圈(Hamiltonian cycle)：一个含图$G$的每个顶点的圈 Hamilton图(Hamiltonian graph)：一个含有Hamilton圈的图 Hamilton路(Hamiltonian path)：一条含图$G$的每个顶点的路 有Hamilton圈, 一定有Hamilton路；有Hamilton路，不一定有Hamilton圈 Hamilton图的特征 $n\\ge 3$阶图的一个Hamilton圈$C$是$n$阶的连通2正则子图 $C$不含有阶小于$n$的圈作为子图 $G$也不含有有度大于等于3的子图 如果$G$含有度为2的顶点，则与$v$关联的两条边一定位于$C$上 定理6.4：Peterson图不是Hamilton的 Hamilton图的性质$k(G)$：图的连通分支数 定理6.5：如果$G$是一个Hamilton图，则对$G$顶点的任一非空真子集$S$，都有$k(G-S)\\ge |S|$（一个图是Hamilton图的必要条件）逆否命题：设$G$为一个图。如果对$V(G)$的某个非空真子集$S$,有$k(G-S)&gt;|S|$，则$G$不是Hamilton的（一个图为非Hamilton的充分条件）如果图$G$含有一个割点$v$，则$G$不是Hamilton的 Hamilton图的充分条件定理6.6(Ore 定理)：设$G$为一个$n(n\\ge 3)$阶的图，如果对于$G$的每对不邻接的顶点$u,v$，有$deg u +deg v\\ge n$,则$G$是Hamilton的。该定理给出的界是紧的 推论6.7：设$G$为一个$n\\ge 3$的图，如果对于$G$的每个顶点$v$，均有$deg v\\ge n/2$，则$G$是Hamilton的。 定理6.8：设$u$和$v$是一个$n$阶图$G$的两个不邻接的顶点，并且$deg u + deg v\\ge n$，则$G+uv$是Hamilton的当且仅当$G$是Hamilton的。 闭包(closure)：由$G$出发递归地连接度数之和至少为$n$的不邻接顶点对，记为$C(G)$ 定理6.9：一个图是Hamilton的当且仅当它的闭包是Hamilton的。 推论6.10：如果$G$是一个阶至少为3的图，且它的闭包$C(G)$是一个完全图，则$G$是一个Hamilton图 定理 6.11：设$G$是一个$n(n\\ge 3)$阶的图。如果对于每个整数$j(1\\le j&lt;\\frac{n}{2})$，$G$中度至多为$j$的顶点数小于$j$，则$G$是Hamilton的。","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"Graph Theory","slug":"Graph-Theory","permalink":"https://mengzelev.github.io/tags/Graph-Theory/"},{"name":"Traversibility","slug":"Traversibility","permalink":"https://mengzelev.github.io/tags/Traversibility/"}]},{"title":"图论学习笔记-图中的连通性与距离","slug":"connectivity","date":"2018-11-14T08:19:10.000Z","updated":"2018-11-30T14:19:28.693Z","comments":true,"path":"2018/11/14/connectivity/","link":"","permalink":"https://mengzelev.github.io/2018/11/14/connectivity/","excerpt":"","text":"割点割点的定义：去掉这个点后，原图不再连通 定理5.1：设$v$是连通图$G$中与bridge相连的一个结点，则$v$是割点当且仅当$deg v\\ge 2$非简单树 = 端点 + 割点 推论5.2：设$G$是一个至少有3个顶点的连通图，若$G$有bridge，则$G$一定有割点 定理5.3：设$v$是连通图$G$的一个割点，$u$和$w$是$G-v$不同components中的两个顶点，则$v$位于$G$的任意一条$u-w$路径上。 回顾定理4.1：边$e$是bridge当且仅当$e$不存在于任何一个cycle上 推论5.4：$v$是连通图$G$的一个割点 当且仅当 存在与$v$不同的两个顶点$u$和$w$，使得$v$位于$G$的任意一条$u-w$路上 定理5.5：设$G$是非平凡连通图，$u\\in V(G)$。若$v$是$G$中距离$u$最远的顶点，则$v$不是$G$的割点。 推论5.6：任意非平凡的连通图至少包含两个非割点的顶点。 块(Blocks)不可分图(nonseparable graph)：没有割点的非平凡连通图 定理5.7：结点数不少于3的图是不可分的 当且仅当 任意两个顶点都位于某个圈上 块(block):图$G$的一个最大的不可分子图 定理5.8：$R$是定义在非平凡连通图$G$的边集上的关系：对于$e,f\\in E(G)$，若$e=f$或$e,f$位于$G$的同一个圈上，则$e,f$有关系$R$，即为$eRf$且$R$是等价关系。该定理将图$G$的边画划分为了若干等价类。 推论5.9：非平凡连通图$G$的任意两个不同的块$B_1$和$B_2$具有下面性质： $B_1$和$B_2$是不相交的 $B_1$和$B_2$至多有一个公共结点 若$B_1$和$B_2$有一个公共结点$v$，则$v$是$G$的割点 连通度顶点割顶点割(vertex-cut)：顶点集$U$，$G-U$是不连通的 最小顶点割：自行感受一下 只有非完全图才有顶点割，且所有非完全图都有顶点割 (点)连通度(vertex-connectivity):$\\kappa(G)$=最小顶点割的基数 0\\le \\kappa(G)\\le n-1图$G$是k-连通的(k-connected)，即$\\kappa(G)\\ge k$，随便去掉$k$个点之后依然是连通的 边割(edge-cut)边割(edge-cut)：边集$X$，$G-X$是不连通的 最小边割和极小边割是不同的概念 边连通度(edge-connectivity):$\\lambda(G)$=最小边割的基数 0\\le \\lambda(G)\\le n-1完全图的边连通度$\\lambda(K_n)=n-1$ 点、边连通度间的关系定理5.11：对于任意图$G$，\\kappa(G)\\le \\lambda(G)\\le \\delta(G)点连通度$\\le$边连通度$\\le$最小度数 定理5.12：立方图$\\kappa(G)=\\lambda(G)$ 定理5.13：$G$顶点数为$n$，边数为$m$，则$\\kappa(G)\\le \\lfloor\\frac{2m}{n}\\rfloor$ Harary图定理5.14：如果$G$是至少有3个结点的连通图，则$G^2$时候2-连通的。 定理5.15：对于任意整数$r,n$满足$2\\le r&lt;n$，有$$\\kappa(H_{r,n})=r$ Menger定理分离集(separating set)：$S$是图$G$的顶点集的一个子集，$u$和$v$是$G$的两个顶点。若$G-S$是不连通的且$u$和$v$属于$G-S$不同的连通分支，则称$S$分离$u$和$v$，$S$是一个$u-v$分离集 内点(internal vertex):一条$u-v$路径上除去$u,v$的点内部不相交(internally disjoint)：两条路径除端点外没有公共点 定理5.16(Menger定理)：设$u$和$v$是图$G$的不邻接的两个顶点，则$u-v$分离集中顶点的最小个数等于$G$中内部不相交$u-v$路的最大个数。证明使用了数学归纳法，归纳步时分了3种情况讨论 定理5.17：一个非平凡图$G$是$k$连通的($k\\ge 2$) 当且仅当 对于$G$的任意两个顶点$u,v$，$G$至少有$k$条内部内部不相交的$u-v$路。 推论5.18：设$G$为$k$连通图，$S$是由$G$中任意$k$个顶点构成的集合。若图$H$是由$G$通过添加一个新的顶点$w$以及连接$w$到$S$中所有的顶点所得，则$H$也是$k$连通的。 推论5.19：若$G$为$k$连通图，$u,v_1,v_2,…,v_k$为$G$中$k+1$个不同的顶点，则$G$有内部不相交的$u-v_i$路($1\\le i\\le k$) 定理5.20：若$G$为$k$连通图($k\\ge 2$)，则$G$中任意$k$个顶点均位于某一个圈上。 定理5.21：对于图$G$两个不同的顶点$u$和$v$，$G$中分离$u,v$的边的最小个额数等于$G$中边不相交$u-v$路的最大个数 定理5.22：一个非平凡图$G$是$k$边连通的当且仅当对于$G$中任意两个不同的顶点$u,v$，$G$包含$k$条边不相交的$u-v$路","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"Graph Theory","slug":"Graph-Theory","permalink":"https://mengzelev.github.io/tags/Graph-Theory/"},{"name":"Connectivity","slug":"Connectivity","permalink":"https://mengzelev.github.io/tags/Connectivity/"}]},{"title":"算法导论学习笔记-所有结点对的最短路径问题","slug":"clrs-25All-Pairs-Shortest-Paths","date":"2018-11-07T08:17:34.000Z","updated":"2019-01-07T11:15:54.734Z","comments":true,"path":"2018/11/07/clrs-25All-Pairs-Shortest-Paths/","link":"","permalink":"https://mengzelev.github.io/2018/11/07/clrs-25All-Pairs-Shortest-Paths/","excerpt":"","text":"矩阵乘法最优子结构$l_{ij}^(m)}$:从结点$i$到结点$j$的至多包含$m$条边的任意路径中的最小权重。 l_{ij}^{(m)} = \\min\\limits_{1\\lek\\le n}\\{l_{ik}^{(m1)}+w_{kj}\\}自底向上计算最短路径权重 三重循环，时间复杂度为$\\Theta(n^3)$ 形式上与矩阵乘法的计算非常类似 计算$L^{(n-1)}=W^{n-1}$ 这个算法本质上就是对$n$个点每个跑了一遍Bellman-Ford 改进运行时间重复平方技术二分计算矩阵的幂 优化后时间复杂度为$\\Theta(n^3\\lgn n)$ Floyd-Warshall算法枚举最短路径上的中间结点来进行递归的计算 不允许有负权重环 但是可以做到在有负权重环的情况下报告（看对角元是否有负数） $d_{ij}^{(k)}$：从$i$到$j$经过的中间结点为${1,…k}$的子集的最短路径长度 伪代码 时间复杂度$\\Theta(n^3)$ 空间复杂度看似需要$\\Theta(n^3)$，但是作业题中证明了只需要一个矩阵来存储，为$\\Theta(n^2)$ 构建最短路径采用动态规划的思想，递推式如下 用于稀疏图的Johnson算法用一种神奇的方式对图中每条边的权重进行重新赋值，使新的图满足 所有权重都为非负值 新图中的最短路径就是旧图中的最短路径 伪代码 先增加一个新结点$s$，该点到原先各结点都有边相连，权重为0对新图进行一次Bellman-Ford算法，寻找是否有负权重环路没有负权重环，就用神奇的长得像顶点的势能函数一样的函数给每条边重新赋值 \\hat{w}(u,v)=w(u,v)+h(u)-h(v)h(u)=\\delta(s,u)然后对每个点进行Dijkstra最后记得将最短路径的权重恢复，并存入矩阵$D$中返回 时间复杂度二叉最小优先队列实现Dijkstra：$O(VE\\lg V)$斐波那契堆实现：$O(V^2\\lgV+VE)$在稀疏图的情况下，表现比Floyd-Warshall好","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://mengzelev.github.io/tags/Graph-Algorithms/"}]},{"title":"Lab2:链接与加载 实验报告","slug":"lab2-report","date":"2018-11-06T09:17:47.000Z","updated":"2018-11-30T14:17:54.141Z","comments":true,"path":"2018/11/06/lab2-report/","link":"","permalink":"https://mengzelev.github.io/2018/11/06/lab2-report/","excerpt":"","text":"实验过程按照实验讲义的提示，首先找到了libc库所在的位置，输出基本与讲义中给出的一致，不作赘述。 编写的测试文件a.c的代码为 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main ()&#123; int a = rand(); printf(&quot;%d\\n&quot;,a); return 0; &#125; 只需要有对rand的调用且保证不会被编译器优化掉就可以了。 找到动态库文件之后，对该二进制文件进行反汇编 $ objdump -d /lib/x86_64-linux-gnu/libc.so.6 &gt; libc64 然后对反汇编后的文件进行查看，可以看到一堆库函数的反汇编代码。此时我看到了讲义中的这句话： 然后你会发现这个文件对你并没有什么卵用，好吧，其实一会儿是会用到的。 导致我真的以为现在用不到这个文件，于是，我傻fufu地按照讲义的指示去找rand函数的地址了。gdb，启动！看到了一堆跳转语句，感受到了自己对课本内容掌握不足；课本，打开！复习了一下动态链接相关的知识点；gdb，开始！单步执行到&lt;rand@plt&gt;处时，发现了rand对应的GOT表项的地址，为0x55555575020 然后疯狂si，会看一堆dl_开头的，八成是和动态链接有关的函数。一不小心回车过头，最后在main里停下来，总之动态链接过程已经完成了，这时候可以查看内存地址为0x55555575020处的内容为0x7ffff7a70820（忘了截图了） 打印0x7ffff7a70820的内容，确认了确实为rand函数的地址 做到这里，感觉像是完成了什么，开始思考下一步要做什么。等一下，我们的最终目标不是只要得到system到rand的偏移量吗，那我费尽千辛万苦搞到rand的地址干什么……算了，就当复习了一下动态链接的相关知识点和回忆了一下gdb的使用方法吧 不管了，总之先打开之前反汇编的动态库看一下，分别找到rand和system的地址 偏移量为0x3f480-0x36820=0x8c60 为了验证一下正确性，使用gdb打印了和rand具有相应偏移量（其实就是后3位不同）出的内存内容 这下准没错了，于是开始编写oj_killer函数 代码解释最初仅考虑64位情况的oj_killer函数代码如下 #include &lt;stdlib.h&gt; void* oj_killer()&#123; void* randptr = (void *)rand; //获得rand函数的地址 return (void*)(randptr + 0x8c60); //加上libc中rand到system的偏移量，返回system函数的地址 &#125; 编译运行后能够成功输出Hello World 兼容32位接下来考虑32位的情况 如果将上述程序直接编译为32位，会得到Illegal instruction的错误 对a.c加上-m32选项进行编译后查看其调用的动态链接库，可以发现调用的是32位的库，和64位的库是不一样的（当然了 $gcc a.c -m32 -o a32.out $file a32.out a32.out: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically link│ ed, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=b3e591a0858f18│ 2549e63239c338f5fd30496ce2, not stripped $ldd a32.out linux-gate.so.1 (0xf77ac000) libc.so.6 =&gt; /lib32/libc.so.6 (0xf75d1000) /lib/ld-linux.so.2 (0xf77ae000) $file -L /lib32/libc.so.6 /lib32/libc.so.6: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=84bb53910470c7ceb2a0963044117fdf8a2bb975, for GNU/Linux 2.6.32, stripped 使用同样的方法进行反汇编后 $objdump -d /lib32/libc.so.6 &gt; libc32 分别得到rand和system在libc内的地址 于是可以按照同样的思路编写代码 真·代码解释void* oj_killer()&#123; int type = sizeof(void*); void* randptr = (void *)rand; //获得rand函数的地址 if(type == 8) //判断当前环境是否为64-bit return (void*)(randptr + 0x8c60); //加上64位时libc中的偏移量 else return (void*)(randptr - 0x2f6f0 + 0x3a850); //加上32位时libc的偏移量 &#125; 为了保证代码的可移植性，特意将变量randptr声明为void*类型，而非int或long long。判断当前环境为32/64位则依靠对void*长度的判断。 暴露了不太会用#if预编译指令的事实 分别按32位和64位编译后，可以得到Hello World的输出：","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Lab","slug":"Lab","permalink":"https://mengzelev.github.io/tags/Lab/"},{"name":"Ics","slug":"Ics","permalink":"https://mengzelev.github.io/tags/Ics/"}]},{"title":"PA2实验报告","slug":"PA2-report","date":"2018-11-06T01:33:26.000Z","updated":"2018-11-06T01:34:50.453Z","comments":true,"path":"2018/11/06/PA2-report/","link":"","permalink":"https://mengzelev.github.io/2018/11/06/PA2-report/","excerpt":"","text":"实验进度描述2018/10/04RTF实验讲义，RTFSC，我是谁，我在哪儿，我要干什么 2018/10/05经历了两天的RTFSC后终于看懂了框架代码是干嘛的，RTFM实现了sub,push,ret,call等指令，在nemu中运行了第一个程序dummy 2018/10/21听了同学们的建议，先实现了diff-test，结果发现PA2.1的指令实现有bug。修复了这些bug并温故框架代码的构成 2018/10/22花了一整天对照着FM实现了exec目录下大部分指令，填写opcode_table巨表，然而有海量bug等待发现 2018/10/27开diff-test跑完了cputest中所有的测试，修复了能发现的PA2.2中的bug。bash runall后看到了绿油油的full-combo，心情舒畅。然而并不知道2.3的时候还有海量bug等着自己 2018/10/28实现了string.c中所有的库函数和sprintf，先在nemu外单独手动测试，然后放入klib中，成功运行string.c和hell-str.c，PA2.2基本完成，make submit 2018/11/2实现了in/out指令，成功运行hello。与同学出去吃火锅，讨论发现自己的diff-test歪打正着可以正常运行。 2018/11/3实现了printf，测试时钟时陷入莫名其妙的Segmentation Fault，在指令中加入大量Log测试，无果；找到大腿进行文件替换，无果；把指令实现和库函数又给了大腿二号进行替换，发现一切运行正常。心态爆炸，怀疑人生，git滚回到2.2完成的状态，从2开始的PA2.3。修仙实现了时钟、键盘和vga，并通过了相关测试，成功运行打字游戏（虽然慢的一笔）。跑分测试时还是出现了bug，遂开启diff-test后滚去睡觉 2018/11/4起来看到结果发现是neg指令写错了，修复bug后成功运行了三个跑分测试。看到超级无敌慢动作马里奥，差点笑死，录成视频发到qq空间被jyy点赞了。复习链接相关知识，自学Makefile语法，编写硬核实验报告。 必答题 只有聪明的人才看得见 我遇到的那些bug以后实验报告新增这一环节，希望可以帮到其他人 有些指令不是RTL完了就完事的，还需要operand_write写入到相应位置 test指令手册表意不清，虽然写了DEST := LeftSRC AND RightSRC，但是两个操作数并不需要改变，不需要进行operand_write 框架里已经为你准备了丰富多彩的译码函数，有些指令有自己特殊的译码函数，赶紧到decode.h里去康康吧！ ret指令需要跳转到返回地址的，没有好好RTFM的后果 sar是需要符号扩展的 译码函数的立即数读入也是需要符号扩展的 编译timetest的时候链接出错：undefined reference to，其实是因为stdio.c没有加上重要的头文件 运行跑分测试coremark时出现内存地址越界，发现是opcode_table中的imul指令的译码函数写错了 neg指令只需要直接取反加一 不知道时钟怎么写，可以参考一下_putc的代码，里面有提示 native的输入输出实现里有不少提示可供参考 框架代码中没有rol指令，不知道是可爱PA作者的疏忽还是故意让我们练手的 蓝框思考题临近期中考试，时间不是很充裕，写得很少，但愿今后有机会二周目思考吧 Q:AT&amp;T格式反汇编结果中的少量指令, 与i386手册中列出的指令名称不符, 如cltd. 除了STFW之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?A:先STFW试图搞清楚这个指令是干什么的，然后翻手册的目录寻找描述差不多的指令。比如cltd是Convert longword to doubleword的意思，翻手册的目录能找到意思差不多的Convert word to double word。运气好的话可能在STFW的时候就能找到对应的i386的指令名称了。 Q：你或许会感到疑惑, 代码优化不是一件好事情吗? 为什么会有volatile这种奇葩的存在? 思考一下, 如果代码中p指向的地址最终被映射到一个设备寄存器, 去掉volatile可能会带来什么问题? A：因为编译器基本是根据输入输出状态进行的代码优化，而我们有些时候是care中间过程的，例如lab01中的性能测试。如果代码中p指向的地址最终被映射到一个设备寄存器，可能会发生设备状态的跳变，比如显示器某块地方应该是由蓝变绿再变红，会直接从蓝色变成红色。 实验心得 未测试的代码永远是错的，测试过的代码也不会是对的！隐藏bug无处不在。【PA2.2full-combo的大家几乎都在2.3里发现了cputests没能暴露的bug，以此类推PA3的时候可能还会发现PA2的bug 要及时坚定滚回去从头再来的决心，试过了力所能及的所有方法都找不出来的bug就不要找了，肯定是在一些玄学的地方犯了玄学的错误，干脆从头重新写一遍 am相关的概念还不是非常清楚，目前还不影响做实验，但还是想进一步了解 Copy-paste是坏文明 github private远程库保命是真的很重要，安心多了 跑分结果堪忧，但是本着先写对，再完美的宗旨，不管了还是值得开心一下的 bug死活找不出的时候容易心态血崩，但是这时候只要实现一个小的功能就能瞬间高兴回来 敲代码真**开心 Appreciation 感谢“™写™PA真™开心”群的群友们，一起修仙，一起写bug，一起交流bug，帮忙debug，还在心态快崩的时候一起出去约了顿火锅 感谢xy同学，提供了可供替换的大腿，做得太快了，还给我剧透了不少，让我少踩了不少坑 感谢ldw同学，用我的代码替换到了他的代码上证明我的指令集和库函数并没有大问题，给了我滚回去重做的决心（ 感谢某位还是不愿意透露姓名的nb学长，通过千里眼，帮忙发现了不少bug 本实验报告同样会将去掉必答题的版本同步上传至个人blog","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"}]},{"title":"算法导论学习笔记-单源最短路径","slug":"clrs-24Single-Source-Shortest-Path","date":"2018-10-30T14:29:50.000Z","updated":"2018-11-07T08:18:49.729Z","comments":true,"path":"2018/10/30/clrs-24Single-Source-Shortest-Path/","link":"","permalink":"https://mengzelev.github.io/2018/10/30/clrs-24Single-Source-Shortest-Path/","excerpt":"","text":"前备概念环路如果有负权重环路，问题比较大，因为你在环路里往死里转路径要多短有多短，这时候定义最短路径长度为负无穷。$\\delta(u,v)=-\\infty$ 如果有正权重环路，那最短路径肯定不会走这个环路，所以不影响 如果有0权重环路，那这个环路等于没有，也不影响 初始化$v.d$：最短路径估计 使用下面运行时间为$\\Theta(V)$的算法来对最短路径估计和前驱结点进行初始化： 初始化操作的时间复杂度为$\\Theta(V)$ 松弛操作松弛过程：试图改善从$s$到$v$的最短路径。可能降低最短路径的估计值$v.d$并更新$v$的前驱属性$v.\\pi$ 松弛是唯一导致最短路径估计和前驱结点发生变化的操作 本章讨论的所有算法之间的不同之处是对每条边进行松弛的次数和松弛边的次序有所不同 最短路径和松弛操作的性质这几条最好要背下来的，我觉得考试很容易考 为了方便记忆，po主尝试着用人话复述一遍： 三角不等式性质：图里任意两个点和源点$s$构成一个三角形（可以退化为直线），有两边之和大于等于第三边 上界性质：$v.d$撑死就是$\\delta(s,v)$，不能再小了 非路径性质：原话已经很人话了 收敛性质：松弛前边的起点已求得最短路径，松弛后边的终点也将获得最短路径buff 路径松弛性质：只要一条最短路径上的点是按松弛的，那么估计值就等于最短路径 前驱子图性质：最短路径算完了，前驱子图是一颗根结点为$s$的最短路径树 Bellman-Ford算法描述 先将结点进行初始化 对每条边进行$|V|-1$次松弛操作 当存在负权重环路时会返回FALSE 如果不存在负权重环路，则返回TRUE，每个结点的$v.d$即为源点$s$到该点的最短路径长度 伪代码 时间复杂度$O(VE)$ 正确性证明用到了三角不等式 + 非路径性质 + 前驱子图性质 有向无环图（DAG）中的单源最短路径问题无环，因此没有负权重的环，对于任何结点，最短路径都是存在的 算法描述先对DAG进行拓扑排序，按照拓扑排序的顺序对每个结点进行松弛操作 伪代码 时间复杂度 拓扑排序(1)： $\\Theta(V+E)$ 初始化(2)：$\\Theta(V)$ 3~5行的循环（聚合分析）：$\\Theta(V)$总时间复杂度：$\\Theta(V+E)$ 正确性证明精髓还是在于神奇的路径松弛性质，只要保证每条最短路径上边的松弛次序，就能得出算法终止时$v_i.d=\\delta(s,v_i)$ 应用PERT图 Dijkstra算法描述 解决带权重的有向图上的单源最短路径问题 要求所有边的权重都为非负值 维护一组结点结合$S$，从源点$s$到该集合中每个结点之间的最短路径已经被找到 使用贪心策略，每次都从结点集$V-S$中选择最短路径估计最小的结点$u$，然后更新与$u$相连的结点的最短路径估计值 伪代码 正确性证明循环不变式：在算法第4~8行的while语句的每次循环开始前，对于每个结点$v\\in S$，有$v.d=\\delta(s,v)$ 证明使用了反证法+最小数原理关键步用到了收敛性质和权重非负的假设 时间复杂度依赖于最小优先队列的实现 数组遍历： $O(V^2)$ 二叉堆：$O(E\\lg V)$ 斐波那契堆:$O(V\\lg V+E)$ 最短路径性质的证明三角不等式根据最短路径的定义即可得证 最短路径树性质最短路径树的三条性质： $v’$是图$G$中从源结点$s$可以到达的所有结点的集合 $G’$形成一棵根结点为$s$的树 对于所有的结点$v\\in V’$，图$G’$中从结点$s$到结点$v$的唯一简单路径是图$G$中从结点$s$到结点$v$的一条最短路径 未完待不会续","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Single Source Shortest Path","slug":"Single-Source-Shortest-Path","permalink":"https://mengzelev.github.io/tags/Single-Source-Shortest-Path/"},{"name":"Bellman-Ford","slug":"Bellman-Ford","permalink":"https://mengzelev.github.io/tags/Bellman-Ford/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://mengzelev.github.io/tags/Dijkstra/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://mengzelev.github.io/tags/Graph-Algorithms/"}]},{"title":"算法导论学习笔记-基本图论算法","slug":"clrs-22graphic-algs","date":"2018-10-24T06:20:35.000Z","updated":"2018-10-30T15:04:07.416Z","comments":true,"path":"2018/10/24/clrs-22graphic-algs/","link":"","permalink":"https://mengzelev.github.io/2018/10/24/clrs-22graphic-algs/","excerpt":"","text":"辣鸡po主只挖坑不填坑因为作业实在太多了！！！ 试一下Mathjax有没有配置成功！ 图的表示邻接链表(Adjacency-list) 由一个包含$|V|$条链表的数组Adj所构成，Adj[u]包含所有与结点u之间有右边相连的结点v 存储空间需求：$\\Theta(V+E)$ 鲁棒性高，稍加修改可以支持许多图的变种（如：有权图） 缺陷：无法快速判断一条边是否在图中 邻接矩阵(Adjacency-matrix) 用矩阵来存储连通信息 存储空间需求：\\Theta(V^2) 与边数|E|无关 简单，图规模较小时优先使用 广度优先搜索BFS算法描述 从一个源结点s开始，每次从已发现的结点向未发现的结点扩展 算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点 用三种颜色标记结点的访问状态： 白色：未被发现 黑色：本身被发现且所有与之相连的结点都已经被发现 灰色：本身被发现且与之相连的结点中存在未被发现的 结果可能以来 伪代码 使用队列存储所有灰色结点 while循环的循环不变式：队列Q中包含的是灰色结点的集合 分析 结点信息初始化： O(V) 队列操作总时间： O(V) （每个结点都要进出各一次） 扫描邻接链表： O(E) 总时间复杂度： O(V+E)是图G的邻接链表大小的一个线性函数 最短路径正确性证明一堆定理和证明 广度优先树深度优先搜索DFS算法描述 大胆地往前走，走到底再回头（雾 深度优先搜索的前驱子图可能有多棵树组成，即深度优先森林因为搜索可能从多个源结点重复进行 对结点进行黑白灰染色，可以保证每个结点仅在一棵深度优先树中出现，保证所有的深度优先树是不相交的 时间戳： 每个结点v有两个时间戳 第一个时间戳v.d记录结点v第一次被发现的时间（染上灰色的时候） 第二个时间戳v.f记录搜索完成对v的邻接链表扫描的时间（图上黑色的时候） 时间戳都是处于1和2|V|之间的整数 u.d &lt; u.f 非树边： 前向边F：从祖先指向后代 后向边B：从后代指向祖先（包括有向图中的自循环） 横向边C：两端点无血缘关系 伪代码 时间复杂度 结点信息初始化： O(V) DFS-VISIT： O(E) 总运行时间： O(V+E) 性质能提供关于图结构的价值很高的信息 括号化结构","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Single Source Shortest Path","slug":"Single-Source-Shortest-Path","permalink":"https://mengzelev.github.io/tags/Single-Source-Shortest-Path/"},{"name":"Bellman-Ford","slug":"Bellman-Ford","permalink":"https://mengzelev.github.io/tags/Bellman-Ford/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://mengzelev.github.io/tags/Dijkstra/"}]},{"title":"图论学习笔记-树","slug":"tree","date":"2018-10-14T08:00:05.000Z","updated":"2018-10-15T01:17:40.985Z","comments":true,"path":"2018/10/14/tree/","link":"","permalink":"https://mengzelev.github.io/2018/10/14/tree/","excerpt":"","text":"本章可用结论整理 定理4.1：e是图G的桥当且仅当e不在G的任何一个cycle上 定理4.2：图G是树当且仅当G的任意两个顶点只有唯一的path相连 定理4.3：每一棵非简单树都有至少两个端点(end-vertice) 定理4.4：每棵有n个顶点的树都有n-1条边 推论4.6：每棵有k个component的森林都有n-k条边 定理4.7：每一个有n个顶点的连通图至少有n-1条边 定理4.8：有n个顶点、m条边的图G，若满足以下3条性质中的2条：(1)连通 (2)无环 (3)m = n - 1，则G是树 定理4.9：设T是一棵有k个顶点的树。如果图G中最小的度数不小于k-1，那么T与G的某个子图同构 定理4.10：每个连通图都包含了一棵生成树 定理4.15(Tree Formula): 有n个不相同的顶点的树的个数为$n^{n-2}$ 定理4.16(Matrix Tree Theorem): 桥(Bridges)概念如果$e=uv$是连通图$G$的一条边，且$G-e$不连通，则$e$称为连通图$G$的桥. 如果$G$是非连通图，那么桥$e$是G一个部分(component)的桥。 考虑componnet的数目，边$e$是图$G$的桥当且仅当$k(G-e)=k(G)+1$ 定理4.1$e$是图$G$的桥当且仅当$e$不在$G$的任何一个cycle上。 树树即无环的连通图。树所有的边都是桥。树也是所有边都是桥的连通图。 双星(double star):包含了恰好两个非端点的树（这两个端点必然相邻） 毛虫树(caterpillar):定点数大于等于3、除去端点后得到的是path的树。除去端点后得到的path叫作毛虫树的脊椎(spine)；顶点数不小于3的path，star，double star都是毛虫树端点其实就是毛毛虫的脚脚 森林(Forests):无环图。森林的每个component的都是树。(过于形象森林不一定要是连通的，但是树必须是。 定理4.2图$G$是树当且仅当$G$的任意两个顶点只有唯一的path相连 这个证明嘛，只有唯一的path不是和无环是等价的吗(流汗.jpg 定理4.3每一棵非简单树都有至少两个端点(end-vertice) 证明取了最长路径的两个端点，利用了最长路径上的端点都不与非路径上点相邻的性质，证得最长路径的两个端点都是end-vertice 这条性质非常有用，可以成为对树结构使用数学归纳法的依据，划掉一个端点就会使order-1使用数学归纳法证明图相关结论的关键在于找到一个end-vertice 定理4.4每棵有n个顶点的树都有n-1条边 证明使用了基于定理4.3的数学归纳法，很直观 推论4.6每棵有k个component的森林都有n-k条边 简单的边数计算就能证明 定理4.7每一个有n个顶点的连通图至少有n-1条边。 证明用到了最小数原理，假设存在一个顶点最少的图少于n-1条边，然后证明此时至少会有一个端点(end vertex)，这时就可以把那一个端点去掉得到一个更小的满足条件的图，从而与假设矛盾。 定理4.8有n个顶点、m条边的图G，若满足以下3条性质中的2条： 连通 无环 m = n - 1则G是树 证明非常直观，活用了上面的定理 定理4.9设T是一棵有k个顶点的树。如果图G中最小的度数不小于k-1，那么T与G的某个子图同构 最小生成树问题实际中存在村庄造路的问题，即造一些路使得所有村庄都连通，并保证造这些路的开销最小这样的问题可以归结为最小生成树问题，求解一个有权图中权值最小的生成树 Kruskal’s Algorithm算法描述：先取权最小的两条边，从第三次开始，每次都取不与取过的边构成cycle的、权最小的边，直到取满n-1条边为止。类似于贪心算法。 正确性证明也类似于证明贪心用到的替换法，取最优解中与算法解重叠最大的解，进行替换，导出矛盾。 Prim’s Algorithm算法描述：先取权最小的一条边，之后每次都选择连接了未连接的点和已连接的点的边中权最小的一条，知道选择了n-1条边为止。类似于动态规划。 证明思路类似于剪切-粘贴法。难以概括…… 生成树的个数书上这部分完全就是在讲故事啊(╯°Д°)╯︵┻━┻ 图论证明特点自己xjb总结的，仅供参考 多用反证法 …….我再想想","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"Graph","slug":"Graph","permalink":"https://mengzelev.github.io/tags/Graph/"},{"name":"Tree","slug":"Tree","permalink":"https://mengzelev.github.io/tags/Tree/"}]},{"title":"Lab1-乘法 实验报告","slug":"lab1-report","date":"2018-10-12T09:17:47.000Z","updated":"2018-10-15T01:25:08.817Z","comments":true,"path":"2018/10/12/lab1-report/","link":"","permalink":"https://mengzelev.github.io/2018/10/12/lab1-report/","excerpt":"","text":"任务1：实现multimod使用了高精度数乘法计算a*b，然后模拟手算除法的形式写了高精度除法（取模）。代码见文件p1.c. 正确性(伪)证明使用python随机生成生成了1000000组a、b、m，0~9223372036854775807(int64_t的最大值)并计算对应答案，与p1.c的计算结果进行对比。 python随机数生成代码如下： import random MAX = 9223372036854775807 for i in range(1,1000000)： a = random.randint(0,MAX) b = random.randint(0,MAX) m = random.randint(1,MAX) ans = (a * b) % m print (a,b,m,ans) 测试结果一百万组全对（从零开始计数的） 任务2：性能优化由于是先听的课再做的lab，出于惰性直接按照jyy课上讲的方法做了（我去面壁）就不多解释了，代码见p2.c 时间测试思路STFW找到了计算使用time.h库函数计算运行时间的方法，也有计算时钟周期的方法，但是后者使用了汇编代码，在对未知事物的恐惧(这样真的不好)的驱使下还是选择了比较好理解、比较好控制的前者。为了防止计算步骤被优化，又不能让多于的操作占用过多的时间，就使程序计算了正确的case的个数并输出。所以得到的时间应该比实际运行时间长一些。 运行时间注：其中p1.c为任务一中的高精度实现，p2.c为任务二中的优化算法，p3.c为任务三中的神奇代码 运行时间分析记a,b,m的位数为n高精度除法需要做O(n)次减法和比较，每次减法和比较的时间复杂度也都为O(n)，因此总时间复杂度是O(n^2)任务二中优化过的时间需要循环次数是O(n)的，每次循环的操作都能在常数时间O(1)内完成，因此总时间复杂度为O(n)而神奇代码对任何输入消耗的时间都是相同的，时间复杂度为O(1)从运行时间上来看的确是t(p1)&gt;t(p2)&gt;t(p3)，符合预期一个神奇的现象是，随着优化等级的升高，运行时间不一定缩短。尤其是p2.c的运行情况，O1和O2反而不如O0（虽然也只差了0.001ms），于是我反汇编对比了一下，发现multimod、testcases和main几个函数的汇编代码几乎一模一样，但对应行的行数不同，可能是调用了不同的系统库函数。对优化的原理不太了解，暂时无法想到合理的解释。可能是因为这个程序的优化空间不是太大？但是编译器肯定比我智能多了，我想不到优化方法不能看不起编译器啊。 任务3：解析神秘代码结论：ab乘积不超过2^53次方，m在int64_t范围内任意取值，可以保证multimod_fast总是能返回正确的数值 过程非常曲折，以下都是流水账碎碎念，老师嫌长可以不看，自己写着好玩，回头上传个人Blog 刚拿到手先试了一大堆随机数据，发现一百万组测试样例总只能过1w+组，正确率非常低。后来和同学讨论了一下，听说m比较小的时候结果最容易出错，我就把m的随机范围改成了1~3，果然错误率高了很多。大概是因为神秘代码中(int64_t)((double)a * b / m + 1e-8)强制类型转换后要除以m，如果m偏小，那么a*b的误差就很容易保存下来，引起答案出错。 保持m1~3的范围，我又试了几组大数。发现是在ab乘积为10^19左右的时候（a和b在算法找中地位是等价的，所以只需要关注ab的乘积的范围）会出现计算错误，于是在这个范围附近取了一些数，绝了，这个使结果正确的区间并不是连续的！然后理智烧却瞎测了几组数据，不太能发现规律，决定先冷静下来，从理论上思考一下算法。毕竟这次是关于数据表示形式的Lab嘛 这个神奇代码大概是把ab乘积转换为double类型。double类型能表示的范围是大于int64_t的，但是精度不够，尾数部分只有52位的精度（加上前面的1一共是53位），所以应该是只能保证这53位的精度，于是我打开python计算器计算了一下2^26.5 =，大概是94900000，于是我把任务一中随机数的生成范围改为了(0,94900000)，测试了5次，每次一百万组，都是全对的。 到这里我就很想吐槽了，这范围怎么还能算int64_t的，保证结果正确的a和b的范围int都达不到，如果能保证输入在这个范围之内，还不如直接用int64_t算呢，ab相乘肯定不会溢出的。但是如果a和b乘积位表示下末尾零比较多，还是有可能正确的。所以这根本就是一份拼人品的神奇代码吗….. 目前尚未想通的问题： 为什么要+1e-8？ 为什么返回时需要判断t的正负并做相应修正？ 最后，这个神奇代码毕竟是O(1)的，凭我的算法功底实在没办法优化到O(n)以下，所以神奇代码虽然正确率不高，但是效率还是很感人的","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Lab","slug":"Lab","permalink":"https://mengzelev.github.io/tags/Lab/"},{"name":"Ics","slug":"Ics","permalink":"https://mengzelev.github.io/tags/Ics/"}]},{"title":"算法导论学习笔记-用于不相交集合的数据结构","slug":"clrs-21DisjointSets","date":"2018-10-06T08:05:58.000Z","updated":"2018-10-07T07:33:25.694Z","comments":true,"path":"2018/10/06/clrs-21DisjointSets/","link":"","permalink":"https://mengzelev.github.io/2018/10/06/clrs-21DisjointSets/","excerpt":"","text":"不相交集合的操作一个不相交集合数据结构维护了一个不相交动态集的集合每个集合都有一个代表标识，它是该集合的某个成员 我们希望集合支持以下三个操作： 应用：确定无向图的连通分量 算法就是将连通的顶点全部合并到同一个集合中。 不相交集合的链表表示每个集合可以用一个自己的链表来表示链表中对象可以以任意次序出现 每个链表组成为： head— 指向表的第一个对象（代表元） tail— 指向表的最后一个对象 链表中每个对象的组成为： 关键字key 指向head的指针prev 指向后一个对象的指针next 时间复杂度：MAKE-SET O(1)FIND-SET O(1)UNION（简单实现） $\\Theta(n^2)$ 【摊还分析】 简单加权合并启发式策略策略是，每次合并时都将较小的链表挂到较大的链表上，需要多维护一个链表长度的属性。 证明的核心在于每个对象的指针在所有的UNION操作中最多被更新$\\lceil\\lg n\\rceil$次，因此所有UNION操作中被更新的对象的指针总数为$O(n\\lg n)$。加上MAKE-SET和FIND-SEt的O(m)。 不相交集合森林使用有根树来表示集合。每棵树表示一个集合，树的根结点是该集合的代表元。执行UNION操作时将两棵树的树根合并。实现时可以用到两种改进运行时间的启发式策略。 按秩合并类似链表的加权合并启发式策略为了易于分析，对于每个结点，维护一个秩，表示该结点高度的一个上界。秩x.rank代表x的高度的一个上界，高度即从x到某一后代叶结点的最长简单路径上边的数目。UNION操作中 如果根的秩不同，则让较大秩的根成为较小秩的根的父结点，但秩本身保持不变 如果根的秩相同，则任意选择两个中的一个作为父结点，并使它的秩+1 路径压缩在FIND-SET操作中是查找路径中的每个结点直接指向根，不改变任何结点的秩。 伪代码","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"Disjoint Sets","slug":"Disjoint-Sets","permalink":"https://mengzelev.github.io/tags/Disjoint-Sets/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://mengzelev.github.io/tags/Data-Structure/"}]},{"title":"做pa的时候可能会用到的操作","slug":"pa-inspirations","date":"2018-10-04T09:18:29.000Z","updated":"2018-10-04T09:21:25.581Z","comments":true,"path":"2018/10/04/pa-inspirations/","link":"","permalink":"https://mengzelev.github.io/2018/10/04/pa-inspirations/","excerpt":"","text":"当做笔记随便写写的，希望能帮到一些人吧。毕竟作为一名优秀的bug maker，别人遇到的问题我基本都能遇到的。 vim和tmux另外写了教程： vim初探 使用tmux变身炫酷程序猿(x 持续更新中最后更新: 2018/10/04 17:18:29 新增PA2时运行dummy出错的解决方式 语言规范 这名字很中二…但其实就是个人写文章的时候一点习惯用的表示，和别人的可能不一样，很可能非常不标准，注意区分就好 []方括号表示需要自定义的内容，括起来的只是你应该输入的东西的名字 $开头的表示在命令行中键入的代码，否则为文件中的代码 在整个目录下查找代码 在某个文件里看到某个函数或者宏或者变量的定义的时候经常会好奇在哪里、怎么使用过，除了用/+(搜索内容)靠vim的功能在文件内搜索外，还可以 $ grep &quot;搜索内容&quot; -r &lt;目录&gt; e.g. $ grep &quot;CPU_state&quot; -r . 其中-r表示递归搜索，可以搜索整个目录下所有的文件 一键跳转定义处 创建接口的时候经常需要查看某些函数、宏、结构体的定义，于是被某位nb的学长安利了ctags神器，可以一键跳转至定义处并一键调回，先贴上自己查到的教程 首先需要安装ctags，一般来说直接apt就好了，但是莫名不行，可能是镜像源的问题 $ sudo apt install ctags 于是我选择了从ctags官网手动下载ctags-5.8.tar.gz 如果是在host里下载的，下载后通过自己的共享方式扔到虚拟机里面，进行解压缩 $ cd [压缩包所在目录] $ tar jxvf [文件名].tar.bz 解压后手动安装 $ cd ctags-5.8 $ ./configure $ make $ make install 安装完成后测试一下是否安装成功 $ whereis ctags 你应该能看到让你觉得成功的提示信息。 安装成功后，为源码生成tags文件，在需要使用ctags的目录下(所有子目录都可以享受到)运行 $ ctags -R 为了使得字段补全有效，在生成tags时需要一些额外的参数，推荐的c语言（c处可以替换成其他语言）参数主要是： $ ctags -R --c-kinds=+px --fields=+iaS --extra=+q 其中，fileds 用于指定每条标记的扩展字段域，extra 选项用于增加额外的条目，f表示每个文件增加一个条目，q为每个类增加一个条目 之后配置vim，就不用每次都手动设置 $ vim ~/.vimrc 在.vimrc 中加入如下内容 set tags=[path]/tags set tags=./tags,tags;$HOME 第二行我暂时也不知道是干什么的，但是不加上去好像用不起来（小声 然后用vim编辑你需要的代码文件，当光标落到你想查询定义的函数上时使用Ctrl + ]跳转到定义处（其实明明是两键跳转对不对），然后Ctrl + o或者Ctrl + t返回跳转前的位置。 参考教程原地址 编译dummy时出错进行到PA2开始时，试图编译dummy会产生如下的报错： 这时候如果STFW得到的答案应该是安装libc6-dev-i386 $ sudo apt-get install libc6-dev-i386 然而我装了之后还是报错，到stackoverflow上稍微刨了一下发现可能还需要安装gcc-multilib $ sudo apt-get install gcc-multilib 然后可以开始愉快的PA2了 stackoverflow原回答地址","categories":[],"tags":[{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"},{"name":"Linux","slug":"Linux","permalink":"https://mengzelev.github.io/tags/Linux/"},{"name":"vim","slug":"vim","permalink":"https://mengzelev.github.io/tags/vim/"}]},{"title":"PA1实验报告","slug":"PA1-report","date":"2018-10-04T09:17:47.000Z","updated":"2018-10-04T09:18:35.194Z","comments":true,"path":"2018/10/04/PA1-report/","link":"","permalink":"https://mengzelev.github.io/2018/10/04/PA1-report/","excerpt":"","text":"实验进度2018/9/15：完成阶段一，实现了单步执行、打印寄存器和扫描内存（简易版）开始做之前忘了git checkout pa1导致工作都在pa0分支里完成了，后来在pa1分支下返工了一遍，两边的git log里都可以查到记录所以求求老师不要扣我的分qwq我下次确定一定肯定确认分支后再开始工作 2018/9/23:完成阶段二，实现了包含(、)、+、-、*、/和十进制数字的表达式计算。为了处理负数将类型都实现为了long long而不是uint32_t，需要按uint32_t类型使用时进行强制类型转换。实现了表达式生成器并测试。 2018/9/29:完成阶段三，扩展了表达式计算中的==、!=、&gt;=、&lt;=、&gt;、&lt;、解除引用和寄存器计算。实现了监视点添加、删除和打印信息功能。用自带的用户镜像初步测试无问题。 2018/9/30:早上起来和同学聊天发现了自己监视点实现的隐藏bug，一开始看了半天没理解到底怎么回事，然后动手加了一堆printf语句缩小范围终于找到了出错的区间，虽然具体的原理还没理解透彻，但是靠着一知半解成功修复了隐藏bug。 必答题不敢po上来的！ 部分蓝框思考题Q：假设你在Windows中使用Docker安装了一个GNU/Linux container, 然后在container中完成PA, 通过NEMU运行Hello World程序. 在这样的情况下, 尝试画出相应的层次图.A：参考了docker官网上的架构图 架构 “Hello World” program simulated x86 hardware NEMU bins/libs Docker host os (windows) Hardware Q：如果没有寄存器, 计算机还可以工作吗? 如果可以, 这会对硬件提供的编程模型有什么影响呢?A：我认为没有寄存器计算机是可以工作的，但是效率会非常低，因为数据的读写只能从内存中进行，而内存的读写速度是慢于寄存器的。而且现在我们学的IA-32架构是不允许在两个内存单元之间进行数据操作的，必须用寄存器作为中间媒介。编程模型一周目的我查了一下没有看懂，但愿二周目的我能看懂吧。 Q：我们知道, 时序逻辑电路里面有”状态”的概念. 那么, 对于TRM来说, 是不是也有这样的概念呢? 具体地, 什么东西表征了TRM的状态? 在状态模型中, 执行指令和执行程序, 其本质分别是什么?A：TRM中存在一个叫做状态寄存器的组成部分，会存储图灵机当前的状态。（状态模型又是什么）执行指令和执行程序的本质区别是程序是一大堆指令的集合。（个人理解） Q：嗯… 如果你觉得提示还不够, 那就来一个劲爆的: 回忆程序设计课的内容, 一个程序从哪里开始执行呢?如果你不屑于回答这个问题, 不妨先冷静下来. 其实这是一个值得探究的问题, 你会在将来重新审视它.A：我正在尝试冷静下来…. Q：阅读reg_test()的代码, 思考代码中的assert()条件是根据什么写出来的A：我不太理解“根据什么写出来”是什么意思……反正没有对错我就说一下个人理解吧。reg_test里的assert们应该是check了一下所有寄存器的存储状态，包括整个32位、低16位和两个低8位，从而来检查CPU_state的结构是否正确。根据…根据CPU_state应有的结构写出来的？ Q：在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1, 你知道这是什么意思吗?A：这样就不会做cpu_exec()中的for循环而直接执行if(nemu_state == NEMU_RUNNING) nemu_state = NEMU_STOP语句实现单步执行。 Q：opcode_table到底是个什么类型的数组?A：是一个opcode_entry结构体类型的数组，通过RTFSC推测应该是模拟指令码的结构体。 Q：你可能会抑制不住编码的冲动: 与其RTFM, 还不如自己写. 如果真是这样, 你可以考虑一下, 你会如何测试自己编写的字符串处理函数?A：其实我更愿意RTFM，有现成的为什么要造轮子写个随机生成字符串的程序产生输入，然后将输入和输出全部都输出肉眼比对一下，大概测试个20组没问题就当过了吧。（做oj的后遗症） Q：框架代码中定义wp_pool等变量的时候使用了关键字static, static在此处的含义是什么? 为什么要在此处使用它?A：static是Internal Linkage的意思，是指编译过程中进行链接时由static修饰的变量不参与与外部文件的链接。这样就使外部的函数一旦使用了这几个变量，编译器就会报错，保证了与WP相关的操作都只能定义在这个文件中。（如果真是这样就有点OOP的感觉？对外只提供接口，实现都在内部，保证了数据和操作的安全性） 剩下一些思考题要么是能力不够STFW找不到满意的答案，要么是找到了看上去满意的答案然而看不懂…. 遇到的问题以及对问题的思考 git merge的时候发生了conflictSTFW之后发现需要先git reset –merge然后cat冲突文件查看是哪里冲突，修改相应地方之后再git merge 全部写完之后才发现写错分支了本来以为git merge之后再给分支重命名就可以了，但是各种冲突实在太多了，所以重新写了一遍，血的教训告诉我们以后一定要在写之前反复检查git branch。因为难以找到一段完整的时间一次性写完，所以每次开始工作之前都需要git branch。 vim忽然“死机”写完一段之后下意识Ctrl+S，之后发现其实是把vim锁定了，Ctrl+Q解锁 vim非正常退出后再次打开与.swp文件发生冲突按R检查是否是自己需要的状态，然后rm .[filename].c.swp将交换文件删除（删之前一定要谨慎不然就是作死） 量子态更新个人blog中，欢迎老师视奸后加分 实验心得 PA虽然是个时间黑洞但是真的很好玩！ 开始动手之前一定要认真RTFSC 看不懂代码的时候手动加点测试可以帮助理解 人真是越学越挑剔，曾经我可以看着全默认的ui手动缩进代码，现在编辑器要是没有（配置）喜欢的字体、自动缩进、括号匹配、甚至一键函数跳转，我可能都会当场疯掉某种意义上越挑剔也就越有学习的欲望很多大佬的故事都告诉我们，工具的改进源于对现有工具的极大不爽 PA1完全是写给自己用的程序而不是OJ那样的了，一定要扪心自问：你写的代码对得起你自己吗？ Acknowledegments 感谢 Massimo同学 在我vim出现异常的时候告诉我是Ctrl+s把屏幕给锁死了并成功教我“急救”方法 感谢 某不愿透露姓名的nb学长 帮忙看了一下表达式生成器的bug，还解决了我的一堆疑问，并且提供深夜debug陪聊服务，并给我负罪感使我以后牢记优先STFW 感谢 xy同学 提供轻度剧透，使我避免了一些bug，还告诉了我一个隐藏bug的存在 感谢 不学习的正经水群 交流pa心得一起快乐编程 实验报告虽然写了很多还是意犹未尽啊，为了赶ddl并尽快愉快地开始PA2先交了，等ddl过了之后会上传删掉了必做题的版本到个人blog，不定时更新","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"}]},{"title":"关于“过程调用”的讨论","slug":"ics-process-calling","date":"2018-09-27T01:59:13.000Z","updated":"2018-10-04T09:15:16.428Z","comments":true,"path":"2018/09/27/ics-process-calling/","link":"","permalink":"https://mengzelev.github.io/2018/09/27/ics-process-calling/","excerpt":"","text":"这是计算机系统基础课上的开放课题，在不同环境下测试一些UB的结果，照理说此处应该有分析但是萌捷列夫懒了，等ddl处理掉了再来写。 实验一代码#include &lt;stdio.h&gt; int main(int argc, char* argv[])&#123; int a = 10; double *p = (double*)&amp;a; printf(&quot;%f\\n&quot;, *p); printf(&quot;%f\\n&quot;, ((double)(a))); return 0; &#125; windows10环境：dev-cpp/TDM-GCC 4.9.2 64bit Release Debian-64bit Ubuntu-32bit 实验二代码#include&lt;stdio.h&gt; int main()&#123; double a = 10; printf(&quot;a = %d\\n&quot;, a); return 0; &#125; windows10 Debian Ubuntu-32bit","categories":[],"tags":[{"name":"ics","slug":"ics","permalink":"https://mengzelev.github.io/tags/ics/"},{"name":"process calling","slug":"process-calling","permalink":"https://mengzelev.github.io/tags/process-calling/"}]},{"title":"正则表达式学习笔记","slug":"regex","date":"2018-09-21T14:04:40.000Z","updated":"2018-09-21T14:38:21.936Z","comments":true,"path":"2018/09/21/regex/","link":"","permalink":"https://mengzelev.github.io/2018/09/21/regex/","excerpt":"","text":"废话不多说，贴4张截图就跑路（。 有空还是会回来写的，容我先把ddl肝完（瘫）。 PA讲义中的Linux-C教程","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"pa","slug":"pa","permalink":"https://mengzelev.github.io/tags/pa/"},{"name":"regular expressions","slug":"regular-expressions","permalink":"https://mengzelev.github.io/tags/regular-expressions/"},{"name":"linux","slug":"linux","permalink":"https://mengzelev.github.io/tags/linux/"}]},{"title":"算法导论学习笔记-摊还分析","slug":"clrs-17amortized","date":"2018-09-17T15:47:29.000Z","updated":"2018-09-20T15:58:45.393Z","comments":true,"path":"2018/09/17/clrs-17amortized/","link":"","permalink":"https://mengzelev.github.io/2018/09/17/clrs-17amortized/","excerpt":"","text":"聚合分析聚合分析指，证明对所有n，一个n个操作的序列的最坏情况下花费的总时间为T(n)。因此在最坏情况下，每个操作的平均代价，或摊还代价为T(n)/n。 摊还操作可以看作是不带概率计算的平均情况分析。因为概率不好计算。概率什么时候好计算过了 此摊还代价适用于每个操作，即使序列中有多种类型的操作也是如此。 算法导论上给出的示例为增加了MULTIPOP的栈操作和二进制计数器递增问题，简单概括一下二者的共同点： 需要分析复杂度的操作由连续的n个操作构成 每个单步操作的时间复杂度难以确定为与n有关的表达式，与当前状态密切相关 对每个单步操作取最坏情况得出的上界过于宽松，浪费时间 n个连续操作的总时间复杂度比较容易求得 大致感觉就是，使用摊还分析可以给这些操作一个清白，它们事实上没有那么慢。 核算法核算法就是对不同的操作赋予不同的信用，这个信用值可能会多于或少于实际消耗的代价。实际操作时采用多退少补的原则，保证总信用（支付的代价-实际的代价）始终非负即可。 一般用于解决不同操作间具有依赖关系的问题，例如聚合分析中提到的栈操作问题（出栈操作次数上界即为进栈操作次数）和二进制计数器递增问题（复位操作次数依赖于置位操作次数）。 势能分析势能分析看上去更加数(wu)学(li)一点，与核算法有点类似，不同之处势能分析为每一个状态都设置了一个对应的势能，即势能函数。虽然在操作过程中势能可能有升有降，但只要最终势能是增加的，就可以证明代价的上界。 选择势能函数应该是比较困难的。产生的摊还代价依赖于选择的势能函数。具体根据需要证明的上界来选择适度的势能函数，毕竟最优势能函数不是那么好找的。 动态表这个有丶玄学，是势能分析的综合应用，建议看书。 睡觉了，先更到这里，明天继续更","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"amortized analysis","slug":"amortized-analysis","permalink":"https://mengzelev.github.io/tags/amortized-analysis/"}]},{"title":"算法导论学习笔记-贪心算法","slug":"clrs-16greedy","date":"2018-09-17T02:53:05.000Z","updated":"2018-09-18T03:10:20.626Z","comments":true,"path":"2018/09/17/clrs-16greedy/","link":"","permalink":"https://mengzelev.github.io/2018/09/17/clrs-16greedy/","excerpt":"","text":"前一篇dp写得又乱又烂简直不想看。但愿自己能坚持下去吧。可是这依然改变不了搬运和截图多于实际内容的事实 基础理论贪心算法可以看做是动态规划的弱化版，处理某一类特殊的具有最优子结构的问题。 在每个贪心算法之下，几乎总有一个更繁琐的动态规划算法。 算法设计步骤 将最优化问题转化为这样的形式：对其作出一次选择后，只剩下一个子问题需要求解【子问题削减】 证明作出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的【安全性证明：替换法】 证明作出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构【确认最优子结构】 贪心选择性质贪心选择性质是指，当进行选择时，我们直接作出在当前问题中看来最优的选择，而不必考虑子问题的解【鼠目寸光】 贪心起来不太方便的时候，可以改进贪心选择，例如做一些预处理（活动选择问题中按照结束时间对活动进行排序） 最优子结构证明：子问题最优解 + 贪心选择 = 原问题最优解隐含地使用了数学归纳法 两种背包问题 0-1背包问题 分数背包问题 共同的条件是有一堆不同价值、重量的东西，用一个有一定承重量的背包去装，求装得的最大价值。不同在于，0-1背包问题中每个东西要么拿要么不拿，而分数背包问题中可以拿分数个东西。 前者无法用贪心算法求解，但后者可以，主要区别在于考虑0-1背包问题中是否将一个商品装入背包时，必须比较包含此商品的子问题的解和不包含此商品的子问题的解。简单来说就是，空闲空间的存在非常讨厌。只能使用动态规划来求解 活动选择问题问题描述 最优子结构通俗地说，对于某一个活动$a_k$，在它开始之前结束的所有活动，和在它结束之后开始的所有活动，这两个集合都应该取到最优解，可以使用剪切-粘贴发得到证明。因为如果子问题存在更优解，只需替换即可得到原问题的最优解，与原问题已经是最优解矛盾。 严谨化表述可以描述为： 其中，$S{ij}$表示在$ai$结束后开始、在$aj$开始前结束的活动的集合； c[i,j]表示集合$S{ij}$的最优解。 贪心选择 --------------------------------- 抛开各种分析直接来看这个问题，或者说和一个不知道动态规划的人谈起这个问题，很容易（大概）有这样一种想法： 对于每一次选择，都取不冲突的、最早结束的活动，感觉应该能够得到最优解。 事实上这个想法是对的，可以使用[替换法](#replace)进行证明。 这样每次做选择的时候就只剩下了一个子问题。 递归实现贪心算法可以自顶向下实现。 迭代实现 其中Q是一个单调队列。如果用最小堆实现，则该算法的时间复杂度为O(nlgn)。 时间复杂度如果直接使用dp，状态转移是O(n)的，子问题总数为O(n^2)，因此总时间复杂度为O(n^3)。 而如果使用贪心策略，压缩了解空间，限制了解的范围，从伪代码可以看出每个$a_{i}$都被检查且只被检查了一次，因此时间复杂度是O(n)的。 如果输入数据是无序的那么还需要一个O(nlgn)的排序时间，总体的时间复杂度为O(nlgn)。 赫夫曼编码问题描述解释起来有点麻烦，提供STFW快捷入口 百度百科-哈夫曼编码 wikipedia-Huffman coding 简单概括一下： 用变长编码压缩编码长度 Huffman树的叶结点与码字的编码一一对应 字符的二进制码字用从根结点到该字符对应的叶结点的简单路径表示 代价的定义： 伪代码 正确性证明这一块设计很多数学推导，难度比较大，此处指概括大致思路，配合算法导论原书食用风味更佳 主要是需要证明两个引理。 引理2旨在说明在单步选择下，贪心能得到是最优解。用的是替换法。从假想出一个抽象的最优解T，经过某些变换得到根据贪心选择构造出的解T’’，运用数学手段证明这两个解具有相等的代价。此处采用的是相减得到大于等于关系，与最优解天然具有的小于等于构造解相结合，证明等价。 引理3旨在证明该问题的最优子结构。采用了喜闻乐见的的剪切-粘贴法，也使用了一定的数学手段导出了矛盾。 引理2+引理3能证明上文的贪心算法可以生成一个最优前缀码。 课程要求暂时只需要看前三章","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"https://mengzelev.github.io/tags/greedy-algorithm/"}]},{"title":"面向OJ的Java学习","slug":"startjava","date":"2018-09-16T05:34:22.000Z","updated":"2018-09-17T15:49:24.661Z","comments":true,"path":"2018/09/16/startjava/","link":"","permalink":"https://mengzelev.github.io/2018/09/16/startjava/","excerpt":"","text":"各路ddl原因本文目前还处于混乱状态，十分丢人，谨慎阅读源代码为了防止查重，在OJ截止后会附上，也十分丢人 准备工作下载安装IDE本UI警察使用的是JetBrains的IntelliJ IDEA，可以直接从官网下载，用学生邮箱注册可以免费获得Utilmate版，下载后安装即可。安装时会安利一些插件，根据个人需要选择安装。 下载后打开IJ，选择新建一个工程，这时候会提醒你选择JDK，只需要点击Download JDK直接在官网上下载即可。（这一步忘记截图了） 下载并安装完JDK之后，可以先对编辑器进行设置(File -&gt; Settings 或 Ctrl + Alt +S)，选择自己喜欢的字体和配色风格。我使用的是默认的Darcula配色和Monaco字体。 大致效果如下（我jio得非常好看（请无视xjb乱写的第一个java程序 创建新项目由于暂时用于应付oj，以下步骤非常不严谨，不适合开发相关，只确保能正常完成oj作业，欢迎随时指出不严谨之处 点击File -&gt; New -&gt; Project，新建一个项目，其他东西可以暂时不用管，在新的项目中找到src文件夹，右键选择New -&gt; Java class，注意命名规范 之后会得到一个有模板的.java代码文件（球球无视一切xjb命名） 移动光标就可以开始敲代码啦！装了IdeaVim插件的童鞋别忘了用vim的相关快捷键啊~某捷列傻直接Ctrl-C+Ctrl-V半天没有反应 编译运行拷贝了一下poj上a + b问题的源代码，之后就要来尝试编译运行了。IJ并没有像dev一样的一键运行，但是如果做oj题的话还是比较方便的，直接右击左边项目列表的该.java文件选择Run &#39;Main.main()&#39;(快捷键Ctrl + Shift +F10)就可以在屏幕下方的运行窗口里得到运行结果并输入数据进行验证。 某捷列傻可是等了半天的黑框框的 开始编程基本工作都做好了以后可以开始学习一点基础的语法应付oj了，大佬们推荐了Thinking in Java这本书（可以下载到pdf），比较适合系统学习Java，但是萌捷列夫的ddl迫在眉睫，所以只能采用简易一点的菜鸟教程 Java的语法总体与C语言是比较相似的，而且默认本教程读者已有一定的C/C++编程基础，萌捷列夫在学的时候大致按照和C一样放心使用和和C不一样了两大类进行了整理，以供参考 时间原因暂时不能贴出比较简洁易懂的示例代码，可以参考上文的菜鸟教程中的代码，本文最后也会贴出本次OJ所有题的题解代码以供参考。 头文件写C程序的时候，第一件事肯定是#inlcude&lt;xxxx&gt;，在Java里也需要头文件，但稍有区别。 Java中的头文件分为package和import两类。package语句用于表示一个类定义在某个包中，包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。这个我们写oj暂时用不到我就先晾这儿了。 import语句的作用类似于C的inlcude，用来提供一个合理的路径，使编译器可以找到某个类。poj的a+b程序源码中有 import java.io.*; 就是用于让命令编译器载入java_installation/java/io路径下的所有类，从名称可以看出这些类与输入输出有关。特别地，IJ提供自动补全import语句的功能，萌捷列夫在手动赋值a+b源码的时候IJ自动将POJ上的import替换为了 import java.util.Scanner; 一样可以正常运行。 头文件命名要遵循的规范： 如果一个类定义在某个包中，那么package语句应该在源文件的首行 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明 各种声明写C的时候敲完所有头文件，差不多就该int main()了，（当然还有全局变量和函数声明），Java也有类似的主方法入口： public static void main(String []args) 所有Java程序都是从这个入口开始执行的。 Java里也有变量的概念，但声明不是从变量开始的，而是从类开始的，充分贯彻了OOP的思想。类声明类似于用C++进行OOP编程，有public和private之别，还有其他一些特殊的类，写oj暂时用不到。类中可以定义变量和方法。 类与对象类的声明遵循以下规范： 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java 同C++一样，类也可以添加不同的访问修饰词 public:表示公开的类和变量，既所有的类都可以引入使用的 protected：表示受保护的类，只有子孙类和本类可以引入使用 private：表示私人的，只有在本类中可以引入使用 啥都不加（默认）：表示同包中和本类中可以引入使用。 定义了类之后可以使用new关键字创建属于这个类的对象。对象是类的实例化，大致需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 变量Java中的变量有三种： 局部变量： 定义在方法、构造方法或者语句块之中，变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。例如循环变量i 成员变量： 定义在类中、方法体之外，表示类的某种属性，在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问，例如人的身高、体重数据 类变量：声明在类中、方法体之外，但必须声明为static类型，为属于该类的所有对象所共有，不会因为对象的个体差异而改变。例如Student类中可以定义一个类变量n来统计学生的总人数，不会因为是不同的学生而不同。 数据类型Java的内置数据类型基本同C，char,short,int,long,float,double,boolean都可以放心使用，默认值都是相应类型下的0。相比于C多出来一个byte，表示8位、有符号的，以二进制补码表示的整数。 Java还有一类引用数据类型变量，类似于C的指针，引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型，所有引用类型的默认值都是null。一个引用变量可以用来引用任何与之兼容的类型。e.g.Site site = new Site(&quot;Runoob&quot;) 方法构造方法：每个类都需要一个构造方法。如果没有显示定义，编译器会提供一个默认构造方法（这点同C）。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法 输入声明完乱七八糟一堆东西之后，一般会从输入入手。Java输入需要调用Scanner这个类，包含在“头文件”import java.util.Scanner中。 先要创建Scanner对象 Scanner cin = new Scanner(System.in) 读入整数，其中nextInt()是指输入中的下一个整数，类似的也可以有空白的next() int a = cin.nextInt(); Java命名规范首先，切记：Java是大小写敏感的 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写，例如myFirstJavaMethod 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java（如果文件名和类名不相同则会导致编译错误） Java所有的组成部分都需要名字，类名、变量名以及方法名都被称为标识符。标识符的命名规范与C/C++基本相同（不同之处已标出）： 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始 首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合 关键字不能用作标识符 标识符是大小写敏感的 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary 相关整理和C一样放心使用 注释语法 枚举语法enum 变量类型，如int,string,void等 和C不一样了 没有指针大快人心哈哈哈哈","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Java","slug":"Java","permalink":"https://mengzelev.github.io/tags/Java/"},{"name":"programming","slug":"programming","permalink":"https://mengzelev.github.io/tags/programming/"}]},{"title":"使用tmux变身炫酷程序猿(x","slug":"tmux","date":"2018-09-12T01:59:29.000Z","updated":"2018-09-15T09:46:34.113Z","comments":true,"path":"2018/09/12/tmux/","link":"","permalink":"https://mengzelev.github.io/2018/09/12/tmux/","excerpt":"","text":"以前看电影里面的程序猿都是屏幕上花花绿绿键盘噼里啪啦根本不用鼠标的觉得太炫酷了，学了cs以后以为希望破灭了，直到被pa讲义安利了tmux…… 本文只是一个备忘笔记，方便日后查阅 更新中未完待续 按键前缀默认是Ctrl-b，大部分话教程会修改成离得比较近的Ctrl-a 修改方法：打开tmux配置文件 $ vim ~/.tmux.conf 添加如下代码： unbind C-b set -g prefix C-a 分割窗口因为是针对pa才学的tmux，所以要用的操作都非常基本 从terminal进入tmux，直接在命令行里输入tmux即可 $ tmux 然后进行分屏 水平分屏: prefix + % 垂直分屏：prefix + &quot; 我一般都使用左1+右2的形式【暂时忘了截图下次贴】 关闭该窗口：prefix + &amp; 会询问是否确定关闭，按y即可 切换窗口：prefix +方向键 使用tmux操作时，先按住Ctrl再按前缀键，然后可以稍微停一下再按下一个功能键 以上操作目前做pa已经够用了，以后遇到新的问题再另寻解决方法并更新该文 他山之玉忙着赶作业来不及写完所以先贴篇别人整理的 tmux多窗口操作","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"linux","slug":"linux","permalink":"https://mengzelev.github.io/tags/linux/"},{"name":"tmux","slug":"tmux","permalink":"https://mengzelev.github.io/tags/tmux/"}]},{"title":"vim初探","slug":"vim","date":"2018-09-06T15:06:23.000Z","updated":"2018-10-01T14:59:18.004Z","comments":true,"path":"2018/09/06/vim/","link":"","permalink":"https://mengzelev.github.io/2018/09/06/vim/","excerpt":"","text":"网上类似的教程已经有很多了，只是在玩耍vimtutor过程中的一点笔记。 同时开markdownPad和vim输入的后果就是在精神分裂的边缘试探.jpg 然而关键还是多用，这些破整理并没有卵用。（不知道我能坚持用vim到什么时候 在学的过程中不断出现的提示： 光标移动方向键：j↓ k↓ h← l→ （两边左右，中间下上） 所以h这篇文l章里j突然出现一些hjkl也不奇怪了呢 光标向前移动n个单词:1w,2w,3w... 光标向前移动至第n个单词的末尾：1e,2e,3e... 移动至行首：0 移动至文末：G 移动至文章开始：gg Ctrl-G配合G使用风味更佳（跳转到某一行） 选中：v+光标移动 模式切换Normal mode: ESC 进入输入模式:i（要操作时记得按esc退出） 保存退出不保存并退出：:q! 保存并退出：:wq 另存为：:w [filename] 删除删除字符：x 删除单词：dw(光标需移动到单词的开头 删除至行末：d$ 删除至词末:dw 用count进行删除：d2w,d1e... 删除整行：dd，2dd,... 从此dd具有了全新的意思 用dd删除的行被放入了寄存器中，p可在上方恢复 撤销撤销最后一步操作:u 撤销整行所有的操作：U 恢复撤销：Ctrl+R 修改改写单个字符（rewrite）：r+(the right character) 改写多个字符：R+(right characters) 改写至词尾：ce（记得esc退出输入模式） 改写至行尾：c$ 整词替换： :s/old/new //替换第一个 :s/old/new/g //在光标所在单行内将&quot;old&quot;全部替换为&quot;new&quot; \\#,#old/new/g //在\\#标记出的行数范围内进行替换 :%s/old/new/g //在全文范围内进行替换 :%s/old/new/gc //在全文范围内查找并询问是否需要替换 插入插入某个文件的内容：:r+[filename] 插入某个命令行函数的返回值:e.g.:r !dir 在光标上方新建一行：O 在光标下方新建一行：o 从词末开始输入：a 从行末开始输入：A（Append） 复制：y(yank) yw可以复制一整个单词 粘贴：p(paste) 查找查找内容：/+（查找内容） 正向查找：n 反向查找：N 从文末开始查找：?+(查找内容) 返回查找前的地方：ctrl-o 是字母O不是数字0 括号匹配：% 忽略大小写：:set ic(ignore case) 关闭忽略大小写::set noic 查找内容高亮：:set hls/hlsearch 关闭高亮：:nohlsearch 部分查找：:set is/incsearch (incsearch) 分屏看到一篇不错的教程，就不复述了 vim分屏功能总结 暂时无法分组指令输入命令行指令::!+(命令行指令) 帮助：F1 or help 指令补全：Ctrl-D配合Tab","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"vim","slug":"vim","permalink":"https://mengzelev.github.io/tags/vim/"}]},{"title":"算法导论学习笔记-动态规划","slug":"clrs-15dp","date":"2018-08-31T08:37:42.000Z","updated":"2018-09-05T02:12:40.869Z","comments":true,"path":"2018/08/31/clrs-15dp/","link":"","permalink":"https://mengzelev.github.io/2018/08/31/clrs-15dp/","excerpt":"","text":"基本原理以下是大段算法导论原句搬运。 只有带下划线的句子才是自己总结的。 最优化问题 动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们成这样的解为问题的一个最优解，而不是最优解。 算法设计步骤 刻画一个最优解的结构特征 递归地定义最优解的值 计算最优解的值，通常采用自底向上的方法 利用计算出的信息构造一个最优解（有时不需要） 动态规划求解最优化问题应该具备的两个要素：最优子结构和子问题重叠。 简单来说就是，能根据原问题得到一个递推式（最优子结构），但是在这个递推式的计算过程中会出现大量重复计算的时候（子问题重叠），可以使用动态规划。 最优子结构性质 问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。 在发觉最优子结构性质的过程中，实际上遵循了如下的通用模式：1.证明问题最优解的第一个组成部分是做出一个选择；2.对于一个给定问题，在其可能的第一步选择中，你假定已经知道哪种选择才会得到最优解。3.给定可获得的最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；4.利用“剪切-粘贴”技术证明：作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解（反证法）：假设子问题存在更优解，将子结构从整体中删除替换为更优解，与最优假设矛盾。 保持子问题空间尽可能简单，只在必要时才扩展它。（e.g.矩阵链乘法问题必须允许子问题在“两端”都可变） 可以用子问题的总数和每个问题需要考察多少种选择这两个因素的乘积来粗略肥西动态规划算法的运行时间。 具有最优子结构的问题子问题之间是无关，同一个原问题的一个子问题的解不影响另一个子问题的解。e.g.无权最短路径vs无权最长路径 子问题重叠如果递归方法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。与之相对的，利用分治方法求解的问题通常在递归的每一步都生成全新的子问题。 重构最优解：用另一个数组来记录最优解 实现 自顶向下的备忘算法 自底向上的动态规划算法一般自底向上的动态规划算法会比较快（没有递归调用开销，表的维护开销也更小） 如果子问题空间中的某些子问题完全不必求解，备忘方法就会体现出优势 钢条切割问题问题描述某公司出售一段长度为i英寸的钢条的价格为$p_i(i=1,2,…,$单位为美元）。给定一段长度为n英寸的钢条和一个价格表$p_i(i=1,2,…,n)$，求切割钢条方案，使得销售收益$r_n$最大。 分析长度为n英寸的钢条共有$2^{n-1}$中不同的切割方案。 如果一个最优解将钢条切割为k段$(1\\le k\\le n$)，那么最优切割方案 n=i_1+i_2+...+i_k将钢条切割为长度分别为$i_1,i_2,…,i_k$的小段，得到最大收益 r_n=p_{i_1}+p_{i_2}+...+p_{i_k}对于$r_n\\ge 1$，我们可以用更短的钢条的最优切割收益来描述： r_n=max(p_n,r_1+r_{n-1},r_2+r_{n-2},...,r_{n-1}+r_1)更简单的，我们将钢条从左边切割下长度为$i$的一段，只对右边剩下的长度为$n-i$的一段继续进行切割（递归求解），对左边的一段则不再进行切割。可以得到r_n=max\\limits_{1\\le i\\le n}(p_i+r_{n-i})这样原问题只包含一个相关子问题的解而不是两个。 复杂度时间复杂度：$\\Theta(n^2)$ 子问题图 矩阵链乘法懒得写了。 最优子结构 对子问题的分析发现必须是子问题必须是两头可动的（i.e.一维数组是不够的） 伪代码为什么原书是分页的我还得手敲一遍不能忍 MATRIX-CHAIN-ORDER(p) //自底向上的动态规划实现 n=p.length-1 let m[1..n,1..n] and s[1..n-1,2..n] be new tables for i=1 to n m[i,i]=0 for l=2 to n for i=1 to n-l+1 j=i+l-1 m[i,j]=\\infty for k=i to j-1 q=m[i,k]+m[k+1,j]+p[i-1]*p[k]*p[j] if q&lt;m[i,j] m[i,j]=q s[i,j]=k return m and s 最长公共子序列（LCS）问题定义先略 最优子结构 伪代码 最优二叉搜索树和矩阵链乘法类似 也懒得抄了 一份毫无营养的学习笔记就完成了","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Problem Solving","slug":"Problem-Solving","permalink":"https://mengzelev.github.io/tags/Problem-Solving/"},{"name":"CLRS","slug":"CLRS","permalink":"https://mengzelev.github.io/tags/CLRS/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://mengzelev.github.io/tags/dynamic-programming/"}]},{"title":"汇编语言复习笔记（二）","slug":"asm2","date":"2018-08-30T08:37:42.000Z","updated":"2018-08-30T08:42:36.625Z","comments":true,"path":"2018/08/30/asm2/","link":"","permalink":"https://mengzelev.github.io/2018/08/30/asm2/","excerpt":"","text":"数据传送数据传送指令格式： mov S(源操作数), D(目标操作数) mov &nbsp;&nbsp; 一般传送指令 movs &nbsp;&nbsp; 符号扩展传送 movz &nbsp;&nbsp; 零扩展传送 push &nbsp;&nbsp; 压栈，等价于sub+mov pop &nbsp;&nbsp; 退栈，等价于mov+add 按源操作数的长度加上b,w,l后缀，分别表示1、2、4字节。(movz,movs需要双后缀) 见leal与movl的区别 指令后缀、操作数长度、目标寄存器宽度必须要一致！！ 操作数类型 立即数 Imm &nbsp;&nbsp; 整型常量，加$前缀，e.g.$233, $0x66FFCC 寄存器 Reg &nbsp;&nbsp; 加%前缀，e.g.%eax,%ebx,%esp 存储器 Mem &nbsp;&nbsp; 寻址操作 不能在一条指令里实现存储器到存储器的传送！！要实现存储器间的传送必须经过寄存器。 寄存器 所有寄存器都可以单独读取低16位 只有%eax,%ecx,%edx,%ebx可以读取低8位（x字辈） 地址运算指令格式: leal S,D S是复杂寻址地址形式的表达式，将表达式表示的值写入D，其中D一定是寄存器 用途： 直接计算地址的值 e.g.p=&amp;x 执行简单的算数运算 leal与mov操作的区别： leal不会对寻址表达式解引用 e.g. //R[%edx]=x movl 7(%edx,%edx,4),%eax //R[%eax]=M[5x+7] leal 7(%edx,%edx,4),%eax //R[%eax]=5x+7 算术和逻辑操作看表 ※使用时也需要根据操作数长度添加后缀 特殊操作imull &nbsp;&nbsp; 带符号乘法指令，只有一个操作数时，另一个乘数隐含在%eax中，乘积的高32位放入%edx,低32位存入%eax idivl &nbsp;&nbsp; 带符号除法指令，只有一个操作数时，%edx-%eax为被除数，操作数为除数，商存入%eax,余数存入%edx 还有无符号版本mull和divl cltd 符号扩展指令，将%eax中的数符号扩展至%edx成为64位,经常用于idivl的准备工作 关于imul 操作数个数 格式 操作 结果存放 1 imul src src*R[%eax]，完全乘法（自己取的名字） %edx-%eax 2 imul src dst src*dst,高位截断，只保留低位 dst 3 imul reg src imm R[reg]=src*imm，只保留低位 reg 具体还是看老师ppt截图吧（侵权删） 条件控制指令比较与测试 cmp和test指令实际上是用减法和按位与操作实现的。 注意两个操作数的先后顺序与实际是相反的 条件置位指令setXsetX指令根据相应的条件标志位将某一位置0或置1。 有符号数的大小关系用greater/less表示，无符号数的用above/below表示。 条件跳转指令jmpX基本同setX 间接跳转：跳转的目标是从寄存器或存储器中读取的，e.g.jmp *%eax表示跳转至R[%eax]存储的地址位置 跳转地址分为绝对地址和相对地址(PC-relative addressing)。 绝对地址即4个字节直接指定的目标地址。 PC-relative addressing程序计数器的值是跳转指令后的那条指令的地址，而非跳转指令本身的地址 实际跳转到的地址=下一条指令的地址+右边的操作数（小端补码表示） e.g. 804828f: 74 05 je XXXXXXX 8048291: e8 1e 00 00 00 call 80482b4 XXXXXXX=0x8048291+0x05=0x8048296 条件传送指令cmovX满足某个条件时执行mov操作 ※必须与cmp操作连用，比较的不是cmov指令的两个操作数而是cmp的两个操作数 条件分支语句的编译if-else语句通常按goto方式执行 一般翻译思路为: if (test-expr) then-statement else else-statement 会被翻译为 if(!test-expr) goto false then-statement goto done false:else-statement done: 可以参考下图中示例： 循环控制语句do-while循环一般循环语句都最终翻译成do-while的形式 do body-statement while(test-expr) 会被翻译为 loop: body-statement if(test-expr) goto loop; while循环while(test-expr) body-statement 会被翻译为 if(!test-expr) goto done; loop: body-statement if(test-expr) goto loop; done: for循环for(init-expr; test-expr; update-expr) body-statement 会被翻译为 init-expr; if(!test-expr) goto done; loop: body-statement update-expr if(test-expr) goto loop; done: switch语句跳跃表跳跃表是一个数组，其中每个下标i对应一个代码段的地址 好处：执行一个switch语句的时间和case的数量无关跳跃表一般被存放在内存的某个位置，可以调用gdb查看 一大波截图预警 作业二的教训 1.几个指令的名称对应功能要背熟 2.确定数据类型：确定长度+有无符号 3.别忘了指针也是一种数据类型 4.jmp指令的第二个操作数是小端补码表示 5.模拟汇编控制流就是要把代码拆分成简单语句（注意运算优先级） 6.分清andl和addl 7.补充C代码的时候就不要再写8x这样意义不明的东西了，是8*x啊老兄","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Assembly Language","slug":"Assembly-Language","permalink":"https://mengzelev.github.io/tags/Assembly-Language/"}]},{"title":"汇编语言复习笔记（一）","slug":"asm-notes","date":"2018-08-29T05:11:42.000Z","updated":"2018-08-30T03:32:00.252Z","comments":true,"path":"2018/08/29/asm-notes/","link":"","permalink":"https://mengzelev.github.io/2018/08/29/asm-notes/","excerpt":"","text":"前言本文为学校课程面向考试复习笔记，参考内容为老师的课堂讲义&amp;深入理解计算机系统，依据这两者做了一些个人的整理便于复习。然而浪了一个假期在退课的边缘试探 信息的表示数值的表示 原码：这个很直观的 反码：这个几乎不用的 补码：$D’=R^n-D$ / 按位取反加1； 移码：见浮点数 补码 相当于取模操作 着重区分基数的值(R)和补码位表示的实际的值(D) R与D的相对大小一致 $R=D+D_{w-1}\\cdot 2^w$ C语言中的整数 无符号数：在数后加U或u 同时有无符号数和带符号数，编译器将带符号数强制转换为无符号数 int的最大正值为2147483647，最大负值为-2147483648 比较时要特别注意是按什么规则进行的 数据的存放 小端：最低有效字节存放在最小地址 大端：最低有效字节存放在最大地址 浮点数编码表示分3个字段 符号s &nbsp; 0正1负 阶码E &nbsp; k位阶码字段exp 尾数M &nbsp; n位小数字段frac &nbsp; 表示的是a/2^n float &nbsp; k=8,n=23 double &nbsp; k=11,n=52 三种表示情况 1.规格化 &nbsp;&nbsp;阶码部分既不全0也不全1 采用偏置形式：E=e-Bias 其中，E为阶码实际的值，e为位模式下的无符号数，偏置Bias= $2^{k-1}-1$ float:127, double:1023 指数范围： float: -126~+127; double -1022~1023 尾数 M=f+1 &nbsp; 其中 0&lt;=f&lt;1; 1&lt;=M&lt;2 非规格化 &nbsp;&nbsp;阶码全0 阶码E=1-Bias 尾数M=f 存在意义：提供了0的表示方法，逐渐溢出 &nbsp; （否则[0,$2^{-n})范围内的数都无法表示） 特殊值 &nbsp;&nbsp;阶码全1 尾数全0：正负无穷大 尾数非全0： NaN 浮点数加减运算步骤：对阶→加减→规格化（→舍入） 对阶：小阶向大阶看齐，小阶尾数右移（带上隐含的1） 整数运算位运算没什么好说的。 移位运算 左移x&lt;&lt;k 丢弃最高k位，在右端补k个0 右移x&gt;&gt;k 丢弃最低k为，在右端补k个0/符号位 移位运算是向下取整 整数加减法发生在n位带标志加法器中 条件标志位计算t=a+b eflag 中文名称 有效条件 OF 溢出标志 a,b同号但t与a,b异号 SF 符号标志 t&lt;0 ZF 零标志 t==0 CF 进位标志 (unsigned)t&lt;(unsigned)a 比较大小相当于做减法 无符号数： CF==0 $\\Leftrightarrow$ a&gt;b 有符号数： OF==SF $\\Leftrightarrow$ a&gt;b 整数乘法乘数中有常数时：采用移位(左移)+加减法相结合的形式 整数除法默认朝0方向舍入：，即正数商取比自身小的最接近整数，负数商取比自身大的最接近整数 用移位代替除法时需要负数需要加上一个偏移量 除数为2的幂次时，采用右移运算，得到朝0方向舍入的结果 无符号数、有符号正整数： 移出的地位直接丢弃 有符号负整数： ：加偏移量 (2^k-1) ，然后再右移k位，低位截断 作业一的教训1.~按位取反 和 ！全部取反要区分清楚 2.非按位运算操作符非0的都视为true 3.浮点数的转化要好好看一下，把转化公式写好 4.移位是向下取整","categories":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/categories/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://mengzelev.github.io/tags/Notes/"},{"name":"Assembly Language","slug":"Assembly-Language","permalink":"https://mengzelev.github.io/tags/Assembly-Language/"}]},{"title":"胡言乱语的大一总结","slug":"freshman","date":"2018-08-18T13:27:02.000Z","updated":"2018-08-18T15:46:17.255Z","comments":true,"path":"2018/08/18/freshman/","link":"","permalink":"https://mengzelev.github.io/2018/08/18/freshman/","excerpt":"","text":"&emsp;&emsp;生日兼七夕窝在家里无聊于是开了这样一篇文章写了整整两天，都是些碎碎念。本来并没有写这种东西的习惯的(:з」∠)但是既然开了个人blog总要写点什么的于是就写吧！试图掩盖写不出教程的事实将来过好几年来看可能会很有回忆的感觉。 学习篇刚进大学的时候，军训期间闲得蛋疼去考了计拔居然还被录取了，txp他老人家眼光真的没问题吗，于是就开始了贼船之旅。大一上第一个国庆长假就只能窝在家里写作业写了好久堪称心理阴影，大一上被问求这门神奇的课给吓尿了，动不动就为了赶作业修仙到两点。其实还是有在疯狂补小排球的 到了大一下觉得大一上还是很空闲的，起码不用搭面包板，也不用抄大物作业。大二上可能会觉得大一下很轻松吧，笑着活下去.jpg 大一上课表 大一下课表 随便说说几门课给我的感受。 微积分早有耳闻，学起来没有觉得很难，可能也是托了qlz的福，这样有主见有原则的老师我超级赞赏的，上课还会讲故事，最重要的是他给分高啊！ 本来和害怕数学的我渐渐也能感受到数学的美了吧，大概。 微电子，浪费生命的水课，课听了，作业做了，考试考了但是感觉毫无收获。 大物实验，水课，求求来个人告诉我实验报告怎样才能拿到优。 大物，不明觉厉，学学物理其实挺好玩的，但是ldx这本书为什么这么…【无fuck说.jpg】果然xmw这种老师还是早点辞退比较好 xw是真的很卖力啊但是为什么我还是听不懂，对不起他。虽然物理课每节都有在听但是经常忍不住水群导致错过了好多，下学期请务必全神贯注，不然电磁学要GG了。 思修， 军理， 马原， 水课三连，马原老师讲的哲学还有那么点意思，可惜全在写oj了没认真听。军理部分老师太sb了请立刻辞退 数电 嘛，还挺有意思的，搭面包板有点抓狂但是比比大班就有心里安慰了。还有wgs真的好帅啊！！！ 英语， 我喜欢，大一上的视听说拍视频很开心，虽然我只是个压榨组员的主催。大一下的配音和演讲超有意思的，演讲做了啊你妹相关的虽然很花时间但还是超开心的。Ruth的读写课天下第一好，我吹爆她！第一学期的时候就猜对了一个谜语而已她居然觉得我很厉害还送了我一个史迪仔期末还给了我满分，真的只是非洲人突然偷渡入欧而已…总之超级感谢的…第二学期结课的时候Ruth还哭了…能跟学生交心的老师是真的难得啊qwq 问求， 终于到了这门让我百感交集无fuck说的课。大一上:卧槽我在学什么；大一下：卧槽这题该怎么做。大一上作业不算难但是量炒鸡大，期末考试也莫名其妙。大一下，作业不多但是好多不会做的，其他课作业又比较多只能出卖灵魂与网络上的算法导论参考答案签订契约成为期末挂科烧酒（雾）。OJ…别提了…我只是题解的搬运工…期末mj查什么重啊…您出题出这么难不找题解还怎么做啊…把OJ当acm校队选拔吗… 汇编，一定要告诫学弟学妹，千万别听whj讲课，看csapp自学效率最高。whj讲课听不懂催眠效果还极好。实验部分装装Linux调调gdb还是挺好玩的，作业也还行，做下来对CPU的工作方式算是有了个全新的认识。【然而汇编笔记的文章还是没有产出来】拆炸弹是真的很有意思，每拆完一个phase都超有成就感，我应该是走火入魔了，连着3个晚上没睡好觉，闭眼就是寄存器，然后被自己炸醒。拆了三天也是够慢的，自卑.jpg.马上开学要考试了完全不想复习，在退课的边缘试探，，， 通识, 感觉这一年里还是太忙于专业课的学习了，通识课上下来并没有太大的收获，基本都是上课不听埋头写作业或者沉迷水群，期末论文之类的也是东拼西凑的学术垃圾。和进大学之前想的完全不一样唉…悦读经典emmmmm论理想与现实的差距，目前为止选的三本书没有哪一本是认真看过的，我什么时候能中《呐喊》、《彷徨》呢？即使中了，在专业课重压之下真的会好好看吗？ 课外学习的话，平时在校根本挤不出时间，总是带着不到ddl不写作业的惰性思维，这一点希望能改啊，可是既然有时间难道不应该优先看番吗。暑假龟速自学了git和markdown，其实都不是很有技术含量的东西，接下来的时间看看能不能学…你数学建模相关还一点没看呢吧…吧…美赛还没报名呢吧…咕掉了校内培训和选拔的严重后果…总之，加油吧。 也一度因为周围的人都去打acm迷茫过要不要去打，但是高中三年noip下来其实也不是太愉快，貌似不太喜欢这种过于理论、过于数学的题目，可能也是一种逃避现实的借口吧。嘛，既然决定了不打acm就一定要认真科研啊。不过现在学得太少真的不敢妄下定论自己喜欢什么。西瓜书，请。 还有既然决定要出国了，请认真背单词。 这个人真的不是精神分裂吗 社团活动篇说到大学必须得有社团活动哒！上大学之前幻想了很多的，进了大学为生活所迫也就活跃了几个地方。 吉协是早就想去的，结果实际上也就大一上去上了弹唱提高班。老师还挺好的吧，至少比家这里的好，还稍微入门了一下指弹。之后的活动完全没有参加了orz什么时候才能把曲子练到能上台表演的水平呢… 辩队还是有好好待的！虽然是被学姐忽悠进去的还只打了两场正式比赛全是输给冠军的一轮游。在辩队一年还从来没赢过一场，太惨了。每次比赛前讨论真的好花时间。一开始写一辩稿还好，后来开始被钦定打三辩稿子都是开场前30min写的了简直丢人。受了信管那边的学长学姐好多照顾（包括wrc)，除了辩论技巧还被拖着玩了狼人杀，所以，传火吧，骚年！ CAC音乐部每天水水群约约饭很开心der!还认识了一帮宅友！好多会玩乐器的、唱歌超好听的小哥哥小姐姐！还有豹跳如雷的海豹们两个月四对的传说！还有每次交作业被33处刑…去过大活楼梯间约歌（一次），线上歌会（两次），107（等末子姐姐拍照一次），完美错过所有线下约k。也算是遗憾比较大的一个地方，当初大一上觉得自己作业太多了没去Monge，乐队的锅也没接。现在Monge都凉了，大二上更不可能有空了。仔细想想大一上其实能好好安排时间的话完全是有空的，但是刚进大学谁能想到呢？还是太求稳了缺少逼自己一把的勇气吧。为才能不足而自卑.jpg。接了vocal团的锅希望表达一点愧疚之意吧。你们的(副)团长是全团最不会唱歌的人。 流跡是在你群水群聊骨头社意外被33拉进去的。之前完全没想过还有这么硬核的探讨宅话题的地方。一开始什么都看不懂（现在依然是），但是以此为契机了解了不少其实也不多啊你妹制作相关的知识。后来进来的玄枝爷爷讲了好多叙事学的东西，很厉害的样子但是完全没听懂自卑.jpg。自从能在流跡吹水新番之后感觉自己的追番越来越勤快了，经各位的安利看番面也越来越广了。和各位的约饭也非常愉快。英语pre做了动画制作流程相关的内容以及现在补《白箱》都和流跡脱不了干系，想快点变得pro能和各位聊起来啊qwq 排队是恶补了小排球之后才加的，虽然没有小排球里那么刺激也没有那么多可爱的男孩子但是打排球真的好开心！在场边加油很晒应该没晒黑多少吧(bushi)学姐们都好厉害！一路打进了院系杯四强！技术不足还不足以成为战力下个学期要好好加油了！ 除此之外开学乱加的几个早就为作业所迫咕掉了。比如校会学创啊，信管乒队什么的。（你真的会打乒乓吗）大二上也不敢对社团活动有所奢望了，好好在辩队带带小孩、vocal团的工作做做好，流跡快点把制作流程产出，我就满足了。你看又开始求稳没有拼劲了 生活篇大学生活的第一年吗…总体还算平稳的吧。 宿舍不是太愉快。烦心事也就不多提了，忘掉最好。 一年来基本都靠食堂过日子，叫外卖的次数屈指可数。大一上基本没出过几次校门，大一下逐渐开始放浪形骸。 寒假鼓起勇气买了人生第一套jk制服，月野家的奶油黄基础款冬服，到快入夏的时候才到的，也就穿了一次。之后入了优马家的绀金和红酒雪梨，燕子家的白五本，从此走上攒钱买衣服的不归路。优马大小姐的定金已经下了，最近出了那么多问题…等浅色的出货爱咋滴咋地吧。代码定金也下了，坐等出货，我也想穿着代码敲代码！ es军训的时候还在肝rock，开学后尝到了生活的艰辛，尤其是在做人情肝了一发节分守门两小时作业一笔未动修仙勉强做完后，从此es脱坑。现在极其想把手头的谷子都卖掉，忘记我这个出坑的人渣吧。fgo军训无聊稍微玩了一下，总之是不想过靠肝和欧生活的日子了，这月就不登了。 大一下开始学车，暑假的时候留校一个多礼拜把科三给考了，过得超惊险。大二上要在上课和作业的夹缝中学科二了。 补番篇就不一一列举了这一年里补/追过的番了，类似于推荐的形式挑几部印象深刻的写吧。 小排球 强推！吹爆！运动番天花板！剧情作画配乐都堪称一流！看到停不下来！一般深夜补番的我多次因为小排球亢奋到睡不着。好久没看这么从头正到尾的番了，既有很现实的设定（及川大王和影山）也有理想的处理（日向和乌野的大家）。不会气活牛顿的科学运动番，唯一不现实的地方是现实中的小男孩哪有这么可爱。看完甚至开始打排球的我不是一个人。心情不好的时候看看小排球就能马上开心起来。有生之年能遇到这样的番真是太好了。 三月的狮子 对上电波的慢节奏番，吹爆羽海野老师和新房！！零酱超可爱！！（摸摸）很喜欢这种有关人生与成长的题材，零酱和三姐妹经历的困难特殊而普遍，仿佛能看到自己的过去。身世悲惨的他们也时常享有寻常的幸福，这种强烈对比大概就是三狮的动人之处。岛田大师兄、小胖、老师等配角刻画得也很好。虽然将棋部分的内容完全看不懂但也不妨碍其成为一部佳作。 超自然九人组 志仓千代丸的作品，剧情，尤其是开头和中间展开很精彩，节奏飞快，收尾略显仓促，不少坑挖了没填，听说游戏表现得反而没有动画好有点可惜。佐仓这回治好了我的巨乳控！ 宅男腐女恋爱难 太甜了！一部刷新我恋爱观的番！我萌捷列夫就是饿死，死外边，也不会看狗粮番的——真香！ 其他看过的番bangumi上都有记录了就不作赘述了。顺便贴上我的bangumi。 恋爱篇您是不是一上来就通过目录索引跳这儿来了？哈哈！对不起！毛都没有！ …… 没有对象但还是想说说恋爱观的，毕竟之前也没有认真思考过这个问题，就大一上拒了俩然后被吓到了发表了一堆独身主义宣言现在想想全tm是黑历史啊好想删说说。其实也没有那么抗拒了啦首先你得...只是自己不是那种想随便玩玩的人，所以想尽可能抱着认真谨慎的心态来对待这么重要的事情首先你得...不过话说回来还是作业太多了，客观上不想再多加一件需要操心的事情了首先你得...没有空间里那些对象怪那么迫切，还是很享受单身的自由生活的，只要管好自己就行了，想喜欢谁就喜欢谁做个dd不好吗？也就是出去玩找不到小伙伴的时候会稍微有点寂寞（）。各有各的生活方式吧。总之，这么看缘分的事情还是随缘吧… 嗯？您问有没有喜欢的人了？这篇文章没加密我当然不会说啦！(doge)","categories":[{"name":"Diary","slug":"Diary","permalink":"https://mengzelev.github.io/categories/Diary/"}],"tags":[{"name":"freshman","slug":"freshman","permalink":"https://mengzelev.github.io/tags/freshman/"},{"name":"college life","slug":"college-life","permalink":"https://mengzelev.github.io/tags/college-life/"}]},{"title":"Markdown test","slug":"test-md","date":"2018-08-12T13:27:02.000Z","updated":"2018-08-12T13:35:34.586Z","comments":true,"path":"2018/08/12/test-md/","link":"","permalink":"https://mengzelev.github.io/2018/08/12/test-md/","excerpt":"","text":"这是标题君这是副标题君我知道这篇文章看起来很沙雕，因为作者就是一个沙雕 列表非常有趣 这是第一项 这是第二项 这是第三项 有时候会有需要强调的内容。 插入代码是一件非常爽的事情： printf(&quot;%s&quot;,&quot;Hello world!\\n&quot;); 突然发现自己不会用printf真是太丢人了。 有时候需要插入链接，这里贴一个百度。 有时候又需要插入图片 看张血小板冷静一下吧（图源网络） 图片的尺寸可以用命令进行修改 暂时先写这么多吧，敬请关注后面几期，计划中将会有 汇编课程相关学习笔记 日本动画制作流程及《白箱》观后感整理 大一回顾与总结 但愿到时候不要鸽（小声）评论功能等我明天再来开不要问我这里为什么是引用格式，看不出来我只是在试试吗","categories":[{"name":"Diary","slug":"Diary","permalink":"https://mengzelev.github.io/categories/Diary/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://mengzelev.github.io/tags/markdown/"}]}]}